[
  {
    "function_name": "inet_gist_same",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
    "lines": "795-809",
    "snippet": "Datum\ninet_gist_same(PG_FUNCTION_ARGS)\n{\n\tGistInetKey *left = DatumGetInetKeyP(PG_GETARG_DATUM(0));\n\tGistInetKey *right = DatumGetInetKeyP(PG_GETARG_DATUM(1));\n\tbool\t   *result = (bool *) PG_GETARG_POINTER(2);\n\n\t*result = (gk_ip_family(left) == gk_ip_family(right) &&\n\t\t\t   gk_ip_minbits(left) == gk_ip_minbits(right) &&\n\t\t\t   gk_ip_commonbits(left) == gk_ip_commonbits(right) &&\n\t\t\t   memcmp(gk_ip_addr(left), gk_ip_addr(right),\n\t\t\t\t\t  gk_ip_addrsize(left)) == 0);\n\n\tPG_RETURN_POINTER(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "result"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "gk_ip_addr(left)",
            "gk_ip_addr(right)",
            "gk_ip_addrsize(left)"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addrsize",
          "args": [
            "left"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "right"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "left"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "right"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "left"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "right"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "left"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "right"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "left"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "PG_GETARG_DATUM(1)"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "PG_GETARG_DATUM(0)"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nDatum\ninet_gist_same(PG_FUNCTION_ARGS)\n{\n\tGistInetKey *left = DatumGetInetKeyP(PG_GETARG_DATUM(0));\n\tGistInetKey *right = DatumGetInetKeyP(PG_GETARG_DATUM(1));\n\tbool\t   *result = (bool *) PG_GETARG_POINTER(2);\n\n\t*result = (gk_ip_family(left) == gk_ip_family(right) &&\n\t\t\t   gk_ip_minbits(left) == gk_ip_minbits(right) &&\n\t\t\t   gk_ip_commonbits(left) == gk_ip_commonbits(right) &&\n\t\t\t   memcmp(gk_ip_addr(left), gk_ip_addr(right),\n\t\t\t\t\t  gk_ip_addrsize(left)) == 0);\n\n\tPG_RETURN_POINTER(result);\n}"
  },
  {
    "function_name": "inet_gist_picksplit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
    "lines": "661-790",
    "snippet": "Datum\ninet_gist_picksplit(PG_FUNCTION_ARGS)\n{\n\tGistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n\tGIST_SPLITVEC *splitvec = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);\n\tGISTENTRY  *ent = entryvec->vector;\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp,\n\t\t\t   *left_union,\n\t\t\t   *right_union;\n\tint\t\t\tmaxoff,\n\t\t\t\tnbytes;\n\tOffsetNumber i,\n\t\t\t   *left,\n\t\t\t   *right;\n\n\tmaxoff = entryvec->n - 1;\n\tnbytes = (maxoff + 1) * sizeof(OffsetNumber);\n\n\tleft = (OffsetNumber *) palloc(nbytes);\n\tright = (OffsetNumber *) palloc(nbytes);\n\n\tsplitvec->spl_left = left;\n\tsplitvec->spl_right = right;\n\n\tsplitvec->spl_nleft = 0;\n\tsplitvec->spl_nright = 0;\n\n\t/* Determine parameters of the union of all the inputs. */\n\tcalc_inet_union_params(ent, FirstOffsetNumber, maxoff,\n\t\t\t\t\t\t   &minfamily, &maxfamily,\n\t\t\t\t\t\t   &minbits, &commonbits);\n\n\tif (minfamily != maxfamily)\n\t{\n\t\t/* Multiple families, so split by family. */\n\t\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t\t{\n\t\t\t/*\n\t\t\t * If there's more than 2 families, all but maxfamily go into the\n\t\t\t * left union.  This could only happen if the inputs include some\n\t\t\t * IPv4, some IPv6, and some already-multiple-family unions.\n\t\t\t */\n\t\t\ttmp = DatumGetInetKeyP(ent[i].key);\n\t\t\tif (gk_ip_family(tmp) != maxfamily)\n\t\t\t\tleft[splitvec->spl_nleft++] = i;\n\t\t\telse\n\t\t\t\tright[splitvec->spl_nright++] = i;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Split on the next bit after the common bits.  If that yields a\n\t\t * trivial split, try the next bit position to the right.  Repeat till\n\t\t * success; or if we run out of bits, do an arbitrary 50-50 split.\n\t\t */\n\t\tint\t\t\tmaxbits = ip_family_maxbits(minfamily);\n\n\t\twhile (commonbits < maxbits)\n\t\t{\n\t\t\t/* Split using the commonbits'th bit position. */\n\t\t\tint\t\t\tbitbyte = commonbits / 8;\n\t\t\tint\t\t\tbitmask = 0x80 >> (commonbits % 8);\n\n\t\t\tsplitvec->spl_nleft = splitvec->spl_nright = 0;\n\n\t\t\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t\t\t{\n\t\t\t\ttmp = DatumGetInetKeyP(ent[i].key);\n\t\t\t\taddr = gk_ip_addr(tmp);\n\t\t\t\tif ((addr[bitbyte] & bitmask) == 0)\n\t\t\t\t\tleft[splitvec->spl_nleft++] = i;\n\t\t\t\telse\n\t\t\t\t\tright[splitvec->spl_nright++] = i;\n\t\t\t}\n\n\t\t\tif (splitvec->spl_nleft > 0 && splitvec->spl_nright > 0)\n\t\t\t\tbreak;\t\t\t/* success */\n\t\t\tcommonbits++;\n\t\t}\n\n\t\tif (commonbits >= maxbits)\n\t\t{\n\t\t\t/* Failed ... do a 50-50 split. */\n\t\t\tsplitvec->spl_nleft = splitvec->spl_nright = 0;\n\n\t\t\tfor (i = FirstOffsetNumber; i <= maxoff / 2; i = OffsetNumberNext(i))\n\t\t\t{\n\t\t\t\tleft[splitvec->spl_nleft++] = i;\n\t\t\t}\n\t\t\tfor (; i <= maxoff; i = OffsetNumberNext(i))\n\t\t\t{\n\t\t\t\tright[splitvec->spl_nright++] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Compute the union value for each side from scratch.  In most cases we\n\t * could approximate the union values with what we already know, but this\n\t * ensures that each side has minbits and commonbits set as high as\n\t * possible.\n\t */\n\tcalc_inet_union_params_indexed(ent, left, splitvec->spl_nleft,\n\t\t\t\t\t\t\t\t   &minfamily, &maxfamily,\n\t\t\t\t\t\t\t\t   &minbits, &commonbits);\n\tif (minfamily != maxfamily)\n\t\tminfamily = 0;\n\ttmp = DatumGetInetKeyP(ent[left[0]].key);\n\taddr = gk_ip_addr(tmp);\n\tleft_union = build_inet_union_key(minfamily, minbits, commonbits, addr);\n\tsplitvec->spl_ldatum = PointerGetDatum(left_union);\n\n\tcalc_inet_union_params_indexed(ent, right, splitvec->spl_nright,\n\t\t\t\t\t\t\t\t   &minfamily, &maxfamily,\n\t\t\t\t\t\t\t\t   &minbits, &commonbits);\n\tif (minfamily != maxfamily)\n\t\tminfamily = 0;\n\ttmp = DatumGetInetKeyP(ent[right[0]].key);\n\taddr = gk_ip_addr(tmp);\n\tright_union = build_inet_union_key(minfamily, minbits, commonbits, addr);\n\tsplitvec->spl_rdatum = PointerGetDatum(right_union);\n\n\tPG_RETURN_POINTER(splitvec);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "splitvec"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "right_union"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_inet_union_key",
          "args": [
            "minfamily",
            "minbits",
            "commonbits",
            "addr"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "build_inet_union_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
          "lines": "470-495",
          "snippet": "static GistInetKey *\nbuild_inet_union_key(int family, int minbits, int commonbits,\n\t\t\t\t\t unsigned char *addr)\n{\n\tGistInetKey *result;\n\n\t/* Make sure any unused bits are zeroed. */\n\tresult = (GistInetKey *) palloc0(sizeof(GistInetKey));\n\n\tgk_ip_family(result) = family;\n\tgk_ip_minbits(result) = minbits;\n\tgk_ip_commonbits(result) = commonbits;\n\n\t/* Clone appropriate bytes of the address. */\n\tif (commonbits > 0)\n\t\tmemcpy(gk_ip_addr(result), addr, (commonbits + 7) / 8);\n\n\t/* Clean any unwanted bits in the last partial byte. */\n\tif (commonbits % 8 != 0)\n\t\tgk_ip_addr(result)[commonbits / 8] &= ~(0xFF >> (commonbits % 8));\n\n\t/* Set varlena header correctly. */\n\tSET_GK_VARSIZE(result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic GistInetKey *\nbuild_inet_union_key(int family, int minbits, int commonbits,\n\t\t\t\t\t unsigned char *addr)\n{\n\tGistInetKey *result;\n\n\t/* Make sure any unused bits are zeroed. */\n\tresult = (GistInetKey *) palloc0(sizeof(GistInetKey));\n\n\tgk_ip_family(result) = family;\n\tgk_ip_minbits(result) = minbits;\n\tgk_ip_commonbits(result) = commonbits;\n\n\t/* Clone appropriate bytes of the address. */\n\tif (commonbits > 0)\n\t\tmemcpy(gk_ip_addr(result), addr, (commonbits + 7) / 8);\n\n\t/* Clean any unwanted bits in the last partial byte. */\n\tif (commonbits % 8 != 0)\n\t\tgk_ip_addr(result)[commonbits / 8] &= ~(0xFF >> (commonbits % 8));\n\n\t/* Set varlena header correctly. */\n\tSET_GK_VARSIZE(result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "tmp"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "ent[right[0]].key"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_inet_union_params_indexed",
          "args": [
            "ent",
            "right",
            "splitvec->spl_nright",
            "&minfamily",
            "&maxfamily",
            "&minbits",
            "&commonbits"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "calc_inet_union_params_indexed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
          "lines": "405-461",
          "snippet": "static void\ncalc_inet_union_params_indexed(GISTENTRY *ent,\n\t\t\t\t\t\t\t   OffsetNumber *offsets, int noffsets,\n\t\t\t\t\t\t\t   int *minfamily_p,\n\t\t\t\t\t\t\t   int *maxfamily_p,\n\t\t\t\t\t\t\t   int *minbits_p,\n\t\t\t\t\t\t\t   int *commonbits_p)\n{\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp;\n\tint\t\t\ti;\n\n\t/* Must be at least one key. */\n\tAssert(noffsets > 0);\n\n\t/* Initialize variables using the first key. */\n\ttmp = DatumGetInetKeyP(ent[offsets[0]].key);\n\tminfamily = maxfamily = gk_ip_family(tmp);\n\tminbits = gk_ip_minbits(tmp);\n\tcommonbits = gk_ip_commonbits(tmp);\n\taddr = gk_ip_addr(tmp);\n\n\t/* Scan remaining keys. */\n\tfor (i = 1; i < noffsets; i++)\n\t{\n\t\ttmp = DatumGetInetKeyP(ent[offsets[i]].key);\n\n\t\t/* Determine range of family numbers */\n\t\tif (minfamily > gk_ip_family(tmp))\n\t\t\tminfamily = gk_ip_family(tmp);\n\t\tif (maxfamily < gk_ip_family(tmp))\n\t\t\tmaxfamily = gk_ip_family(tmp);\n\n\t\t/* Find minimum minbits */\n\t\tif (minbits > gk_ip_minbits(tmp))\n\t\t\tminbits = gk_ip_minbits(tmp);\n\n\t\t/* Find minimum number of bits in common */\n\t\tif (commonbits > gk_ip_commonbits(tmp))\n\t\t\tcommonbits = gk_ip_commonbits(tmp);\n\t\tif (commonbits > 0)\n\t\t\tcommonbits = bitncommon(addr, gk_ip_addr(tmp), commonbits);\n\t}\n\n\t/* Force minbits/commonbits to zero if more than one family. */\n\tif (minfamily != maxfamily)\n\t\tminbits = commonbits = 0;\n\n\t*minfamily_p = minfamily;\n\t*maxfamily_p = maxfamily;\n\t*minbits_p = minbits;\n\t*commonbits_p = commonbits;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic void\ncalc_inet_union_params_indexed(GISTENTRY *ent,\n\t\t\t\t\t\t\t   OffsetNumber *offsets, int noffsets,\n\t\t\t\t\t\t\t   int *minfamily_p,\n\t\t\t\t\t\t\t   int *maxfamily_p,\n\t\t\t\t\t\t\t   int *minbits_p,\n\t\t\t\t\t\t\t   int *commonbits_p)\n{\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp;\n\tint\t\t\ti;\n\n\t/* Must be at least one key. */\n\tAssert(noffsets > 0);\n\n\t/* Initialize variables using the first key. */\n\ttmp = DatumGetInetKeyP(ent[offsets[0]].key);\n\tminfamily = maxfamily = gk_ip_family(tmp);\n\tminbits = gk_ip_minbits(tmp);\n\tcommonbits = gk_ip_commonbits(tmp);\n\taddr = gk_ip_addr(tmp);\n\n\t/* Scan remaining keys. */\n\tfor (i = 1; i < noffsets; i++)\n\t{\n\t\ttmp = DatumGetInetKeyP(ent[offsets[i]].key);\n\n\t\t/* Determine range of family numbers */\n\t\tif (minfamily > gk_ip_family(tmp))\n\t\t\tminfamily = gk_ip_family(tmp);\n\t\tif (maxfamily < gk_ip_family(tmp))\n\t\t\tmaxfamily = gk_ip_family(tmp);\n\n\t\t/* Find minimum minbits */\n\t\tif (minbits > gk_ip_minbits(tmp))\n\t\t\tminbits = gk_ip_minbits(tmp);\n\n\t\t/* Find minimum number of bits in common */\n\t\tif (commonbits > gk_ip_commonbits(tmp))\n\t\t\tcommonbits = gk_ip_commonbits(tmp);\n\t\tif (commonbits > 0)\n\t\t\tcommonbits = bitncommon(addr, gk_ip_addr(tmp), commonbits);\n\t}\n\n\t/* Force minbits/commonbits to zero if more than one family. */\n\tif (minfamily != maxfamily)\n\t\tminbits = commonbits = 0;\n\n\t*minfamily_p = minfamily;\n\t*maxfamily_p = maxfamily;\n\t*minbits_p = minbits;\n\t*commonbits_p = commonbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "left_union"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "tmp"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "ent[left[0]].key"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OffsetNumberNext",
          "args": [
            "i"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OffsetNumberNext",
          "args": [
            "i"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "tmp"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "ent[i].key"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OffsetNumberNext",
          "args": [
            "i"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family_maxbits",
          "args": [
            "minfamily"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "ent[i].key"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OffsetNumberNext",
          "args": [
            "i"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nbytes"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nDatum\ninet_gist_picksplit(PG_FUNCTION_ARGS)\n{\n\tGistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n\tGIST_SPLITVEC *splitvec = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);\n\tGISTENTRY  *ent = entryvec->vector;\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp,\n\t\t\t   *left_union,\n\t\t\t   *right_union;\n\tint\t\t\tmaxoff,\n\t\t\t\tnbytes;\n\tOffsetNumber i,\n\t\t\t   *left,\n\t\t\t   *right;\n\n\tmaxoff = entryvec->n - 1;\n\tnbytes = (maxoff + 1) * sizeof(OffsetNumber);\n\n\tleft = (OffsetNumber *) palloc(nbytes);\n\tright = (OffsetNumber *) palloc(nbytes);\n\n\tsplitvec->spl_left = left;\n\tsplitvec->spl_right = right;\n\n\tsplitvec->spl_nleft = 0;\n\tsplitvec->spl_nright = 0;\n\n\t/* Determine parameters of the union of all the inputs. */\n\tcalc_inet_union_params(ent, FirstOffsetNumber, maxoff,\n\t\t\t\t\t\t   &minfamily, &maxfamily,\n\t\t\t\t\t\t   &minbits, &commonbits);\n\n\tif (minfamily != maxfamily)\n\t{\n\t\t/* Multiple families, so split by family. */\n\t\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t\t{\n\t\t\t/*\n\t\t\t * If there's more than 2 families, all but maxfamily go into the\n\t\t\t * left union.  This could only happen if the inputs include some\n\t\t\t * IPv4, some IPv6, and some already-multiple-family unions.\n\t\t\t */\n\t\t\ttmp = DatumGetInetKeyP(ent[i].key);\n\t\t\tif (gk_ip_family(tmp) != maxfamily)\n\t\t\t\tleft[splitvec->spl_nleft++] = i;\n\t\t\telse\n\t\t\t\tright[splitvec->spl_nright++] = i;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Split on the next bit after the common bits.  If that yields a\n\t\t * trivial split, try the next bit position to the right.  Repeat till\n\t\t * success; or if we run out of bits, do an arbitrary 50-50 split.\n\t\t */\n\t\tint\t\t\tmaxbits = ip_family_maxbits(minfamily);\n\n\t\twhile (commonbits < maxbits)\n\t\t{\n\t\t\t/* Split using the commonbits'th bit position. */\n\t\t\tint\t\t\tbitbyte = commonbits / 8;\n\t\t\tint\t\t\tbitmask = 0x80 >> (commonbits % 8);\n\n\t\t\tsplitvec->spl_nleft = splitvec->spl_nright = 0;\n\n\t\t\tfor (i = FirstOffsetNumber; i <= maxoff; i = OffsetNumberNext(i))\n\t\t\t{\n\t\t\t\ttmp = DatumGetInetKeyP(ent[i].key);\n\t\t\t\taddr = gk_ip_addr(tmp);\n\t\t\t\tif ((addr[bitbyte] & bitmask) == 0)\n\t\t\t\t\tleft[splitvec->spl_nleft++] = i;\n\t\t\t\telse\n\t\t\t\t\tright[splitvec->spl_nright++] = i;\n\t\t\t}\n\n\t\t\tif (splitvec->spl_nleft > 0 && splitvec->spl_nright > 0)\n\t\t\t\tbreak;\t\t\t/* success */\n\t\t\tcommonbits++;\n\t\t}\n\n\t\tif (commonbits >= maxbits)\n\t\t{\n\t\t\t/* Failed ... do a 50-50 split. */\n\t\t\tsplitvec->spl_nleft = splitvec->spl_nright = 0;\n\n\t\t\tfor (i = FirstOffsetNumber; i <= maxoff / 2; i = OffsetNumberNext(i))\n\t\t\t{\n\t\t\t\tleft[splitvec->spl_nleft++] = i;\n\t\t\t}\n\t\t\tfor (; i <= maxoff; i = OffsetNumberNext(i))\n\t\t\t{\n\t\t\t\tright[splitvec->spl_nright++] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Compute the union value for each side from scratch.  In most cases we\n\t * could approximate the union values with what we already know, but this\n\t * ensures that each side has minbits and commonbits set as high as\n\t * possible.\n\t */\n\tcalc_inet_union_params_indexed(ent, left, splitvec->spl_nleft,\n\t\t\t\t\t\t\t\t   &minfamily, &maxfamily,\n\t\t\t\t\t\t\t\t   &minbits, &commonbits);\n\tif (minfamily != maxfamily)\n\t\tminfamily = 0;\n\ttmp = DatumGetInetKeyP(ent[left[0]].key);\n\taddr = gk_ip_addr(tmp);\n\tleft_union = build_inet_union_key(minfamily, minbits, commonbits, addr);\n\tsplitvec->spl_ldatum = PointerGetDatum(left_union);\n\n\tcalc_inet_union_params_indexed(ent, right, splitvec->spl_nright,\n\t\t\t\t\t\t\t\t   &minfamily, &maxfamily,\n\t\t\t\t\t\t\t\t   &minbits, &commonbits);\n\tif (minfamily != maxfamily)\n\t\tminfamily = 0;\n\ttmp = DatumGetInetKeyP(ent[right[0]].key);\n\taddr = gk_ip_addr(tmp);\n\tright_union = build_inet_union_key(minfamily, minbits, commonbits, addr);\n\tsplitvec->spl_rdatum = PointerGetDatum(right_union);\n\n\tPG_RETURN_POINTER(splitvec);\n}"
  },
  {
    "function_name": "inet_gist_penalty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
    "lines": "618-647",
    "snippet": "Datum\ninet_gist_penalty(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *origent = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tGISTENTRY  *newent = (GISTENTRY *) PG_GETARG_POINTER(1);\n\tfloat\t   *penalty = (float *) PG_GETARG_POINTER(2);\n\tGistInetKey *orig = DatumGetInetKeyP(origent->key),\n\t\t\t   *new = DatumGetInetKeyP(newent->key);\n\tint\t\t\tcommonbits;\n\n\tif (gk_ip_family(orig) == gk_ip_family(new))\n\t{\n\t\tif (gk_ip_minbits(orig) <= gk_ip_minbits(new))\n\t\t{\n\t\t\tcommonbits = bitncommon(gk_ip_addr(orig), gk_ip_addr(new),\n\t\t\t\t\t\t\t\t\tMin(gk_ip_commonbits(orig),\n\t\t\t\t\t\t\t\t\t\tgk_ip_commonbits(new)));\n\t\t\tif (commonbits > 0)\n\t\t\t\t*penalty = 1.0f / commonbits;\n\t\t\telse\n\t\t\t\t*penalty = 2;\n\t\t}\n\t\telse\n\t\t\t*penalty = 3;\n\t}\n\telse\n\t\t*penalty = 4;\n\n\tPG_RETURN_POINTER(penalty);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "penalty"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitncommon",
          "args": [
            "gk_ip_addr(orig)",
            "gk_ip_addr(new)",
            "Min(gk_ip_commonbits(orig),\n\t\t\t\t\t\t\t\t\t\tgk_ip_commonbits(new))"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "bitncommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "1010-1042",
          "snippet": "int\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nint\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "gk_ip_commonbits(orig)",
            "gk_ip_commonbits(new)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "new"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "orig"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "new"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "orig"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "new"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "orig"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "new"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "orig"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "newent->key"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "origent->key"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nDatum\ninet_gist_penalty(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *origent = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tGISTENTRY  *newent = (GISTENTRY *) PG_GETARG_POINTER(1);\n\tfloat\t   *penalty = (float *) PG_GETARG_POINTER(2);\n\tGistInetKey *orig = DatumGetInetKeyP(origent->key),\n\t\t\t   *new = DatumGetInetKeyP(newent->key);\n\tint\t\t\tcommonbits;\n\n\tif (gk_ip_family(orig) == gk_ip_family(new))\n\t{\n\t\tif (gk_ip_minbits(orig) <= gk_ip_minbits(new))\n\t\t{\n\t\t\tcommonbits = bitncommon(gk_ip_addr(orig), gk_ip_addr(new),\n\t\t\t\t\t\t\t\t\tMin(gk_ip_commonbits(orig),\n\t\t\t\t\t\t\t\t\t\tgk_ip_commonbits(new)));\n\t\t\tif (commonbits > 0)\n\t\t\t\t*penalty = 1.0f / commonbits;\n\t\t\telse\n\t\t\t\t*penalty = 2;\n\t\t}\n\t\telse\n\t\t\t*penalty = 3;\n\t}\n\telse\n\t\t*penalty = 4;\n\n\tPG_RETURN_POINTER(penalty);\n}"
  },
  {
    "function_name": "inet_gist_fetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
    "lines": "588-608",
    "snippet": "Datum\ninet_gist_fetch(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tGistInetKey *key = DatumGetInetKeyP(entry->key);\n\tGISTENTRY  *retval;\n\tinet\t   *dst;\n\n\tdst = (inet *) palloc0(sizeof(inet));\n\n\tip_family(dst) = gk_ip_family(key);\n\tip_bits(dst) = gk_ip_minbits(key);\n\tmemcpy(ip_addr(dst), gk_ip_addr(key), ip_addrsize(dst));\n\tSET_INET_VARSIZE(dst);\n\n\tretval = palloc(sizeof(GISTENTRY));\n\tgistentryinit(*retval, InetPGetDatum(dst), entry->rel, entry->page,\n\t\t\t\t  entry->offset, false);\n\n\tPG_RETURN_POINTER(retval);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "retval"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gistentryinit",
          "args": [
            "*retval",
            "InetPGetDatum(dst)",
            "entry->rel",
            "entry->page",
            "entry->offset",
            "false"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InetPGetDatum",
          "args": [
            "dst"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(GISTENTRY)"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_INET_VARSIZE",
          "args": [
            "dst"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ip_addr(dst)",
            "gk_ip_addr(key)",
            "ip_addrsize(dst)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addrsize",
          "args": [
            "dst"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "key"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "dst"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "dst"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "key"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "dst"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(inet)"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "entry->key"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nDatum\ninet_gist_fetch(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tGistInetKey *key = DatumGetInetKeyP(entry->key);\n\tGISTENTRY  *retval;\n\tinet\t   *dst;\n\n\tdst = (inet *) palloc0(sizeof(inet));\n\n\tip_family(dst) = gk_ip_family(key);\n\tip_bits(dst) = gk_ip_minbits(key);\n\tmemcpy(ip_addr(dst), gk_ip_addr(key), ip_addrsize(dst));\n\tSET_INET_VARSIZE(dst);\n\n\tretval = palloc(sizeof(GISTENTRY));\n\tgistentryinit(*retval, InetPGetDatum(dst), entry->rel, entry->page,\n\t\t\t\t  entry->offset, false);\n\n\tPG_RETURN_POINTER(retval);\n}"
  },
  {
    "function_name": "inet_gist_compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
    "lines": "540-576",
    "snippet": "Datum\ninet_gist_compress(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tGISTENTRY  *retval;\n\n\tif (entry->leafkey)\n\t{\n\t\tretval = palloc(sizeof(GISTENTRY));\n\t\tif (DatumGetPointer(entry->key) != NULL)\n\t\t{\n\t\t\tinet\t   *in = DatumGetInetPP(entry->key);\n\t\t\tGistInetKey *r;\n\n\t\t\tr = (GistInetKey *) palloc0(sizeof(GistInetKey));\n\n\t\t\tgk_ip_family(r) = ip_family(in);\n\t\t\tgk_ip_minbits(r) = ip_bits(in);\n\t\t\tgk_ip_commonbits(r) = gk_ip_maxbits(r);\n\t\t\tmemcpy(gk_ip_addr(r), ip_addr(in), gk_ip_addrsize(r));\n\t\t\tSET_GK_VARSIZE(r);\n\n\t\t\tgistentryinit(*retval, PointerGetDatum(r),\n\t\t\t\t\t\t  entry->rel, entry->page,\n\t\t\t\t\t\t  entry->offset, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgistentryinit(*retval, (Datum) 0,\n\t\t\t\t\t\t  entry->rel, entry->page,\n\t\t\t\t\t\t  entry->offset, false);\n\t\t}\n\t}\n\telse\n\t\tretval = entry;\n\tPG_RETURN_POINTER(retval);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "retval"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gistentryinit",
          "args": [
            "*retval",
            "(Datum) 0",
            "entry->rel",
            "entry->page",
            "entry->offset",
            "false"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gistentryinit",
          "args": [
            "*retval",
            "PointerGetDatum(r)",
            "entry->rel",
            "entry->page",
            "entry->offset",
            "false"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "r"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_GK_VARSIZE",
          "args": [
            "r"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "gk_ip_addr(r)",
            "ip_addr(in)",
            "gk_ip_addrsize(r)"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addrsize",
          "args": [
            "r"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "in"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "r"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_maxbits",
          "args": [
            "r"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "r"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "in"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "r"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "in"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "r"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(GistInetKey)"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetInetPP",
          "args": [
            "entry->key"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "entry->key"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(GISTENTRY)"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nDatum\ninet_gist_compress(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tGISTENTRY  *retval;\n\n\tif (entry->leafkey)\n\t{\n\t\tretval = palloc(sizeof(GISTENTRY));\n\t\tif (DatumGetPointer(entry->key) != NULL)\n\t\t{\n\t\t\tinet\t   *in = DatumGetInetPP(entry->key);\n\t\t\tGistInetKey *r;\n\n\t\t\tr = (GistInetKey *) palloc0(sizeof(GistInetKey));\n\n\t\t\tgk_ip_family(r) = ip_family(in);\n\t\t\tgk_ip_minbits(r) = ip_bits(in);\n\t\t\tgk_ip_commonbits(r) = gk_ip_maxbits(r);\n\t\t\tmemcpy(gk_ip_addr(r), ip_addr(in), gk_ip_addrsize(r));\n\t\t\tSET_GK_VARSIZE(r);\n\n\t\t\tgistentryinit(*retval, PointerGetDatum(r),\n\t\t\t\t\t\t  entry->rel, entry->page,\n\t\t\t\t\t\t  entry->offset, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgistentryinit(*retval, (Datum) 0,\n\t\t\t\t\t\t  entry->rel, entry->page,\n\t\t\t\t\t\t  entry->offset, false);\n\t\t}\n\t}\n\telse\n\t\tretval = entry;\n\tPG_RETURN_POINTER(retval);\n}"
  },
  {
    "function_name": "inet_gist_union",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
    "lines": "503-533",
    "snippet": "Datum\ninet_gist_union(PG_FUNCTION_ARGS)\n{\n\tGistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n\tGISTENTRY  *ent = entryvec->vector;\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp,\n\t\t\t   *result;\n\n\t/* Determine parameters of the union. */\n\tcalc_inet_union_params(ent, 0, entryvec->n - 1,\n\t\t\t\t\t\t   &minfamily, &maxfamily,\n\t\t\t\t\t\t   &minbits, &commonbits);\n\n\t/* If more than one family, emit family number zero. */\n\tif (minfamily != maxfamily)\n\t\tminfamily = 0;\n\n\t/* Initialize address using the first key. */\n\ttmp = DatumGetInetKeyP(ent[0].key);\n\taddr = gk_ip_addr(tmp);\n\n\t/* Construct the union value. */\n\tresult = build_inet_union_key(minfamily, minbits, commonbits, addr);\n\n\tPG_RETURN_POINTER(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "result"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_inet_union_key",
          "args": [
            "minfamily",
            "minbits",
            "commonbits",
            "addr"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "build_inet_union_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
          "lines": "470-495",
          "snippet": "static GistInetKey *\nbuild_inet_union_key(int family, int minbits, int commonbits,\n\t\t\t\t\t unsigned char *addr)\n{\n\tGistInetKey *result;\n\n\t/* Make sure any unused bits are zeroed. */\n\tresult = (GistInetKey *) palloc0(sizeof(GistInetKey));\n\n\tgk_ip_family(result) = family;\n\tgk_ip_minbits(result) = minbits;\n\tgk_ip_commonbits(result) = commonbits;\n\n\t/* Clone appropriate bytes of the address. */\n\tif (commonbits > 0)\n\t\tmemcpy(gk_ip_addr(result), addr, (commonbits + 7) / 8);\n\n\t/* Clean any unwanted bits in the last partial byte. */\n\tif (commonbits % 8 != 0)\n\t\tgk_ip_addr(result)[commonbits / 8] &= ~(0xFF >> (commonbits % 8));\n\n\t/* Set varlena header correctly. */\n\tSET_GK_VARSIZE(result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic GistInetKey *\nbuild_inet_union_key(int family, int minbits, int commonbits,\n\t\t\t\t\t unsigned char *addr)\n{\n\tGistInetKey *result;\n\n\t/* Make sure any unused bits are zeroed. */\n\tresult = (GistInetKey *) palloc0(sizeof(GistInetKey));\n\n\tgk_ip_family(result) = family;\n\tgk_ip_minbits(result) = minbits;\n\tgk_ip_commonbits(result) = commonbits;\n\n\t/* Clone appropriate bytes of the address. */\n\tif (commonbits > 0)\n\t\tmemcpy(gk_ip_addr(result), addr, (commonbits + 7) / 8);\n\n\t/* Clean any unwanted bits in the last partial byte. */\n\tif (commonbits % 8 != 0)\n\t\tgk_ip_addr(result)[commonbits / 8] &= ~(0xFF >> (commonbits % 8));\n\n\t/* Set varlena header correctly. */\n\tSET_GK_VARSIZE(result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "tmp"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "ent[0].key"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_inet_union_params",
          "args": [
            "ent",
            "0",
            "entryvec->n - 1",
            "&minfamily",
            "&maxfamily",
            "&minbits",
            "&commonbits"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "calc_inet_union_params_indexed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
          "lines": "405-461",
          "snippet": "static void\ncalc_inet_union_params_indexed(GISTENTRY *ent,\n\t\t\t\t\t\t\t   OffsetNumber *offsets, int noffsets,\n\t\t\t\t\t\t\t   int *minfamily_p,\n\t\t\t\t\t\t\t   int *maxfamily_p,\n\t\t\t\t\t\t\t   int *minbits_p,\n\t\t\t\t\t\t\t   int *commonbits_p)\n{\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp;\n\tint\t\t\ti;\n\n\t/* Must be at least one key. */\n\tAssert(noffsets > 0);\n\n\t/* Initialize variables using the first key. */\n\ttmp = DatumGetInetKeyP(ent[offsets[0]].key);\n\tminfamily = maxfamily = gk_ip_family(tmp);\n\tminbits = gk_ip_minbits(tmp);\n\tcommonbits = gk_ip_commonbits(tmp);\n\taddr = gk_ip_addr(tmp);\n\n\t/* Scan remaining keys. */\n\tfor (i = 1; i < noffsets; i++)\n\t{\n\t\ttmp = DatumGetInetKeyP(ent[offsets[i]].key);\n\n\t\t/* Determine range of family numbers */\n\t\tif (minfamily > gk_ip_family(tmp))\n\t\t\tminfamily = gk_ip_family(tmp);\n\t\tif (maxfamily < gk_ip_family(tmp))\n\t\t\tmaxfamily = gk_ip_family(tmp);\n\n\t\t/* Find minimum minbits */\n\t\tif (minbits > gk_ip_minbits(tmp))\n\t\t\tminbits = gk_ip_minbits(tmp);\n\n\t\t/* Find minimum number of bits in common */\n\t\tif (commonbits > gk_ip_commonbits(tmp))\n\t\t\tcommonbits = gk_ip_commonbits(tmp);\n\t\tif (commonbits > 0)\n\t\t\tcommonbits = bitncommon(addr, gk_ip_addr(tmp), commonbits);\n\t}\n\n\t/* Force minbits/commonbits to zero if more than one family. */\n\tif (minfamily != maxfamily)\n\t\tminbits = commonbits = 0;\n\n\t*minfamily_p = minfamily;\n\t*maxfamily_p = maxfamily;\n\t*minbits_p = minbits;\n\t*commonbits_p = commonbits;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/gist.h\"",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic void\ncalc_inet_union_params_indexed(GISTENTRY *ent,\n\t\t\t\t\t\t\t   OffsetNumber *offsets, int noffsets,\n\t\t\t\t\t\t\t   int *minfamily_p,\n\t\t\t\t\t\t\t   int *maxfamily_p,\n\t\t\t\t\t\t\t   int *minbits_p,\n\t\t\t\t\t\t\t   int *commonbits_p)\n{\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp;\n\tint\t\t\ti;\n\n\t/* Must be at least one key. */\n\tAssert(noffsets > 0);\n\n\t/* Initialize variables using the first key. */\n\ttmp = DatumGetInetKeyP(ent[offsets[0]].key);\n\tminfamily = maxfamily = gk_ip_family(tmp);\n\tminbits = gk_ip_minbits(tmp);\n\tcommonbits = gk_ip_commonbits(tmp);\n\taddr = gk_ip_addr(tmp);\n\n\t/* Scan remaining keys. */\n\tfor (i = 1; i < noffsets; i++)\n\t{\n\t\ttmp = DatumGetInetKeyP(ent[offsets[i]].key);\n\n\t\t/* Determine range of family numbers */\n\t\tif (minfamily > gk_ip_family(tmp))\n\t\t\tminfamily = gk_ip_family(tmp);\n\t\tif (maxfamily < gk_ip_family(tmp))\n\t\t\tmaxfamily = gk_ip_family(tmp);\n\n\t\t/* Find minimum minbits */\n\t\tif (minbits > gk_ip_minbits(tmp))\n\t\t\tminbits = gk_ip_minbits(tmp);\n\n\t\t/* Find minimum number of bits in common */\n\t\tif (commonbits > gk_ip_commonbits(tmp))\n\t\t\tcommonbits = gk_ip_commonbits(tmp);\n\t\tif (commonbits > 0)\n\t\t\tcommonbits = bitncommon(addr, gk_ip_addr(tmp), commonbits);\n\t}\n\n\t/* Force minbits/commonbits to zero if more than one family. */\n\tif (minfamily != maxfamily)\n\t\tminbits = commonbits = 0;\n\n\t*minfamily_p = minfamily;\n\t*maxfamily_p = maxfamily;\n\t*minbits_p = minbits;\n\t*commonbits_p = commonbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nDatum\ninet_gist_union(PG_FUNCTION_ARGS)\n{\n\tGistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);\n\tGISTENTRY  *ent = entryvec->vector;\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp,\n\t\t\t   *result;\n\n\t/* Determine parameters of the union. */\n\tcalc_inet_union_params(ent, 0, entryvec->n - 1,\n\t\t\t\t\t\t   &minfamily, &maxfamily,\n\t\t\t\t\t\t   &minbits, &commonbits);\n\n\t/* If more than one family, emit family number zero. */\n\tif (minfamily != maxfamily)\n\t\tminfamily = 0;\n\n\t/* Initialize address using the first key. */\n\ttmp = DatumGetInetKeyP(ent[0].key);\n\taddr = gk_ip_addr(tmp);\n\n\t/* Construct the union value. */\n\tresult = build_inet_union_key(minfamily, minbits, commonbits, addr);\n\n\tPG_RETURN_POINTER(result);\n}"
  },
  {
    "function_name": "build_inet_union_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
    "lines": "470-495",
    "snippet": "static GistInetKey *\nbuild_inet_union_key(int family, int minbits, int commonbits,\n\t\t\t\t\t unsigned char *addr)\n{\n\tGistInetKey *result;\n\n\t/* Make sure any unused bits are zeroed. */\n\tresult = (GistInetKey *) palloc0(sizeof(GistInetKey));\n\n\tgk_ip_family(result) = family;\n\tgk_ip_minbits(result) = minbits;\n\tgk_ip_commonbits(result) = commonbits;\n\n\t/* Clone appropriate bytes of the address. */\n\tif (commonbits > 0)\n\t\tmemcpy(gk_ip_addr(result), addr, (commonbits + 7) / 8);\n\n\t/* Clean any unwanted bits in the last partial byte. */\n\tif (commonbits % 8 != 0)\n\t\tgk_ip_addr(result)[commonbits / 8] &= ~(0xFF >> (commonbits % 8));\n\n\t/* Set varlena header correctly. */\n\tSET_GK_VARSIZE(result);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_GK_VARSIZE",
          "args": [
            "result"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "result"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "gk_ip_addr(result)",
            "addr",
            "(commonbits + 7) / 8"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "result"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "result"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "result"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "result"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(GistInetKey)"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic GistInetKey *\nbuild_inet_union_key(int family, int minbits, int commonbits,\n\t\t\t\t\t unsigned char *addr)\n{\n\tGistInetKey *result;\n\n\t/* Make sure any unused bits are zeroed. */\n\tresult = (GistInetKey *) palloc0(sizeof(GistInetKey));\n\n\tgk_ip_family(result) = family;\n\tgk_ip_minbits(result) = minbits;\n\tgk_ip_commonbits(result) = commonbits;\n\n\t/* Clone appropriate bytes of the address. */\n\tif (commonbits > 0)\n\t\tmemcpy(gk_ip_addr(result), addr, (commonbits + 7) / 8);\n\n\t/* Clean any unwanted bits in the last partial byte. */\n\tif (commonbits % 8 != 0)\n\t\tgk_ip_addr(result)[commonbits / 8] &= ~(0xFF >> (commonbits % 8));\n\n\t/* Set varlena header correctly. */\n\tSET_GK_VARSIZE(result);\n\n\treturn result;\n}"
  },
  {
    "function_name": "calc_inet_union_params_indexed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
    "lines": "405-461",
    "snippet": "static void\ncalc_inet_union_params_indexed(GISTENTRY *ent,\n\t\t\t\t\t\t\t   OffsetNumber *offsets, int noffsets,\n\t\t\t\t\t\t\t   int *minfamily_p,\n\t\t\t\t\t\t\t   int *maxfamily_p,\n\t\t\t\t\t\t\t   int *minbits_p,\n\t\t\t\t\t\t\t   int *commonbits_p)\n{\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp;\n\tint\t\t\ti;\n\n\t/* Must be at least one key. */\n\tAssert(noffsets > 0);\n\n\t/* Initialize variables using the first key. */\n\ttmp = DatumGetInetKeyP(ent[offsets[0]].key);\n\tminfamily = maxfamily = gk_ip_family(tmp);\n\tminbits = gk_ip_minbits(tmp);\n\tcommonbits = gk_ip_commonbits(tmp);\n\taddr = gk_ip_addr(tmp);\n\n\t/* Scan remaining keys. */\n\tfor (i = 1; i < noffsets; i++)\n\t{\n\t\ttmp = DatumGetInetKeyP(ent[offsets[i]].key);\n\n\t\t/* Determine range of family numbers */\n\t\tif (minfamily > gk_ip_family(tmp))\n\t\t\tminfamily = gk_ip_family(tmp);\n\t\tif (maxfamily < gk_ip_family(tmp))\n\t\t\tmaxfamily = gk_ip_family(tmp);\n\n\t\t/* Find minimum minbits */\n\t\tif (minbits > gk_ip_minbits(tmp))\n\t\t\tminbits = gk_ip_minbits(tmp);\n\n\t\t/* Find minimum number of bits in common */\n\t\tif (commonbits > gk_ip_commonbits(tmp))\n\t\t\tcommonbits = gk_ip_commonbits(tmp);\n\t\tif (commonbits > 0)\n\t\t\tcommonbits = bitncommon(addr, gk_ip_addr(tmp), commonbits);\n\t}\n\n\t/* Force minbits/commonbits to zero if more than one family. */\n\tif (minfamily != maxfamily)\n\t\tminbits = commonbits = 0;\n\n\t*minfamily_p = minfamily;\n\t*maxfamily_p = maxfamily;\n\t*minbits_p = minbits;\n\t*commonbits_p = commonbits;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitncommon",
          "args": [
            "addr",
            "gk_ip_addr(tmp)",
            "commonbits"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "bitncommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "1010-1042",
          "snippet": "int\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nint\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "tmp"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "tmp"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "tmp"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "tmp"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "tmp"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "ent[offsets[i]].key"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "tmp"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "tmp"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "tmp"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "ent[offsets[0]].key"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "noffsets > 0"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic void\ncalc_inet_union_params_indexed(GISTENTRY *ent,\n\t\t\t\t\t\t\t   OffsetNumber *offsets, int noffsets,\n\t\t\t\t\t\t\t   int *minfamily_p,\n\t\t\t\t\t\t\t   int *maxfamily_p,\n\t\t\t\t\t\t\t   int *minbits_p,\n\t\t\t\t\t\t\t   int *commonbits_p)\n{\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp;\n\tint\t\t\ti;\n\n\t/* Must be at least one key. */\n\tAssert(noffsets > 0);\n\n\t/* Initialize variables using the first key. */\n\ttmp = DatumGetInetKeyP(ent[offsets[0]].key);\n\tminfamily = maxfamily = gk_ip_family(tmp);\n\tminbits = gk_ip_minbits(tmp);\n\tcommonbits = gk_ip_commonbits(tmp);\n\taddr = gk_ip_addr(tmp);\n\n\t/* Scan remaining keys. */\n\tfor (i = 1; i < noffsets; i++)\n\t{\n\t\ttmp = DatumGetInetKeyP(ent[offsets[i]].key);\n\n\t\t/* Determine range of family numbers */\n\t\tif (minfamily > gk_ip_family(tmp))\n\t\t\tminfamily = gk_ip_family(tmp);\n\t\tif (maxfamily < gk_ip_family(tmp))\n\t\t\tmaxfamily = gk_ip_family(tmp);\n\n\t\t/* Find minimum minbits */\n\t\tif (minbits > gk_ip_minbits(tmp))\n\t\t\tminbits = gk_ip_minbits(tmp);\n\n\t\t/* Find minimum number of bits in common */\n\t\tif (commonbits > gk_ip_commonbits(tmp))\n\t\t\tcommonbits = gk_ip_commonbits(tmp);\n\t\tif (commonbits > 0)\n\t\t\tcommonbits = bitncommon(addr, gk_ip_addr(tmp), commonbits);\n\t}\n\n\t/* Force minbits/commonbits to zero if more than one family. */\n\tif (minfamily != maxfamily)\n\t\tminbits = commonbits = 0;\n\n\t*minfamily_p = minfamily;\n\t*maxfamily_p = maxfamily;\n\t*minbits_p = minbits;\n\t*commonbits_p = commonbits;\n}"
  },
  {
    "function_name": "calc_inet_union_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
    "lines": "343-399",
    "snippet": "static void\ncalc_inet_union_params(GISTENTRY *ent,\n\t\t\t\t\t   int m, int n,\n\t\t\t\t\t   int *minfamily_p,\n\t\t\t\t\t   int *maxfamily_p,\n\t\t\t\t\t   int *minbits_p,\n\t\t\t\t\t   int *commonbits_p)\n{\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp;\n\tint\t\t\ti;\n\n\t/* Must be at least one key. */\n\tAssert(m <= n);\n\n\t/* Initialize variables using the first key. */\n\ttmp = DatumGetInetKeyP(ent[m].key);\n\tminfamily = maxfamily = gk_ip_family(tmp);\n\tminbits = gk_ip_minbits(tmp);\n\tcommonbits = gk_ip_commonbits(tmp);\n\taddr = gk_ip_addr(tmp);\n\n\t/* Scan remaining keys. */\n\tfor (i = m + 1; i <= n; i++)\n\t{\n\t\ttmp = DatumGetInetKeyP(ent[i].key);\n\n\t\t/* Determine range of family numbers */\n\t\tif (minfamily > gk_ip_family(tmp))\n\t\t\tminfamily = gk_ip_family(tmp);\n\t\tif (maxfamily < gk_ip_family(tmp))\n\t\t\tmaxfamily = gk_ip_family(tmp);\n\n\t\t/* Find minimum minbits */\n\t\tif (minbits > gk_ip_minbits(tmp))\n\t\t\tminbits = gk_ip_minbits(tmp);\n\n\t\t/* Find minimum number of bits in common */\n\t\tif (commonbits > gk_ip_commonbits(tmp))\n\t\t\tcommonbits = gk_ip_commonbits(tmp);\n\t\tif (commonbits > 0)\n\t\t\tcommonbits = bitncommon(addr, gk_ip_addr(tmp), commonbits);\n\t}\n\n\t/* Force minbits/commonbits to zero if more than one family. */\n\tif (minfamily != maxfamily)\n\t\tminbits = commonbits = 0;\n\n\t*minfamily_p = minfamily;\n\t*maxfamily_p = maxfamily;\n\t*minbits_p = minbits;\n\t*commonbits_p = commonbits;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitncommon",
          "args": [
            "addr",
            "gk_ip_addr(tmp)",
            "commonbits"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "bitncommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "1010-1042",
          "snippet": "int\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nint\nbitncommon(const unsigned char *l, const unsigned char *r, int n)\n{\n\tint\t\t\tbyte,\n\t\t\t\tnbits;\n\n\t/* number of bits to examine in last byte */\n\tnbits = n % 8;\n\n\t/* check whole bytes */\n\tfor (byte = 0; byte < n / 8; byte++)\n\t{\n\t\tif (l[byte] != r[byte])\n\t\t{\n\t\t\t/* at least one bit in the last byte is not common */\n\t\t\tnbits = 7;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* check bits in last partial byte */\n\tif (nbits != 0)\n\t{\n\t\t/* calculate diff of first non-matching bytes */\n\t\tunsigned int diff = l[byte] ^ r[byte];\n\n\t\t/* compare the bits from the most to the least */\n\t\twhile ((diff >> (8 - nbits)) != 0)\n\t\t\tnbits--;\n\t}\n\n\treturn (8 * byte) + nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "tmp"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "tmp"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "tmp"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "tmp"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "tmp"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "ent[i].key"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "tmp"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "tmp"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "tmp"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "tmp"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "ent[m].key"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "m <= n"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic void\ncalc_inet_union_params(GISTENTRY *ent,\n\t\t\t\t\t   int m, int n,\n\t\t\t\t\t   int *minfamily_p,\n\t\t\t\t\t   int *maxfamily_p,\n\t\t\t\t\t   int *minbits_p,\n\t\t\t\t\t   int *commonbits_p)\n{\n\tint\t\t\tminfamily,\n\t\t\t\tmaxfamily,\n\t\t\t\tminbits,\n\t\t\t\tcommonbits;\n\tunsigned char *addr;\n\tGistInetKey *tmp;\n\tint\t\t\ti;\n\n\t/* Must be at least one key. */\n\tAssert(m <= n);\n\n\t/* Initialize variables using the first key. */\n\ttmp = DatumGetInetKeyP(ent[m].key);\n\tminfamily = maxfamily = gk_ip_family(tmp);\n\tminbits = gk_ip_minbits(tmp);\n\tcommonbits = gk_ip_commonbits(tmp);\n\taddr = gk_ip_addr(tmp);\n\n\t/* Scan remaining keys. */\n\tfor (i = m + 1; i <= n; i++)\n\t{\n\t\ttmp = DatumGetInetKeyP(ent[i].key);\n\n\t\t/* Determine range of family numbers */\n\t\tif (minfamily > gk_ip_family(tmp))\n\t\t\tminfamily = gk_ip_family(tmp);\n\t\tif (maxfamily < gk_ip_family(tmp))\n\t\t\tmaxfamily = gk_ip_family(tmp);\n\n\t\t/* Find minimum minbits */\n\t\tif (minbits > gk_ip_minbits(tmp))\n\t\t\tminbits = gk_ip_minbits(tmp);\n\n\t\t/* Find minimum number of bits in common */\n\t\tif (commonbits > gk_ip_commonbits(tmp))\n\t\t\tcommonbits = gk_ip_commonbits(tmp);\n\t\tif (commonbits > 0)\n\t\t\tcommonbits = bitncommon(addr, gk_ip_addr(tmp), commonbits);\n\t}\n\n\t/* Force minbits/commonbits to zero if more than one family. */\n\tif (minfamily != maxfamily)\n\t\tminbits = commonbits = 0;\n\n\t*minfamily_p = minfamily;\n\t*maxfamily_p = maxfamily;\n\t*minbits_p = minbits;\n\t*commonbits_p = commonbits;\n}"
  },
  {
    "function_name": "inet_gist_consistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network_gist.c",
    "lines": "113-328",
    "snippet": "Datum\ninet_gist_consistent(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *ent = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tinet\t   *query = PG_GETARG_INET_PP(1);\n\tStrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);\n\n\t/* Oid\t\tsubtype = PG_GETARG_OID(3); */\n\tbool\t   *recheck = (bool *) PG_GETARG_POINTER(4);\n\tGistInetKey *key = DatumGetInetKeyP(ent->key);\n\tint\t\t\tminbits,\n\t\t\t\torder;\n\n\t/* All operators served by this function are exact. */\n\t*recheck = false;\n\n\t/*\n\t * Check 0: different families\n\t *\n\t * If key represents multiple address families, its children could match\n\t * anything.  This can only happen on an inner index page.\n\t */\n\tif (gk_ip_family(key) == 0)\n\t{\n\t\tAssert(!GIST_LEAF(ent));\n\t\tPG_RETURN_BOOL(true);\n\t}\n\n\t/*\n\t * Check 1: different families\n\t *\n\t * Matching families do not help any of the strategies.\n\t */\n\tif (gk_ip_family(key) != ip_family(query))\n\t{\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase INETSTRAT_LT:\n\t\t\tcase INETSTRAT_LE:\n\t\t\t\tif (gk_ip_family(key) < ip_family(query))\n\t\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\t\tbreak;\n\n\t\t\tcase INETSTRAT_GE:\n\t\t\tcase INETSTRAT_GT:\n\t\t\t\tif (gk_ip_family(key) > ip_family(query))\n\t\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\t\tbreak;\n\n\t\t\tcase INETSTRAT_NE:\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t}\n\t\t/* For all other cases, we can be sure there is no match */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\t/*\n\t * Check 2: network bit count\n\t *\n\t * Network bit count (ip_bits) helps to check leaves for sub network and\n\t * sup network operators.  At non-leaf nodes, we know every child value\n\t * has ip_bits >= gk_ip_minbits(key), so we can avoid descending in some\n\t * cases too.\n\t */\n\tswitch (strategy)\n\t{\n\t\tcase INETSTRAT_SUB:\n\t\t\tif (GIST_LEAF(ent) && gk_ip_minbits(key) <= ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_SUBEQ:\n\t\t\tif (GIST_LEAF(ent) && gk_ip_minbits(key) < ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_SUPEQ:\n\t\tcase INETSTRAT_EQ:\n\t\t\tif (gk_ip_minbits(key) > ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_SUP:\n\t\t\tif (gk_ip_minbits(key) >= ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Check 3: common network bits\n\t *\n\t * Compare available common prefix bits to the query, but not beyond\n\t * either the query's netmask or the minimum netmask among the represented\n\t * values.  If these bits don't match the query, we have our answer (and\n\t * may or may not need to descend, depending on the operator).  If they do\n\t * match, and we are not at a leaf, we descend in all cases.\n\t *\n\t * Note this is the final check for operators that only consider the\n\t * network part of the address.\n\t */\n\tminbits = Min(gk_ip_commonbits(key), gk_ip_minbits(key));\n\tminbits = Min(minbits, ip_bits(query));\n\n\torder = bitncmp(gk_ip_addr(key), ip_addr(query), minbits);\n\n\tswitch (strategy)\n\t{\n\t\tcase INETSTRAT_SUB:\n\t\tcase INETSTRAT_SUBEQ:\n\t\tcase INETSTRAT_OVERLAPS:\n\t\tcase INETSTRAT_SUPEQ:\n\t\tcase INETSTRAT_SUP:\n\t\t\tPG_RETURN_BOOL(order == 0);\n\n\t\tcase INETSTRAT_LT:\n\t\tcase INETSTRAT_LE:\n\t\t\tif (order > 0)\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tif (order < 0 || !GIST_LEAF(ent))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_EQ:\n\t\t\tif (order != 0)\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tif (!GIST_LEAF(ent))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_GE:\n\t\tcase INETSTRAT_GT:\n\t\t\tif (order < 0)\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tif (order > 0 || !GIST_LEAF(ent))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_NE:\n\t\t\tif (order != 0 || !GIST_LEAF(ent))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Remaining checks are only for leaves and basic comparison strategies.\n\t * See network_cmp_internal() in network.c for the implementation we need\n\t * to match.  Note that in a leaf key, commonbits should equal the address\n\t * length, so we compared the whole network parts above.\n\t */\n\tAssert(GIST_LEAF(ent));\n\n\t/*\n\t * Check 4: network bit count\n\t *\n\t * Next step is to compare netmask widths.\n\t */\n\tswitch (strategy)\n\t{\n\t\tcase INETSTRAT_LT:\n\t\tcase INETSTRAT_LE:\n\t\t\tif (gk_ip_minbits(key) < ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tif (gk_ip_minbits(key) > ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_EQ:\n\t\t\tif (gk_ip_minbits(key) != ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_GE:\n\t\tcase INETSTRAT_GT:\n\t\t\tif (gk_ip_minbits(key) > ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tif (gk_ip_minbits(key) < ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_NE:\n\t\t\tif (gk_ip_minbits(key) != ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Check 5: whole address\n\t *\n\t * Netmask bit counts are the same, so check all the address bits.\n\t */\n\torder = bitncmp(gk_ip_addr(key), ip_addr(query), gk_ip_maxbits(key));\n\n\tswitch (strategy)\n\t{\n\t\tcase INETSTRAT_LT:\n\t\t\tPG_RETURN_BOOL(order < 0);\n\n\t\tcase INETSTRAT_LE:\n\t\t\tPG_RETURN_BOOL(order <= 0);\n\n\t\tcase INETSTRAT_EQ:\n\t\t\tPG_RETURN_BOOL(order == 0);\n\n\t\tcase INETSTRAT_GE:\n\t\t\tPG_RETURN_BOOL(order >= 0);\n\n\t\tcase INETSTRAT_GT:\n\t\t\tPG_RETURN_BOOL(order > 0);\n\n\t\tcase INETSTRAT_NE:\n\t\t\tPG_RETURN_BOOL(order != 0);\n\t}\n\n\telog(ERROR, \"unknown strategy for inet GiST\");\n\tPG_RETURN_BOOL(false);\t\t/* keep compiler quiet */\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/gist.h\"",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define INETSTRAT_SUPEQ\t\t\tRTSuperEqualStrategyNumber",
      "#define INETSTRAT_SUP\t\t\tRTSuperStrategyNumber",
      "#define INETSTRAT_SUBEQ\t\t\tRTSubEqualStrategyNumber",
      "#define INETSTRAT_SUB\t\t\tRTSubStrategyNumber",
      "#define INETSTRAT_GE\t\t\tRTGreaterEqualStrategyNumber",
      "#define INETSTRAT_GT\t\t\tRTGreaterStrategyNumber",
      "#define INETSTRAT_LE\t\t\tRTLessEqualStrategyNumber",
      "#define INETSTRAT_LT\t\t\tRTLessStrategyNumber",
      "#define INETSTRAT_NE\t\t\tRTNotEqualStrategyNumber",
      "#define INETSTRAT_EQ\t\t\tRTEqualStrategyNumber",
      "#define INETSTRAT_OVERLAPS\t\tRTOverlapStrategyNumber"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown strategy for inet GiST\""
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "order != 0"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "order > 0"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "order >= 0"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "order == 0"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "order <= 0"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "order < 0"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitncmp",
          "args": [
            "gk_ip_addr(key)",
            "ip_addr(query)",
            "gk_ip_maxbits(key)"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "bitncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "976-1003",
          "snippet": "int\nbitncmp(const unsigned char *l, const unsigned char *r, int n)\n{\n\tunsigned int lb,\n\t\t\t\trb;\n\tint\t\t\tx,\n\t\t\t\tb;\n\n\tb = n / 8;\n\tx = memcmp(l, r, b);\n\tif (x || (n % 8) == 0)\n\t\treturn x;\n\n\tlb = l[b];\n\trb = r[b];\n\tfor (b = n % 8; b > 0; b--)\n\t{\n\t\tif (IS_HIGHBIT_SET(lb) != IS_HIGHBIT_SET(rb))\n\t\t{\n\t\t\tif (IS_HIGHBIT_SET(lb))\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\t\tlb <<= 1;\n\t\trb <<= 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nint\nbitncmp(const unsigned char *l, const unsigned char *r, int n)\n{\n\tunsigned int lb,\n\t\t\t\trb;\n\tint\t\t\tx,\n\t\t\t\tb;\n\n\tb = n / 8;\n\tx = memcmp(l, r, b);\n\tif (x || (n % 8) == 0)\n\t\treturn x;\n\n\tlb = l[b];\n\trb = r[b];\n\tfor (b = n % 8; b > 0; b--)\n\t{\n\t\tif (IS_HIGHBIT_SET(lb) != IS_HIGHBIT_SET(rb))\n\t\t{\n\t\t\tif (IS_HIGHBIT_SET(lb))\n\t\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\t\tlb <<= 1;\n\t\trb <<= 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gk_ip_maxbits",
          "args": [
            "key"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "query"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "key"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "GIST_LEAF(ent)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIST_LEAF",
          "args": [
            "ent"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIST_LEAF",
          "args": [
            "ent"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIST_LEAF",
          "args": [
            "ent"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIST_LEAF",
          "args": [
            "ent"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIST_LEAF",
          "args": [
            "ent"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "order == 0"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_addr",
          "args": [
            "query"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_addr",
          "args": [
            "key"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "minbits",
            "ip_bits(query)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "gk_ip_commonbits(key)",
            "gk_ip_minbits(key)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_commonbits",
          "args": [
            "key"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIST_LEAF",
          "args": [
            "ent"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_bits",
          "args": [
            "query"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_minbits",
          "args": [
            "key"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIST_LEAF",
          "args": [
            "ent"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "query"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "key"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "query"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "key"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip_family",
          "args": [
            "query"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "key"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!GIST_LEAF(ent)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIST_LEAF",
          "args": [
            "ent"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gk_ip_family",
          "args": [
            "key"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInetKeyP",
          "args": [
            "ent->key"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "4"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_UINT16",
          "args": [
            "2"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INET_PP",
          "args": [
            "1"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"access/stratnum.h\"\n#include \"access/gist.h\"\n#include <sys/socket.h>\n#include \"postgres.h\"\n\n#define INETSTRAT_SUPEQ\t\t\tRTSuperEqualStrategyNumber\n#define INETSTRAT_SUP\t\t\tRTSuperStrategyNumber\n#define INETSTRAT_SUBEQ\t\t\tRTSubEqualStrategyNumber\n#define INETSTRAT_SUB\t\t\tRTSubStrategyNumber\n#define INETSTRAT_GE\t\t\tRTGreaterEqualStrategyNumber\n#define INETSTRAT_GT\t\t\tRTGreaterStrategyNumber\n#define INETSTRAT_LE\t\t\tRTLessEqualStrategyNumber\n#define INETSTRAT_LT\t\t\tRTLessStrategyNumber\n#define INETSTRAT_NE\t\t\tRTNotEqualStrategyNumber\n#define INETSTRAT_EQ\t\t\tRTEqualStrategyNumber\n#define INETSTRAT_OVERLAPS\t\tRTOverlapStrategyNumber\n\nDatum\ninet_gist_consistent(PG_FUNCTION_ARGS)\n{\n\tGISTENTRY  *ent = (GISTENTRY *) PG_GETARG_POINTER(0);\n\tinet\t   *query = PG_GETARG_INET_PP(1);\n\tStrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);\n\n\t/* Oid\t\tsubtype = PG_GETARG_OID(3); */\n\tbool\t   *recheck = (bool *) PG_GETARG_POINTER(4);\n\tGistInetKey *key = DatumGetInetKeyP(ent->key);\n\tint\t\t\tminbits,\n\t\t\t\torder;\n\n\t/* All operators served by this function are exact. */\n\t*recheck = false;\n\n\t/*\n\t * Check 0: different families\n\t *\n\t * If key represents multiple address families, its children could match\n\t * anything.  This can only happen on an inner index page.\n\t */\n\tif (gk_ip_family(key) == 0)\n\t{\n\t\tAssert(!GIST_LEAF(ent));\n\t\tPG_RETURN_BOOL(true);\n\t}\n\n\t/*\n\t * Check 1: different families\n\t *\n\t * Matching families do not help any of the strategies.\n\t */\n\tif (gk_ip_family(key) != ip_family(query))\n\t{\n\t\tswitch (strategy)\n\t\t{\n\t\t\tcase INETSTRAT_LT:\n\t\t\tcase INETSTRAT_LE:\n\t\t\t\tif (gk_ip_family(key) < ip_family(query))\n\t\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\t\tbreak;\n\n\t\t\tcase INETSTRAT_GE:\n\t\t\tcase INETSTRAT_GT:\n\t\t\t\tif (gk_ip_family(key) > ip_family(query))\n\t\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\t\tbreak;\n\n\t\t\tcase INETSTRAT_NE:\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t}\n\t\t/* For all other cases, we can be sure there is no match */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\t/*\n\t * Check 2: network bit count\n\t *\n\t * Network bit count (ip_bits) helps to check leaves for sub network and\n\t * sup network operators.  At non-leaf nodes, we know every child value\n\t * has ip_bits >= gk_ip_minbits(key), so we can avoid descending in some\n\t * cases too.\n\t */\n\tswitch (strategy)\n\t{\n\t\tcase INETSTRAT_SUB:\n\t\t\tif (GIST_LEAF(ent) && gk_ip_minbits(key) <= ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_SUBEQ:\n\t\t\tif (GIST_LEAF(ent) && gk_ip_minbits(key) < ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_SUPEQ:\n\t\tcase INETSTRAT_EQ:\n\t\t\tif (gk_ip_minbits(key) > ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_SUP:\n\t\t\tif (gk_ip_minbits(key) >= ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Check 3: common network bits\n\t *\n\t * Compare available common prefix bits to the query, but not beyond\n\t * either the query's netmask or the minimum netmask among the represented\n\t * values.  If these bits don't match the query, we have our answer (and\n\t * may or may not need to descend, depending on the operator).  If they do\n\t * match, and we are not at a leaf, we descend in all cases.\n\t *\n\t * Note this is the final check for operators that only consider the\n\t * network part of the address.\n\t */\n\tminbits = Min(gk_ip_commonbits(key), gk_ip_minbits(key));\n\tminbits = Min(minbits, ip_bits(query));\n\n\torder = bitncmp(gk_ip_addr(key), ip_addr(query), minbits);\n\n\tswitch (strategy)\n\t{\n\t\tcase INETSTRAT_SUB:\n\t\tcase INETSTRAT_SUBEQ:\n\t\tcase INETSTRAT_OVERLAPS:\n\t\tcase INETSTRAT_SUPEQ:\n\t\tcase INETSTRAT_SUP:\n\t\t\tPG_RETURN_BOOL(order == 0);\n\n\t\tcase INETSTRAT_LT:\n\t\tcase INETSTRAT_LE:\n\t\t\tif (order > 0)\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tif (order < 0 || !GIST_LEAF(ent))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_EQ:\n\t\t\tif (order != 0)\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tif (!GIST_LEAF(ent))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_GE:\n\t\tcase INETSTRAT_GT:\n\t\t\tif (order < 0)\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tif (order > 0 || !GIST_LEAF(ent))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_NE:\n\t\t\tif (order != 0 || !GIST_LEAF(ent))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Remaining checks are only for leaves and basic comparison strategies.\n\t * See network_cmp_internal() in network.c for the implementation we need\n\t * to match.  Note that in a leaf key, commonbits should equal the address\n\t * length, so we compared the whole network parts above.\n\t */\n\tAssert(GIST_LEAF(ent));\n\n\t/*\n\t * Check 4: network bit count\n\t *\n\t * Next step is to compare netmask widths.\n\t */\n\tswitch (strategy)\n\t{\n\t\tcase INETSTRAT_LT:\n\t\tcase INETSTRAT_LE:\n\t\t\tif (gk_ip_minbits(key) < ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tif (gk_ip_minbits(key) > ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_EQ:\n\t\t\tif (gk_ip_minbits(key) != ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_GE:\n\t\tcase INETSTRAT_GT:\n\t\t\tif (gk_ip_minbits(key) > ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tif (gk_ip_minbits(key) < ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(false);\n\t\t\tbreak;\n\n\t\tcase INETSTRAT_NE:\n\t\t\tif (gk_ip_minbits(key) != ip_bits(query))\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Check 5: whole address\n\t *\n\t * Netmask bit counts are the same, so check all the address bits.\n\t */\n\torder = bitncmp(gk_ip_addr(key), ip_addr(query), gk_ip_maxbits(key));\n\n\tswitch (strategy)\n\t{\n\t\tcase INETSTRAT_LT:\n\t\t\tPG_RETURN_BOOL(order < 0);\n\n\t\tcase INETSTRAT_LE:\n\t\t\tPG_RETURN_BOOL(order <= 0);\n\n\t\tcase INETSTRAT_EQ:\n\t\t\tPG_RETURN_BOOL(order == 0);\n\n\t\tcase INETSTRAT_GE:\n\t\t\tPG_RETURN_BOOL(order >= 0);\n\n\t\tcase INETSTRAT_GT:\n\t\t\tPG_RETURN_BOOL(order > 0);\n\n\t\tcase INETSTRAT_NE:\n\t\t\tPG_RETURN_BOOL(order != 0);\n\t}\n\n\telog(ERROR, \"unknown strategy for inet GiST\");\n\tPG_RETURN_BOOL(false);\t\t/* keep compiler quiet */\n}"
  }
]