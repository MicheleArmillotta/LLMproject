[
  {
    "function_name": "deconstruct_expanded_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
    "lines": "423-453",
    "snippet": "void\ndeconstruct_expanded_array(ExpandedArrayHeader *eah)\n{\n\tif (eah->dvalues == NULL)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\t\tDatum\t   *dvalues;\n\t\tbool\t   *dnulls;\n\t\tint\t\t\tnelems;\n\n\t\tdnulls = NULL;\n\t\tdeconstruct_array(eah->fvalue,\n\t\t\t\t\t\t  eah->element_type,\n\t\t\t\t\t\t  eah->typlen, eah->typbyval, eah->typalign,\n\t\t\t\t\t\t  &dvalues,\n\t\t\t\t\t\t  ARR_HASNULL(eah->fvalue) ? &dnulls : NULL,\n\t\t\t\t\t\t  &nelems);\n\n\t\t/*\n\t\t * Update header only after successful completion of this step.  If\n\t\t * deconstruct_array fails partway through, worst consequence is some\n\t\t * leaked memory in the object's context.  If the caller fails at a\n\t\t * later point, that's fine, since the deconstructed representation is\n\t\t * valid anyhow.\n\t\t */\n\t\teah->dvalues = dvalues;\n\t\teah->dnulls = dnulls;\n\t\teah->dvalueslen = eah->nelems = nelems;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/array.h\"",
      "#include \"access/tupmacs.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "eah->fvalue",
            "eah->element_type",
            "eah->typlen",
            "eah->typbyval",
            "eah->typalign",
            "&dvalues",
            "ARR_HASNULL(eah->fvalue) ? &dnulls : NULL",
            "&nelems"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "eah->fvalue"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "eah->hdr.eoh_context"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nvoid\ndeconstruct_expanded_array(ExpandedArrayHeader *eah)\n{\n\tif (eah->dvalues == NULL)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\t\tDatum\t   *dvalues;\n\t\tbool\t   *dnulls;\n\t\tint\t\t\tnelems;\n\n\t\tdnulls = NULL;\n\t\tdeconstruct_array(eah->fvalue,\n\t\t\t\t\t\t  eah->element_type,\n\t\t\t\t\t\t  eah->typlen, eah->typbyval, eah->typalign,\n\t\t\t\t\t\t  &dvalues,\n\t\t\t\t\t\t  ARR_HASNULL(eah->fvalue) ? &dnulls : NULL,\n\t\t\t\t\t\t  &nelems);\n\n\t\t/*\n\t\t * Update header only after successful completion of this step.  If\n\t\t * deconstruct_array fails partway through, worst consequence is some\n\t\t * leaked memory in the object's context.  If the caller fails at a\n\t\t * later point, that's fine, since the deconstructed representation is\n\t\t * valid anyhow.\n\t\t */\n\t\teah->dvalues = dvalues;\n\t\teah->dnulls = dnulls;\n\t\teah->dvalueslen = eah->nelems = nelems;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n}"
  },
  {
    "function_name": "DatumGetAnyArrayP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
    "lines": "400-417",
    "snippet": "AnyArrayType *\nDatumGetAnyArrayP(Datum d)\n{\n\tExpandedArrayHeader *eah;\n\n\t/*\n\t * If it's an expanded array (RW or RO), return the header pointer.\n\t */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(d)))\n\t{\n\t\teah = (ExpandedArrayHeader *) DatumGetEOHP(d);\n\t\tAssert(eah->ea_magic == EA_MAGIC);\n\t\treturn (AnyArrayType *) eah;\n\t}\n\n\t/* Else do regular detoasting as needed */\n\treturn (AnyArrayType *) PG_DETOAST_DATUM(d);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/array.h\"",
      "#include \"access/tupmacs.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "d"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "eah->ea_magic == EA_MAGIC"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetEOHP",
          "args": [
            "d"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetEOHP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "28-38",
          "snippet": "ExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED",
          "args": [
            "DatumGetPointer(d)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "d"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nAnyArrayType *\nDatumGetAnyArrayP(Datum d)\n{\n\tExpandedArrayHeader *eah;\n\n\t/*\n\t * If it's an expanded array (RW or RO), return the header pointer.\n\t */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(d)))\n\t{\n\t\teah = (ExpandedArrayHeader *) DatumGetEOHP(d);\n\t\tAssert(eah->ea_magic == EA_MAGIC);\n\t\treturn (AnyArrayType *) eah;\n\t}\n\n\t/* Else do regular detoasting as needed */\n\treturn (AnyArrayType *) PG_DETOAST_DATUM(d);\n}"
  },
  {
    "function_name": "DatumGetExpandedArrayX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
    "lines": "371-394",
    "snippet": "ExpandedArrayHeader *\nDatumGetExpandedArrayX(Datum d, ArrayMetaState *metacache)\n{\n\t/* If it's a writable expanded array already, just return it */\n\tif (VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)))\n\t{\n\t\tExpandedArrayHeader *eah = (ExpandedArrayHeader *) DatumGetEOHP(d);\n\n\t\tAssert(eah->ea_magic == EA_MAGIC);\n\t\t/* Update cache if provided */\n\t\tif (metacache)\n\t\t{\n\t\t\tmetacache->element_type = eah->element_type;\n\t\t\tmetacache->typlen = eah->typlen;\n\t\t\tmetacache->typbyval = eah->typbyval;\n\t\t\tmetacache->typalign = eah->typalign;\n\t\t}\n\t\treturn eah;\n\t}\n\n\t/* Else expand using caller's cache if any */\n\td = expand_array(d, CurrentMemoryContext, metacache);\n\treturn (ExpandedArrayHeader *) DatumGetEOHP(d);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/array.h\"",
      "#include \"access/tupmacs.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetEOHP",
          "args": [
            "d"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetEOHP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "28-38",
          "snippet": "ExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_array",
          "args": [
            "d",
            "CurrentMemoryContext",
            "metacache"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "expand_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
          "lines": "49-179",
          "snippet": "Datum\nexpand_array(Datum arraydatum, MemoryContext parentcontext,\n\t\t\t ArrayMetaState *metacache)\n{\n\tArrayType  *array;\n\tExpandedArrayHeader *eah;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tArrayMetaState fakecache;\n\n\t/*\n\t * Allocate private context for expanded object.  We start by assuming\n\t * that the array won't be very large; but if it does grow a lot, don't\n\t * constrain aset.c's large-context behavior.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded array\",\n\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\t/* Set up expanded array header */\n\teah = (ExpandedArrayHeader *)\n\t\tMemoryContextAlloc(objcxt, sizeof(ExpandedArrayHeader));\n\n\tEOH_init_header(&eah->hdr, &EA_methods, objcxt);\n\teah->ea_magic = EA_MAGIC;\n\n\t/* If the source is an expanded array, we may be able to optimize */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\tExpandedArrayHeader *oldeah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\n\t\tAssert(oldeah->ea_magic == EA_MAGIC);\n\n\t\t/*\n\t\t * Update caller's cache if provided; we don't need it this time, but\n\t\t * next call might be for a non-expanded source array.  Furthermore,\n\t\t * if the caller didn't provide a cache area, use some local storage\n\t\t * to cache anyway, thereby avoiding a catalog lookup in the case\n\t\t * where we fall through to the flat-copy code path.\n\t\t */\n\t\tif (metacache == NULL)\n\t\t\tmetacache = &fakecache;\n\t\tmetacache->element_type = oldeah->element_type;\n\t\tmetacache->typlen = oldeah->typlen;\n\t\tmetacache->typbyval = oldeah->typbyval;\n\t\tmetacache->typalign = oldeah->typalign;\n\n\t\t/*\n\t\t * If element type is pass-by-value and we have a Datum-array\n\t\t * representation, just copy the source's metadata and Datum/isnull\n\t\t * arrays.  The original flat array, if present at all, adds no\n\t\t * additional information so we need not copy it.\n\t\t */\n\t\tif (oldeah->typbyval && oldeah->dvalues != NULL)\n\t\t{\n\t\t\tcopy_byval_expanded_array(eah, oldeah);\n\t\t\t/* return a R/W pointer to the expanded array */\n\t\t\treturn EOHPGetRWDatum(&eah->hdr);\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, either we have only a flat representation or the\n\t\t * elements are pass-by-reference.  In either case, the best thing\n\t\t * seems to be to copy the source as a flat representation and then\n\t\t * deconstruct that later if necessary.  For the pass-by-ref case, we\n\t\t * could perhaps save some cycles with custom code that generates the\n\t\t * deconstructed representation in parallel with copying the values,\n\t\t * but it would be a lot of extra code for fairly marginal gain.  So,\n\t\t * fall through into the flat-source code path.\n\t\t */\n\t}\n\n\t/*\n\t * Detoast and copy source array into private context, as a flat array.\n\t *\n\t * Note that this coding risks leaking some memory in the private context\n\t * if we have to fetch data from a TOAST table; however, experimentation\n\t * says that the leak is minimal.  Doing it this way saves a copy step,\n\t * which seems worthwhile, especially if the array is large enough to need\n\t * external storage.\n\t */\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tarray = DatumGetArrayTypePCopy(arraydatum);\n\tMemoryContextSwitchTo(oldcxt);\n\n\teah->ndims = ARR_NDIM(array);\n\t/* note these pointers point into the fvalue header! */\n\teah->dims = ARR_DIMS(array);\n\teah->lbound = ARR_LBOUND(array);\n\n\t/* Save array's element-type data for possible use later */\n\teah->element_type = ARR_ELEMTYPE(array);\n\tif (metacache && metacache->element_type == eah->element_type)\n\t{\n\t\t/* We have a valid cache of representational data */\n\t\teah->typlen = metacache->typlen;\n\t\teah->typbyval = metacache->typbyval;\n\t\teah->typalign = metacache->typalign;\n\t}\n\telse\n\t{\n\t\t/* No, so look it up */\n\t\tget_typlenbyvalalign(eah->element_type,\n\t\t\t\t\t\t\t &eah->typlen,\n\t\t\t\t\t\t\t &eah->typbyval,\n\t\t\t\t\t\t\t &eah->typalign);\n\t\t/* Update cache if provided */\n\t\tif (metacache)\n\t\t{\n\t\t\tmetacache->element_type = eah->element_type;\n\t\t\tmetacache->typlen = eah->typlen;\n\t\t\tmetacache->typbyval = eah->typbyval;\n\t\t\tmetacache->typalign = eah->typalign;\n\t\t}\n\t}\n\n\t/* we don't make a deconstructed representation now */\n\teah->dvalues = NULL;\n\teah->dnulls = NULL;\n\teah->dvalueslen = 0;\n\teah->nelems = 0;\n\teah->flat_size = 0;\n\n\t/* remember we have a flat representation */\n\teah->fvalue = array;\n\teah->fstartptr = ARR_DATA_PTR(array);\n\teah->fendptr = ((char *) array) + ARR_SIZE(array);\n\n\t/* return a R/W pointer to the expanded array */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/array.h\"",
            "#include \"access/tupmacs.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const ExpandedObjectMethods EA_methods =\n{\n\tEA_get_flat_size,\n\tEA_flatten_into\n};",
            "static void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods EA_methods =\n{\n\tEA_get_flat_size,\n\tEA_flatten_into\n};\nstatic void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);\n\nDatum\nexpand_array(Datum arraydatum, MemoryContext parentcontext,\n\t\t\t ArrayMetaState *metacache)\n{\n\tArrayType  *array;\n\tExpandedArrayHeader *eah;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tArrayMetaState fakecache;\n\n\t/*\n\t * Allocate private context for expanded object.  We start by assuming\n\t * that the array won't be very large; but if it does grow a lot, don't\n\t * constrain aset.c's large-context behavior.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded array\",\n\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\t/* Set up expanded array header */\n\teah = (ExpandedArrayHeader *)\n\t\tMemoryContextAlloc(objcxt, sizeof(ExpandedArrayHeader));\n\n\tEOH_init_header(&eah->hdr, &EA_methods, objcxt);\n\teah->ea_magic = EA_MAGIC;\n\n\t/* If the source is an expanded array, we may be able to optimize */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\tExpandedArrayHeader *oldeah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\n\t\tAssert(oldeah->ea_magic == EA_MAGIC);\n\n\t\t/*\n\t\t * Update caller's cache if provided; we don't need it this time, but\n\t\t * next call might be for a non-expanded source array.  Furthermore,\n\t\t * if the caller didn't provide a cache area, use some local storage\n\t\t * to cache anyway, thereby avoiding a catalog lookup in the case\n\t\t * where we fall through to the flat-copy code path.\n\t\t */\n\t\tif (metacache == NULL)\n\t\t\tmetacache = &fakecache;\n\t\tmetacache->element_type = oldeah->element_type;\n\t\tmetacache->typlen = oldeah->typlen;\n\t\tmetacache->typbyval = oldeah->typbyval;\n\t\tmetacache->typalign = oldeah->typalign;\n\n\t\t/*\n\t\t * If element type is pass-by-value and we have a Datum-array\n\t\t * representation, just copy the source's metadata and Datum/isnull\n\t\t * arrays.  The original flat array, if present at all, adds no\n\t\t * additional information so we need not copy it.\n\t\t */\n\t\tif (oldeah->typbyval && oldeah->dvalues != NULL)\n\t\t{\n\t\t\tcopy_byval_expanded_array(eah, oldeah);\n\t\t\t/* return a R/W pointer to the expanded array */\n\t\t\treturn EOHPGetRWDatum(&eah->hdr);\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, either we have only a flat representation or the\n\t\t * elements are pass-by-reference.  In either case, the best thing\n\t\t * seems to be to copy the source as a flat representation and then\n\t\t * deconstruct that later if necessary.  For the pass-by-ref case, we\n\t\t * could perhaps save some cycles with custom code that generates the\n\t\t * deconstructed representation in parallel with copying the values,\n\t\t * but it would be a lot of extra code for fairly marginal gain.  So,\n\t\t * fall through into the flat-source code path.\n\t\t */\n\t}\n\n\t/*\n\t * Detoast and copy source array into private context, as a flat array.\n\t *\n\t * Note that this coding risks leaking some memory in the private context\n\t * if we have to fetch data from a TOAST table; however, experimentation\n\t * says that the leak is minimal.  Doing it this way saves a copy step,\n\t * which seems worthwhile, especially if the array is large enough to need\n\t * external storage.\n\t */\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tarray = DatumGetArrayTypePCopy(arraydatum);\n\tMemoryContextSwitchTo(oldcxt);\n\n\teah->ndims = ARR_NDIM(array);\n\t/* note these pointers point into the fvalue header! */\n\teah->dims = ARR_DIMS(array);\n\teah->lbound = ARR_LBOUND(array);\n\n\t/* Save array's element-type data for possible use later */\n\teah->element_type = ARR_ELEMTYPE(array);\n\tif (metacache && metacache->element_type == eah->element_type)\n\t{\n\t\t/* We have a valid cache of representational data */\n\t\teah->typlen = metacache->typlen;\n\t\teah->typbyval = metacache->typbyval;\n\t\teah->typalign = metacache->typalign;\n\t}\n\telse\n\t{\n\t\t/* No, so look it up */\n\t\tget_typlenbyvalalign(eah->element_type,\n\t\t\t\t\t\t\t &eah->typlen,\n\t\t\t\t\t\t\t &eah->typbyval,\n\t\t\t\t\t\t\t &eah->typalign);\n\t\t/* Update cache if provided */\n\t\tif (metacache)\n\t\t{\n\t\t\tmetacache->element_type = eah->element_type;\n\t\t\tmetacache->typlen = eah->typlen;\n\t\t\tmetacache->typbyval = eah->typbyval;\n\t\t\tmetacache->typalign = eah->typalign;\n\t\t}\n\t}\n\n\t/* we don't make a deconstructed representation now */\n\teah->dvalues = NULL;\n\teah->dnulls = NULL;\n\teah->dvalueslen = 0;\n\teah->nelems = 0;\n\teah->flat_size = 0;\n\n\t/* remember we have a flat representation */\n\teah->fvalue = array;\n\teah->fstartptr = ARR_DATA_PTR(array);\n\teah->fendptr = ((char *) array) + ARR_SIZE(array);\n\n\t/* return a R/W pointer to the expanded array */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "eah->ea_magic == EA_MAGIC"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED_RW",
          "args": [
            "DatumGetPointer(d)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "d"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nExpandedArrayHeader *\nDatumGetExpandedArrayX(Datum d, ArrayMetaState *metacache)\n{\n\t/* If it's a writable expanded array already, just return it */\n\tif (VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)))\n\t{\n\t\tExpandedArrayHeader *eah = (ExpandedArrayHeader *) DatumGetEOHP(d);\n\n\t\tAssert(eah->ea_magic == EA_MAGIC);\n\t\t/* Update cache if provided */\n\t\tif (metacache)\n\t\t{\n\t\t\tmetacache->element_type = eah->element_type;\n\t\t\tmetacache->typlen = eah->typlen;\n\t\t\tmetacache->typbyval = eah->typbyval;\n\t\t\tmetacache->typalign = eah->typalign;\n\t\t}\n\t\treturn eah;\n\t}\n\n\t/* Else expand using caller's cache if any */\n\td = expand_array(d, CurrentMemoryContext, metacache);\n\treturn (ExpandedArrayHeader *) DatumGetEOHP(d);\n}"
  },
  {
    "function_name": "DatumGetExpandedArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
    "lines": "351-366",
    "snippet": "ExpandedArrayHeader *\nDatumGetExpandedArray(Datum d)\n{\n\t/* If it's a writable expanded array already, just return it */\n\tif (VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)))\n\t{\n\t\tExpandedArrayHeader *eah = (ExpandedArrayHeader *) DatumGetEOHP(d);\n\n\t\tAssert(eah->ea_magic == EA_MAGIC);\n\t\treturn eah;\n\t}\n\n\t/* Else expand the hard way */\n\td = expand_array(d, CurrentMemoryContext, NULL);\n\treturn (ExpandedArrayHeader *) DatumGetEOHP(d);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/array.h\"",
      "#include \"access/tupmacs.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetEOHP",
          "args": [
            "d"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetEOHP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "28-38",
          "snippet": "ExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_array",
          "args": [
            "d",
            "CurrentMemoryContext",
            "NULL"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "expand_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
          "lines": "49-179",
          "snippet": "Datum\nexpand_array(Datum arraydatum, MemoryContext parentcontext,\n\t\t\t ArrayMetaState *metacache)\n{\n\tArrayType  *array;\n\tExpandedArrayHeader *eah;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tArrayMetaState fakecache;\n\n\t/*\n\t * Allocate private context for expanded object.  We start by assuming\n\t * that the array won't be very large; but if it does grow a lot, don't\n\t * constrain aset.c's large-context behavior.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded array\",\n\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\t/* Set up expanded array header */\n\teah = (ExpandedArrayHeader *)\n\t\tMemoryContextAlloc(objcxt, sizeof(ExpandedArrayHeader));\n\n\tEOH_init_header(&eah->hdr, &EA_methods, objcxt);\n\teah->ea_magic = EA_MAGIC;\n\n\t/* If the source is an expanded array, we may be able to optimize */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\tExpandedArrayHeader *oldeah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\n\t\tAssert(oldeah->ea_magic == EA_MAGIC);\n\n\t\t/*\n\t\t * Update caller's cache if provided; we don't need it this time, but\n\t\t * next call might be for a non-expanded source array.  Furthermore,\n\t\t * if the caller didn't provide a cache area, use some local storage\n\t\t * to cache anyway, thereby avoiding a catalog lookup in the case\n\t\t * where we fall through to the flat-copy code path.\n\t\t */\n\t\tif (metacache == NULL)\n\t\t\tmetacache = &fakecache;\n\t\tmetacache->element_type = oldeah->element_type;\n\t\tmetacache->typlen = oldeah->typlen;\n\t\tmetacache->typbyval = oldeah->typbyval;\n\t\tmetacache->typalign = oldeah->typalign;\n\n\t\t/*\n\t\t * If element type is pass-by-value and we have a Datum-array\n\t\t * representation, just copy the source's metadata and Datum/isnull\n\t\t * arrays.  The original flat array, if present at all, adds no\n\t\t * additional information so we need not copy it.\n\t\t */\n\t\tif (oldeah->typbyval && oldeah->dvalues != NULL)\n\t\t{\n\t\t\tcopy_byval_expanded_array(eah, oldeah);\n\t\t\t/* return a R/W pointer to the expanded array */\n\t\t\treturn EOHPGetRWDatum(&eah->hdr);\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, either we have only a flat representation or the\n\t\t * elements are pass-by-reference.  In either case, the best thing\n\t\t * seems to be to copy the source as a flat representation and then\n\t\t * deconstruct that later if necessary.  For the pass-by-ref case, we\n\t\t * could perhaps save some cycles with custom code that generates the\n\t\t * deconstructed representation in parallel with copying the values,\n\t\t * but it would be a lot of extra code for fairly marginal gain.  So,\n\t\t * fall through into the flat-source code path.\n\t\t */\n\t}\n\n\t/*\n\t * Detoast and copy source array into private context, as a flat array.\n\t *\n\t * Note that this coding risks leaking some memory in the private context\n\t * if we have to fetch data from a TOAST table; however, experimentation\n\t * says that the leak is minimal.  Doing it this way saves a copy step,\n\t * which seems worthwhile, especially if the array is large enough to need\n\t * external storage.\n\t */\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tarray = DatumGetArrayTypePCopy(arraydatum);\n\tMemoryContextSwitchTo(oldcxt);\n\n\teah->ndims = ARR_NDIM(array);\n\t/* note these pointers point into the fvalue header! */\n\teah->dims = ARR_DIMS(array);\n\teah->lbound = ARR_LBOUND(array);\n\n\t/* Save array's element-type data for possible use later */\n\teah->element_type = ARR_ELEMTYPE(array);\n\tif (metacache && metacache->element_type == eah->element_type)\n\t{\n\t\t/* We have a valid cache of representational data */\n\t\teah->typlen = metacache->typlen;\n\t\teah->typbyval = metacache->typbyval;\n\t\teah->typalign = metacache->typalign;\n\t}\n\telse\n\t{\n\t\t/* No, so look it up */\n\t\tget_typlenbyvalalign(eah->element_type,\n\t\t\t\t\t\t\t &eah->typlen,\n\t\t\t\t\t\t\t &eah->typbyval,\n\t\t\t\t\t\t\t &eah->typalign);\n\t\t/* Update cache if provided */\n\t\tif (metacache)\n\t\t{\n\t\t\tmetacache->element_type = eah->element_type;\n\t\t\tmetacache->typlen = eah->typlen;\n\t\t\tmetacache->typbyval = eah->typbyval;\n\t\t\tmetacache->typalign = eah->typalign;\n\t\t}\n\t}\n\n\t/* we don't make a deconstructed representation now */\n\teah->dvalues = NULL;\n\teah->dnulls = NULL;\n\teah->dvalueslen = 0;\n\teah->nelems = 0;\n\teah->flat_size = 0;\n\n\t/* remember we have a flat representation */\n\teah->fvalue = array;\n\teah->fstartptr = ARR_DATA_PTR(array);\n\teah->fendptr = ((char *) array) + ARR_SIZE(array);\n\n\t/* return a R/W pointer to the expanded array */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/array.h\"",
            "#include \"access/tupmacs.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const ExpandedObjectMethods EA_methods =\n{\n\tEA_get_flat_size,\n\tEA_flatten_into\n};",
            "static void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods EA_methods =\n{\n\tEA_get_flat_size,\n\tEA_flatten_into\n};\nstatic void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);\n\nDatum\nexpand_array(Datum arraydatum, MemoryContext parentcontext,\n\t\t\t ArrayMetaState *metacache)\n{\n\tArrayType  *array;\n\tExpandedArrayHeader *eah;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tArrayMetaState fakecache;\n\n\t/*\n\t * Allocate private context for expanded object.  We start by assuming\n\t * that the array won't be very large; but if it does grow a lot, don't\n\t * constrain aset.c's large-context behavior.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded array\",\n\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\t/* Set up expanded array header */\n\teah = (ExpandedArrayHeader *)\n\t\tMemoryContextAlloc(objcxt, sizeof(ExpandedArrayHeader));\n\n\tEOH_init_header(&eah->hdr, &EA_methods, objcxt);\n\teah->ea_magic = EA_MAGIC;\n\n\t/* If the source is an expanded array, we may be able to optimize */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\tExpandedArrayHeader *oldeah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\n\t\tAssert(oldeah->ea_magic == EA_MAGIC);\n\n\t\t/*\n\t\t * Update caller's cache if provided; we don't need it this time, but\n\t\t * next call might be for a non-expanded source array.  Furthermore,\n\t\t * if the caller didn't provide a cache area, use some local storage\n\t\t * to cache anyway, thereby avoiding a catalog lookup in the case\n\t\t * where we fall through to the flat-copy code path.\n\t\t */\n\t\tif (metacache == NULL)\n\t\t\tmetacache = &fakecache;\n\t\tmetacache->element_type = oldeah->element_type;\n\t\tmetacache->typlen = oldeah->typlen;\n\t\tmetacache->typbyval = oldeah->typbyval;\n\t\tmetacache->typalign = oldeah->typalign;\n\n\t\t/*\n\t\t * If element type is pass-by-value and we have a Datum-array\n\t\t * representation, just copy the source's metadata and Datum/isnull\n\t\t * arrays.  The original flat array, if present at all, adds no\n\t\t * additional information so we need not copy it.\n\t\t */\n\t\tif (oldeah->typbyval && oldeah->dvalues != NULL)\n\t\t{\n\t\t\tcopy_byval_expanded_array(eah, oldeah);\n\t\t\t/* return a R/W pointer to the expanded array */\n\t\t\treturn EOHPGetRWDatum(&eah->hdr);\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, either we have only a flat representation or the\n\t\t * elements are pass-by-reference.  In either case, the best thing\n\t\t * seems to be to copy the source as a flat representation and then\n\t\t * deconstruct that later if necessary.  For the pass-by-ref case, we\n\t\t * could perhaps save some cycles with custom code that generates the\n\t\t * deconstructed representation in parallel with copying the values,\n\t\t * but it would be a lot of extra code for fairly marginal gain.  So,\n\t\t * fall through into the flat-source code path.\n\t\t */\n\t}\n\n\t/*\n\t * Detoast and copy source array into private context, as a flat array.\n\t *\n\t * Note that this coding risks leaking some memory in the private context\n\t * if we have to fetch data from a TOAST table; however, experimentation\n\t * says that the leak is minimal.  Doing it this way saves a copy step,\n\t * which seems worthwhile, especially if the array is large enough to need\n\t * external storage.\n\t */\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tarray = DatumGetArrayTypePCopy(arraydatum);\n\tMemoryContextSwitchTo(oldcxt);\n\n\teah->ndims = ARR_NDIM(array);\n\t/* note these pointers point into the fvalue header! */\n\teah->dims = ARR_DIMS(array);\n\teah->lbound = ARR_LBOUND(array);\n\n\t/* Save array's element-type data for possible use later */\n\teah->element_type = ARR_ELEMTYPE(array);\n\tif (metacache && metacache->element_type == eah->element_type)\n\t{\n\t\t/* We have a valid cache of representational data */\n\t\teah->typlen = metacache->typlen;\n\t\teah->typbyval = metacache->typbyval;\n\t\teah->typalign = metacache->typalign;\n\t}\n\telse\n\t{\n\t\t/* No, so look it up */\n\t\tget_typlenbyvalalign(eah->element_type,\n\t\t\t\t\t\t\t &eah->typlen,\n\t\t\t\t\t\t\t &eah->typbyval,\n\t\t\t\t\t\t\t &eah->typalign);\n\t\t/* Update cache if provided */\n\t\tif (metacache)\n\t\t{\n\t\t\tmetacache->element_type = eah->element_type;\n\t\t\tmetacache->typlen = eah->typlen;\n\t\t\tmetacache->typbyval = eah->typbyval;\n\t\t\tmetacache->typalign = eah->typalign;\n\t\t}\n\t}\n\n\t/* we don't make a deconstructed representation now */\n\teah->dvalues = NULL;\n\teah->dnulls = NULL;\n\teah->dvalueslen = 0;\n\teah->nelems = 0;\n\teah->flat_size = 0;\n\n\t/* remember we have a flat representation */\n\teah->fvalue = array;\n\teah->fstartptr = ARR_DATA_PTR(array);\n\teah->fendptr = ((char *) array) + ARR_SIZE(array);\n\n\t/* return a R/W pointer to the expanded array */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "eah->ea_magic == EA_MAGIC"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED_RW",
          "args": [
            "DatumGetPointer(d)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "d"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nExpandedArrayHeader *\nDatumGetExpandedArray(Datum d)\n{\n\t/* If it's a writable expanded array already, just return it */\n\tif (VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)))\n\t{\n\t\tExpandedArrayHeader *eah = (ExpandedArrayHeader *) DatumGetEOHP(d);\n\n\t\tAssert(eah->ea_magic == EA_MAGIC);\n\t\treturn eah;\n\t}\n\n\t/* Else expand the hard way */\n\td = expand_array(d, CurrentMemoryContext, NULL);\n\treturn (ExpandedArrayHeader *) DatumGetEOHP(d);\n}"
  },
  {
    "function_name": "EA_flatten_into",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
    "lines": "292-338",
    "snippet": "static void\nEA_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\tvoid *result, Size allocated_size)\n{\n\tExpandedArrayHeader *eah = (ExpandedArrayHeader *) eohptr;\n\tArrayType  *aresult = (ArrayType *) result;\n\tint\t\t\tnelems;\n\tint\t\t\tndims;\n\tint32\t\tdataoffset;\n\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* Easy if we have a valid flattened value */\n\tif (eah->fvalue)\n\t{\n\t\tAssert(allocated_size == ARR_SIZE(eah->fvalue));\n\t\tmemcpy(result, eah->fvalue, allocated_size);\n\t\treturn;\n\t}\n\n\t/* Else allocation should match previous get_flat_size result */\n\tAssert(allocated_size == eah->flat_size);\n\n\t/* Fill result array from dvalues/dnulls */\n\tnelems = eah->nelems;\n\tndims = eah->ndims;\n\n\tif (eah->dnulls)\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\telse\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\n\t/* We must ensure that any pad space is zero-filled */\n\tmemset(aresult, 0, allocated_size);\n\n\tSET_VARSIZE(aresult, allocated_size);\n\taresult->ndim = ndims;\n\taresult->dataoffset = dataoffset;\n\taresult->elemtype = eah->element_type;\n\tmemcpy(ARR_DIMS(aresult), eah->dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(aresult), eah->lbound, ndims * sizeof(int));\n\n\tCopyArrayEls(aresult,\n\t\t\t\t eah->dvalues, eah->dnulls, nelems,\n\t\t\t\t eah->typlen, eah->typbyval, eah->typalign,\n\t\t\t\t false);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/array.h\"",
      "#include \"access/tupmacs.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size EA_get_flat_size(ExpandedObjectHeader *eohptr);",
      "static void EA_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\tvoid *result, Size allocated_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CopyArrayEls",
          "args": [
            "aresult",
            "eah->dvalues",
            "eah->dnulls",
            "nelems",
            "eah->typlen",
            "eah->typbyval",
            "eah->typalign",
            "false"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "CopyArrayEls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "956-1004",
          "snippet": "void\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nvoid\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(aresult)",
            "eah->lbound",
            "ndims * sizeof(int)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "aresult"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(aresult)",
            "eah->dims",
            "ndims * sizeof(int)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "aresult"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "aresult",
            "allocated_size"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "aresult",
            "0",
            "allocated_size"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndims",
            "nelems"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "allocated_size == eah->flat_size"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "eah->fvalue",
            "allocated_size"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "allocated_size == ARR_SIZE(eah->fvalue)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_SIZE",
          "args": [
            "eah->fvalue"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "eah->ea_magic == EA_MAGIC"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nstatic Size EA_get_flat_size(ExpandedObjectHeader *eohptr);\nstatic void EA_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\tvoid *result, Size allocated_size);\n\nstatic void\nEA_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\tvoid *result, Size allocated_size)\n{\n\tExpandedArrayHeader *eah = (ExpandedArrayHeader *) eohptr;\n\tArrayType  *aresult = (ArrayType *) result;\n\tint\t\t\tnelems;\n\tint\t\t\tndims;\n\tint32\t\tdataoffset;\n\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* Easy if we have a valid flattened value */\n\tif (eah->fvalue)\n\t{\n\t\tAssert(allocated_size == ARR_SIZE(eah->fvalue));\n\t\tmemcpy(result, eah->fvalue, allocated_size);\n\t\treturn;\n\t}\n\n\t/* Else allocation should match previous get_flat_size result */\n\tAssert(allocated_size == eah->flat_size);\n\n\t/* Fill result array from dvalues/dnulls */\n\tnelems = eah->nelems;\n\tndims = eah->ndims;\n\n\tif (eah->dnulls)\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\telse\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\n\t/* We must ensure that any pad space is zero-filled */\n\tmemset(aresult, 0, allocated_size);\n\n\tSET_VARSIZE(aresult, allocated_size);\n\taresult->ndim = ndims;\n\taresult->dataoffset = dataoffset;\n\taresult->elemtype = eah->element_type;\n\tmemcpy(ARR_DIMS(aresult), eah->dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(aresult), eah->lbound, ndims * sizeof(int));\n\n\tCopyArrayEls(aresult,\n\t\t\t\t eah->dvalues, eah->dnulls, nelems,\n\t\t\t\t eah->typlen, eah->typbyval, eah->typalign,\n\t\t\t\t false);\n}"
  },
  {
    "function_name": "EA_get_flat_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
    "lines": "232-287",
    "snippet": "static Size\nEA_get_flat_size(ExpandedObjectHeader *eohptr)\n{\n\tExpandedArrayHeader *eah = (ExpandedArrayHeader *) eohptr;\n\tint\t\t\tnelems;\n\tint\t\t\tndims;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tSize\t\tnbytes;\n\tint\t\t\ti;\n\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* Easy if we have a valid flattened value */\n\tif (eah->fvalue)\n\t\treturn ARR_SIZE(eah->fvalue);\n\n\t/* If we have a cached size value, believe that */\n\tif (eah->flat_size)\n\t\treturn eah->flat_size;\n\n\t/*\n\t * Compute space needed by examining dvalues/dnulls.  Note that the result\n\t * array will have a nulls bitmap if dnulls isn't NULL, even if the array\n\t * doesn't actually contain any nulls now.\n\t */\n\tnelems = eah->nelems;\n\tndims = eah->ndims;\n\tAssert(nelems == ArrayGetNItems(ndims, eah->dims));\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\tnbytes = 0;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (dnulls && dnulls[i])\n\t\t\tcontinue;\n\t\tnbytes = att_addlength_datum(nbytes, eah->typlen, dvalues[i]);\n\t\tnbytes = att_align_nominal(nbytes, eah->typalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\tif (dnulls)\n\t\tnbytes += ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\telse\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\n\t/* cache for next time */\n\teah->flat_size = nbytes;\n\n\treturn nbytes;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/array.h\"",
      "#include \"access/tupmacs.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size EA_get_flat_size(ExpandedObjectHeader *eohptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndims"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndims",
            "nelems"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize))"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"array size exceeds the maximum allowed (%d)\"",
            "(int) MaxAllocSize"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSizeIsValid",
          "args": [
            "nbytes"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "nbytes",
            "eah->typalign"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "nbytes",
            "eah->typlen",
            "dvalues[i]"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nelems == ArrayGetNItems(ndims, eah->dims)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims",
            "eah->dims"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_SIZE",
          "args": [
            "eah->fvalue"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "eah->ea_magic == EA_MAGIC"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nstatic Size EA_get_flat_size(ExpandedObjectHeader *eohptr);\n\nstatic Size\nEA_get_flat_size(ExpandedObjectHeader *eohptr)\n{\n\tExpandedArrayHeader *eah = (ExpandedArrayHeader *) eohptr;\n\tint\t\t\tnelems;\n\tint\t\t\tndims;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tSize\t\tnbytes;\n\tint\t\t\ti;\n\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* Easy if we have a valid flattened value */\n\tif (eah->fvalue)\n\t\treturn ARR_SIZE(eah->fvalue);\n\n\t/* If we have a cached size value, believe that */\n\tif (eah->flat_size)\n\t\treturn eah->flat_size;\n\n\t/*\n\t * Compute space needed by examining dvalues/dnulls.  Note that the result\n\t * array will have a nulls bitmap if dnulls isn't NULL, even if the array\n\t * doesn't actually contain any nulls now.\n\t */\n\tnelems = eah->nelems;\n\tndims = eah->ndims;\n\tAssert(nelems == ArrayGetNItems(ndims, eah->dims));\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\tnbytes = 0;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (dnulls && dnulls[i])\n\t\t\tcontinue;\n\t\tnbytes = att_addlength_datum(nbytes, eah->typlen, dvalues[i]);\n\t\tnbytes = att_align_nominal(nbytes, eah->typalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\tif (dnulls)\n\t\tnbytes += ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\telse\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\n\t/* cache for next time */\n\teah->flat_size = nbytes;\n\n\treturn nbytes;\n}"
  },
  {
    "function_name": "copy_byval_expanded_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
    "lines": "184-227",
    "snippet": "static void\ncopy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah)\n{\n\tMemoryContext objcxt = eah->hdr.eoh_context;\n\tint\t\t\tndims = oldeah->ndims;\n\tint\t\t\tdvalueslen = oldeah->dvalueslen;\n\n\t/* Copy array dimensionality information */\n\teah->ndims = ndims;\n\t/* We can alloc both dimensionality arrays with one palloc */\n\teah->dims = (int *) MemoryContextAlloc(objcxt, ndims * 2 * sizeof(int));\n\teah->lbound = eah->dims + ndims;\n\t/* .. but don't assume the source's arrays are contiguous */\n\tmemcpy(eah->dims, oldeah->dims, ndims * sizeof(int));\n\tmemcpy(eah->lbound, oldeah->lbound, ndims * sizeof(int));\n\n\t/* Copy element-type data */\n\teah->element_type = oldeah->element_type;\n\teah->typlen = oldeah->typlen;\n\teah->typbyval = oldeah->typbyval;\n\teah->typalign = oldeah->typalign;\n\n\t/* Copy the deconstructed representation */\n\teah->dvalues = (Datum *) MemoryContextAlloc(objcxt,\n\t\t\t\t\t\t\t\t\t\t\t\tdvalueslen * sizeof(Datum));\n\tmemcpy(eah->dvalues, oldeah->dvalues, dvalueslen * sizeof(Datum));\n\tif (oldeah->dnulls)\n\t{\n\t\teah->dnulls = (bool *) MemoryContextAlloc(objcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t  dvalueslen * sizeof(bool));\n\t\tmemcpy(eah->dnulls, oldeah->dnulls, dvalueslen * sizeof(bool));\n\t}\n\telse\n\t\teah->dnulls = NULL;\n\teah->dvalueslen = dvalueslen;\n\teah->nelems = oldeah->nelems;\n\teah->flat_size = oldeah->flat_size;\n\n\t/* we don't make a flat representation */\n\teah->fvalue = NULL;\n\teah->fstartptr = NULL;\n\teah->fendptr = NULL;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/array.h\"",
      "#include \"access/tupmacs.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "eah->dnulls",
            "oldeah->dnulls",
            "dvalueslen * sizeof(bool)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "objcxt",
            "dvalueslen * sizeof(bool)"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "eah->dvalues",
            "oldeah->dvalues",
            "dvalueslen * sizeof(Datum)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "eah->lbound",
            "oldeah->lbound",
            "ndims * sizeof(int)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "eah->dims",
            "oldeah->dims",
            "ndims * sizeof(int)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nstatic void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);\n\nstatic void\ncopy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah)\n{\n\tMemoryContext objcxt = eah->hdr.eoh_context;\n\tint\t\t\tndims = oldeah->ndims;\n\tint\t\t\tdvalueslen = oldeah->dvalueslen;\n\n\t/* Copy array dimensionality information */\n\teah->ndims = ndims;\n\t/* We can alloc both dimensionality arrays with one palloc */\n\teah->dims = (int *) MemoryContextAlloc(objcxt, ndims * 2 * sizeof(int));\n\teah->lbound = eah->dims + ndims;\n\t/* .. but don't assume the source's arrays are contiguous */\n\tmemcpy(eah->dims, oldeah->dims, ndims * sizeof(int));\n\tmemcpy(eah->lbound, oldeah->lbound, ndims * sizeof(int));\n\n\t/* Copy element-type data */\n\teah->element_type = oldeah->element_type;\n\teah->typlen = oldeah->typlen;\n\teah->typbyval = oldeah->typbyval;\n\teah->typalign = oldeah->typalign;\n\n\t/* Copy the deconstructed representation */\n\teah->dvalues = (Datum *) MemoryContextAlloc(objcxt,\n\t\t\t\t\t\t\t\t\t\t\t\tdvalueslen * sizeof(Datum));\n\tmemcpy(eah->dvalues, oldeah->dvalues, dvalueslen * sizeof(Datum));\n\tif (oldeah->dnulls)\n\t{\n\t\teah->dnulls = (bool *) MemoryContextAlloc(objcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t  dvalueslen * sizeof(bool));\n\t\tmemcpy(eah->dnulls, oldeah->dnulls, dvalueslen * sizeof(bool));\n\t}\n\telse\n\t\teah->dnulls = NULL;\n\teah->dvalueslen = dvalueslen;\n\teah->nelems = oldeah->nelems;\n\teah->flat_size = oldeah->flat_size;\n\n\t/* we don't make a flat representation */\n\teah->fvalue = NULL;\n\teah->fstartptr = NULL;\n\teah->fendptr = NULL;\n}"
  },
  {
    "function_name": "expand_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
    "lines": "49-179",
    "snippet": "Datum\nexpand_array(Datum arraydatum, MemoryContext parentcontext,\n\t\t\t ArrayMetaState *metacache)\n{\n\tArrayType  *array;\n\tExpandedArrayHeader *eah;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tArrayMetaState fakecache;\n\n\t/*\n\t * Allocate private context for expanded object.  We start by assuming\n\t * that the array won't be very large; but if it does grow a lot, don't\n\t * constrain aset.c's large-context behavior.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded array\",\n\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\t/* Set up expanded array header */\n\teah = (ExpandedArrayHeader *)\n\t\tMemoryContextAlloc(objcxt, sizeof(ExpandedArrayHeader));\n\n\tEOH_init_header(&eah->hdr, &EA_methods, objcxt);\n\teah->ea_magic = EA_MAGIC;\n\n\t/* If the source is an expanded array, we may be able to optimize */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\tExpandedArrayHeader *oldeah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\n\t\tAssert(oldeah->ea_magic == EA_MAGIC);\n\n\t\t/*\n\t\t * Update caller's cache if provided; we don't need it this time, but\n\t\t * next call might be for a non-expanded source array.  Furthermore,\n\t\t * if the caller didn't provide a cache area, use some local storage\n\t\t * to cache anyway, thereby avoiding a catalog lookup in the case\n\t\t * where we fall through to the flat-copy code path.\n\t\t */\n\t\tif (metacache == NULL)\n\t\t\tmetacache = &fakecache;\n\t\tmetacache->element_type = oldeah->element_type;\n\t\tmetacache->typlen = oldeah->typlen;\n\t\tmetacache->typbyval = oldeah->typbyval;\n\t\tmetacache->typalign = oldeah->typalign;\n\n\t\t/*\n\t\t * If element type is pass-by-value and we have a Datum-array\n\t\t * representation, just copy the source's metadata and Datum/isnull\n\t\t * arrays.  The original flat array, if present at all, adds no\n\t\t * additional information so we need not copy it.\n\t\t */\n\t\tif (oldeah->typbyval && oldeah->dvalues != NULL)\n\t\t{\n\t\t\tcopy_byval_expanded_array(eah, oldeah);\n\t\t\t/* return a R/W pointer to the expanded array */\n\t\t\treturn EOHPGetRWDatum(&eah->hdr);\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, either we have only a flat representation or the\n\t\t * elements are pass-by-reference.  In either case, the best thing\n\t\t * seems to be to copy the source as a flat representation and then\n\t\t * deconstruct that later if necessary.  For the pass-by-ref case, we\n\t\t * could perhaps save some cycles with custom code that generates the\n\t\t * deconstructed representation in parallel with copying the values,\n\t\t * but it would be a lot of extra code for fairly marginal gain.  So,\n\t\t * fall through into the flat-source code path.\n\t\t */\n\t}\n\n\t/*\n\t * Detoast and copy source array into private context, as a flat array.\n\t *\n\t * Note that this coding risks leaking some memory in the private context\n\t * if we have to fetch data from a TOAST table; however, experimentation\n\t * says that the leak is minimal.  Doing it this way saves a copy step,\n\t * which seems worthwhile, especially if the array is large enough to need\n\t * external storage.\n\t */\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tarray = DatumGetArrayTypePCopy(arraydatum);\n\tMemoryContextSwitchTo(oldcxt);\n\n\teah->ndims = ARR_NDIM(array);\n\t/* note these pointers point into the fvalue header! */\n\teah->dims = ARR_DIMS(array);\n\teah->lbound = ARR_LBOUND(array);\n\n\t/* Save array's element-type data for possible use later */\n\teah->element_type = ARR_ELEMTYPE(array);\n\tif (metacache && metacache->element_type == eah->element_type)\n\t{\n\t\t/* We have a valid cache of representational data */\n\t\teah->typlen = metacache->typlen;\n\t\teah->typbyval = metacache->typbyval;\n\t\teah->typalign = metacache->typalign;\n\t}\n\telse\n\t{\n\t\t/* No, so look it up */\n\t\tget_typlenbyvalalign(eah->element_type,\n\t\t\t\t\t\t\t &eah->typlen,\n\t\t\t\t\t\t\t &eah->typbyval,\n\t\t\t\t\t\t\t &eah->typalign);\n\t\t/* Update cache if provided */\n\t\tif (metacache)\n\t\t{\n\t\t\tmetacache->element_type = eah->element_type;\n\t\t\tmetacache->typlen = eah->typlen;\n\t\t\tmetacache->typbyval = eah->typbyval;\n\t\t\tmetacache->typalign = eah->typalign;\n\t\t}\n\t}\n\n\t/* we don't make a deconstructed representation now */\n\teah->dvalues = NULL;\n\teah->dnulls = NULL;\n\teah->dvalueslen = 0;\n\teah->nelems = 0;\n\teah->flat_size = 0;\n\n\t/* remember we have a flat representation */\n\teah->fvalue = array;\n\teah->fstartptr = ARR_DATA_PTR(array);\n\teah->fendptr = ((char *) array) + ARR_SIZE(array);\n\n\t/* return a R/W pointer to the expanded array */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/array.h\"",
      "#include \"access/tupmacs.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const ExpandedObjectMethods EA_methods =\n{\n\tEA_get_flat_size,\n\tEA_flatten_into\n};",
      "static void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EOHPGetRWDatum",
          "args": [
            "&eah->hdr"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_SIZE",
          "args": [
            "array"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "array"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "eah->element_type",
            "&eah->typlen",
            "&eah->typbyval",
            "&eah->typalign"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "array"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "array"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypePCopy",
          "args": [
            "arraydatum"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "objcxt"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOHPGetRWDatum",
          "args": [
            "&eah->hdr"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_byval_expanded_array",
          "args": [
            "eah",
            "oldeah"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "copy_byval_expanded_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
          "lines": "184-227",
          "snippet": "static void\ncopy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah)\n{\n\tMemoryContext objcxt = eah->hdr.eoh_context;\n\tint\t\t\tndims = oldeah->ndims;\n\tint\t\t\tdvalueslen = oldeah->dvalueslen;\n\n\t/* Copy array dimensionality information */\n\teah->ndims = ndims;\n\t/* We can alloc both dimensionality arrays with one palloc */\n\teah->dims = (int *) MemoryContextAlloc(objcxt, ndims * 2 * sizeof(int));\n\teah->lbound = eah->dims + ndims;\n\t/* .. but don't assume the source's arrays are contiguous */\n\tmemcpy(eah->dims, oldeah->dims, ndims * sizeof(int));\n\tmemcpy(eah->lbound, oldeah->lbound, ndims * sizeof(int));\n\n\t/* Copy element-type data */\n\teah->element_type = oldeah->element_type;\n\teah->typlen = oldeah->typlen;\n\teah->typbyval = oldeah->typbyval;\n\teah->typalign = oldeah->typalign;\n\n\t/* Copy the deconstructed representation */\n\teah->dvalues = (Datum *) MemoryContextAlloc(objcxt,\n\t\t\t\t\t\t\t\t\t\t\t\tdvalueslen * sizeof(Datum));\n\tmemcpy(eah->dvalues, oldeah->dvalues, dvalueslen * sizeof(Datum));\n\tif (oldeah->dnulls)\n\t{\n\t\teah->dnulls = (bool *) MemoryContextAlloc(objcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t  dvalueslen * sizeof(bool));\n\t\tmemcpy(eah->dnulls, oldeah->dnulls, dvalueslen * sizeof(bool));\n\t}\n\telse\n\t\teah->dnulls = NULL;\n\teah->dvalueslen = dvalueslen;\n\teah->nelems = oldeah->nelems;\n\teah->flat_size = oldeah->flat_size;\n\n\t/* we don't make a flat representation */\n\teah->fvalue = NULL;\n\teah->fstartptr = NULL;\n\teah->fendptr = NULL;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/array.h\"",
            "#include \"access/tupmacs.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nstatic void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);\n\nstatic void\ncopy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah)\n{\n\tMemoryContext objcxt = eah->hdr.eoh_context;\n\tint\t\t\tndims = oldeah->ndims;\n\tint\t\t\tdvalueslen = oldeah->dvalueslen;\n\n\t/* Copy array dimensionality information */\n\teah->ndims = ndims;\n\t/* We can alloc both dimensionality arrays with one palloc */\n\teah->dims = (int *) MemoryContextAlloc(objcxt, ndims * 2 * sizeof(int));\n\teah->lbound = eah->dims + ndims;\n\t/* .. but don't assume the source's arrays are contiguous */\n\tmemcpy(eah->dims, oldeah->dims, ndims * sizeof(int));\n\tmemcpy(eah->lbound, oldeah->lbound, ndims * sizeof(int));\n\n\t/* Copy element-type data */\n\teah->element_type = oldeah->element_type;\n\teah->typlen = oldeah->typlen;\n\teah->typbyval = oldeah->typbyval;\n\teah->typalign = oldeah->typalign;\n\n\t/* Copy the deconstructed representation */\n\teah->dvalues = (Datum *) MemoryContextAlloc(objcxt,\n\t\t\t\t\t\t\t\t\t\t\t\tdvalueslen * sizeof(Datum));\n\tmemcpy(eah->dvalues, oldeah->dvalues, dvalueslen * sizeof(Datum));\n\tif (oldeah->dnulls)\n\t{\n\t\teah->dnulls = (bool *) MemoryContextAlloc(objcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t  dvalueslen * sizeof(bool));\n\t\tmemcpy(eah->dnulls, oldeah->dnulls, dvalueslen * sizeof(bool));\n\t}\n\telse\n\t\teah->dnulls = NULL;\n\teah->dvalueslen = dvalueslen;\n\teah->nelems = oldeah->nelems;\n\teah->flat_size = oldeah->flat_size;\n\n\t/* we don't make a flat representation */\n\teah->fvalue = NULL;\n\teah->fstartptr = NULL;\n\teah->fendptr = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "oldeah->ea_magic == EA_MAGIC"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetEOHP",
          "args": [
            "arraydatum"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetEOHP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "28-38",
          "snippet": "ExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED",
          "args": [
            "DatumGetPointer(arraydatum)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "arraydatum"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOH_init_header",
          "args": [
            "&eah->hdr",
            "&EA_methods",
            "objcxt"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "47-65",
          "snippet": "void\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nvoid\nEOH_init_header(ExpandedObjectHeader *eohptr,\n\t\t\t\tconst ExpandedObjectMethods *methods,\n\t\t\t\tMemoryContext obj_context)\n{\n\tvaratt_expanded ptr;\n\n\teohptr->vl_len_ = EOH_HEADER_MAGIC;\n\teohptr->eoh_methods = methods;\n\teohptr->eoh_context = obj_context;\n\n\tptr.eohptr = eohptr;\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_rw_ptr, VARTAG_EXPANDED_RW);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_rw_ptr), &ptr, sizeof(ptr));\n\n\tSET_VARTAG_EXTERNAL(eohptr->eoh_ro_ptr, VARTAG_EXPANDED_RO);\n\tmemcpy(VARDATA_EXTERNAL(eohptr->eoh_ro_ptr), &ptr, sizeof(ptr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "objcxt",
            "sizeof(ExpandedArrayHeader)"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "parentcontext",
            "\"expanded array\"",
            "ALLOCSET_START_SMALL_SIZES"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods EA_methods =\n{\n\tEA_get_flat_size,\n\tEA_flatten_into\n};\nstatic void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);\n\nDatum\nexpand_array(Datum arraydatum, MemoryContext parentcontext,\n\t\t\t ArrayMetaState *metacache)\n{\n\tArrayType  *array;\n\tExpandedArrayHeader *eah;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tArrayMetaState fakecache;\n\n\t/*\n\t * Allocate private context for expanded object.  We start by assuming\n\t * that the array won't be very large; but if it does grow a lot, don't\n\t * constrain aset.c's large-context behavior.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded array\",\n\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\t/* Set up expanded array header */\n\teah = (ExpandedArrayHeader *)\n\t\tMemoryContextAlloc(objcxt, sizeof(ExpandedArrayHeader));\n\n\tEOH_init_header(&eah->hdr, &EA_methods, objcxt);\n\teah->ea_magic = EA_MAGIC;\n\n\t/* If the source is an expanded array, we may be able to optimize */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\tExpandedArrayHeader *oldeah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\n\t\tAssert(oldeah->ea_magic == EA_MAGIC);\n\n\t\t/*\n\t\t * Update caller's cache if provided; we don't need it this time, but\n\t\t * next call might be for a non-expanded source array.  Furthermore,\n\t\t * if the caller didn't provide a cache area, use some local storage\n\t\t * to cache anyway, thereby avoiding a catalog lookup in the case\n\t\t * where we fall through to the flat-copy code path.\n\t\t */\n\t\tif (metacache == NULL)\n\t\t\tmetacache = &fakecache;\n\t\tmetacache->element_type = oldeah->element_type;\n\t\tmetacache->typlen = oldeah->typlen;\n\t\tmetacache->typbyval = oldeah->typbyval;\n\t\tmetacache->typalign = oldeah->typalign;\n\n\t\t/*\n\t\t * If element type is pass-by-value and we have a Datum-array\n\t\t * representation, just copy the source's metadata and Datum/isnull\n\t\t * arrays.  The original flat array, if present at all, adds no\n\t\t * additional information so we need not copy it.\n\t\t */\n\t\tif (oldeah->typbyval && oldeah->dvalues != NULL)\n\t\t{\n\t\t\tcopy_byval_expanded_array(eah, oldeah);\n\t\t\t/* return a R/W pointer to the expanded array */\n\t\t\treturn EOHPGetRWDatum(&eah->hdr);\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, either we have only a flat representation or the\n\t\t * elements are pass-by-reference.  In either case, the best thing\n\t\t * seems to be to copy the source as a flat representation and then\n\t\t * deconstruct that later if necessary.  For the pass-by-ref case, we\n\t\t * could perhaps save some cycles with custom code that generates the\n\t\t * deconstructed representation in parallel with copying the values,\n\t\t * but it would be a lot of extra code for fairly marginal gain.  So,\n\t\t * fall through into the flat-source code path.\n\t\t */\n\t}\n\n\t/*\n\t * Detoast and copy source array into private context, as a flat array.\n\t *\n\t * Note that this coding risks leaking some memory in the private context\n\t * if we have to fetch data from a TOAST table; however, experimentation\n\t * says that the leak is minimal.  Doing it this way saves a copy step,\n\t * which seems worthwhile, especially if the array is large enough to need\n\t * external storage.\n\t */\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tarray = DatumGetArrayTypePCopy(arraydatum);\n\tMemoryContextSwitchTo(oldcxt);\n\n\teah->ndims = ARR_NDIM(array);\n\t/* note these pointers point into the fvalue header! */\n\teah->dims = ARR_DIMS(array);\n\teah->lbound = ARR_LBOUND(array);\n\n\t/* Save array's element-type data for possible use later */\n\teah->element_type = ARR_ELEMTYPE(array);\n\tif (metacache && metacache->element_type == eah->element_type)\n\t{\n\t\t/* We have a valid cache of representational data */\n\t\teah->typlen = metacache->typlen;\n\t\teah->typbyval = metacache->typbyval;\n\t\teah->typalign = metacache->typalign;\n\t}\n\telse\n\t{\n\t\t/* No, so look it up */\n\t\tget_typlenbyvalalign(eah->element_type,\n\t\t\t\t\t\t\t &eah->typlen,\n\t\t\t\t\t\t\t &eah->typbyval,\n\t\t\t\t\t\t\t &eah->typalign);\n\t\t/* Update cache if provided */\n\t\tif (metacache)\n\t\t{\n\t\t\tmetacache->element_type = eah->element_type;\n\t\t\tmetacache->typlen = eah->typlen;\n\t\t\tmetacache->typbyval = eah->typbyval;\n\t\t\tmetacache->typalign = eah->typalign;\n\t\t}\n\t}\n\n\t/* we don't make a deconstructed representation now */\n\teah->dvalues = NULL;\n\teah->dnulls = NULL;\n\teah->dvalueslen = 0;\n\teah->nelems = 0;\n\teah->flat_size = 0;\n\n\t/* remember we have a flat representation */\n\teah->fvalue = array;\n\teah->fstartptr = ARR_DATA_PTR(array);\n\teah->fendptr = ((char *) array) + ARR_SIZE(array);\n\n\t/* return a R/W pointer to the expanded array */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}"
  }
]