[
  {
    "function_name": "HeapTupleSatisfiesHistoricMVCC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "1662-1798",
    "snippet": "bool\nHeapTupleSatisfiesHistoricMVCC(HeapTuple htup, Snapshot snapshot,\n\t\t\t\t\t\t\t   Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\tTransactionId xmin = HeapTupleHeaderGetXmin(tuple);\n\tTransactionId xmax = HeapTupleHeaderGetRawXmax(tuple);\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\t/* inserting transaction aborted */\n\tif (HeapTupleHeaderXminInvalid(tuple))\n\t{\n\t\tAssert(!TransactionIdDidCommit(xmin));\n\t\treturn false;\n\t}\n\t/* check if it's one of our txids, toplevel is also in there */\n\telse if (TransactionIdInArray(xmin, snapshot->subxip, snapshot->subxcnt))\n\t{\n\t\tbool\t\tresolved;\n\t\tCommandId\tcmin = HeapTupleHeaderGetRawCommandId(tuple);\n\t\tCommandId\tcmax = InvalidCommandId;\n\n\t\t/*\n\t\t * another transaction might have (tried to) delete this tuple or\n\t\t * cmin/cmax was stored in a combocid. So we need to lookup the actual\n\t\t * values externally.\n\t\t */\n\t\tresolved = ResolveCminCmaxDuringDecoding(HistoricSnapshotGetTupleCids(), snapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t htup, buffer,\n\t\t\t\t\t\t\t\t\t\t\t\t &cmin, &cmax);\n\n\t\tif (!resolved)\n\t\t\telog(ERROR, \"could not resolve cmin/cmax of catalog tuple\");\n\n\t\tAssert(cmin != InvalidCommandId);\n\n\t\tif (cmin >= snapshot->curcid)\n\t\t\treturn false;\t\t/* inserted after scan started */\n\t\t/* fall through */\n\t}\n\t/* committed before our xmin horizon. Do a normal visibility check. */\n\telse if (TransactionIdPrecedes(xmin, snapshot->xmin))\n\t{\n\t\tAssert(!(HeapTupleHeaderXminCommitted(tuple) &&\n\t\t\t\t !TransactionIdDidCommit(xmin)));\n\n\t\t/* check for hint bit first, consult clog afterwards */\n\t\tif (!HeapTupleHeaderXminCommitted(tuple) &&\n\t\t\t!TransactionIdDidCommit(xmin))\n\t\t\treturn false;\n\t\t/* fall through */\n\t}\n\t/* beyond our xmax horizon, i.e. invisible */\n\telse if (TransactionIdFollowsOrEquals(xmin, snapshot->xmax))\n\t{\n\t\treturn false;\n\t}\n\t/* check if it's a committed transaction in [xmin, xmax) */\n\telse if (TransactionIdInArray(xmin, snapshot->xip, snapshot->xcnt))\n\t{\n\t\t/* fall through */\n\t}\n\n\t/*\n\t * none of the above, i.e. between [xmin, xmax) but hasn't committed. I.e.\n\t * invisible.\n\t */\n\telse\n\t{\n\t\treturn false;\n\t}\n\n\t/* at this point we know xmin is visible, go on to check xmax */\n\n\t/* xid invalid or aborted */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn true;\n\t/* locked tuples are always visible */\n\telse if (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\treturn true;\n\n\t/*\n\t * We can see multis here if we're looking at user tables or if somebody\n\t * SELECT ... FOR SHARE/UPDATE a system table.\n\t */\n\telse if (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\txmax = HeapTupleGetUpdateXid(tuple);\n\t}\n\n\t/* check if it's one of our txids, toplevel is also in there */\n\tif (TransactionIdInArray(xmax, snapshot->subxip, snapshot->subxcnt))\n\t{\n\t\tbool\t\tresolved;\n\t\tCommandId\tcmin;\n\t\tCommandId\tcmax = HeapTupleHeaderGetRawCommandId(tuple);\n\n\t\t/* Lookup actual cmin/cmax values */\n\t\tresolved = ResolveCminCmaxDuringDecoding(HistoricSnapshotGetTupleCids(), snapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t htup, buffer,\n\t\t\t\t\t\t\t\t\t\t\t\t &cmin, &cmax);\n\n\t\tif (!resolved)\n\t\t\telog(ERROR, \"could not resolve combocid to cmax\");\n\n\t\tAssert(cmax != InvalidCommandId);\n\n\t\tif (cmax >= snapshot->curcid)\n\t\t\treturn true;\t\t/* deleted after scan started */\n\t\telse\n\t\t\treturn false;\t\t/* deleted before scan started */\n\t}\n\t/* below xmin horizon, normal transaction state is valid */\n\telse if (TransactionIdPrecedes(xmax, snapshot->xmin))\n\t{\n\t\tAssert(!(tuple->t_infomask & HEAP_XMAX_COMMITTED &&\n\t\t\t\t !TransactionIdDidCommit(xmax)));\n\n\t\t/* check hint bit first */\n\t\tif (tuple->t_infomask & HEAP_XMAX_COMMITTED)\n\t\t\treturn false;\n\n\t\t/* check clog */\n\t\treturn !TransactionIdDidCommit(xmax);\n\t}\n\t/* above xmax horizon, we cannot possibly see the deleting transaction */\n\telse if (TransactionIdFollowsOrEquals(xmax, snapshot->xmax))\n\t\treturn true;\n\t/* xmax is between [xmin, xmax), check known committed array */\n\telse if (TransactionIdInArray(xmax, snapshot->xip, snapshot->xcnt))\n\t\treturn false;\n\t/* xmax is between [xmin, xmax), but known not to have committed yet */\n\telse\n\t\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransactionIdInArray",
          "args": [
            "xmax",
            "snapshot->xip",
            "snapshot->xcnt"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "TransactionIdInArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "1641-1646",
          "snippet": "static bool\nTransactionIdInArray(TransactionId xid, TransactionId *xip, Size num)\n{\n\treturn bsearch(&xid, xip, num,\n\t\t\t\t   sizeof(TransactionId), xidComparator) != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool\nTransactionIdInArray(TransactionId xid, TransactionId *xip, Size num)\n{\n\treturn bsearch(&xid, xip, num,\n\t\t\t\t   sizeof(TransactionId), xidComparator) != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdFollowsOrEquals",
          "args": [
            "xmax",
            "snapshot->xmax"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmax"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!(tuple->t_infomask & HEAP_XMAX_COMMITTED &&\n\t\t\t\t !TransactionIdDidCommit(xmax))"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmax"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "xmax",
            "snapshot->xmin"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "cmax != InvalidCommandId"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not resolve combocid to cmax\""
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResolveCminCmaxDuringDecoding",
          "args": [
            "HistoricSnapshotGetTupleCids()",
            "snapshot",
            "htup",
            "buffer",
            "&cmin",
            "&cmax"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HistoricSnapshotGetTupleCids",
          "args": [],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "HistoricSnapshotGetTupleCids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "2029-2034",
          "snippet": "HTAB *\nHistoricSnapshotGetTupleCids(void)\n{\n\tAssert(HistoricSnapshotActive());\n\treturn tuplecid_data;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *tuplecid_data = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic HTAB *tuplecid_data = NULL;\n\nHTAB *\nHistoricSnapshotGetTupleCids(void)\n{\n\tAssert(HistoricSnapshotActive());\n\treturn tuplecid_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawCommandId",
          "args": [
            "tuple"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdFollowsOrEquals",
          "args": [
            "xmin",
            "snapshot->xmax"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmin"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminCommitted",
          "args": [
            "tuple"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!(HeapTupleHeaderXminCommitted(tuple) &&\n\t\t\t\t !TransactionIdDidCommit(xmin))"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmin"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminCommitted",
          "args": [
            "tuple"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "xmin",
            "snapshot->xmin"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "cmin != InvalidCommandId"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResolveCminCmaxDuringDecoding",
          "args": [
            "HistoricSnapshotGetTupleCids()",
            "snapshot",
            "htup",
            "buffer",
            "&cmin",
            "&cmax"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawCommandId",
          "args": [
            "tuple"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!TransactionIdDidCommit(xmin)"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmin"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminInvalid",
          "args": [
            "tuple"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "htup->t_tableOid != InvalidOid"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ItemPointerIsValid(&htup->t_self)"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerIsValid",
          "args": [
            "&htup->t_self"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXmin",
          "args": [
            "tuple"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nHeapTupleSatisfiesHistoricMVCC(HeapTuple htup, Snapshot snapshot,\n\t\t\t\t\t\t\t   Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\tTransactionId xmin = HeapTupleHeaderGetXmin(tuple);\n\tTransactionId xmax = HeapTupleHeaderGetRawXmax(tuple);\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\t/* inserting transaction aborted */\n\tif (HeapTupleHeaderXminInvalid(tuple))\n\t{\n\t\tAssert(!TransactionIdDidCommit(xmin));\n\t\treturn false;\n\t}\n\t/* check if it's one of our txids, toplevel is also in there */\n\telse if (TransactionIdInArray(xmin, snapshot->subxip, snapshot->subxcnt))\n\t{\n\t\tbool\t\tresolved;\n\t\tCommandId\tcmin = HeapTupleHeaderGetRawCommandId(tuple);\n\t\tCommandId\tcmax = InvalidCommandId;\n\n\t\t/*\n\t\t * another transaction might have (tried to) delete this tuple or\n\t\t * cmin/cmax was stored in a combocid. So we need to lookup the actual\n\t\t * values externally.\n\t\t */\n\t\tresolved = ResolveCminCmaxDuringDecoding(HistoricSnapshotGetTupleCids(), snapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t htup, buffer,\n\t\t\t\t\t\t\t\t\t\t\t\t &cmin, &cmax);\n\n\t\tif (!resolved)\n\t\t\telog(ERROR, \"could not resolve cmin/cmax of catalog tuple\");\n\n\t\tAssert(cmin != InvalidCommandId);\n\n\t\tif (cmin >= snapshot->curcid)\n\t\t\treturn false;\t\t/* inserted after scan started */\n\t\t/* fall through */\n\t}\n\t/* committed before our xmin horizon. Do a normal visibility check. */\n\telse if (TransactionIdPrecedes(xmin, snapshot->xmin))\n\t{\n\t\tAssert(!(HeapTupleHeaderXminCommitted(tuple) &&\n\t\t\t\t !TransactionIdDidCommit(xmin)));\n\n\t\t/* check for hint bit first, consult clog afterwards */\n\t\tif (!HeapTupleHeaderXminCommitted(tuple) &&\n\t\t\t!TransactionIdDidCommit(xmin))\n\t\t\treturn false;\n\t\t/* fall through */\n\t}\n\t/* beyond our xmax horizon, i.e. invisible */\n\telse if (TransactionIdFollowsOrEquals(xmin, snapshot->xmax))\n\t{\n\t\treturn false;\n\t}\n\t/* check if it's a committed transaction in [xmin, xmax) */\n\telse if (TransactionIdInArray(xmin, snapshot->xip, snapshot->xcnt))\n\t{\n\t\t/* fall through */\n\t}\n\n\t/*\n\t * none of the above, i.e. between [xmin, xmax) but hasn't committed. I.e.\n\t * invisible.\n\t */\n\telse\n\t{\n\t\treturn false;\n\t}\n\n\t/* at this point we know xmin is visible, go on to check xmax */\n\n\t/* xid invalid or aborted */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn true;\n\t/* locked tuples are always visible */\n\telse if (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\treturn true;\n\n\t/*\n\t * We can see multis here if we're looking at user tables or if somebody\n\t * SELECT ... FOR SHARE/UPDATE a system table.\n\t */\n\telse if (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\txmax = HeapTupleGetUpdateXid(tuple);\n\t}\n\n\t/* check if it's one of our txids, toplevel is also in there */\n\tif (TransactionIdInArray(xmax, snapshot->subxip, snapshot->subxcnt))\n\t{\n\t\tbool\t\tresolved;\n\t\tCommandId\tcmin;\n\t\tCommandId\tcmax = HeapTupleHeaderGetRawCommandId(tuple);\n\n\t\t/* Lookup actual cmin/cmax values */\n\t\tresolved = ResolveCminCmaxDuringDecoding(HistoricSnapshotGetTupleCids(), snapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t htup, buffer,\n\t\t\t\t\t\t\t\t\t\t\t\t &cmin, &cmax);\n\n\t\tif (!resolved)\n\t\t\telog(ERROR, \"could not resolve combocid to cmax\");\n\n\t\tAssert(cmax != InvalidCommandId);\n\n\t\tif (cmax >= snapshot->curcid)\n\t\t\treturn true;\t\t/* deleted after scan started */\n\t\telse\n\t\t\treturn false;\t\t/* deleted before scan started */\n\t}\n\t/* below xmin horizon, normal transaction state is valid */\n\telse if (TransactionIdPrecedes(xmax, snapshot->xmin))\n\t{\n\t\tAssert(!(tuple->t_infomask & HEAP_XMAX_COMMITTED &&\n\t\t\t\t !TransactionIdDidCommit(xmax)));\n\n\t\t/* check hint bit first */\n\t\tif (tuple->t_infomask & HEAP_XMAX_COMMITTED)\n\t\t\treturn false;\n\n\t\t/* check clog */\n\t\treturn !TransactionIdDidCommit(xmax);\n\t}\n\t/* above xmax horizon, we cannot possibly see the deleting transaction */\n\telse if (TransactionIdFollowsOrEquals(xmax, snapshot->xmax))\n\t\treturn true;\n\t/* xmax is between [xmin, xmax), check known committed array */\n\telse if (TransactionIdInArray(xmax, snapshot->xip, snapshot->xcnt))\n\t\treturn false;\n\t/* xmax is between [xmin, xmax), but known not to have committed yet */\n\telse\n\t\treturn true;\n}"
  },
  {
    "function_name": "TransactionIdInArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "1641-1646",
    "snippet": "static bool\nTransactionIdInArray(TransactionId xid, TransactionId *xip, Size num)\n{\n\treturn bsearch(&xid, xip, num,\n\t\t\t\t   sizeof(TransactionId), xidComparator) != NULL;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&xid",
            "xip",
            "num",
            "sizeof(TransactionId)",
            "xidComparator"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "rbound_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "617-637",
          "snippet": "static int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool\nTransactionIdInArray(TransactionId xid, TransactionId *xip, Size num)\n{\n\treturn bsearch(&xid, xip, num,\n\t\t\t\t   sizeof(TransactionId), xidComparator) != NULL;\n}"
  },
  {
    "function_name": "HeapTupleHeaderIsOnlyLocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "1595-1636",
    "snippet": "bool\nHeapTupleHeaderIsOnlyLocked(HeapTupleHeader tuple)\n{\n\tTransactionId xmax;\n\n\t/* if there's no valid Xmax, then there's obviously no update either */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn true;\n\n\tif (tuple->t_infomask & HEAP_XMAX_LOCK_ONLY)\n\t\treturn true;\n\n\t/* invalid xmax means no update */\n\tif (!TransactionIdIsValid(HeapTupleHeaderGetRawXmax(tuple)))\n\t\treturn true;\n\n\t/*\n\t * if HEAP_XMAX_LOCK_ONLY is not set and not a multi, then this must\n\t * necessarily have been updated\n\t */\n\tif (!(tuple->t_infomask & HEAP_XMAX_IS_MULTI))\n\t\treturn false;\n\n\t/* ... but if it's a multi, then perhaps the updating Xid aborted. */\n\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t/* not LOCKED_ONLY, so it has to have an xmax */\n\tAssert(TransactionIdIsValid(xmax));\n\n\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\treturn false;\n\tif (TransactionIdIsInProgress(xmax))\n\t\treturn false;\n\tif (TransactionIdDidCommit(xmax))\n\t\treturn false;\n\n\t/*\n\t * not current, not in progress, not committed -- must have aborted or\n\t * crashed\n\t */\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmax"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xmax"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xmax"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xmax)"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nHeapTupleHeaderIsOnlyLocked(HeapTupleHeader tuple)\n{\n\tTransactionId xmax;\n\n\t/* if there's no valid Xmax, then there's obviously no update either */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn true;\n\n\tif (tuple->t_infomask & HEAP_XMAX_LOCK_ONLY)\n\t\treturn true;\n\n\t/* invalid xmax means no update */\n\tif (!TransactionIdIsValid(HeapTupleHeaderGetRawXmax(tuple)))\n\t\treturn true;\n\n\t/*\n\t * if HEAP_XMAX_LOCK_ONLY is not set and not a multi, then this must\n\t * necessarily have been updated\n\t */\n\tif (!(tuple->t_infomask & HEAP_XMAX_IS_MULTI))\n\t\treturn false;\n\n\t/* ... but if it's a multi, then perhaps the updating Xid aborted. */\n\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t/* not LOCKED_ONLY, so it has to have an xmax */\n\tAssert(TransactionIdIsValid(xmax));\n\n\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\treturn false;\n\tif (TransactionIdIsInProgress(xmax))\n\t\treturn false;\n\tif (TransactionIdDidCommit(xmax))\n\t\treturn false;\n\n\t/*\n\t * not current, not in progress, not committed -- must have aborted or\n\t * crashed\n\t */\n\treturn true;\n}"
  },
  {
    "function_name": "XidInMVCCSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "1474-1584",
    "snippet": "bool\nXidInMVCCSnapshot(TransactionId xid, Snapshot snapshot)\n{\n\tuint32\t\ti;\n\n\t/*\n\t * Make a quick range check to eliminate most XIDs without looking at the\n\t * xip arrays.  Note that this is OK even if we convert a subxact XID to\n\t * its parent below, because a subxact with XID < xmin has surely also got\n\t * a parent with XID < xmin, while one with XID >= xmax must belong to a\n\t * parent that was not yet committed at the time of this snapshot.\n\t */\n\n\t/* Any xid < xmin is not in-progress */\n\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\treturn false;\n\t/* Any xid >= xmax is in-progress */\n\tif (TransactionIdFollowsOrEquals(xid, snapshot->xmax))\n\t\treturn true;\n\n\t/*\n\t * Snapshot information is stored slightly differently in snapshots taken\n\t * during recovery.\n\t */\n\tif (!snapshot->takenDuringRecovery)\n\t{\n\t\t/*\n\t\t * If the snapshot contains full subxact data, the fastest way to\n\t\t * check things is just to compare the given XID against both subxact\n\t\t * XIDs and top-level XIDs.  If the snapshot overflowed, we have to\n\t\t * use pg_subtrans to convert a subxact XID to its parent XID, but\n\t\t * then we need only look at top-level XIDs not subxacts.\n\t\t */\n\t\tif (!snapshot->suboverflowed)\n\t\t{\n\t\t\t/* we have full data, so search subxip */\n\t\t\tint32\t\tj;\n\n\t\t\tfor (j = 0; j < snapshot->subxcnt; j++)\n\t\t\t{\n\t\t\t\tif (TransactionIdEquals(xid, snapshot->subxip[j]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/* not there, fall through to search xip[] */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Snapshot overflowed, so convert xid to top-level.  This is safe\n\t\t\t * because we eliminated too-old XIDs above.\n\t\t\t */\n\t\t\txid = SubTransGetTopmostTransaction(xid);\n\n\t\t\t/*\n\t\t\t * If xid was indeed a subxact, we might now have an xid < xmin,\n\t\t\t * so recheck to avoid an array scan.  No point in rechecking\n\t\t\t * xmax.\n\t\t\t */\n\t\t\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0; i < snapshot->xcnt; i++)\n\t\t{\n\t\t\tif (TransactionIdEquals(xid, snapshot->xip[i]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint32\t\tj;\n\n\t\t/*\n\t\t * In recovery we store all xids in the subxact array because it is by\n\t\t * far the bigger array, and we mostly don't know which xids are\n\t\t * top-level and which are subxacts. The xip array is empty.\n\t\t *\n\t\t * We start by searching subtrans, if we overflowed.\n\t\t */\n\t\tif (snapshot->suboverflowed)\n\t\t{\n\t\t\t/*\n\t\t\t * Snapshot overflowed, so convert xid to top-level.  This is safe\n\t\t\t * because we eliminated too-old XIDs above.\n\t\t\t */\n\t\t\txid = SubTransGetTopmostTransaction(xid);\n\n\t\t\t/*\n\t\t\t * If xid was indeed a subxact, we might now have an xid < xmin,\n\t\t\t * so recheck to avoid an array scan.  No point in rechecking\n\t\t\t * xmax.\n\t\t\t */\n\t\t\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * We now have either a top-level xid higher than xmin or an\n\t\t * indeterminate xid. We don't know whether it's top level or subxact\n\t\t * but it doesn't matter. If it's present, the xid is visible.\n\t\t */\n\t\tfor (j = 0; j < snapshot->subxcnt; j++)\n\t\t{\n\t\t\tif (TransactionIdEquals(xid, snapshot->subxip[j]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransactionIdEquals",
          "args": [
            "xid",
            "snapshot->subxip[j]"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "xid",
            "snapshot->xmin"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SubTransGetTopmostTransaction",
          "args": [
            "xid"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdEquals",
          "args": [
            "xid",
            "snapshot->xip[i]"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "xid",
            "snapshot->xmin"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SubTransGetTopmostTransaction",
          "args": [
            "xid"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdEquals",
          "args": [
            "xid",
            "snapshot->subxip[j]"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdFollowsOrEquals",
          "args": [
            "xid",
            "snapshot->xmax"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "xid",
            "snapshot->xmin"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nXidInMVCCSnapshot(TransactionId xid, Snapshot snapshot)\n{\n\tuint32\t\ti;\n\n\t/*\n\t * Make a quick range check to eliminate most XIDs without looking at the\n\t * xip arrays.  Note that this is OK even if we convert a subxact XID to\n\t * its parent below, because a subxact with XID < xmin has surely also got\n\t * a parent with XID < xmin, while one with XID >= xmax must belong to a\n\t * parent that was not yet committed at the time of this snapshot.\n\t */\n\n\t/* Any xid < xmin is not in-progress */\n\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\treturn false;\n\t/* Any xid >= xmax is in-progress */\n\tif (TransactionIdFollowsOrEquals(xid, snapshot->xmax))\n\t\treturn true;\n\n\t/*\n\t * Snapshot information is stored slightly differently in snapshots taken\n\t * during recovery.\n\t */\n\tif (!snapshot->takenDuringRecovery)\n\t{\n\t\t/*\n\t\t * If the snapshot contains full subxact data, the fastest way to\n\t\t * check things is just to compare the given XID against both subxact\n\t\t * XIDs and top-level XIDs.  If the snapshot overflowed, we have to\n\t\t * use pg_subtrans to convert a subxact XID to its parent XID, but\n\t\t * then we need only look at top-level XIDs not subxacts.\n\t\t */\n\t\tif (!snapshot->suboverflowed)\n\t\t{\n\t\t\t/* we have full data, so search subxip */\n\t\t\tint32\t\tj;\n\n\t\t\tfor (j = 0; j < snapshot->subxcnt; j++)\n\t\t\t{\n\t\t\t\tif (TransactionIdEquals(xid, snapshot->subxip[j]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/* not there, fall through to search xip[] */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Snapshot overflowed, so convert xid to top-level.  This is safe\n\t\t\t * because we eliminated too-old XIDs above.\n\t\t\t */\n\t\t\txid = SubTransGetTopmostTransaction(xid);\n\n\t\t\t/*\n\t\t\t * If xid was indeed a subxact, we might now have an xid < xmin,\n\t\t\t * so recheck to avoid an array scan.  No point in rechecking\n\t\t\t * xmax.\n\t\t\t */\n\t\t\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0; i < snapshot->xcnt; i++)\n\t\t{\n\t\t\tif (TransactionIdEquals(xid, snapshot->xip[i]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint32\t\tj;\n\n\t\t/*\n\t\t * In recovery we store all xids in the subxact array because it is by\n\t\t * far the bigger array, and we mostly don't know which xids are\n\t\t * top-level and which are subxacts. The xip array is empty.\n\t\t *\n\t\t * We start by searching subtrans, if we overflowed.\n\t\t */\n\t\tif (snapshot->suboverflowed)\n\t\t{\n\t\t\t/*\n\t\t\t * Snapshot overflowed, so convert xid to top-level.  This is safe\n\t\t\t * because we eliminated too-old XIDs above.\n\t\t\t */\n\t\t\txid = SubTransGetTopmostTransaction(xid);\n\n\t\t\t/*\n\t\t\t * If xid was indeed a subxact, we might now have an xid < xmin,\n\t\t\t * so recheck to avoid an array scan.  No point in rechecking\n\t\t\t * xmax.\n\t\t\t */\n\t\t\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * We now have either a top-level xid higher than xmin or an\n\t\t * indeterminate xid. We don't know whether it's top level or subxact\n\t\t * but it doesn't matter. If it's present, the xid is visible.\n\t\t */\n\t\tfor (j = 0; j < snapshot->subxcnt; j++)\n\t\t{\n\t\t\tif (TransactionIdEquals(xid, snapshot->subxip[j]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "HeapTupleIsSurelyDead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "1419-1462",
    "snippet": "bool\nHeapTupleIsSurelyDead(HeapTuple htup, TransactionId OldestXmin)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\t/*\n\t * If the inserting transaction is marked invalid, then it aborted, and\n\t * the tuple is definitely dead.  If it's marked neither committed nor\n\t * invalid, then we assume it's still alive (since the presumption is that\n\t * all relevant hint bits were just set moments ago).\n\t */\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t\treturn HeapTupleHeaderXminInvalid(tuple) ? true : false;\n\n\t/*\n\t * If the inserting transaction committed, but any deleting transaction\n\t * aborted, the tuple is still alive.\n\t */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn false;\n\n\t/*\n\t * If the XMAX is just a lock, the tuple is still alive.\n\t */\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\treturn false;\n\n\t/*\n\t * If the Xmax is a MultiXact, it might be dead or alive, but we cannot\n\t * know without checking pg_multixact.\n\t */\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\treturn false;\n\n\t/* If deleter isn't known to have committed, assume it's still running. */\n\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t\treturn false;\n\n\t/* Deleter committed, so tuple is dead if the XID is old enough. */\n\treturn TransactionIdPrecedes(HeapTupleHeaderGetRawXmax(tuple), OldestXmin);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)",
            "OldestXmin"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminInvalid",
          "args": [
            "tuple"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminCommitted",
          "args": [
            "tuple"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "htup->t_tableOid != InvalidOid"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ItemPointerIsValid(&htup->t_self)"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerIsValid",
          "args": [
            "&htup->t_self"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nHeapTupleIsSurelyDead(HeapTuple htup, TransactionId OldestXmin)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\t/*\n\t * If the inserting transaction is marked invalid, then it aborted, and\n\t * the tuple is definitely dead.  If it's marked neither committed nor\n\t * invalid, then we assume it's still alive (since the presumption is that\n\t * all relevant hint bits were just set moments ago).\n\t */\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t\treturn HeapTupleHeaderXminInvalid(tuple) ? true : false;\n\n\t/*\n\t * If the inserting transaction committed, but any deleting transaction\n\t * aborted, the tuple is still alive.\n\t */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn false;\n\n\t/*\n\t * If the XMAX is just a lock, the tuple is still alive.\n\t */\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\treturn false;\n\n\t/*\n\t * If the Xmax is a MultiXact, it might be dead or alive, but we cannot\n\t * know without checking pg_multixact.\n\t */\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\treturn false;\n\n\t/* If deleter isn't known to have committed, assume it's still running. */\n\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t\treturn false;\n\n\t/* Deleter committed, so tuple is dead if the XID is old enough. */\n\treturn TransactionIdPrecedes(HeapTupleHeaderGetRawXmax(tuple), OldestXmin);\n}"
  },
  {
    "function_name": "HeapTupleSatisfiesNonVacuumable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "1397-1403",
    "snippet": "bool\nHeapTupleSatisfiesNonVacuumable(HeapTuple htup, Snapshot snapshot,\n\t\t\t\t\t\t\t\tBuffer buffer)\n{\n\treturn HeapTupleSatisfiesVacuum(htup, snapshot->xmin, buffer)\n\t\t!= HEAPTUPLE_DEAD;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HeapTupleSatisfiesVacuum",
          "args": [
            "htup",
            "snapshot->xmin",
            "buffer"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleSatisfiesVacuum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "1163-1384",
          "snippet": "HTSV_Result\nHeapTupleSatisfiesVacuum(HeapTuple htup, TransactionId OldestXmin,\n\t\t\t\t\t\t Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\t/*\n\t * Has inserting transaction committed?\n\t *\n\t * If the inserting transaction aborted, then the tuple was never visible\n\t * to any other transaction, so we can delete it immediately.\n\t */\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t{\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn HEAPTUPLE_DEAD;\n\t\t\t}\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\telse\n\t\t\t{\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn HEAPTUPLE_DEAD;\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\t/* only locked? run infomask-only check first, for performance */\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask) ||\n\t\t\t\tHeapTupleHeaderIsOnlyLocked(tuple))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\t/* inserted and then deleted by same xact */\n\t\t\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tuple)))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\t/* deleting subtransaction must have aborted */\n\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t}\n\t\telse if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\t/*\n\t\t\t * It'd be possible to discern between INSERT/DELETE in progress\n\t\t\t * here by looking at xmax - but that doesn't seem beneficial for\n\t\t\t * the majority of callers and even detrimental for some. We'd\n\t\t\t * rather have callers look at/wait for xmin than xmax. It's\n\t\t\t * always correct to return INSERT_IN_PROGRESS because that's\n\t\t\t * what's happening from the view of other backends.\n\t\t\t */\n\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t}\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t}\n\n\t\t/*\n\t\t * At this point the xmin is known committed, but we might not have\n\t\t * been able to set the hint bit yet; so we can no longer Assert that\n\t\t * it's set.\n\t\t */\n\t}\n\n\t/*\n\t * Okay, the inserter committed, so it was good at some point.  Now what\n\t * about the deleting transaction?\n\t */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn HEAPTUPLE_LIVE;\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t{\n\t\t/*\n\t\t * \"Deleting\" xact really only locked it, so the tuple is live in any\n\t\t * case.  However, we should make sure that either XMAX_COMMITTED or\n\t\t * XMAX_INVALID gets set once the xact is gone, to reduce the costs of\n\t\t * examining the tuple for future xacts.\n\t\t */\n\t\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a pre-pg_upgrade tuple, the multixact cannot\n\t\t\t\t * possibly be running; otherwise have to check.\n\t\t\t\t */\n\t\t\t\tif (!HEAP_LOCKED_UPGRADED(tuple->t_infomask) &&\n\t\t\t\t\tMultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple),\n\t\t\t\t\t\t\t\t\t\t true))\n\t\t\t\t\treturn HEAPTUPLE_LIVE;\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID, InvalidTransactionId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t\t\treturn HEAPTUPLE_LIVE;\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We don't really care whether xmax did commit, abort or crash. We\n\t\t * know that xmax did lock the tuple, but it did not and will never\n\t\t * actually update it.\n\t\t */\n\n\t\treturn HEAPTUPLE_LIVE;\n\t}\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t/* already checked above */\n\t\tAssert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsInProgress(xmax))\n\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\telse if (TransactionIdDidCommit(xmax))\n\t\t{\n\t\t\t/*\n\t\t\t * The multixact might still be running due to lockers.  If the\n\t\t\t * updater is below the xid horizon, we have to return DEAD\n\t\t\t * regardless -- otherwise we could end up with a tuple where the\n\t\t\t * updater has to be removed due to the horizon, but is not pruned\n\t\t\t * away.  It's not a problem to prune that tuple, because any\n\t\t\t * remaining lockers will also be present in newer tuple versions.\n\t\t\t */\n\t\t\tif (!TransactionIdPrecedes(xmax, OldestXmin))\n\t\t\t\treturn HEAPTUPLE_RECENTLY_DEAD;\n\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t}\n\t\telse if (!MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), false))\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed.\n\t\t\t * Mark the Xmax as invalid.\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID, InvalidTransactionId);\n\t\t}\n\n\t\treturn HEAPTUPLE_LIVE;\n\t}\n\n\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t{\n\t\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HEAPTUPLE_LIVE;\n\t\t}\n\n\t\t/*\n\t\t * At this point the xmax is known committed, but we might not have\n\t\t * been able to set the hint bit yet; so we can no longer Assert that\n\t\t * it's set.\n\t\t */\n\t}\n\n\t/*\n\t * Deleter committed, but perhaps it was recent enough that some open\n\t * transactions could still see the tuple.\n\t */\n\tif (!TransactionIdPrecedes(HeapTupleHeaderGetRawXmax(tuple), OldestXmin))\n\t\treturn HEAPTUPLE_RECENTLY_DEAD;\n\n\t/* Otherwise, it's dead and removable */\n\treturn HEAPTUPLE_DEAD;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nHTSV_Result\nHeapTupleSatisfiesVacuum(HeapTuple htup, TransactionId OldestXmin,\n\t\t\t\t\t\t Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\t/*\n\t * Has inserting transaction committed?\n\t *\n\t * If the inserting transaction aborted, then the tuple was never visible\n\t * to any other transaction, so we can delete it immediately.\n\t */\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t{\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn HEAPTUPLE_DEAD;\n\t\t\t}\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\telse\n\t\t\t{\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn HEAPTUPLE_DEAD;\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\t/* only locked? run infomask-only check first, for performance */\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask) ||\n\t\t\t\tHeapTupleHeaderIsOnlyLocked(tuple))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\t/* inserted and then deleted by same xact */\n\t\t\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tuple)))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\t/* deleting subtransaction must have aborted */\n\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t}\n\t\telse if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\t/*\n\t\t\t * It'd be possible to discern between INSERT/DELETE in progress\n\t\t\t * here by looking at xmax - but that doesn't seem beneficial for\n\t\t\t * the majority of callers and even detrimental for some. We'd\n\t\t\t * rather have callers look at/wait for xmin than xmax. It's\n\t\t\t * always correct to return INSERT_IN_PROGRESS because that's\n\t\t\t * what's happening from the view of other backends.\n\t\t\t */\n\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t}\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t}\n\n\t\t/*\n\t\t * At this point the xmin is known committed, but we might not have\n\t\t * been able to set the hint bit yet; so we can no longer Assert that\n\t\t * it's set.\n\t\t */\n\t}\n\n\t/*\n\t * Okay, the inserter committed, so it was good at some point.  Now what\n\t * about the deleting transaction?\n\t */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn HEAPTUPLE_LIVE;\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t{\n\t\t/*\n\t\t * \"Deleting\" xact really only locked it, so the tuple is live in any\n\t\t * case.  However, we should make sure that either XMAX_COMMITTED or\n\t\t * XMAX_INVALID gets set once the xact is gone, to reduce the costs of\n\t\t * examining the tuple for future xacts.\n\t\t */\n\t\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a pre-pg_upgrade tuple, the multixact cannot\n\t\t\t\t * possibly be running; otherwise have to check.\n\t\t\t\t */\n\t\t\t\tif (!HEAP_LOCKED_UPGRADED(tuple->t_infomask) &&\n\t\t\t\t\tMultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple),\n\t\t\t\t\t\t\t\t\t\t true))\n\t\t\t\t\treturn HEAPTUPLE_LIVE;\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID, InvalidTransactionId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t\t\treturn HEAPTUPLE_LIVE;\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We don't really care whether xmax did commit, abort or crash. We\n\t\t * know that xmax did lock the tuple, but it did not and will never\n\t\t * actually update it.\n\t\t */\n\n\t\treturn HEAPTUPLE_LIVE;\n\t}\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t/* already checked above */\n\t\tAssert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsInProgress(xmax))\n\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\telse if (TransactionIdDidCommit(xmax))\n\t\t{\n\t\t\t/*\n\t\t\t * The multixact might still be running due to lockers.  If the\n\t\t\t * updater is below the xid horizon, we have to return DEAD\n\t\t\t * regardless -- otherwise we could end up with a tuple where the\n\t\t\t * updater has to be removed due to the horizon, but is not pruned\n\t\t\t * away.  It's not a problem to prune that tuple, because any\n\t\t\t * remaining lockers will also be present in newer tuple versions.\n\t\t\t */\n\t\t\tif (!TransactionIdPrecedes(xmax, OldestXmin))\n\t\t\t\treturn HEAPTUPLE_RECENTLY_DEAD;\n\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t}\n\t\telse if (!MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), false))\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed.\n\t\t\t * Mark the Xmax as invalid.\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID, InvalidTransactionId);\n\t\t}\n\n\t\treturn HEAPTUPLE_LIVE;\n\t}\n\n\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t{\n\t\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HEAPTUPLE_LIVE;\n\t\t}\n\n\t\t/*\n\t\t * At this point the xmax is known committed, but we might not have\n\t\t * been able to set the hint bit yet; so we can no longer Assert that\n\t\t * it's set.\n\t\t */\n\t}\n\n\t/*\n\t * Deleter committed, but perhaps it was recent enough that some open\n\t * transactions could still see the tuple.\n\t */\n\tif (!TransactionIdPrecedes(HeapTupleHeaderGetRawXmax(tuple), OldestXmin))\n\t\treturn HEAPTUPLE_RECENTLY_DEAD;\n\n\t/* Otherwise, it's dead and removable */\n\treturn HEAPTUPLE_DEAD;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nHeapTupleSatisfiesNonVacuumable(HeapTuple htup, Snapshot snapshot,\n\t\t\t\t\t\t\t\tBuffer buffer)\n{\n\treturn HeapTupleSatisfiesVacuum(htup, snapshot->xmin, buffer)\n\t\t!= HEAPTUPLE_DEAD;\n}"
  },
  {
    "function_name": "HeapTupleSatisfiesVacuum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "1163-1384",
    "snippet": "HTSV_Result\nHeapTupleSatisfiesVacuum(HeapTuple htup, TransactionId OldestXmin,\n\t\t\t\t\t\t Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\t/*\n\t * Has inserting transaction committed?\n\t *\n\t * If the inserting transaction aborted, then the tuple was never visible\n\t * to any other transaction, so we can delete it immediately.\n\t */\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t{\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn HEAPTUPLE_DEAD;\n\t\t\t}\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\telse\n\t\t\t{\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn HEAPTUPLE_DEAD;\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\t/* only locked? run infomask-only check first, for performance */\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask) ||\n\t\t\t\tHeapTupleHeaderIsOnlyLocked(tuple))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\t/* inserted and then deleted by same xact */\n\t\t\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tuple)))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\t/* deleting subtransaction must have aborted */\n\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t}\n\t\telse if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\t/*\n\t\t\t * It'd be possible to discern between INSERT/DELETE in progress\n\t\t\t * here by looking at xmax - but that doesn't seem beneficial for\n\t\t\t * the majority of callers and even detrimental for some. We'd\n\t\t\t * rather have callers look at/wait for xmin than xmax. It's\n\t\t\t * always correct to return INSERT_IN_PROGRESS because that's\n\t\t\t * what's happening from the view of other backends.\n\t\t\t */\n\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t}\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t}\n\n\t\t/*\n\t\t * At this point the xmin is known committed, but we might not have\n\t\t * been able to set the hint bit yet; so we can no longer Assert that\n\t\t * it's set.\n\t\t */\n\t}\n\n\t/*\n\t * Okay, the inserter committed, so it was good at some point.  Now what\n\t * about the deleting transaction?\n\t */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn HEAPTUPLE_LIVE;\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t{\n\t\t/*\n\t\t * \"Deleting\" xact really only locked it, so the tuple is live in any\n\t\t * case.  However, we should make sure that either XMAX_COMMITTED or\n\t\t * XMAX_INVALID gets set once the xact is gone, to reduce the costs of\n\t\t * examining the tuple for future xacts.\n\t\t */\n\t\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a pre-pg_upgrade tuple, the multixact cannot\n\t\t\t\t * possibly be running; otherwise have to check.\n\t\t\t\t */\n\t\t\t\tif (!HEAP_LOCKED_UPGRADED(tuple->t_infomask) &&\n\t\t\t\t\tMultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple),\n\t\t\t\t\t\t\t\t\t\t true))\n\t\t\t\t\treturn HEAPTUPLE_LIVE;\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID, InvalidTransactionId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t\t\treturn HEAPTUPLE_LIVE;\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We don't really care whether xmax did commit, abort or crash. We\n\t\t * know that xmax did lock the tuple, but it did not and will never\n\t\t * actually update it.\n\t\t */\n\n\t\treturn HEAPTUPLE_LIVE;\n\t}\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t/* already checked above */\n\t\tAssert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsInProgress(xmax))\n\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\telse if (TransactionIdDidCommit(xmax))\n\t\t{\n\t\t\t/*\n\t\t\t * The multixact might still be running due to lockers.  If the\n\t\t\t * updater is below the xid horizon, we have to return DEAD\n\t\t\t * regardless -- otherwise we could end up with a tuple where the\n\t\t\t * updater has to be removed due to the horizon, but is not pruned\n\t\t\t * away.  It's not a problem to prune that tuple, because any\n\t\t\t * remaining lockers will also be present in newer tuple versions.\n\t\t\t */\n\t\t\tif (!TransactionIdPrecedes(xmax, OldestXmin))\n\t\t\t\treturn HEAPTUPLE_RECENTLY_DEAD;\n\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t}\n\t\telse if (!MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), false))\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed.\n\t\t\t * Mark the Xmax as invalid.\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID, InvalidTransactionId);\n\t\t}\n\n\t\treturn HEAPTUPLE_LIVE;\n\t}\n\n\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t{\n\t\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HEAPTUPLE_LIVE;\n\t\t}\n\n\t\t/*\n\t\t * At this point the xmax is known committed, but we might not have\n\t\t * been able to set the hint bit yet; so we can no longer Assert that\n\t\t * it's set.\n\t\t */\n\t}\n\n\t/*\n\t * Deleter committed, but perhaps it was recent enough that some open\n\t * transactions could still see the tuple.\n\t */\n\tif (!TransactionIdPrecedes(HeapTupleHeaderGetRawXmax(tuple), OldestXmin))\n\t\treturn HEAPTUPLE_RECENTLY_DEAD;\n\n\t/* Otherwise, it's dead and removable */\n\treturn HEAPTUPLE_DEAD;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)",
            "OldestXmin"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetHintBits",
          "args": [
            "tuple",
            "buffer",
            "HEAP_XMAX_INVALID",
            "InvalidTransactionId"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleSetHintBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "143-148",
          "snippet": "void\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiXactIdIsRunning",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)",
            "false"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "xmax",
            "OldestXmin"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmax"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xmax"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xmax)"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask)"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiXactIdIsRunning",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)",
            "true"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_LOCKED_UPGRADED",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetUpdateXid(tuple)"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderIsOnlyLocked",
          "args": [
            "tuple"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleHeaderIsOnlyLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "1595-1636",
          "snippet": "bool\nHeapTupleHeaderIsOnlyLocked(HeapTupleHeader tuple)\n{\n\tTransactionId xmax;\n\n\t/* if there's no valid Xmax, then there's obviously no update either */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn true;\n\n\tif (tuple->t_infomask & HEAP_XMAX_LOCK_ONLY)\n\t\treturn true;\n\n\t/* invalid xmax means no update */\n\tif (!TransactionIdIsValid(HeapTupleHeaderGetRawXmax(tuple)))\n\t\treturn true;\n\n\t/*\n\t * if HEAP_XMAX_LOCK_ONLY is not set and not a multi, then this must\n\t * necessarily have been updated\n\t */\n\tif (!(tuple->t_infomask & HEAP_XMAX_IS_MULTI))\n\t\treturn false;\n\n\t/* ... but if it's a multi, then perhaps the updating Xid aborted. */\n\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t/* not LOCKED_ONLY, so it has to have an xmax */\n\tAssert(TransactionIdIsValid(xmax));\n\n\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\treturn false;\n\tif (TransactionIdIsInProgress(xmax))\n\t\treturn false;\n\tif (TransactionIdDidCommit(xmax))\n\t\treturn false;\n\n\t/*\n\t * not current, not in progress, not committed -- must have aborted or\n\t * crashed\n\t */\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nHeapTupleHeaderIsOnlyLocked(HeapTupleHeader tuple)\n{\n\tTransactionId xmax;\n\n\t/* if there's no valid Xmax, then there's obviously no update either */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn true;\n\n\tif (tuple->t_infomask & HEAP_XMAX_LOCK_ONLY)\n\t\treturn true;\n\n\t/* invalid xmax means no update */\n\tif (!TransactionIdIsValid(HeapTupleHeaderGetRawXmax(tuple)))\n\t\treturn true;\n\n\t/*\n\t * if HEAP_XMAX_LOCK_ONLY is not set and not a multi, then this must\n\t * necessarily have been updated\n\t */\n\tif (!(tuple->t_infomask & HEAP_XMAX_IS_MULTI))\n\t\treturn false;\n\n\t/* ... but if it's a multi, then perhaps the updating Xid aborted. */\n\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t/* not LOCKED_ONLY, so it has to have an xmax */\n\tAssert(TransactionIdIsValid(xmax));\n\n\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\treturn false;\n\tif (TransactionIdIsInProgress(xmax))\n\t\treturn false;\n\tif (TransactionIdDidCommit(xmax))\n\t\treturn false;\n\n\t/*\n\t * not current, not in progress, not committed -- must have aborted or\n\t * crashed\n\t */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xvac"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xvac"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminInvalid",
          "args": [
            "tuple"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminCommitted",
          "args": [
            "tuple"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "htup->t_tableOid != InvalidOid"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ItemPointerIsValid(&htup->t_self)"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerIsValid",
          "args": [
            "&htup->t_self"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nHTSV_Result\nHeapTupleSatisfiesVacuum(HeapTuple htup, TransactionId OldestXmin,\n\t\t\t\t\t\t Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\t/*\n\t * Has inserting transaction committed?\n\t *\n\t * If the inserting transaction aborted, then the tuple was never visible\n\t * to any other transaction, so we can delete it immediately.\n\t */\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t{\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn HEAPTUPLE_DEAD;\n\t\t\t}\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\telse\n\t\t\t{\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn HEAPTUPLE_DEAD;\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\t/* only locked? run infomask-only check first, for performance */\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask) ||\n\t\t\t\tHeapTupleHeaderIsOnlyLocked(tuple))\n\t\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t\t/* inserted and then deleted by same xact */\n\t\t\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tuple)))\n\t\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\t\t/* deleting subtransaction must have aborted */\n\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t}\n\t\telse if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\t/*\n\t\t\t * It'd be possible to discern between INSERT/DELETE in progress\n\t\t\t * here by looking at xmax - but that doesn't seem beneficial for\n\t\t\t * the majority of callers and even detrimental for some. We'd\n\t\t\t * rather have callers look at/wait for xmin than xmax. It's\n\t\t\t * always correct to return INSERT_IN_PROGRESS because that's\n\t\t\t * what's happening from the view of other backends.\n\t\t\t */\n\t\t\treturn HEAPTUPLE_INSERT_IN_PROGRESS;\n\t\t}\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t}\n\n\t\t/*\n\t\t * At this point the xmin is known committed, but we might not have\n\t\t * been able to set the hint bit yet; so we can no longer Assert that\n\t\t * it's set.\n\t\t */\n\t}\n\n\t/*\n\t * Okay, the inserter committed, so it was good at some point.  Now what\n\t * about the deleting transaction?\n\t */\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\n\t\treturn HEAPTUPLE_LIVE;\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t{\n\t\t/*\n\t\t * \"Deleting\" xact really only locked it, so the tuple is live in any\n\t\t * case.  However, we should make sure that either XMAX_COMMITTED or\n\t\t * XMAX_INVALID gets set once the xact is gone, to reduce the costs of\n\t\t * examining the tuple for future xacts.\n\t\t */\n\t\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a pre-pg_upgrade tuple, the multixact cannot\n\t\t\t\t * possibly be running; otherwise have to check.\n\t\t\t\t */\n\t\t\t\tif (!HEAP_LOCKED_UPGRADED(tuple->t_infomask) &&\n\t\t\t\t\tMultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple),\n\t\t\t\t\t\t\t\t\t\t true))\n\t\t\t\t\treturn HEAPTUPLE_LIVE;\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID, InvalidTransactionId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t\t\treturn HEAPTUPLE_LIVE;\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We don't really care whether xmax did commit, abort or crash. We\n\t\t * know that xmax did lock the tuple, but it did not and will never\n\t\t * actually update it.\n\t\t */\n\n\t\treturn HEAPTUPLE_LIVE;\n\t}\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t/* already checked above */\n\t\tAssert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsInProgress(xmax))\n\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\telse if (TransactionIdDidCommit(xmax))\n\t\t{\n\t\t\t/*\n\t\t\t * The multixact might still be running due to lockers.  If the\n\t\t\t * updater is below the xid horizon, we have to return DEAD\n\t\t\t * regardless -- otherwise we could end up with a tuple where the\n\t\t\t * updater has to be removed due to the horizon, but is not pruned\n\t\t\t * away.  It's not a problem to prune that tuple, because any\n\t\t\t * remaining lockers will also be present in newer tuple versions.\n\t\t\t */\n\t\t\tif (!TransactionIdPrecedes(xmax, OldestXmin))\n\t\t\t\treturn HEAPTUPLE_RECENTLY_DEAD;\n\n\t\t\treturn HEAPTUPLE_DEAD;\n\t\t}\n\t\telse if (!MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), false))\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed.\n\t\t\t * Mark the Xmax as invalid.\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID, InvalidTransactionId);\n\t\t}\n\n\t\treturn HEAPTUPLE_LIVE;\n\t}\n\n\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t{\n\t\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\treturn HEAPTUPLE_DELETE_IN_PROGRESS;\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Not in Progress, Not Committed, so either Aborted or crashed\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HEAPTUPLE_LIVE;\n\t\t}\n\n\t\t/*\n\t\t * At this point the xmax is known committed, but we might not have\n\t\t * been able to set the hint bit yet; so we can no longer Assert that\n\t\t * it's set.\n\t\t */\n\t}\n\n\t/*\n\t * Deleter committed, but perhaps it was recent enough that some open\n\t * transactions could still see the tuple.\n\t */\n\tif (!TransactionIdPrecedes(HeapTupleHeaderGetRawXmax(tuple), OldestXmin))\n\t\treturn HEAPTUPLE_RECENTLY_DEAD;\n\n\t/* Otherwise, it's dead and removable */\n\treturn HEAPTUPLE_DEAD;\n}"
  },
  {
    "function_name": "HeapTupleSatisfiesMVCC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "962-1148",
    "snippet": "bool\nHeapTupleSatisfiesMVCC(HeapTuple htup, Snapshot snapshot,\n\t\t\t\t\t   Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn false;\n\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\tif (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn false;\n\t\t\tif (!XidInMVCCSnapshot(xvac, snapshot))\n\t\t\t{\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t{\n\t\t\t\tif (XidInMVCCSnapshot(xvac, snapshot))\n\t\t\t\t\treturn false;\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (HeapTupleHeaderGetCmin(tuple) >= snapshot->curcid)\n\t\t\t\treturn false;\t/* inserted after scan started */\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn true;\n\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\t/* not deleter */\n\t\t\t\treturn true;\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\tTransactionId xmax;\n\n\t\t\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\t\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\t\t\t/* updating subtransaction must have aborted */\n\t\t\t\tif (!TransactionIdIsCurrentTransactionId(xmax))\n\t\t\t\t\treturn true;\n\t\t\t\telse if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)\n\t\t\t\t\treturn true;\t/* updated after scan started */\n\t\t\t\telse\n\t\t\t\t\treturn false;\t/* updated before scan started */\n\t\t\t}\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t{\n\t\t\t\t/* deleting subtransaction must have aborted */\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)\n\t\t\t\treturn true;\t/* deleted after scan started */\n\t\t\telse\n\t\t\t\treturn false;\t/* deleted before scan started */\n\t\t}\n\t\telse if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmin(tuple), snapshot))\n\t\t\treturn false;\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/* it must have aborted or crashed */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* xmin is committed, but maybe not according to our snapshot */\n\t\tif (!HeapTupleHeaderXminFrozen(tuple) &&\n\t\t\tXidInMVCCSnapshot(HeapTupleHeaderGetRawXmin(tuple), snapshot))\n\t\t\treturn false;\t\t/* treat as still in progress */\n\t}\n\n\t/* by here, the inserting transaction has committed */\n\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid or aborted */\n\t\treturn true;\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\treturn true;\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax;\n\n\t\t/* already checked above */\n\t\tAssert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));\n\n\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\t{\n\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)\n\t\t\t\treturn true;\t/* deleted after scan started */\n\t\t\telse\n\t\t\t\treturn false;\t/* deleted before scan started */\n\t\t}\n\t\tif (XidInMVCCSnapshot(xmax, snapshot))\n\t\t\treturn true;\n\t\tif (TransactionIdDidCommit(xmax))\n\t\t\treturn false;\t\t/* updating transaction committed */\n\t\t/* it must have aborted or crashed */\n\t\treturn true;\n\t}\n\n\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t{\n\t\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t{\n\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)\n\t\t\t\treturn true;\t/* deleted after scan started */\n\t\t\telse\n\t\t\t\treturn false;\t/* deleted before scan started */\n\t\t}\n\n\t\tif (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))\n\t\t\treturn true;\n\n\t\tif (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t{\n\t\t\t/* it must have aborted or crashed */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn true;\n\t\t}\n\n\t\t/* xmax transaction committed */\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\t}\n\telse\n\t{\n\t\t/* xmax is committed, but maybe not according to our snapshot */\n\t\tif (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))\n\t\t\treturn true;\t\t/* treat as still in progress */\n\t}\n\n\t/* xmax transaction committed */\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XidInMVCCSnapshot",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)",
            "snapshot"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "XidInMVCCSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "1474-1584",
          "snippet": "bool\nXidInMVCCSnapshot(TransactionId xid, Snapshot snapshot)\n{\n\tuint32\t\ti;\n\n\t/*\n\t * Make a quick range check to eliminate most XIDs without looking at the\n\t * xip arrays.  Note that this is OK even if we convert a subxact XID to\n\t * its parent below, because a subxact with XID < xmin has surely also got\n\t * a parent with XID < xmin, while one with XID >= xmax must belong to a\n\t * parent that was not yet committed at the time of this snapshot.\n\t */\n\n\t/* Any xid < xmin is not in-progress */\n\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\treturn false;\n\t/* Any xid >= xmax is in-progress */\n\tif (TransactionIdFollowsOrEquals(xid, snapshot->xmax))\n\t\treturn true;\n\n\t/*\n\t * Snapshot information is stored slightly differently in snapshots taken\n\t * during recovery.\n\t */\n\tif (!snapshot->takenDuringRecovery)\n\t{\n\t\t/*\n\t\t * If the snapshot contains full subxact data, the fastest way to\n\t\t * check things is just to compare the given XID against both subxact\n\t\t * XIDs and top-level XIDs.  If the snapshot overflowed, we have to\n\t\t * use pg_subtrans to convert a subxact XID to its parent XID, but\n\t\t * then we need only look at top-level XIDs not subxacts.\n\t\t */\n\t\tif (!snapshot->suboverflowed)\n\t\t{\n\t\t\t/* we have full data, so search subxip */\n\t\t\tint32\t\tj;\n\n\t\t\tfor (j = 0; j < snapshot->subxcnt; j++)\n\t\t\t{\n\t\t\t\tif (TransactionIdEquals(xid, snapshot->subxip[j]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/* not there, fall through to search xip[] */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Snapshot overflowed, so convert xid to top-level.  This is safe\n\t\t\t * because we eliminated too-old XIDs above.\n\t\t\t */\n\t\t\txid = SubTransGetTopmostTransaction(xid);\n\n\t\t\t/*\n\t\t\t * If xid was indeed a subxact, we might now have an xid < xmin,\n\t\t\t * so recheck to avoid an array scan.  No point in rechecking\n\t\t\t * xmax.\n\t\t\t */\n\t\t\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0; i < snapshot->xcnt; i++)\n\t\t{\n\t\t\tif (TransactionIdEquals(xid, snapshot->xip[i]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint32\t\tj;\n\n\t\t/*\n\t\t * In recovery we store all xids in the subxact array because it is by\n\t\t * far the bigger array, and we mostly don't know which xids are\n\t\t * top-level and which are subxacts. The xip array is empty.\n\t\t *\n\t\t * We start by searching subtrans, if we overflowed.\n\t\t */\n\t\tif (snapshot->suboverflowed)\n\t\t{\n\t\t\t/*\n\t\t\t * Snapshot overflowed, so convert xid to top-level.  This is safe\n\t\t\t * because we eliminated too-old XIDs above.\n\t\t\t */\n\t\t\txid = SubTransGetTopmostTransaction(xid);\n\n\t\t\t/*\n\t\t\t * If xid was indeed a subxact, we might now have an xid < xmin,\n\t\t\t * so recheck to avoid an array scan.  No point in rechecking\n\t\t\t * xmax.\n\t\t\t */\n\t\t\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * We now have either a top-level xid higher than xmin or an\n\t\t * indeterminate xid. We don't know whether it's top level or subxact\n\t\t * but it doesn't matter. If it's present, the xid is visible.\n\t\t */\n\t\tfor (j = 0; j < snapshot->subxcnt; j++)\n\t\t{\n\t\t\tif (TransactionIdEquals(xid, snapshot->subxip[j]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nXidInMVCCSnapshot(TransactionId xid, Snapshot snapshot)\n{\n\tuint32\t\ti;\n\n\t/*\n\t * Make a quick range check to eliminate most XIDs without looking at the\n\t * xip arrays.  Note that this is OK even if we convert a subxact XID to\n\t * its parent below, because a subxact with XID < xmin has surely also got\n\t * a parent with XID < xmin, while one with XID >= xmax must belong to a\n\t * parent that was not yet committed at the time of this snapshot.\n\t */\n\n\t/* Any xid < xmin is not in-progress */\n\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\treturn false;\n\t/* Any xid >= xmax is in-progress */\n\tif (TransactionIdFollowsOrEquals(xid, snapshot->xmax))\n\t\treturn true;\n\n\t/*\n\t * Snapshot information is stored slightly differently in snapshots taken\n\t * during recovery.\n\t */\n\tif (!snapshot->takenDuringRecovery)\n\t{\n\t\t/*\n\t\t * If the snapshot contains full subxact data, the fastest way to\n\t\t * check things is just to compare the given XID against both subxact\n\t\t * XIDs and top-level XIDs.  If the snapshot overflowed, we have to\n\t\t * use pg_subtrans to convert a subxact XID to its parent XID, but\n\t\t * then we need only look at top-level XIDs not subxacts.\n\t\t */\n\t\tif (!snapshot->suboverflowed)\n\t\t{\n\t\t\t/* we have full data, so search subxip */\n\t\t\tint32\t\tj;\n\n\t\t\tfor (j = 0; j < snapshot->subxcnt; j++)\n\t\t\t{\n\t\t\t\tif (TransactionIdEquals(xid, snapshot->subxip[j]))\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/* not there, fall through to search xip[] */\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Snapshot overflowed, so convert xid to top-level.  This is safe\n\t\t\t * because we eliminated too-old XIDs above.\n\t\t\t */\n\t\t\txid = SubTransGetTopmostTransaction(xid);\n\n\t\t\t/*\n\t\t\t * If xid was indeed a subxact, we might now have an xid < xmin,\n\t\t\t * so recheck to avoid an array scan.  No point in rechecking\n\t\t\t * xmax.\n\t\t\t */\n\t\t\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0; i < snapshot->xcnt; i++)\n\t\t{\n\t\t\tif (TransactionIdEquals(xid, snapshot->xip[i]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint32\t\tj;\n\n\t\t/*\n\t\t * In recovery we store all xids in the subxact array because it is by\n\t\t * far the bigger array, and we mostly don't know which xids are\n\t\t * top-level and which are subxacts. The xip array is empty.\n\t\t *\n\t\t * We start by searching subtrans, if we overflowed.\n\t\t */\n\t\tif (snapshot->suboverflowed)\n\t\t{\n\t\t\t/*\n\t\t\t * Snapshot overflowed, so convert xid to top-level.  This is safe\n\t\t\t * because we eliminated too-old XIDs above.\n\t\t\t */\n\t\t\txid = SubTransGetTopmostTransaction(xid);\n\n\t\t\t/*\n\t\t\t * If xid was indeed a subxact, we might now have an xid < xmin,\n\t\t\t * so recheck to avoid an array scan.  No point in rechecking\n\t\t\t * xmax.\n\t\t\t */\n\t\t\tif (TransactionIdPrecedes(xid, snapshot->xmin))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * We now have either a top-level xid higher than xmin or an\n\t\t * indeterminate xid. We don't know whether it's top level or subxact\n\t\t * but it doesn't matter. If it's present, the xid is visible.\n\t\t */\n\t\tfor (j = 0; j < snapshot->subxcnt; j++)\n\t\t{\n\t\t\tif (TransactionIdEquals(xid, snapshot->subxip[j]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetHintBits",
          "args": [
            "tuple",
            "buffer",
            "HEAP_XMAX_COMMITTED",
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleSetHintBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "143-148",
          "snippet": "void\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetCmax",
          "args": [
            "tuple"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleHeaderGetCmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
          "lines": "118-138",
          "snippet": "CommandId\nHeapTupleHeaderGetCmax(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\n\t/*\n\t * Because GetUpdateXid() performs memory allocations if xmax is a\n\t * multixact we can't Assert() if we're inside a critical section. This\n\t * weakens the check, but not using GetCmax() inside one would complicate\n\t * things too much.\n\t */\n\tAssert(CritSectionCount > 0 ||\n\t\t   TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmax(cid);\n\telse\n\t\treturn cid;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nCommandId\nHeapTupleHeaderGetCmax(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\n\t/*\n\t * Because GetUpdateXid() performs memory allocations if xmax is a\n\t * multixact we can't Assert() if we're inside a critical section. This\n\t * weakens the check, but not using GetCmax() inside one would complicate\n\t * things too much.\n\t */\n\tAssert(CritSectionCount > 0 ||\n\t\t   TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmax(cid);\n\telse\n\t\treturn cid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmax"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xmax"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xmax)"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask)"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminFrozen",
          "args": [
            "tuple"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xmax"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xmax)"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetCmin",
          "args": [
            "tuple"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleHeaderGetCmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
          "lines": "104-116",
          "snippet": "CommandId\nHeapTupleHeaderGetCmin(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\tAssert(TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmin(cid);\n\telse\n\t\treturn cid;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nCommandId\nHeapTupleHeaderGetCmin(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\tAssert(TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmin(cid);\n\telse\n\t\treturn cid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminInvalid",
          "args": [
            "tuple"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminCommitted",
          "args": [
            "tuple"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "htup->t_tableOid != InvalidOid"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ItemPointerIsValid(&htup->t_self)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerIsValid",
          "args": [
            "&htup->t_self"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nHeapTupleSatisfiesMVCC(HeapTuple htup, Snapshot snapshot,\n\t\t\t\t\t   Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn false;\n\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\tif (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn false;\n\t\t\tif (!XidInMVCCSnapshot(xvac, snapshot))\n\t\t\t{\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t{\n\t\t\t\tif (XidInMVCCSnapshot(xvac, snapshot))\n\t\t\t\t\treturn false;\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (HeapTupleHeaderGetCmin(tuple) >= snapshot->curcid)\n\t\t\t\treturn false;\t/* inserted after scan started */\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn true;\n\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\t/* not deleter */\n\t\t\t\treturn true;\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\tTransactionId xmax;\n\n\t\t\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\t\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\t\t\t/* updating subtransaction must have aborted */\n\t\t\t\tif (!TransactionIdIsCurrentTransactionId(xmax))\n\t\t\t\t\treturn true;\n\t\t\t\telse if (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)\n\t\t\t\t\treturn true;\t/* updated after scan started */\n\t\t\t\telse\n\t\t\t\t\treturn false;\t/* updated before scan started */\n\t\t\t}\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t{\n\t\t\t\t/* deleting subtransaction must have aborted */\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)\n\t\t\t\treturn true;\t/* deleted after scan started */\n\t\t\telse\n\t\t\t\treturn false;\t/* deleted before scan started */\n\t\t}\n\t\telse if (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmin(tuple), snapshot))\n\t\t\treturn false;\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/* it must have aborted or crashed */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* xmin is committed, but maybe not according to our snapshot */\n\t\tif (!HeapTupleHeaderXminFrozen(tuple) &&\n\t\t\tXidInMVCCSnapshot(HeapTupleHeaderGetRawXmin(tuple), snapshot))\n\t\t\treturn false;\t\t/* treat as still in progress */\n\t}\n\n\t/* by here, the inserting transaction has committed */\n\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid or aborted */\n\t\treturn true;\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\treturn true;\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax;\n\n\t\t/* already checked above */\n\t\tAssert(!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask));\n\n\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\t{\n\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)\n\t\t\t\treturn true;\t/* deleted after scan started */\n\t\t\telse\n\t\t\t\treturn false;\t/* deleted before scan started */\n\t\t}\n\t\tif (XidInMVCCSnapshot(xmax, snapshot))\n\t\t\treturn true;\n\t\tif (TransactionIdDidCommit(xmax))\n\t\t\treturn false;\t\t/* updating transaction committed */\n\t\t/* it must have aborted or crashed */\n\t\treturn true;\n\t}\n\n\tif (!(tuple->t_infomask & HEAP_XMAX_COMMITTED))\n\t{\n\t\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t{\n\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= snapshot->curcid)\n\t\t\t\treturn true;\t/* deleted after scan started */\n\t\t\telse\n\t\t\t\treturn false;\t/* deleted before scan started */\n\t\t}\n\n\t\tif (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))\n\t\t\treturn true;\n\n\t\tif (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t{\n\t\t\t/* it must have aborted or crashed */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn true;\n\t\t}\n\n\t\t/* xmax transaction committed */\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\t}\n\telse\n\t{\n\t\t/* xmax is committed, but maybe not according to our snapshot */\n\t\tif (XidInMVCCSnapshot(HeapTupleHeaderGetRawXmax(tuple), snapshot))\n\t\t\treturn true;\t\t/* treat as still in progress */\n\t}\n\n\t/* xmax transaction committed */\n\n\treturn false;\n}"
  },
  {
    "function_name": "HeapTupleSatisfiesDirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "738-931",
    "snippet": "bool\nHeapTupleSatisfiesDirty(HeapTuple htup, Snapshot snapshot,\n\t\t\t\t\t\tBuffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\tsnapshot->xmin = snapshot->xmax = InvalidTransactionId;\n\tsnapshot->speculativeToken = 0;\n\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn false;\n\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\tif (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn false;\n\t\t\tif (!TransactionIdIsInProgress(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\t\treturn false;\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn true;\n\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\t/* not deleter */\n\t\t\t\treturn true;\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\tTransactionId xmax;\n\n\t\t\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\t\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\t\t\t/* updating subtransaction must have aborted */\n\t\t\t\tif (!TransactionIdIsCurrentTransactionId(xmax))\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t{\n\t\t\t\t/* deleting subtransaction must have aborted */\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t\telse if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\t/*\n\t\t\t * Return the speculative token to caller.  Caller can worry about\n\t\t\t * xmax, since it requires a conclusively locked row version, and\n\t\t\t * a concurrent update to this tuple is a conflict of its\n\t\t\t * purposes.\n\t\t\t */\n\t\t\tif (HeapTupleHeaderIsSpeculative(tuple))\n\t\t\t{\n\t\t\t\tsnapshot->speculativeToken =\n\t\t\t\t\tHeapTupleHeaderGetSpeculativeToken(tuple);\n\n\t\t\t\tAssert(snapshot->speculativeToken != 0);\n\t\t\t}\n\n\t\t\tsnapshot->xmin = HeapTupleHeaderGetRawXmin(tuple);\n\t\t\t/* XXX shouldn't we fall through to look at xmax? */\n\t\t\treturn true;\t\t/* in insertion by other */\n\t\t}\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/* it must have aborted or crashed */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* by here, the inserting transaction has committed */\n\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid or aborted */\n\t\treturn true;\n\n\tif (tuple->t_infomask & HEAP_XMAX_COMMITTED)\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\t\treturn false;\t\t\t/* updated by other */\n\t}\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax;\n\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\n\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\t\treturn false;\n\t\tif (TransactionIdIsInProgress(xmax))\n\t\t{\n\t\t\tsnapshot->xmax = xmax;\n\t\t\treturn true;\n\t\t}\n\t\tif (TransactionIdDidCommit(xmax))\n\t\t\treturn false;\n\t\t/* it must have aborted or crashed */\n\t\treturn true;\n\t}\n\n\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\tif (!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\tsnapshot->xmax = HeapTupleHeaderGetRawXmax(tuple);\n\t\treturn true;\n\t}\n\n\tif (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\t/* it must have aborted or crashed */\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn true;\n\t}\n\n\t/* xmax transaction committed */\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t{\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn true;\n\t}\n\n\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\treturn false;\t\t\t\t/* updated by other */\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetHintBits",
          "args": [
            "tuple",
            "buffer",
            "HEAP_XMAX_COMMITTED",
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleSetHintBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "143-148",
          "snippet": "void\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmax"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xmax"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xmax"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xmax)"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "snapshot->speculativeToken != 0"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetSpeculativeToken",
          "args": [
            "tuple"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderIsSpeculative",
          "args": [
            "tuple"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xmax"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xmax)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xvac"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xvac"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminInvalid",
          "args": [
            "tuple"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminCommitted",
          "args": [
            "tuple"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "htup->t_tableOid != InvalidOid"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ItemPointerIsValid(&htup->t_self)"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerIsValid",
          "args": [
            "&htup->t_self"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nHeapTupleSatisfiesDirty(HeapTuple htup, Snapshot snapshot,\n\t\t\t\t\t\tBuffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\tsnapshot->xmin = snapshot->xmax = InvalidTransactionId;\n\tsnapshot->speculativeToken = 0;\n\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn false;\n\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\tif (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn false;\n\t\t\tif (!TransactionIdIsInProgress(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\t\treturn false;\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn true;\n\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\t/* not deleter */\n\t\t\t\treturn true;\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\tTransactionId xmax;\n\n\t\t\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\t\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\t\t\t/* updating subtransaction must have aborted */\n\t\t\t\tif (!TransactionIdIsCurrentTransactionId(xmax))\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t{\n\t\t\t\t/* deleting subtransaction must have aborted */\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t\telse if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\t/*\n\t\t\t * Return the speculative token to caller.  Caller can worry about\n\t\t\t * xmax, since it requires a conclusively locked row version, and\n\t\t\t * a concurrent update to this tuple is a conflict of its\n\t\t\t * purposes.\n\t\t\t */\n\t\t\tif (HeapTupleHeaderIsSpeculative(tuple))\n\t\t\t{\n\t\t\t\tsnapshot->speculativeToken =\n\t\t\t\t\tHeapTupleHeaderGetSpeculativeToken(tuple);\n\n\t\t\t\tAssert(snapshot->speculativeToken != 0);\n\t\t\t}\n\n\t\t\tsnapshot->xmin = HeapTupleHeaderGetRawXmin(tuple);\n\t\t\t/* XXX shouldn't we fall through to look at xmax? */\n\t\t\treturn true;\t\t/* in insertion by other */\n\t\t}\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/* it must have aborted or crashed */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* by here, the inserting transaction has committed */\n\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid or aborted */\n\t\treturn true;\n\n\tif (tuple->t_infomask & HEAP_XMAX_COMMITTED)\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\t\treturn false;\t\t\t/* updated by other */\n\t}\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax;\n\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\n\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\t\treturn false;\n\t\tif (TransactionIdIsInProgress(xmax))\n\t\t{\n\t\t\tsnapshot->xmax = xmax;\n\t\t\treturn true;\n\t\t}\n\t\tif (TransactionIdDidCommit(xmax))\n\t\t\treturn false;\n\t\t/* it must have aborted or crashed */\n\t\treturn true;\n\t}\n\n\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\tif (!HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\tsnapshot->xmax = HeapTupleHeaderGetRawXmax(tuple);\n\t\treturn true;\n\t}\n\n\tif (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\t/* it must have aborted or crashed */\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn true;\n\t}\n\n\t/* xmax transaction committed */\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t{\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn true;\n\t}\n\n\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\treturn false;\t\t\t\t/* updated by other */\n}"
  },
  {
    "function_name": "HeapTupleSatisfiesUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "459-713",
    "snippet": "HTSU_Result\nHeapTupleSatisfiesUpdate(HeapTuple htup, CommandId curcid,\n\t\t\t\t\t\t Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn HeapTupleInvisible;\n\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\tif (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn HeapTupleInvisible;\n\t\t\tif (!TransactionIdIsInProgress(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn HeapTupleInvisible;\n\t\t\t\t}\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\t\treturn HeapTupleInvisible;\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn HeapTupleInvisible;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (HeapTupleHeaderGetCmin(tuple) >= curcid)\n\t\t\t\treturn HeapTupleInvisible;\t/* inserted after scan started */\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn HeapTupleMayBeUpdated;\n\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\t{\n\t\t\t\tTransactionId xmax;\n\n\t\t\t\txmax = HeapTupleHeaderGetRawXmax(tuple);\n\n\t\t\t\t/*\n\t\t\t\t * Careful here: even though this tuple was created by our own\n\t\t\t\t * transaction, it might be locked by other transactions, if\n\t\t\t\t * the original version was key-share locked when we updated\n\t\t\t\t * it.\n\t\t\t\t */\n\n\t\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t\t{\n\t\t\t\t\tif (MultiXactIdIsRunning(xmax, true))\n\t\t\t\t\t\treturn HeapTupleBeingUpdated;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn HeapTupleMayBeUpdated;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If the locker is gone, then there is nothing of interest\n\t\t\t\t * left in this Xmax; otherwise, report the tuple as\n\t\t\t\t * locked/updated.\n\t\t\t\t */\n\t\t\t\tif (!TransactionIdIsInProgress(xmax))\n\t\t\t\t\treturn HeapTupleMayBeUpdated;\n\t\t\t\treturn HeapTupleBeingUpdated;\n\t\t\t}\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\tTransactionId xmax;\n\n\t\t\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\t\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\t\t\t/* deleting subtransaction must have aborted */\n\t\t\t\tif (!TransactionIdIsCurrentTransactionId(xmax))\n\t\t\t\t{\n\t\t\t\t\tif (MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple),\n\t\t\t\t\t\t\t\t\t\t\t false))\n\t\t\t\t\t\treturn HeapTupleBeingUpdated;\n\t\t\t\t\treturn HeapTupleMayBeUpdated;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= curcid)\n\t\t\t\t\t\treturn HeapTupleSelfUpdated;\t/* updated after scan\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * started */\n\t\t\t\t\telse\n\t\t\t\t\t\treturn HeapTupleInvisible;\t/* updated before scan\n\t\t\t\t\t\t\t\t\t\t\t\t\t * started */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t{\n\t\t\t\t/* deleting subtransaction must have aborted */\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn HeapTupleMayBeUpdated;\n\t\t\t}\n\n\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= curcid)\n\t\t\t\treturn HeapTupleSelfUpdated;\t/* updated after scan started */\n\t\t\telse\n\t\t\t\treturn HeapTupleInvisible;\t/* updated before scan started */\n\t\t}\n\t\telse if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\treturn HeapTupleInvisible;\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/* it must have aborted or crashed */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HeapTupleInvisible;\n\t\t}\n\t}\n\n\t/* by here, the inserting transaction has committed */\n\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid or aborted */\n\t\treturn HeapTupleMayBeUpdated;\n\n\tif (tuple->t_infomask & HEAP_XMAX_COMMITTED)\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn HeapTupleMayBeUpdated;\n\t\treturn HeapTupleUpdated;\t/* updated by other */\n\t}\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax;\n\n\t\tif (HEAP_LOCKED_UPGRADED(tuple->t_infomask))\n\t\t\treturn HeapTupleMayBeUpdated;\n\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t{\n\t\t\tif (MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), true))\n\t\t\t\treturn HeapTupleBeingUpdated;\n\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID, InvalidTransactionId);\n\t\t\treturn HeapTupleMayBeUpdated;\n\t\t}\n\n\t\txmax = HeapTupleGetUpdateXid(tuple);\n\t\tif (!TransactionIdIsValid(xmax))\n\t\t{\n\t\t\tif (MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), false))\n\t\t\t\treturn HeapTupleBeingUpdated;\n\t\t}\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\t{\n\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= curcid)\n\t\t\t\treturn HeapTupleSelfUpdated;\t/* updated after scan started */\n\t\t\telse\n\t\t\t\treturn HeapTupleInvisible;\t/* updated before scan started */\n\t\t}\n\n\t\tif (MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), false))\n\t\t\treturn HeapTupleBeingUpdated;\n\n\t\tif (TransactionIdDidCommit(xmax))\n\t\t\treturn HeapTupleUpdated;\n\n\t\t/*\n\t\t * By here, the update in the Xmax is either aborted or crashed, but\n\t\t * what about the other members?\n\t\t */\n\n\t\tif (!MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), false))\n\t\t{\n\t\t\t/*\n\t\t\t * There's no member, even just a locker, alive anymore, so we can\n\t\t\t * mark the Xmax as invalid.\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HeapTupleMayBeUpdated;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* There are lockers running */\n\t\t\treturn HeapTupleBeingUpdated;\n\t\t}\n\t}\n\n\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn HeapTupleBeingUpdated;\n\t\tif (HeapTupleHeaderGetCmax(tuple) >= curcid)\n\t\t\treturn HeapTupleSelfUpdated;\t/* updated after scan started */\n\t\telse\n\t\t\treturn HeapTupleInvisible;\t/* updated before scan started */\n\t}\n\n\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\treturn HeapTupleBeingUpdated;\n\n\tif (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\t/* it must have aborted or crashed */\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn HeapTupleMayBeUpdated;\n\t}\n\n\t/* xmax transaction committed */\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t{\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn HeapTupleMayBeUpdated;\n\t}\n\n\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\treturn HeapTupleUpdated;\t/* updated by other */\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetHintBits",
          "args": [
            "tuple",
            "buffer",
            "HEAP_XMAX_COMMITTED",
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleSetHintBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "143-148",
          "snippet": "void\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetCmax",
          "args": [
            "tuple"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleHeaderGetCmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
          "lines": "118-138",
          "snippet": "CommandId\nHeapTupleHeaderGetCmax(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\n\t/*\n\t * Because GetUpdateXid() performs memory allocations if xmax is a\n\t * multixact we can't Assert() if we're inside a critical section. This\n\t * weakens the check, but not using GetCmax() inside one would complicate\n\t * things too much.\n\t */\n\tAssert(CritSectionCount > 0 ||\n\t\t   TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmax(cid);\n\telse\n\t\treturn cid;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nCommandId\nHeapTupleHeaderGetCmax(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\n\t/*\n\t * Because GetUpdateXid() performs memory allocations if xmax is a\n\t * multixact we can't Assert() if we're inside a critical section. This\n\t * weakens the check, but not using GetCmax() inside one would complicate\n\t * things too much.\n\t */\n\tAssert(CritSectionCount > 0 ||\n\t\t   TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetUpdateXid(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmax(cid);\n\telse\n\t\treturn cid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiXactIdIsRunning",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)",
            "false"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmax"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiXactIdIsRunning",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)",
            "false"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xmax"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xmax)"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiXactIdIsRunning",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)",
            "false"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiXactIdIsRunning",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)",
            "true"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_LOCKED_UPGRADED",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiXactIdIsRunning",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)",
            "false"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xmax"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xmax)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xmax"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiXactIdIsRunning",
          "args": [
            "xmax",
            "true"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetCmin",
          "args": [
            "tuple"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleHeaderGetCmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/combocid.c",
          "lines": "104-116",
          "snippet": "CommandId\nHeapTupleHeaderGetCmin(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\tAssert(TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmin(cid);\n\telse\n\t\treturn cid;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"miscadmin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/combocid.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"miscadmin.h\"\n#include \"postgres.h\"\n\nCommandId\nHeapTupleHeaderGetCmin(HeapTupleHeader tup)\n{\n\tCommandId\tcid = HeapTupleHeaderGetRawCommandId(tup);\n\n\tAssert(!(tup->t_infomask & HEAP_MOVED));\n\tAssert(TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetXmin(tup)));\n\n\tif (tup->t_infomask & HEAP_COMBOCID)\n\t\treturn GetRealCmin(cid);\n\telse\n\t\treturn cid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xvac"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xvac"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminInvalid",
          "args": [
            "tuple"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminCommitted",
          "args": [
            "tuple"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "htup->t_tableOid != InvalidOid"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ItemPointerIsValid(&htup->t_self)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerIsValid",
          "args": [
            "&htup->t_self"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nHTSU_Result\nHeapTupleSatisfiesUpdate(HeapTuple htup, CommandId curcid,\n\t\t\t\t\t\t Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn HeapTupleInvisible;\n\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\tif (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn HeapTupleInvisible;\n\t\t\tif (!TransactionIdIsInProgress(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn HeapTupleInvisible;\n\t\t\t\t}\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\t\treturn HeapTupleInvisible;\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn HeapTupleInvisible;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (HeapTupleHeaderGetCmin(tuple) >= curcid)\n\t\t\t\treturn HeapTupleInvisible;\t/* inserted after scan started */\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn HeapTupleMayBeUpdated;\n\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\t{\n\t\t\t\tTransactionId xmax;\n\n\t\t\t\txmax = HeapTupleHeaderGetRawXmax(tuple);\n\n\t\t\t\t/*\n\t\t\t\t * Careful here: even though this tuple was created by our own\n\t\t\t\t * transaction, it might be locked by other transactions, if\n\t\t\t\t * the original version was key-share locked when we updated\n\t\t\t\t * it.\n\t\t\t\t */\n\n\t\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t\t{\n\t\t\t\t\tif (MultiXactIdIsRunning(xmax, true))\n\t\t\t\t\t\treturn HeapTupleBeingUpdated;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn HeapTupleMayBeUpdated;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If the locker is gone, then there is nothing of interest\n\t\t\t\t * left in this Xmax; otherwise, report the tuple as\n\t\t\t\t * locked/updated.\n\t\t\t\t */\n\t\t\t\tif (!TransactionIdIsInProgress(xmax))\n\t\t\t\t\treturn HeapTupleMayBeUpdated;\n\t\t\t\treturn HeapTupleBeingUpdated;\n\t\t\t}\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\tTransactionId xmax;\n\n\t\t\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\t\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\t\t\t/* deleting subtransaction must have aborted */\n\t\t\t\tif (!TransactionIdIsCurrentTransactionId(xmax))\n\t\t\t\t{\n\t\t\t\t\tif (MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple),\n\t\t\t\t\t\t\t\t\t\t\t false))\n\t\t\t\t\t\treturn HeapTupleBeingUpdated;\n\t\t\t\t\treturn HeapTupleMayBeUpdated;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= curcid)\n\t\t\t\t\t\treturn HeapTupleSelfUpdated;\t/* updated after scan\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * started */\n\t\t\t\t\telse\n\t\t\t\t\t\treturn HeapTupleInvisible;\t/* updated before scan\n\t\t\t\t\t\t\t\t\t\t\t\t\t * started */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t{\n\t\t\t\t/* deleting subtransaction must have aborted */\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn HeapTupleMayBeUpdated;\n\t\t\t}\n\n\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= curcid)\n\t\t\t\treturn HeapTupleSelfUpdated;\t/* updated after scan started */\n\t\t\telse\n\t\t\t\treturn HeapTupleInvisible;\t/* updated before scan started */\n\t\t}\n\t\telse if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\treturn HeapTupleInvisible;\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/* it must have aborted or crashed */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HeapTupleInvisible;\n\t\t}\n\t}\n\n\t/* by here, the inserting transaction has committed */\n\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid or aborted */\n\t\treturn HeapTupleMayBeUpdated;\n\n\tif (tuple->t_infomask & HEAP_XMAX_COMMITTED)\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn HeapTupleMayBeUpdated;\n\t\treturn HeapTupleUpdated;\t/* updated by other */\n\t}\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax;\n\n\t\tif (HEAP_LOCKED_UPGRADED(tuple->t_infomask))\n\t\t\treturn HeapTupleMayBeUpdated;\n\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t{\n\t\t\tif (MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), true))\n\t\t\t\treturn HeapTupleBeingUpdated;\n\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID, InvalidTransactionId);\n\t\t\treturn HeapTupleMayBeUpdated;\n\t\t}\n\n\t\txmax = HeapTupleGetUpdateXid(tuple);\n\t\tif (!TransactionIdIsValid(xmax))\n\t\t{\n\t\t\tif (MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), false))\n\t\t\t\treturn HeapTupleBeingUpdated;\n\t\t}\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\t{\n\t\t\tif (HeapTupleHeaderGetCmax(tuple) >= curcid)\n\t\t\t\treturn HeapTupleSelfUpdated;\t/* updated after scan started */\n\t\t\telse\n\t\t\t\treturn HeapTupleInvisible;\t/* updated before scan started */\n\t\t}\n\n\t\tif (MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), false))\n\t\t\treturn HeapTupleBeingUpdated;\n\n\t\tif (TransactionIdDidCommit(xmax))\n\t\t\treturn HeapTupleUpdated;\n\n\t\t/*\n\t\t * By here, the update in the Xmax is either aborted or crashed, but\n\t\t * what about the other members?\n\t\t */\n\n\t\tif (!MultiXactIdIsRunning(HeapTupleHeaderGetRawXmax(tuple), false))\n\t\t{\n\t\t\t/*\n\t\t\t * There's no member, even just a locker, alive anymore, so we can\n\t\t\t * mark the Xmax as invalid.\n\t\t\t */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn HeapTupleMayBeUpdated;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* There are lockers running */\n\t\t\treturn HeapTupleBeingUpdated;\n\t\t}\n\t}\n\n\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn HeapTupleBeingUpdated;\n\t\tif (HeapTupleHeaderGetCmax(tuple) >= curcid)\n\t\t\treturn HeapTupleSelfUpdated;\t/* updated after scan started */\n\t\telse\n\t\t\treturn HeapTupleInvisible;\t/* updated before scan started */\n\t}\n\n\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\treturn HeapTupleBeingUpdated;\n\n\tif (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\t/* it must have aborted or crashed */\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn HeapTupleMayBeUpdated;\n\t}\n\n\t/* xmax transaction committed */\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t{\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn HeapTupleMayBeUpdated;\n\t}\n\n\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\treturn HeapTupleUpdated;\t/* updated by other */\n}"
  },
  {
    "function_name": "HeapTupleSatisfiesToast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "365-430",
    "snippet": "bool\nHeapTupleSatisfiesToast(HeapTuple htup, Snapshot snapshot,\n\t\t\t\t\t\tBuffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn false;\n\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\tif (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn false;\n\t\t\tif (!TransactionIdIsInProgress(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\t\treturn false;\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * An invalid Xmin can be left behind by a speculative insertion that\n\t\t * is canceled by super-deleting the tuple.  This also applies to\n\t\t * TOAST tuples created during speculative insertion.\n\t\t */\n\t\telse if (!TransactionIdIsValid(HeapTupleHeaderGetXmin(tuple)))\n\t\t\treturn false;\n\t}\n\n\t/* otherwise assume the tuple is valid for TOAST. */\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "HeapTupleHeaderGetXmin(tuple)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXmin",
          "args": [
            "tuple"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetHintBits",
          "args": [
            "tuple",
            "buffer",
            "HEAP_XMIN_INVALID",
            "InvalidTransactionId"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleSetHintBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "143-148",
          "snippet": "void\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xvac"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xvac"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminInvalid",
          "args": [
            "tuple"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminCommitted",
          "args": [
            "tuple"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "htup->t_tableOid != InvalidOid"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ItemPointerIsValid(&htup->t_self)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerIsValid",
          "args": [
            "&htup->t_self"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nHeapTupleSatisfiesToast(HeapTuple htup, Snapshot snapshot,\n\t\t\t\t\t\tBuffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn false;\n\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\tif (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn false;\n\t\t\tif (!TransactionIdIsInProgress(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\t\treturn false;\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * An invalid Xmin can be left behind by a speculative insertion that\n\t\t * is canceled by super-deleting the tuple.  This also applies to\n\t\t * TOAST tuples created during speculative insertion.\n\t\t */\n\t\telse if (!TransactionIdIsValid(HeapTupleHeaderGetXmin(tuple)))\n\t\t\treturn false;\n\t}\n\n\t/* otherwise assume the tuple is valid for TOAST. */\n\treturn true;\n}"
  },
  {
    "function_name": "HeapTupleSatisfiesAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "345-349",
    "snippet": "bool\nHeapTupleSatisfiesAny(HeapTuple htup, Snapshot snapshot, Buffer buffer)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nHeapTupleSatisfiesAny(HeapTuple htup, Snapshot snapshot, Buffer buffer)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "HeapTupleSatisfiesSelf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "175-339",
    "snippet": "bool\nHeapTupleSatisfiesSelf(HeapTuple htup, Snapshot snapshot, Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn false;\n\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\tif (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn false;\n\t\t\tif (!TransactionIdIsInProgress(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\t\treturn false;\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn true;\n\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\t/* not deleter */\n\t\t\t\treturn true;\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\tTransactionId xmax;\n\n\t\t\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\t\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\t\t\t/* updating subtransaction must have aborted */\n\t\t\t\tif (!TransactionIdIsCurrentTransactionId(xmax))\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t{\n\t\t\t\t/* deleting subtransaction must have aborted */\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t\telse if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\treturn false;\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/* it must have aborted or crashed */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* by here, the inserting transaction has committed */\n\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid or aborted */\n\t\treturn true;\n\n\tif (tuple->t_infomask & HEAP_XMAX_COMMITTED)\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\t\treturn false;\t\t\t/* updated by other */\n\t}\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax;\n\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\n\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\t\treturn false;\n\t\tif (TransactionIdIsInProgress(xmax))\n\t\t\treturn true;\n\t\tif (TransactionIdDidCommit(xmax))\n\t\t\treturn false;\n\t\t/* it must have aborted or crashed */\n\t\treturn true;\n\t}\n\n\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\treturn true;\n\n\tif (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\t/* it must have aborted or crashed */\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn true;\n\t}\n\n\t/* xmax transaction committed */\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t{\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn true;\n\t}\n\n\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\treturn false;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetHintBits",
          "args": [
            "tuple",
            "buffer",
            "HEAP_XMAX_COMMITTED",
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleSetHintBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "143-148",
          "snippet": "void\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/combocid.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/subtrans.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xmax"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xmax"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xmax"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xmax)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmax(tuple)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmax",
          "args": [
            "tuple"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xmax"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xmax)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xmax"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetUpdateXid",
          "args": [
            "tuple"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HEAP_XMAX_IS_LOCKED_ONLY",
          "args": [
            "tuple->t_infomask"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "HeapTupleHeaderGetRawXmin(tuple)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "tuple"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xvac"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xvac"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsInProgress",
          "args": [
            "xvac"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xvac"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXvac",
          "args": [
            "tuple"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminInvalid",
          "args": [
            "tuple"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderXminCommitted",
          "args": [
            "tuple"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "htup->t_tableOid != InvalidOid"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ItemPointerIsValid(&htup->t_self)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ItemPointerIsValid",
          "args": [
            "&htup->t_self"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nHeapTupleSatisfiesSelf(HeapTuple htup, Snapshot snapshot, Buffer buffer)\n{\n\tHeapTupleHeader tuple = htup->t_data;\n\n\tAssert(ItemPointerIsValid(&htup->t_self));\n\tAssert(htup->t_tableOid != InvalidOid);\n\n\tif (!HeapTupleHeaderXminCommitted(tuple))\n\t{\n\t\tif (HeapTupleHeaderXminInvalid(tuple))\n\t\t\treturn false;\n\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\tif (tuple->t_infomask & HEAP_MOVED_OFF)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t\treturn false;\n\t\t\tif (!TransactionIdIsInProgress(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t}\n\t\t}\n\t\t/* Used by pre-9.0 binary upgrades */\n\t\telse if (tuple->t_infomask & HEAP_MOVED_IN)\n\t\t{\n\t\t\tTransactionId xvac = HeapTupleHeaderGetXvac(tuple);\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(xvac))\n\t\t\t{\n\t\t\t\tif (TransactionIdIsInProgress(xvac))\n\t\t\t\t\treturn false;\n\t\t\t\tif (TransactionIdDidCommit(xvac))\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t{\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid */\n\t\t\t\treturn true;\n\n\t\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\t/* not deleter */\n\t\t\t\treturn true;\n\n\t\t\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t\t\t{\n\t\t\t\tTransactionId xmax;\n\n\t\t\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\t\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\t\t\t/* updating subtransaction must have aborted */\n\t\t\t\tif (!TransactionIdIsCurrentTransactionId(xmax))\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t\t\t{\n\t\t\t\t/* deleting subtransaction must have aborted */\n\t\t\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\t\t\tInvalidTransactionId);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t\telse if (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\treturn false;\n\t\telse if (TransactionIdDidCommit(HeapTupleHeaderGetRawXmin(tuple)))\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_COMMITTED,\n\t\t\t\t\t\tHeapTupleHeaderGetRawXmin(tuple));\n\t\telse\n\t\t{\n\t\t\t/* it must have aborted or crashed */\n\t\t\tSetHintBits(tuple, buffer, HEAP_XMIN_INVALID,\n\t\t\t\t\t\tInvalidTransactionId);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* by here, the inserting transaction has committed */\n\n\tif (tuple->t_infomask & HEAP_XMAX_INVALID)\t/* xid invalid or aborted */\n\t\treturn true;\n\n\tif (tuple->t_infomask & HEAP_XMAX_COMMITTED)\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\t\treturn false;\t\t\t/* updated by other */\n\t}\n\n\tif (tuple->t_infomask & HEAP_XMAX_IS_MULTI)\n\t{\n\t\tTransactionId xmax;\n\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\n\t\txmax = HeapTupleGetUpdateXid(tuple);\n\n\t\t/* not LOCKED_ONLY, so it has to have an xmax */\n\t\tAssert(TransactionIdIsValid(xmax));\n\n\t\tif (TransactionIdIsCurrentTransactionId(xmax))\n\t\t\treturn false;\n\t\tif (TransactionIdIsInProgress(xmax))\n\t\t\treturn true;\n\t\tif (TransactionIdDidCommit(xmax))\n\t\t\treturn false;\n\t\t/* it must have aborted or crashed */\n\t\treturn true;\n\t}\n\n\tif (TransactionIdIsCurrentTransactionId(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tif (TransactionIdIsInProgress(HeapTupleHeaderGetRawXmax(tuple)))\n\t\treturn true;\n\n\tif (!TransactionIdDidCommit(HeapTupleHeaderGetRawXmax(tuple)))\n\t{\n\t\t/* it must have aborted or crashed */\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn true;\n\t}\n\n\t/* xmax transaction committed */\n\n\tif (HEAP_XMAX_IS_LOCKED_ONLY(tuple->t_infomask))\n\t{\n\t\tSetHintBits(tuple, buffer, HEAP_XMAX_INVALID,\n\t\t\t\t\tInvalidTransactionId);\n\t\treturn true;\n\t}\n\n\tSetHintBits(tuple, buffer, HEAP_XMAX_COMMITTED,\n\t\t\t\tHeapTupleHeaderGetRawXmax(tuple));\n\treturn false;\n}"
  },
  {
    "function_name": "HeapTupleSetHintBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "143-148",
    "snippet": "void\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetHintBits",
          "args": [
            "tuple",
            "buffer",
            "infomask",
            "xid"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "HeapTupleSetHintBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
          "lines": "143-148",
          "snippet": "void\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nHeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\t\t\t uint16 infomask, TransactionId xid)\n{\n\tSetHintBits(tuple, buffer, infomask, xid);\n}"
  },
  {
    "function_name": "SetHintBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/tqual.c",
    "lines": "116-135",
    "snippet": "static inline void\nSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\tuint16 infomask, TransactionId xid)\n{\n\tif (TransactionIdIsValid(xid))\n\t{\n\t\t/* NB: xid must be known committed here! */\n\t\tXLogRecPtr\tcommitLSN = TransactionIdGetCommitLSN(xid);\n\n\t\tif (BufferIsPermanent(buffer) && XLogNeedsFlush(commitLSN) &&\n\t\t\tBufferGetLSNAtomic(buffer) < commitLSN)\n\t\t{\n\t\t\t/* not flushed and no LSN interlock, so don't set hint */\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttuple->t_infomask |= infomask;\n\tMarkBufferDirtyHint(buffer, true);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/combocid.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/procarray.h\"",
      "#include \"storage/bufmgr.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/subtrans.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MarkBufferDirtyHint",
          "args": [
            "buffer",
            "true"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufferGetLSNAtomic",
          "args": [
            "buffer"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XLogNeedsFlush",
          "args": [
            "commitLSN"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BufferIsPermanent",
          "args": [
            "buffer"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdGetCommitLSN",
          "args": [
            "xid"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xid"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/combocid.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/bufmgr.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/subtrans.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic inline void\nSetHintBits(HeapTupleHeader tuple, Buffer buffer,\n\t\t\tuint16 infomask, TransactionId xid)\n{\n\tif (TransactionIdIsValid(xid))\n\t{\n\t\t/* NB: xid must be known committed here! */\n\t\tXLogRecPtr\tcommitLSN = TransactionIdGetCommitLSN(xid);\n\n\t\tif (BufferIsPermanent(buffer) && XLogNeedsFlush(commitLSN) &&\n\t\t\tBufferGetLSNAtomic(buffer) < commitLSN)\n\t\t{\n\t\t\t/* not flushed and no LSN interlock, so don't set hint */\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttuple->t_infomask |= infomask;\n\tMarkBufferDirtyHint(buffer, true);\n}"
  }
]