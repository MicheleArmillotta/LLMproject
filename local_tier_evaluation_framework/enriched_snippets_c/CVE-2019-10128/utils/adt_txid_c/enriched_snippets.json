[
  {
    "function_name": "txid_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "741-792",
    "snippet": "Datum\ntxid_status(PG_FUNCTION_ARGS)\n{\n\tconst char *status;\n\tuint64\t\txid_with_epoch = PG_GETARG_INT64(0);\n\tTransactionId xid;\n\n\t/*\n\t * We must protect against concurrent truncation of clog entries to avoid\n\t * an I/O error on SLRU lookup.\n\t */\n\tLWLockAcquire(CLogTruncationLock, LW_SHARED);\n\tif (TransactionIdInRecentPast(xid_with_epoch, &xid))\n\t{\n\t\tAssert(TransactionIdIsValid(xid));\n\n\t\tif (TransactionIdIsCurrentTransactionId(xid))\n\t\t\tstatus = \"in progress\";\n\t\telse if (TransactionIdDidCommit(xid))\n\t\t\tstatus = \"committed\";\n\t\telse if (TransactionIdDidAbort(xid))\n\t\t\tstatus = \"aborted\";\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The xact is not marked as either committed or aborted in clog.\n\t\t\t *\n\t\t\t * It could be a transaction that ended without updating clog or\n\t\t\t * writing an abort record due to a crash. We can safely assume\n\t\t\t * it's aborted if it isn't committed and is older than our\n\t\t\t * snapshot xmin.\n\t\t\t *\n\t\t\t * Otherwise it must be in-progress (or have been at the time we\n\t\t\t * checked commit/abort status).\n\t\t\t */\n\t\t\tif (TransactionIdPrecedes(xid, GetActiveSnapshot()->xmin))\n\t\t\t\tstatus = \"aborted\";\n\t\t\telse\n\t\t\t\tstatus = \"in progress\";\n\t\t}\n\t}\n\telse\n\t{\n\t\tstatus = NULL;\n\t}\n\tLWLockRelease(CLogTruncationLock);\n\n\tif (status == NULL)\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_TEXT_P(cstring_to_text(status));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(status)"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "status"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "CLogTruncationLock"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "xid",
            "GetActiveSnapshot()->xmin"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetActiveSnapshot",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "GetActiveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "838-844",
          "snippet": "Snapshot\nGetActiveSnapshot(void)\n{\n\tAssert(ActiveSnapshot != NULL);\n\n\treturn ActiveSnapshot->as_snap;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\n\nSnapshot\nGetActiveSnapshot(void)\n{\n\tAssert(ActiveSnapshot != NULL);\n\n\treturn ActiveSnapshot->as_snap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdDidAbort",
          "args": [
            "xid"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdDidCommit",
          "args": [
            "xid"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsCurrentTransactionId",
          "args": [
            "xid"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsValid(xid)"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xid"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdInRecentPast",
          "args": [
            "xid_with_epoch",
            "&xid"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "TransactionIdInRecentPast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "110-159",
          "snippet": "static bool\nTransactionIdInRecentPast(uint64 xid_with_epoch, TransactionId *extracted_xid)\n{\n\tuint32\t\txid_epoch = (uint32) (xid_with_epoch >> 32);\n\tTransactionId xid = (TransactionId) xid_with_epoch;\n\tuint32\t\tnow_epoch;\n\tTransactionId now_epoch_next_xid;\n\n\tGetNextXidAndEpoch(&now_epoch_next_xid, &now_epoch);\n\n\tif (extracted_xid != NULL)\n\t\t*extracted_xid = xid;\n\n\tif (!TransactionIdIsValid(xid))\n\t\treturn false;\n\n\t/* For non-normal transaction IDs, we can ignore the epoch. */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn true;\n\n\t/* If the transaction ID is in the future, throw an error. */\n\tif (xid_epoch > now_epoch\n\t\t|| (xid_epoch == now_epoch && xid >= now_epoch_next_xid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"transaction ID %s is in the future\",\n\t\t\t\t\t\tpsprintf(UINT64_FORMAT, xid_with_epoch))));\n\n\t/*\n\t * ShmemVariableCache->oldestClogXid is protected by CLogTruncationLock,\n\t * but we don't acquire that lock here.  Instead, we require the caller to\n\t * acquire it, because the caller is presumably going to look up the\n\t * returned XID.  If we took and released the lock within this function, a\n\t * CLOG truncation could occur before the caller finished with the XID.\n\t */\n\tAssert(LWLockHeldByMe(CLogTruncationLock));\n\n\t/*\n\t * If the transaction ID has wrapped around, it's definitely too old to\n\t * determine the commit status.  Otherwise, we can compare it to\n\t * ShmemVariableCache->oldestClogXid to determine whether the relevant\n\t * CLOG entry is guaranteed to still exist.\n\t */\n\tif (xid_epoch + 1 < now_epoch\n\t\t|| (xid_epoch + 1 == now_epoch && xid < now_epoch_next_xid)\n\t\t|| TransactionIdPrecedes(xid, ShmemVariableCache->oldestClogXid))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic bool\nTransactionIdInRecentPast(uint64 xid_with_epoch, TransactionId *extracted_xid)\n{\n\tuint32\t\txid_epoch = (uint32) (xid_with_epoch >> 32);\n\tTransactionId xid = (TransactionId) xid_with_epoch;\n\tuint32\t\tnow_epoch;\n\tTransactionId now_epoch_next_xid;\n\n\tGetNextXidAndEpoch(&now_epoch_next_xid, &now_epoch);\n\n\tif (extracted_xid != NULL)\n\t\t*extracted_xid = xid;\n\n\tif (!TransactionIdIsValid(xid))\n\t\treturn false;\n\n\t/* For non-normal transaction IDs, we can ignore the epoch. */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn true;\n\n\t/* If the transaction ID is in the future, throw an error. */\n\tif (xid_epoch > now_epoch\n\t\t|| (xid_epoch == now_epoch && xid >= now_epoch_next_xid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"transaction ID %s is in the future\",\n\t\t\t\t\t\tpsprintf(UINT64_FORMAT, xid_with_epoch))));\n\n\t/*\n\t * ShmemVariableCache->oldestClogXid is protected by CLogTruncationLock,\n\t * but we don't acquire that lock here.  Instead, we require the caller to\n\t * acquire it, because the caller is presumably going to look up the\n\t * returned XID.  If we took and released the lock within this function, a\n\t * CLOG truncation could occur before the caller finished with the XID.\n\t */\n\tAssert(LWLockHeldByMe(CLogTruncationLock));\n\n\t/*\n\t * If the transaction ID has wrapped around, it's definitely too old to\n\t * determine the commit status.  Otherwise, we can compare it to\n\t * ShmemVariableCache->oldestClogXid to determine whether the relevant\n\t * CLOG entry is guaranteed to still exist.\n\t */\n\tif (xid_epoch + 1 < now_epoch\n\t\t|| (xid_epoch + 1 == now_epoch && xid < now_epoch_next_xid)\n\t\t|| TransactionIdPrecedes(xid, ShmemVariableCache->oldestClogXid))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "CLogTruncationLock",
            "LW_SHARED"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nDatum\ntxid_status(PG_FUNCTION_ARGS)\n{\n\tconst char *status;\n\tuint64\t\txid_with_epoch = PG_GETARG_INT64(0);\n\tTransactionId xid;\n\n\t/*\n\t * We must protect against concurrent truncation of clog entries to avoid\n\t * an I/O error on SLRU lookup.\n\t */\n\tLWLockAcquire(CLogTruncationLock, LW_SHARED);\n\tif (TransactionIdInRecentPast(xid_with_epoch, &xid))\n\t{\n\t\tAssert(TransactionIdIsValid(xid));\n\n\t\tif (TransactionIdIsCurrentTransactionId(xid))\n\t\t\tstatus = \"in progress\";\n\t\telse if (TransactionIdDidCommit(xid))\n\t\t\tstatus = \"committed\";\n\t\telse if (TransactionIdDidAbort(xid))\n\t\t\tstatus = \"aborted\";\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * The xact is not marked as either committed or aborted in clog.\n\t\t\t *\n\t\t\t * It could be a transaction that ended without updating clog or\n\t\t\t * writing an abort record due to a crash. We can safely assume\n\t\t\t * it's aborted if it isn't committed and is older than our\n\t\t\t * snapshot xmin.\n\t\t\t *\n\t\t\t * Otherwise it must be in-progress (or have been at the time we\n\t\t\t * checked commit/abort status).\n\t\t\t */\n\t\t\tif (TransactionIdPrecedes(xid, GetActiveSnapshot()->xmin))\n\t\t\t\tstatus = \"aborted\";\n\t\t\telse\n\t\t\t\tstatus = \"in progress\";\n\t\t}\n\t}\n\telse\n\t{\n\t\tstatus = NULL;\n\t}\n\tLWLockRelease(CLogTruncationLock);\n\n\tif (status == NULL)\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_TEXT_P(cstring_to_text(status));\n}"
  },
  {
    "function_name": "txid_snapshot_xip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "696-729",
    "snippet": "Datum\ntxid_snapshot_xip(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *fctx;\n\tTxidSnapshot *snap;\n\ttxid\t\tvalue;\n\n\t/* on first call initialize snap_state and get copy of snapshot */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTxidSnapshot *arg = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\n\t\tfctx = SRF_FIRSTCALL_INIT();\n\n\t\t/* make a copy of user snapshot */\n\t\tsnap = MemoryContextAlloc(fctx->multi_call_memory_ctx, VARSIZE(arg));\n\t\tmemcpy(snap, arg, VARSIZE(arg));\n\n\t\tfctx->user_fctx = snap;\n\t}\n\n\t/* return values one-by-one */\n\tfctx = SRF_PERCALL_SETUP();\n\tsnap = fctx->user_fctx;\n\tif (fctx->call_cntr < snap->nxip)\n\t{\n\t\tvalue = snap->xip[fctx->call_cntr];\n\t\tSRF_RETURN_NEXT(fctx, Int64GetDatum(value));\n\t}\n\telse\n\t{\n\t\tSRF_RETURN_DONE(fctx);\n\t}\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "fctx"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "fctx",
            "Int64GetDatum(value)"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "value"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "snap",
            "arg",
            "VARSIZE(arg)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fctx->multi_call_memory_ctx",
            "VARSIZE(arg)"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "arg"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARLENA_P",
          "args": [
            "0"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nDatum\ntxid_snapshot_xip(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *fctx;\n\tTxidSnapshot *snap;\n\ttxid\t\tvalue;\n\n\t/* on first call initialize snap_state and get copy of snapshot */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTxidSnapshot *arg = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\n\t\tfctx = SRF_FIRSTCALL_INIT();\n\n\t\t/* make a copy of user snapshot */\n\t\tsnap = MemoryContextAlloc(fctx->multi_call_memory_ctx, VARSIZE(arg));\n\t\tmemcpy(snap, arg, VARSIZE(arg));\n\n\t\tfctx->user_fctx = snap;\n\t}\n\n\t/* return values one-by-one */\n\tfctx = SRF_PERCALL_SETUP();\n\tsnap = fctx->user_fctx;\n\tif (fctx->call_cntr < snap->nxip)\n\t{\n\t\tvalue = snap->xip[fctx->call_cntr];\n\t\tSRF_RETURN_NEXT(fctx, Int64GetDatum(value));\n\t}\n\telse\n\t{\n\t\tSRF_RETURN_DONE(fctx);\n\t}\n}"
  },
  {
    "function_name": "txid_snapshot_xmax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "683-689",
    "snippet": "Datum\ntxid_snapshot_xmax(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\n\tPG_RETURN_INT64(snap->xmax);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "snap->xmax"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARLENA_P",
          "args": [
            "0"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nDatum\ntxid_snapshot_xmax(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\n\tPG_RETURN_INT64(snap->xmax);\n}"
  },
  {
    "function_name": "txid_snapshot_xmin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "670-676",
    "snippet": "Datum\ntxid_snapshot_xmin(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\n\tPG_RETURN_INT64(snap->xmin);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "snap->xmin"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARLENA_P",
          "args": [
            "0"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nDatum\ntxid_snapshot_xmin(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\n\tPG_RETURN_INT64(snap->xmin);\n}"
  },
  {
    "function_name": "txid_visible_in_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "656-663",
    "snippet": "Datum\ntxid_visible_in_snapshot(PG_FUNCTION_ARGS)\n{\n\ttxid\t\tvalue = PG_GETARG_INT64(0);\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(1);\n\n\tPG_RETURN_BOOL(is_visible_txid(value, snap));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "is_visible_txid(value, snap)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_visible_txid",
          "args": [
            "value",
            "snap"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "is_visible_txid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "237-265",
          "snippet": "static bool\nis_visible_txid(txid value, const TxidSnapshot *snap)\n{\n\tif (value < snap->xmin)\n\t\treturn true;\n\telse if (value >= snap->xmax)\n\t\treturn false;\n#ifdef USE_BSEARCH_IF_NXIP_GREATER\n\telse if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)\n\t{\n\t\tvoid\t   *res;\n\n\t\tres = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);\n\t\t/* if found, transaction is still in progress */\n\t\treturn (res) ? false : true;\n\t}\n#endif\n\telse\n\t{\n\t\tuint32\t\ti;\n\n\t\tfor (i = 0; i < snap->nxip; i++)\n\t\t{\n\t\t\tif (value == snap->xip[i])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define USE_BSEARCH_IF_NXIP_GREATER 30"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\n#define USE_BSEARCH_IF_NXIP_GREATER 30\n\nstatic bool\nis_visible_txid(txid value, const TxidSnapshot *snap)\n{\n\tif (value < snap->xmin)\n\t\treturn true;\n\telse if (value >= snap->xmax)\n\t\treturn false;\n#ifdef USE_BSEARCH_IF_NXIP_GREATER\n\telse if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)\n\t{\n\t\tvoid\t   *res;\n\n\t\tres = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);\n\t\t/* if found, transaction is still in progress */\n\t\treturn (res) ? false : true;\n\t}\n#endif\n\telse\n\t{\n\t\tuint32\t\ti;\n\n\t\tfor (i = 0; i < snap->nxip; i++)\n\t\t{\n\t\t\tif (value == snap->xip[i])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARLENA_P",
          "args": [
            "1"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nDatum\ntxid_visible_in_snapshot(PG_FUNCTION_ARGS)\n{\n\ttxid\t\tvalue = PG_GETARG_INT64(0);\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(1);\n\n\tPG_RETURN_BOOL(is_visible_txid(value, snap));\n}"
  },
  {
    "function_name": "txid_snapshot_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "635-649",
    "snippet": "Datum\ntxid_snapshot_send(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\tStringInfoData buf;\n\tuint32\t\ti;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, snap->nxip);\n\tpq_sendint64(&buf, snap->xmin);\n\tpq_sendint64(&buf, snap->xmax);\n\tfor (i = 0; i < snap->nxip; i++)\n\t\tpq_sendint64(&buf, snap->xip[i]);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint64",
          "args": [
            "&buf",
            "snap->xip[i]"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint64",
          "args": [
            "&buf",
            "snap->xmax"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint64",
          "args": [
            "&buf",
            "snap->xmin"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "snap->nxip"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARLENA_P",
          "args": [
            "0"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nDatum\ntxid_snapshot_send(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\tStringInfoData buf;\n\tuint32\t\ti;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, snap->nxip);\n\tpq_sendint64(&buf, snap->xmin);\n\tpq_sendint64(&buf, snap->xmax);\n\tfor (i = 0; i < snap->nxip; i++)\n\t\tpq_sendint64(&buf, snap->xip[i]);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "txid_snapshot_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "574-626",
    "snippet": "Datum\ntxid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\n\t/* load and validate nxip */\n\tnxip = pq_getmsgint(buf, 4);\n\tif (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)\n\t\tgoto bad_format;\n\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\n\t\tif (cur < last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\n\t\t/* skip duplicate xips */\n\t\tif (cur == last)\n\t\t{\n\t\t\ti--;\n\t\t\tnxip--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\tPG_RETURN_POINTER(snap);\n\nbad_format:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t errmsg(\"invalid external txid_snapshot data\")));\n\tPG_RETURN_POINTER(NULL);\t/* keep compiler quiet */\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TXID_SNAPSHOT_MAX_NXIP \\\n\t((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))",
      "#define MAX_TXID   ((uint64) PG_INT64_MAX)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "NULL"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t errmsg(\"invalid external txid_snapshot data\"))"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid external txid_snapshot data\""
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_BINARY_REPRESENTATION"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "snap"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "snap",
            "TXID_SNAPSHOT_SIZE(nxip)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXID_SNAPSHOT_SIZE",
          "args": [
            "nxip"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint64",
          "args": [
            "buf"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "TXID_SNAPSHOT_SIZE(nxip)"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXID_SNAPSHOT_SIZE",
          "args": [
            "nxip"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint64",
          "args": [
            "buf"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint64",
          "args": [
            "buf"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "4"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\n#define TXID_SNAPSHOT_MAX_NXIP \\\n\t((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))\n#define MAX_TXID   ((uint64) PG_INT64_MAX)\n\nDatum\ntxid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\n\t/* load and validate nxip */\n\tnxip = pq_getmsgint(buf, 4);\n\tif (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)\n\t\tgoto bad_format;\n\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\n\t\tif (cur < last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\n\t\t/* skip duplicate xips */\n\t\tif (cur == last)\n\t\t{\n\t\t\ti--;\n\t\t\tnxip--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\tPG_RETURN_POINTER(snap);\n\nbad_format:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t errmsg(\"invalid external txid_snapshot data\")));\n\tPG_RETURN_POINTER(NULL);\t/* keep compiler quiet */\n}"
  },
  {
    "function_name": "txid_snapshot_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "545-565",
    "snippet": "Datum\ntxid_snapshot_out(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\tStringInfoData str;\n\tuint32\t\ti;\n\n\tinitStringInfo(&str);\n\n\tappendStringInfo(&str, TXID_FMT \":\", snap->xmin);\n\tappendStringInfo(&str, TXID_FMT \":\", snap->xmax);\n\n\tfor (i = 0; i < snap->nxip; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, ',');\n\t\tappendStringInfo(&str, TXID_FMT, snap->xip[i]);\n\t}\n\n\tPG_RETURN_CSTRING(str.data);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TXID_FMT UINT64_FORMAT"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "str.data"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&str",
            "TXID_FMT",
            "snap->xip[i]"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&str",
            "','"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&str",
            "TXID_FMT \":\"",
            "snap->xmax"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&str",
            "TXID_FMT \":\"",
            "snap->xmin"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&str"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_VARLENA_P",
          "args": [
            "0"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\n#define TXID_FMT UINT64_FORMAT\n\nDatum\ntxid_snapshot_out(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\tStringInfoData str;\n\tuint32\t\ti;\n\n\tinitStringInfo(&str);\n\n\tappendStringInfo(&str, TXID_FMT \":\", snap->xmin);\n\tappendStringInfo(&str, TXID_FMT \":\", snap->xmax);\n\n\tfor (i = 0; i < snap->nxip; i++)\n\t{\n\t\tif (i > 0)\n\t\t\tappendStringInfoChar(&str, ',');\n\t\tappendStringInfo(&str, TXID_FMT, snap->xip[i]);\n\t}\n\n\tPG_RETURN_CSTRING(str.data);\n}"
  },
  {
    "function_name": "txid_snapshot_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "529-538",
    "snippet": "Datum\ntxid_snapshot_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tTxidSnapshot *snap;\n\n\tsnap = parse_snapshot(str);\n\n\tPG_RETURN_POINTER(snap);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "snap"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_snapshot",
          "args": [
            "str"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "parse_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "350-408",
          "snippet": "static TxidSnapshot *\nparse_snapshot(const char *str)\n{\n\ttxid\t\txmin;\n\ttxid\t\txmax;\n\ttxid\t\tlast_val = 0,\n\t\t\t\tval;\n\tconst char *str_start = str;\n\tconst char *endp;\n\tStringInfo\tbuf;\n\n\txmin = str2txid(str, &endp);\n\tif (*endp != ':')\n\t\tgoto bad_format;\n\tstr = endp + 1;\n\n\txmax = str2txid(str, &endp);\n\tif (*endp != ':')\n\t\tgoto bad_format;\n\tstr = endp + 1;\n\n\t/* it should look sane */\n\tif (xmin == 0 || xmax == 0 || xmin > xmax)\n\t\tgoto bad_format;\n\n\t/* allocate buffer */\n\tbuf = buf_init(xmin, xmax);\n\n\t/* loop over values */\n\twhile (*str != '\\0')\n\t{\n\t\t/* read next value */\n\t\tval = str2txid(str, &endp);\n\t\tstr = endp;\n\n\t\t/* require the input to be in order */\n\t\tif (val < xmin || val >= xmax || val < last_val)\n\t\t\tgoto bad_format;\n\n\t\t/* skip duplicates */\n\t\tif (val != last_val)\n\t\t\tbuf_add_txid(buf, val);\n\t\tlast_val = val;\n\n\t\tif (*str == ',')\n\t\t\tstr++;\n\t\telse if (*str != '\\0')\n\t\t\tgoto bad_format;\n\t}\n\n\treturn buf_finalize(buf);\n\nbad_format:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\"txid_snapshot\", str_start)));\n\treturn NULL;\t\t\t\t/* keep compiler quiet */\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic TxidSnapshot *\nparse_snapshot(const char *str)\n{\n\ttxid\t\txmin;\n\ttxid\t\txmax;\n\ttxid\t\tlast_val = 0,\n\t\t\t\tval;\n\tconst char *str_start = str;\n\tconst char *endp;\n\tStringInfo\tbuf;\n\n\txmin = str2txid(str, &endp);\n\tif (*endp != ':')\n\t\tgoto bad_format;\n\tstr = endp + 1;\n\n\txmax = str2txid(str, &endp);\n\tif (*endp != ':')\n\t\tgoto bad_format;\n\tstr = endp + 1;\n\n\t/* it should look sane */\n\tif (xmin == 0 || xmax == 0 || xmin > xmax)\n\t\tgoto bad_format;\n\n\t/* allocate buffer */\n\tbuf = buf_init(xmin, xmax);\n\n\t/* loop over values */\n\twhile (*str != '\\0')\n\t{\n\t\t/* read next value */\n\t\tval = str2txid(str, &endp);\n\t\tstr = endp;\n\n\t\t/* require the input to be in order */\n\t\tif (val < xmin || val >= xmax || val < last_val)\n\t\t\tgoto bad_format;\n\n\t\t/* skip duplicates */\n\t\tif (val != last_val)\n\t\t\tbuf_add_txid(buf, val);\n\t\tlast_val = val;\n\n\t\tif (*str == ',')\n\t\t\tstr++;\n\t\telse if (*str != '\\0')\n\t\t\tgoto bad_format;\n\t}\n\n\treturn buf_finalize(buf);\n\nbad_format:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\"txid_snapshot\", str_start)));\n\treturn NULL;\t\t\t\t/* keep compiler quiet */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nDatum\ntxid_snapshot_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tTxidSnapshot *snap;\n\n\tsnap = parse_snapshot(str);\n\n\tPG_RETURN_POINTER(snap);\n}"
  },
  {
    "function_name": "txid_current_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "476-522",
    "snippet": "Datum\ntxid_current_snapshot(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap;\n\tuint32\t\tnxip,\n\t\t\t\ti;\n\tTxidEpoch\tstate;\n\tSnapshot\tcur;\n\n\tcur = GetActiveSnapshot();\n\tif (cur == NULL)\n\t\telog(ERROR, \"no active snapshot set\");\n\n\tload_xid_epoch(&state);\n\n\t/*\n\t * Compile-time limits on the procarray (MAX_BACKENDS processes plus\n\t * MAX_BACKENDS prepared transactions) guarantee nxip won't be too large.\n\t */\n\tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,\n\t\t\t\t\t \"possible overflow in txid_current_snapshot()\");\n\n\t/* allocate */\n\tnxip = cur->xcnt;\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\n\t/* fill */\n\tsnap->xmin = convert_xid(cur->xmin, &state);\n\tsnap->xmax = convert_xid(cur->xmax, &state);\n\tsnap->nxip = nxip;\n\tfor (i = 0; i < nxip; i++)\n\t\tsnap->xip[i] = convert_xid(cur->xip[i], &state);\n\n\t/*\n\t * We want them guaranteed to be in ascending order.  This also removes\n\t * any duplicate xids.  Normally, an XID can only be assigned to one\n\t * backend, but when preparing a transaction for two-phase commit, there\n\t * is a transient state when both the original backend and the dummy\n\t * PGPROC entry reserved for the prepared transaction hold the same XID.\n\t */\n\tsort_snapshot(snap);\n\n\t/* set size after sorting, because it may have removed duplicate xips */\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(snap->nxip));\n\n\tPG_RETURN_POINTER(snap);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TXID_SNAPSHOT_MAX_NXIP \\\n\t((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "snap"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "snap",
            "TXID_SNAPSHOT_SIZE(snap->nxip)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXID_SNAPSHOT_SIZE",
          "args": [
            "snap->nxip"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort_snapshot",
          "args": [
            "snap"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "sort_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "208-232",
          "snippet": "static void\nsort_snapshot(TxidSnapshot *snap)\n{\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip,\n\t\t\t\tidx1,\n\t\t\t\tidx2;\n\n\tif (snap->nxip > 1)\n\t{\n\t\tqsort(snap->xip, snap->nxip, sizeof(txid), cmp_txid);\n\n\t\t/* remove duplicates */\n\t\tnxip = snap->nxip;\n\t\tidx1 = idx2 = 0;\n\t\twhile (idx1 < nxip)\n\t\t{\n\t\t\tif (snap->xip[idx1] != last)\n\t\t\t\tlast = snap->xip[idx2++] = snap->xip[idx1];\n\t\t\telse\n\t\t\t\tsnap->nxip--;\n\t\t\tidx1++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic void\nsort_snapshot(TxidSnapshot *snap)\n{\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip,\n\t\t\t\tidx1,\n\t\t\t\tidx2;\n\n\tif (snap->nxip > 1)\n\t{\n\t\tqsort(snap->xip, snap->nxip, sizeof(txid), cmp_txid);\n\n\t\t/* remove duplicates */\n\t\tnxip = snap->nxip;\n\t\tidx1 = idx2 = 0;\n\t\twhile (idx1 < nxip)\n\t\t{\n\t\t\tif (snap->xip[idx1] != last)\n\t\t\t\tlast = snap->xip[idx2++] = snap->xip[idx1];\n\t\t\telse\n\t\t\t\tsnap->nxip--;\n\t\t\tidx1++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_xid",
          "args": [
            "cur->xip[i]",
            "&state"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "convert_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "164-183",
          "snippet": "static txid\nconvert_xid(TransactionId xid, const TxidEpoch *state)\n{\n\tuint64\t\tepoch;\n\n\t/* return special xid's as-is */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn (txid) xid;\n\n\t/* xid can be on either side when near wrap-around */\n\tepoch = (uint64) state->epoch;\n\tif (xid > state->last_xid &&\n\t\tTransactionIdPrecedes(xid, state->last_xid))\n\t\tepoch--;\n\telse if (xid < state->last_xid &&\n\t\t\t TransactionIdFollows(xid, state->last_xid))\n\t\tepoch++;\n\n\treturn (epoch << 32) | xid;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic txid\nconvert_xid(TransactionId xid, const TxidEpoch *state)\n{\n\tuint64\t\tepoch;\n\n\t/* return special xid's as-is */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn (txid) xid;\n\n\t/* xid can be on either side when near wrap-around */\n\tepoch = (uint64) state->epoch;\n\tif (xid > state->last_xid &&\n\t\tTransactionIdPrecedes(xid, state->last_xid))\n\t\tepoch--;\n\telse if (xid < state->last_xid &&\n\t\t\t TransactionIdFollows(xid, state->last_xid))\n\t\tepoch++;\n\n\treturn (epoch << 32) | xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "TXID_SNAPSHOT_SIZE(nxip)"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TXID_SNAPSHOT_SIZE",
          "args": [
            "nxip"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StaticAssertStmt",
          "args": [
            "MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP",
            "\"possible overflow in txid_current_snapshot()\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_xid_epoch",
          "args": [
            "&state"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "load_xid_epoch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "91-95",
          "snippet": "static void\nload_xid_epoch(TxidEpoch *state)\n{\n\tGetNextXidAndEpoch(&state->last_xid, &state->epoch);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic void\nload_xid_epoch(TxidEpoch *state)\n{\n\tGetNextXidAndEpoch(&state->last_xid, &state->epoch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"no active snapshot set\""
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetActiveSnapshot",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "GetActiveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "838-844",
          "snippet": "Snapshot\nGetActiveSnapshot(void)\n{\n\tAssert(ActiveSnapshot != NULL);\n\n\treturn ActiveSnapshot->as_snap;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\n\nSnapshot\nGetActiveSnapshot(void)\n{\n\tAssert(ActiveSnapshot != NULL);\n\n\treturn ActiveSnapshot->as_snap;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\n#define TXID_SNAPSHOT_MAX_NXIP \\\n\t((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))\n\nDatum\ntxid_current_snapshot(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap;\n\tuint32\t\tnxip,\n\t\t\t\ti;\n\tTxidEpoch\tstate;\n\tSnapshot\tcur;\n\n\tcur = GetActiveSnapshot();\n\tif (cur == NULL)\n\t\telog(ERROR, \"no active snapshot set\");\n\n\tload_xid_epoch(&state);\n\n\t/*\n\t * Compile-time limits on the procarray (MAX_BACKENDS processes plus\n\t * MAX_BACKENDS prepared transactions) guarantee nxip won't be too large.\n\t */\n\tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,\n\t\t\t\t\t \"possible overflow in txid_current_snapshot()\");\n\n\t/* allocate */\n\tnxip = cur->xcnt;\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\n\t/* fill */\n\tsnap->xmin = convert_xid(cur->xmin, &state);\n\tsnap->xmax = convert_xid(cur->xmax, &state);\n\tsnap->nxip = nxip;\n\tfor (i = 0; i < nxip; i++)\n\t\tsnap->xip[i] = convert_xid(cur->xip[i], &state);\n\n\t/*\n\t * We want them guaranteed to be in ascending order.  This also removes\n\t * any duplicate xids.  Normally, an XID can only be assigned to one\n\t * backend, but when preparing a transaction for two-phase commit, there\n\t * is a transient state when both the original backend and the dummy\n\t * PGPROC entry reserved for the prepared transaction hold the same XID.\n\t */\n\tsort_snapshot(snap);\n\n\t/* set size after sorting, because it may have removed duplicate xips */\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(snap->nxip));\n\n\tPG_RETURN_POINTER(snap);\n}"
  },
  {
    "function_name": "txid_current_if_assigned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "452-467",
    "snippet": "Datum\ntxid_current_if_assigned(PG_FUNCTION_ARGS)\n{\n\ttxid\t\tval;\n\tTxidEpoch\tstate;\n\tTransactionId topxid = GetTopTransactionIdIfAny();\n\n\tif (topxid == InvalidTransactionId)\n\t\tPG_RETURN_NULL();\n\n\tload_xid_epoch(&state);\n\n\tval = convert_xid(topxid, &state);\n\n\tPG_RETURN_INT64(val);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "val"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_xid",
          "args": [
            "topxid",
            "&state"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "convert_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "164-183",
          "snippet": "static txid\nconvert_xid(TransactionId xid, const TxidEpoch *state)\n{\n\tuint64\t\tepoch;\n\n\t/* return special xid's as-is */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn (txid) xid;\n\n\t/* xid can be on either side when near wrap-around */\n\tepoch = (uint64) state->epoch;\n\tif (xid > state->last_xid &&\n\t\tTransactionIdPrecedes(xid, state->last_xid))\n\t\tepoch--;\n\telse if (xid < state->last_xid &&\n\t\t\t TransactionIdFollows(xid, state->last_xid))\n\t\tepoch++;\n\n\treturn (epoch << 32) | xid;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic txid\nconvert_xid(TransactionId xid, const TxidEpoch *state)\n{\n\tuint64\t\tepoch;\n\n\t/* return special xid's as-is */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn (txid) xid;\n\n\t/* xid can be on either side when near wrap-around */\n\tepoch = (uint64) state->epoch;\n\tif (xid > state->last_xid &&\n\t\tTransactionIdPrecedes(xid, state->last_xid))\n\t\tepoch--;\n\telse if (xid < state->last_xid &&\n\t\t\t TransactionIdFollows(xid, state->last_xid))\n\t\tepoch++;\n\n\treturn (epoch << 32) | xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_xid_epoch",
          "args": [
            "&state"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "load_xid_epoch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "91-95",
          "snippet": "static void\nload_xid_epoch(TxidEpoch *state)\n{\n\tGetNextXidAndEpoch(&state->last_xid, &state->epoch);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic void\nload_xid_epoch(TxidEpoch *state)\n{\n\tGetNextXidAndEpoch(&state->last_xid, &state->epoch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTopTransactionIdIfAny",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nDatum\ntxid_current_if_assigned(PG_FUNCTION_ARGS)\n{\n\ttxid\t\tval;\n\tTxidEpoch\tstate;\n\tTransactionId topxid = GetTopTransactionIdIfAny();\n\n\tif (topxid == InvalidTransactionId)\n\t\tPG_RETURN_NULL();\n\n\tload_xid_epoch(&state);\n\n\tval = convert_xid(topxid, &state);\n\n\tPG_RETURN_INT64(val);\n}"
  },
  {
    "function_name": "txid_current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "427-446",
    "snippet": "Datum\ntxid_current(PG_FUNCTION_ARGS)\n{\n\ttxid\t\tval;\n\tTxidEpoch\tstate;\n\n\t/*\n\t * Must prevent during recovery because if an xid is not assigned we try\n\t * to assign one, which would fail. Programs already rely on this function\n\t * to always return a valid current xid, so we should not change this to\n\t * return NULL or similar invalid xid.\n\t */\n\tPreventCommandDuringRecovery(\"txid_current()\");\n\n\tload_xid_epoch(&state);\n\n\tval = convert_xid(GetTopTransactionId(), &state);\n\n\tPG_RETURN_INT64(val);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT64",
          "args": [
            "val"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_xid",
          "args": [
            "GetTopTransactionId()",
            "&state"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "convert_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "164-183",
          "snippet": "static txid\nconvert_xid(TransactionId xid, const TxidEpoch *state)\n{\n\tuint64\t\tepoch;\n\n\t/* return special xid's as-is */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn (txid) xid;\n\n\t/* xid can be on either side when near wrap-around */\n\tepoch = (uint64) state->epoch;\n\tif (xid > state->last_xid &&\n\t\tTransactionIdPrecedes(xid, state->last_xid))\n\t\tepoch--;\n\telse if (xid < state->last_xid &&\n\t\t\t TransactionIdFollows(xid, state->last_xid))\n\t\tepoch++;\n\n\treturn (epoch << 32) | xid;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic txid\nconvert_xid(TransactionId xid, const TxidEpoch *state)\n{\n\tuint64\t\tepoch;\n\n\t/* return special xid's as-is */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn (txid) xid;\n\n\t/* xid can be on either side when near wrap-around */\n\tepoch = (uint64) state->epoch;\n\tif (xid > state->last_xid &&\n\t\tTransactionIdPrecedes(xid, state->last_xid))\n\t\tepoch--;\n\telse if (xid < state->last_xid &&\n\t\t\t TransactionIdFollows(xid, state->last_xid))\n\t\tepoch++;\n\n\treturn (epoch << 32) | xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTopTransactionId",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_xid_epoch",
          "args": [
            "&state"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "load_xid_epoch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "91-95",
          "snippet": "static void\nload_xid_epoch(TxidEpoch *state)\n{\n\tGetNextXidAndEpoch(&state->last_xid, &state->epoch);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic void\nload_xid_epoch(TxidEpoch *state)\n{\n\tGetNextXidAndEpoch(&state->last_xid, &state->epoch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PreventCommandDuringRecovery",
          "args": [
            "\"txid_current()\""
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nDatum\ntxid_current(PG_FUNCTION_ARGS)\n{\n\ttxid\t\tval;\n\tTxidEpoch\tstate;\n\n\t/*\n\t * Must prevent during recovery because if an xid is not assigned we try\n\t * to assign one, which would fail. Programs already rely on this function\n\t * to always return a valid current xid, so we should not change this to\n\t * return NULL or similar invalid xid.\n\t */\n\tPreventCommandDuringRecovery(\"txid_current()\");\n\n\tload_xid_epoch(&state);\n\n\tval = convert_xid(GetTopTransactionId(), &state);\n\n\tPG_RETURN_INT64(val);\n}"
  },
  {
    "function_name": "parse_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "350-408",
    "snippet": "static TxidSnapshot *\nparse_snapshot(const char *str)\n{\n\ttxid\t\txmin;\n\ttxid\t\txmax;\n\ttxid\t\tlast_val = 0,\n\t\t\t\tval;\n\tconst char *str_start = str;\n\tconst char *endp;\n\tStringInfo\tbuf;\n\n\txmin = str2txid(str, &endp);\n\tif (*endp != ':')\n\t\tgoto bad_format;\n\tstr = endp + 1;\n\n\txmax = str2txid(str, &endp);\n\tif (*endp != ':')\n\t\tgoto bad_format;\n\tstr = endp + 1;\n\n\t/* it should look sane */\n\tif (xmin == 0 || xmax == 0 || xmin > xmax)\n\t\tgoto bad_format;\n\n\t/* allocate buffer */\n\tbuf = buf_init(xmin, xmax);\n\n\t/* loop over values */\n\twhile (*str != '\\0')\n\t{\n\t\t/* read next value */\n\t\tval = str2txid(str, &endp);\n\t\tstr = endp;\n\n\t\t/* require the input to be in order */\n\t\tif (val < xmin || val >= xmax || val < last_val)\n\t\t\tgoto bad_format;\n\n\t\t/* skip duplicates */\n\t\tif (val != last_val)\n\t\t\tbuf_add_txid(buf, val);\n\t\tlast_val = val;\n\n\t\tif (*str == ',')\n\t\t\tstr++;\n\t\telse if (*str != '\\0')\n\t\t\tgoto bad_format;\n\t}\n\n\treturn buf_finalize(buf);\n\nbad_format:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\"txid_snapshot\", str_start)));\n\treturn NULL;\t\t\t\t/* keep compiler quiet */\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\"txid_snapshot\", str_start))"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "\"txid_snapshot\"",
            "str_start"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "buf_finalize",
          "args": [
            "buf"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "buf_finalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "297-309",
          "snippet": "static TxidSnapshot *\nbuf_finalize(StringInfo buf)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) buf->data;\n\n\tSET_VARSIZE(snap, buf->len);\n\n\t/* buf is not needed anymore */\n\tbuf->data = NULL;\n\tpfree(buf);\n\n\treturn snap;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic TxidSnapshot *\nbuf_finalize(StringInfo buf)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) buf->data;\n\n\tSET_VARSIZE(snap, buf->len);\n\n\t/* buf is not needed anymore */\n\tbuf->data = NULL;\n\tpfree(buf);\n\n\treturn snap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buf_add_txid",
          "args": [
            "buf",
            "val"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "buf_add_txid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "286-295",
          "snippet": "static void\nbuf_add_txid(StringInfo buf, txid xid)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) buf->data;\n\n\t/* do this before possible realloc */\n\tsnap->nxip++;\n\n\tappendBinaryStringInfo(buf, (char *) &xid, sizeof(xid));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic void\nbuf_add_txid(StringInfo buf, txid xid)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) buf->data;\n\n\t/* do this before possible realloc */\n\tsnap->nxip++;\n\n\tappendBinaryStringInfo(buf, (char *) &xid, sizeof(xid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "str2txid",
          "args": [
            "str",
            "&endp"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "str2txid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "316-345",
          "snippet": "static txid\nstr2txid(const char *s, const char **endp)\n{\n\ttxid\t\tval = 0;\n\ttxid\t\tcutoff = MAX_TXID / 10;\n\ttxid\t\tcutlim = MAX_TXID % 10;\n\n\tfor (; *s; s++)\n\t{\n\t\tunsigned\td;\n\n\t\tif (*s < '0' || *s > '9')\n\t\t\tbreak;\n\t\td = *s - '0';\n\n\t\t/*\n\t\t * check for overflow\n\t\t */\n\t\tif (val > cutoff || (val == cutoff && d > cutlim))\n\t\t{\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tval = val * 10 + d;\n\t}\n\tif (endp)\n\t\t*endp = s;\n\treturn val;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_TXID   ((uint64) PG_INT64_MAX)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\n#define MAX_TXID   ((uint64) PG_INT64_MAX)\n\nstatic txid\nstr2txid(const char *s, const char **endp)\n{\n\ttxid\t\tval = 0;\n\ttxid\t\tcutoff = MAX_TXID / 10;\n\ttxid\t\tcutlim = MAX_TXID % 10;\n\n\tfor (; *s; s++)\n\t{\n\t\tunsigned\td;\n\n\t\tif (*s < '0' || *s > '9')\n\t\t\tbreak;\n\t\td = *s - '0';\n\n\t\t/*\n\t\t * check for overflow\n\t\t */\n\t\tif (val > cutoff || (val == cutoff && d > cutlim))\n\t\t{\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tval = val * 10 + d;\n\t}\n\tif (endp)\n\t\t*endp = s;\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buf_init",
          "args": [
            "xmin",
            "xmax"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
          "lines": "271-284",
          "snippet": "static StringInfo\nbuf_init(txid xmin, txid xmax)\n{\n\tTxidSnapshot snap;\n\tStringInfo\tbuf;\n\n\tsnap.xmin = xmin;\n\tsnap.xmax = xmax;\n\tsnap.nxip = 0;\n\n\tbuf = makeStringInfo();\n\tappendBinaryStringInfo(buf, (char *) &snap, TXID_SNAPSHOT_SIZE(0));\n\treturn buf;\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/clog.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic StringInfo\nbuf_init(txid xmin, txid xmax)\n{\n\tTxidSnapshot snap;\n\tStringInfo\tbuf;\n\n\tsnap.xmin = xmin;\n\tsnap.xmax = xmax;\n\tsnap.nxip = 0;\n\n\tbuf = makeStringInfo();\n\tappendBinaryStringInfo(buf, (char *) &snap, TXID_SNAPSHOT_SIZE(0));\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic TxidSnapshot *\nparse_snapshot(const char *str)\n{\n\ttxid\t\txmin;\n\ttxid\t\txmax;\n\ttxid\t\tlast_val = 0,\n\t\t\t\tval;\n\tconst char *str_start = str;\n\tconst char *endp;\n\tStringInfo\tbuf;\n\n\txmin = str2txid(str, &endp);\n\tif (*endp != ':')\n\t\tgoto bad_format;\n\tstr = endp + 1;\n\n\txmax = str2txid(str, &endp);\n\tif (*endp != ':')\n\t\tgoto bad_format;\n\tstr = endp + 1;\n\n\t/* it should look sane */\n\tif (xmin == 0 || xmax == 0 || xmin > xmax)\n\t\tgoto bad_format;\n\n\t/* allocate buffer */\n\tbuf = buf_init(xmin, xmax);\n\n\t/* loop over values */\n\twhile (*str != '\\0')\n\t{\n\t\t/* read next value */\n\t\tval = str2txid(str, &endp);\n\t\tstr = endp;\n\n\t\t/* require the input to be in order */\n\t\tif (val < xmin || val >= xmax || val < last_val)\n\t\t\tgoto bad_format;\n\n\t\t/* skip duplicates */\n\t\tif (val != last_val)\n\t\t\tbuf_add_txid(buf, val);\n\t\tlast_val = val;\n\n\t\tif (*str == ',')\n\t\t\tstr++;\n\t\telse if (*str != '\\0')\n\t\t\tgoto bad_format;\n\t}\n\n\treturn buf_finalize(buf);\n\nbad_format:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\"txid_snapshot\", str_start)));\n\treturn NULL;\t\t\t\t/* keep compiler quiet */\n}"
  },
  {
    "function_name": "str2txid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "316-345",
    "snippet": "static txid\nstr2txid(const char *s, const char **endp)\n{\n\ttxid\t\tval = 0;\n\ttxid\t\tcutoff = MAX_TXID / 10;\n\ttxid\t\tcutlim = MAX_TXID % 10;\n\n\tfor (; *s; s++)\n\t{\n\t\tunsigned\td;\n\n\t\tif (*s < '0' || *s > '9')\n\t\t\tbreak;\n\t\td = *s - '0';\n\n\t\t/*\n\t\t * check for overflow\n\t\t */\n\t\tif (val > cutoff || (val == cutoff && d > cutlim))\n\t\t{\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tval = val * 10 + d;\n\t}\n\tif (endp)\n\t\t*endp = s;\n\treturn val;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_TXID   ((uint64) PG_INT64_MAX)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\n#define MAX_TXID   ((uint64) PG_INT64_MAX)\n\nstatic txid\nstr2txid(const char *s, const char **endp)\n{\n\ttxid\t\tval = 0;\n\ttxid\t\tcutoff = MAX_TXID / 10;\n\ttxid\t\tcutlim = MAX_TXID % 10;\n\n\tfor (; *s; s++)\n\t{\n\t\tunsigned\td;\n\n\t\tif (*s < '0' || *s > '9')\n\t\t\tbreak;\n\t\td = *s - '0';\n\n\t\t/*\n\t\t * check for overflow\n\t\t */\n\t\tif (val > cutoff || (val == cutoff && d > cutlim))\n\t\t{\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tval = val * 10 + d;\n\t}\n\tif (endp)\n\t\t*endp = s;\n\treturn val;\n}"
  },
  {
    "function_name": "buf_finalize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "297-309",
    "snippet": "static TxidSnapshot *\nbuf_finalize(StringInfo buf)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) buf->data;\n\n\tSET_VARSIZE(snap, buf->len);\n\n\t/* buf is not needed anymore */\n\tbuf->data = NULL;\n\tpfree(buf);\n\n\treturn snap;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "buf"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "snap",
            "buf->len"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic TxidSnapshot *\nbuf_finalize(StringInfo buf)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) buf->data;\n\n\tSET_VARSIZE(snap, buf->len);\n\n\t/* buf is not needed anymore */\n\tbuf->data = NULL;\n\tpfree(buf);\n\n\treturn snap;\n}"
  },
  {
    "function_name": "buf_add_txid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "286-295",
    "snippet": "static void\nbuf_add_txid(StringInfo buf, txid xid)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) buf->data;\n\n\t/* do this before possible realloc */\n\tsnap->nxip++;\n\n\tappendBinaryStringInfo(buf, (char *) &xid, sizeof(xid));\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "buf",
            "(char *) &xid",
            "sizeof(xid)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic void\nbuf_add_txid(StringInfo buf, txid xid)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) buf->data;\n\n\t/* do this before possible realloc */\n\tsnap->nxip++;\n\n\tappendBinaryStringInfo(buf, (char *) &xid, sizeof(xid));\n}"
  },
  {
    "function_name": "buf_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "271-284",
    "snippet": "static StringInfo\nbuf_init(txid xmin, txid xmax)\n{\n\tTxidSnapshot snap;\n\tStringInfo\tbuf;\n\n\tsnap.xmin = xmin;\n\tsnap.xmax = xmax;\n\tsnap.nxip = 0;\n\n\tbuf = makeStringInfo();\n\tappendBinaryStringInfo(buf, (char *) &snap, TXID_SNAPSHOT_SIZE(0));\n\treturn buf;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "buf",
            "(char *) &snap",
            "TXID_SNAPSHOT_SIZE(0)"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TXID_SNAPSHOT_SIZE",
          "args": [
            "0"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeStringInfo",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic StringInfo\nbuf_init(txid xmin, txid xmax)\n{\n\tTxidSnapshot snap;\n\tStringInfo\tbuf;\n\n\tsnap.xmin = xmin;\n\tsnap.xmax = xmax;\n\tsnap.nxip = 0;\n\n\tbuf = makeStringInfo();\n\tappendBinaryStringInfo(buf, (char *) &snap, TXID_SNAPSHOT_SIZE(0));\n\treturn buf;\n}"
  },
  {
    "function_name": "is_visible_txid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "237-265",
    "snippet": "static bool\nis_visible_txid(txid value, const TxidSnapshot *snap)\n{\n\tif (value < snap->xmin)\n\t\treturn true;\n\telse if (value >= snap->xmax)\n\t\treturn false;\n#ifdef USE_BSEARCH_IF_NXIP_GREATER\n\telse if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)\n\t{\n\t\tvoid\t   *res;\n\n\t\tres = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);\n\t\t/* if found, transaction is still in progress */\n\t\treturn (res) ? false : true;\n\t}\n#endif\n\telse\n\t{\n\t\tuint32\t\ti;\n\n\t\tfor (i = 0; i < snap->nxip; i++)\n\t\t{\n\t\t\tif (value == snap->xip[i])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define USE_BSEARCH_IF_NXIP_GREATER 30"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&value",
            "snap->xip",
            "snap->nxip",
            "sizeof(txid)",
            "cmp_txid"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "rbound_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "617-637",
          "snippet": "static int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\n#define USE_BSEARCH_IF_NXIP_GREATER 30\n\nstatic bool\nis_visible_txid(txid value, const TxidSnapshot *snap)\n{\n\tif (value < snap->xmin)\n\t\treturn true;\n\telse if (value >= snap->xmax)\n\t\treturn false;\n#ifdef USE_BSEARCH_IF_NXIP_GREATER\n\telse if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)\n\t{\n\t\tvoid\t   *res;\n\n\t\tres = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);\n\t\t/* if found, transaction is still in progress */\n\t\treturn (res) ? false : true;\n\t}\n#endif\n\telse\n\t{\n\t\tuint32\t\ti;\n\n\t\tfor (i = 0; i < snap->nxip; i++)\n\t\t{\n\t\t\tif (value == snap->xip[i])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "function_name": "sort_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "208-232",
    "snippet": "static void\nsort_snapshot(TxidSnapshot *snap)\n{\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip,\n\t\t\t\tidx1,\n\t\t\t\tidx2;\n\n\tif (snap->nxip > 1)\n\t{\n\t\tqsort(snap->xip, snap->nxip, sizeof(txid), cmp_txid);\n\n\t\t/* remove duplicates */\n\t\tnxip = snap->nxip;\n\t\tidx1 = idx2 = 0;\n\t\twhile (idx1 < nxip)\n\t\t{\n\t\t\tif (snap->xip[idx1] != last)\n\t\t\t\tlast = snap->xip[idx2++] = snap->xip[idx1];\n\t\t\telse\n\t\t\t\tsnap->nxip--;\n\t\t\tidx1++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "snap->xip",
            "snap->nxip",
            "sizeof(txid)",
            "cmp_txid"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic void\nsort_snapshot(TxidSnapshot *snap)\n{\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip,\n\t\t\t\tidx1,\n\t\t\t\tidx2;\n\n\tif (snap->nxip > 1)\n\t{\n\t\tqsort(snap->xip, snap->nxip, sizeof(txid), cmp_txid);\n\n\t\t/* remove duplicates */\n\t\tnxip = snap->nxip;\n\t\tidx1 = idx2 = 0;\n\t\twhile (idx1 < nxip)\n\t\t{\n\t\t\tif (snap->xip[idx1] != last)\n\t\t\t\tlast = snap->xip[idx2++] = snap->xip[idx1];\n\t\t\telse\n\t\t\t\tsnap->nxip--;\n\t\t\tidx1++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cmp_txid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "188-199",
    "snippet": "static int\ncmp_txid(const void *aa, const void *bb)\n{\n\ttxid\t\ta = *(const txid *) aa;\n\ttxid\t\tb = *(const txid *) bb;\n\n\tif (a < b)\n\t\treturn -1;\n\tif (a > b)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic int\ncmp_txid(const void *aa, const void *bb)\n{\n\ttxid\t\ta = *(const txid *) aa;\n\ttxid\t\tb = *(const txid *) bb;\n\n\tif (a < b)\n\t\treturn -1;\n\tif (a > b)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "convert_xid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "164-183",
    "snippet": "static txid\nconvert_xid(TransactionId xid, const TxidEpoch *state)\n{\n\tuint64\t\tepoch;\n\n\t/* return special xid's as-is */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn (txid) xid;\n\n\t/* xid can be on either side when near wrap-around */\n\tepoch = (uint64) state->epoch;\n\tif (xid > state->last_xid &&\n\t\tTransactionIdPrecedes(xid, state->last_xid))\n\t\tepoch--;\n\telse if (xid < state->last_xid &&\n\t\t\t TransactionIdFollows(xid, state->last_xid))\n\t\tepoch++;\n\n\treturn (epoch << 32) | xid;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransactionIdFollows",
          "args": [
            "xid",
            "state->last_xid"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "xid",
            "state->last_xid"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsNormal",
          "args": [
            "xid"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic txid\nconvert_xid(TransactionId xid, const TxidEpoch *state)\n{\n\tuint64\t\tepoch;\n\n\t/* return special xid's as-is */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn (txid) xid;\n\n\t/* xid can be on either side when near wrap-around */\n\tepoch = (uint64) state->epoch;\n\tif (xid > state->last_xid &&\n\t\tTransactionIdPrecedes(xid, state->last_xid))\n\t\tepoch--;\n\telse if (xid < state->last_xid &&\n\t\t\t TransactionIdFollows(xid, state->last_xid))\n\t\tepoch++;\n\n\treturn (epoch << 32) | xid;\n}"
  },
  {
    "function_name": "TransactionIdInRecentPast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "110-159",
    "snippet": "static bool\nTransactionIdInRecentPast(uint64 xid_with_epoch, TransactionId *extracted_xid)\n{\n\tuint32\t\txid_epoch = (uint32) (xid_with_epoch >> 32);\n\tTransactionId xid = (TransactionId) xid_with_epoch;\n\tuint32\t\tnow_epoch;\n\tTransactionId now_epoch_next_xid;\n\n\tGetNextXidAndEpoch(&now_epoch_next_xid, &now_epoch);\n\n\tif (extracted_xid != NULL)\n\t\t*extracted_xid = xid;\n\n\tif (!TransactionIdIsValid(xid))\n\t\treturn false;\n\n\t/* For non-normal transaction IDs, we can ignore the epoch. */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn true;\n\n\t/* If the transaction ID is in the future, throw an error. */\n\tif (xid_epoch > now_epoch\n\t\t|| (xid_epoch == now_epoch && xid >= now_epoch_next_xid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"transaction ID %s is in the future\",\n\t\t\t\t\t\tpsprintf(UINT64_FORMAT, xid_with_epoch))));\n\n\t/*\n\t * ShmemVariableCache->oldestClogXid is protected by CLogTruncationLock,\n\t * but we don't acquire that lock here.  Instead, we require the caller to\n\t * acquire it, because the caller is presumably going to look up the\n\t * returned XID.  If we took and released the lock within this function, a\n\t * CLOG truncation could occur before the caller finished with the XID.\n\t */\n\tAssert(LWLockHeldByMe(CLogTruncationLock));\n\n\t/*\n\t * If the transaction ID has wrapped around, it's definitely too old to\n\t * determine the commit status.  Otherwise, we can compare it to\n\t * ShmemVariableCache->oldestClogXid to determine whether the relevant\n\t * CLOG entry is guaranteed to still exist.\n\t */\n\tif (xid_epoch + 1 < now_epoch\n\t\t|| (xid_epoch + 1 == now_epoch && xid < now_epoch_next_xid)\n\t\t|| TransactionIdPrecedes(xid, ShmemVariableCache->oldestClogXid))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransactionIdPrecedes",
          "args": [
            "xid",
            "ShmemVariableCache->oldestClogXid"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "LWLockHeldByMe(CLogTruncationLock)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LWLockHeldByMe",
          "args": [
            "CLogTruncationLock"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"transaction ID %s is in the future\",\n\t\t\t\t\t\tpsprintf(UINT64_FORMAT, xid_with_epoch)))"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"transaction ID %s is in the future\"",
            "psprintf(UINT64_FORMAT, xid_with_epoch)"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "UINT64_FORMAT",
            "xid_with_epoch"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdIsNormal",
          "args": [
            "xid"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "xid"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNextXidAndEpoch",
          "args": [
            "&now_epoch_next_xid",
            "&now_epoch"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "xid_with_epoch >> 32"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic bool\nTransactionIdInRecentPast(uint64 xid_with_epoch, TransactionId *extracted_xid)\n{\n\tuint32\t\txid_epoch = (uint32) (xid_with_epoch >> 32);\n\tTransactionId xid = (TransactionId) xid_with_epoch;\n\tuint32\t\tnow_epoch;\n\tTransactionId now_epoch_next_xid;\n\n\tGetNextXidAndEpoch(&now_epoch_next_xid, &now_epoch);\n\n\tif (extracted_xid != NULL)\n\t\t*extracted_xid = xid;\n\n\tif (!TransactionIdIsValid(xid))\n\t\treturn false;\n\n\t/* For non-normal transaction IDs, we can ignore the epoch. */\n\tif (!TransactionIdIsNormal(xid))\n\t\treturn true;\n\n\t/* If the transaction ID is in the future, throw an error. */\n\tif (xid_epoch > now_epoch\n\t\t|| (xid_epoch == now_epoch && xid >= now_epoch_next_xid))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"transaction ID %s is in the future\",\n\t\t\t\t\t\tpsprintf(UINT64_FORMAT, xid_with_epoch))));\n\n\t/*\n\t * ShmemVariableCache->oldestClogXid is protected by CLogTruncationLock,\n\t * but we don't acquire that lock here.  Instead, we require the caller to\n\t * acquire it, because the caller is presumably going to look up the\n\t * returned XID.  If we took and released the lock within this function, a\n\t * CLOG truncation could occur before the caller finished with the XID.\n\t */\n\tAssert(LWLockHeldByMe(CLogTruncationLock));\n\n\t/*\n\t * If the transaction ID has wrapped around, it's definitely too old to\n\t * determine the commit status.  Otherwise, we can compare it to\n\t * ShmemVariableCache->oldestClogXid to determine whether the relevant\n\t * CLOG entry is guaranteed to still exist.\n\t */\n\tif (xid_epoch + 1 < now_epoch\n\t\t|| (xid_epoch + 1 == now_epoch && xid < now_epoch_next_xid)\n\t\t|| TransactionIdPrecedes(xid, ShmemVariableCache->oldestClogXid))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "load_xid_epoch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/txid.c",
    "lines": "91-95",
    "snippet": "static void\nload_xid_epoch(TxidEpoch *state)\n{\n\tGetNextXidAndEpoch(&state->last_xid, &state->epoch);\n}",
    "includes": [
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"storage/lwlock.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include \"access/clog.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetNextXidAndEpoch",
          "args": [
            "&state->last_xid",
            "&state->epoch"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"postmaster/postmaster.h\"\n#include \"libpq/pqformat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include \"access/clog.h\"\n#include \"postgres.h\"\n\nstatic void\nload_xid_epoch(TxidEpoch *state)\n{\n\tGetNextXidAndEpoch(&state->last_xid, &state->epoch);\n}"
  }
]