[
  {
    "function_name": "brincostestimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "8037-8236",
    "snippet": "void\nbrincostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t\t Cost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t\t Selectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t\t double *indexPages)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tdouble\t\tnumPages = index->pages;\n\tRelOptInfo *baserel = index->rel;\n\tRangeTblEntry *rte = planner_rt_fetch(baserel->relid, root);\n\tList\t   *qinfos;\n\tCost\t\tspc_seq_page_cost;\n\tCost\t\tspc_random_page_cost;\n\tdouble\t\tqual_arg_cost;\n\tdouble\t\tqualSelectivity;\n\tBrinStatsData statsData;\n\tdouble\t\tindexRanges;\n\tdouble\t\tminimalRanges;\n\tdouble\t\testimatedRanges;\n\tdouble\t\tselec;\n\tRelation\tindexRel;\n\tListCell   *l;\n\tVariableStatData vardata;\n\n\tAssert(rte->rtekind == RTE_RELATION);\n\n\t/* fetch estimated page cost for the tablespace containing the index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  &spc_seq_page_cost);\n\n\t/*\n\t * Obtain some data from the index itself.\n\t */\n\tindexRel = index_open(index->indexoid, AccessShareLock);\n\tbrinGetStats(indexRel, &statsData);\n\tindex_close(indexRel, AccessShareLock);\n\n\t/*\n\t * Compute index correlation\n\t *\n\t * Because we can use all index quals equally when scanning, we can use\n\t * the largest correlation (in absolute value) among columns used by the\n\t * query.  Start at zero, the worst possible case.  If we cannot find any\n\t * correlation statistics, we will keep it as 0.\n\t */\n\t*indexCorrelation = 0;\n\n\tqinfos = deconstruct_indexquals(path);\n\tforeach(l, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(l);\n\t\tAttrNumber\tattnum = index->indexkeys[qinfo->indexcol];\n\n\t\t/* attempt to lookup stats in relation for this index column */\n\t\tif (attnum != 0)\n\t\t{\n\t\t\t/* Simple variable -- look to stats for the underlying table */\n\t\t\tif (get_relation_stats_hook &&\n\t\t\t\t(*get_relation_stats_hook) (root, rte, attnum, &vardata))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The hook took control of acquiring a stats tuple.  If it\n\t\t\t\t * did supply a tuple, it'd better have supplied a freefunc.\n\t\t\t\t */\n\t\t\t\tif (HeapTupleIsValid(vardata.statsTuple) && !vardata.freefunc)\n\t\t\t\t\telog(ERROR,\n\t\t\t\t\t\t \"no function provided to release variable stats with\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvardata.statsTuple =\n\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\tObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\tInt16GetDatum(attnum),\n\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\tvardata.freefunc = ReleaseSysCache;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Looks like we've found an expression column in the index. Let's\n\t\t\t * see if there's any stats for it.\n\t\t\t */\n\n\t\t\t/* get the attnum from the 0-based index. */\n\t\t\tattnum = qinfo->indexcol + 1;\n\n\t\t\tif (get_index_stats_hook &&\n\t\t\t\t(*get_index_stats_hook) (root, index->indexoid, attnum, &vardata))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The hook took control of acquiring a stats tuple.  If it\n\t\t\t\t * did supply a tuple, it'd better have supplied a freefunc.\n\t\t\t\t */\n\t\t\t\tif (HeapTupleIsValid(vardata.statsTuple) &&\n\t\t\t\t\t!vardata.freefunc)\n\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvardata.statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\t\t Int16GetDatum(attnum),\n\t\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(false));\n\t\t\t\tvardata.freefunc = ReleaseSysCache;\n\t\t\t}\n\t\t}\n\n\t\tif (HeapTupleIsValid(vardata.statsTuple))\n\t\t{\n\t\t\tAttStatsSlot sslot;\n\n\t\t\tif (get_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t\t STATISTIC_KIND_CORRELATION, InvalidOid,\n\t\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t\t{\n\t\t\t\tdouble\t\tvarCorrelation = 0.0;\n\n\t\t\t\tif (sslot.nnumbers > 0)\n\t\t\t\t\tvarCorrelation = Abs(sslot.numbers[0]);\n\n\t\t\t\tif (varCorrelation > *indexCorrelation)\n\t\t\t\t\t*indexCorrelation = varCorrelation;\n\n\t\t\t\tfree_attstatsslot(&sslot);\n\t\t\t}\n\t\t}\n\n\t\tReleaseVariableStats(vardata);\n\t}\n\n\tqualSelectivity = clauselist_selectivity(root, indexQuals,\n\t\t\t\t\t\t\t\t\t\t\t baserel->relid,\n\t\t\t\t\t\t\t\t\t\t\t JOIN_INNER, NULL);\n\n\t/* work out the actual number of ranges in the index */\n\tindexRanges = Max(ceil((double) baserel->pages / statsData.pagesPerRange),\n\t\t\t\t\t  1.0);\n\n\t/*\n\t * Now calculate the minimum possible ranges we could match with if all of\n\t * the rows were in the perfect order in the table's heap.\n\t */\n\tminimalRanges = ceil(indexRanges * qualSelectivity);\n\n\t/*\n\t * Now estimate the number of ranges that we'll touch by using the\n\t * indexCorrelation from the stats. Careful not to divide by zero (note\n\t * we're using the absolute value of the correlation).\n\t */\n\tif (*indexCorrelation < 1.0e-10)\n\t\testimatedRanges = indexRanges;\n\telse\n\t\testimatedRanges = Min(minimalRanges / *indexCorrelation, indexRanges);\n\n\t/* we expect to visit this portion of the table */\n\tselec = estimatedRanges / indexRanges;\n\n\tCLAMP_PROBABILITY(selec);\n\n\t*indexSelectivity = selec;\n\n\t/*\n\t * Compute the index qual costs, much as in genericcostestimate, to add to\n\t * the index costs.\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\n\t/*\n\t * Compute the startup cost as the cost to read the whole revmap\n\t * sequentially, including the cost to execute the index quals.\n\t */\n\t*indexStartupCost =\n\t\tspc_seq_page_cost * statsData.revmapNumPages * loop_count;\n\t*indexStartupCost += qual_arg_cost;\n\n\t/*\n\t * To read a BRIN index there might be a bit of back and forth over\n\t * regular pages, as revmap might point to them out of sequential order;\n\t * calculate the total cost as reading the whole index in random order.\n\t */\n\t*indexTotalCost = *indexStartupCost +\n\t\tspc_random_page_cost * (numPages - statsData.revmapNumPages) * loop_count;\n\n\t/*\n\t * Charge a small amount per range tuple which we expect to match to. This\n\t * is meant to reflect the costs of manipulating the bitmap. The BRIN scan\n\t * will set a bit for each page in the range when we find a matching\n\t * range, so we must multiply the charge by the number of pages in the\n\t * range.\n\t */\n\t*indexTotalCost += 0.1 * cpu_operator_cost * estimatedRanges *\n\t\tstatsData.pagesPerRange;\n\n\t*indexPages = index->pages;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "get_relation_stats_hook_type get_relation_stats_hook = NULL;",
      "get_index_stats_hook_type get_index_stats_hook = NULL;",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
      "static List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "orderby_operands_eval_cost",
          "args": [
            "root",
            "path"
          ],
          "line": 8207
        },
        "resolved": true,
        "details": {
          "function_name": "orderby_operands_eval_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6685-6712",
          "snippet": "static Cost\norderby_operands_eval_cost(PlannerInfo *root, IndexPath *path)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, path->indexorderbys)\n\t{\n\t\tExpr\t   *clause = (Expr *) lfirst(lc);\n\t\tNode\t   *other_operand;\n\t\tQualCost\tindex_qual_cost;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tother_operand = get_rightop(clause);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexorderby type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t\tother_operand = NULL;\t/* keep compiler quiet */\n\t\t}\n\n\t\tcost_qual_eval_node(&index_qual_cost, other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Cost\norderby_operands_eval_cost(PlannerInfo *root, IndexPath *path)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, path->indexorderbys)\n\t{\n\t\tExpr\t   *clause = (Expr *) lfirst(lc);\n\t\tNode\t   *other_operand;\n\t\tQualCost\tindex_qual_cost;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tother_operand = get_rightop(clause);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexorderby type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t\tother_operand = NULL;\t/* keep compiler quiet */\n\t\t}\n\n\t\tcost_qual_eval_node(&index_qual_cost, other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}"
        }
      },
      {
        "call_info": {
          "callee": "other_operands_eval_cost",
          "args": [
            "root",
            "qinfos"
          ],
          "line": 8206
        },
        "resolved": true,
        "details": {
          "function_name": "other_operands_eval_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6660-6675",
          "snippet": "static Cost\nother_operands_eval_cost(PlannerInfo *root, List *qinfos)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(lc);\n\t\tQualCost\tindex_qual_cost;\n\n\t\tcost_qual_eval_node(&index_qual_cost, qinfo->other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Cost\nother_operands_eval_cost(PlannerInfo *root, List *qinfos)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(lc);\n\t\tQualCost\tindex_qual_cost;\n\n\t\tcost_qual_eval_node(&index_qual_cost, qinfo->other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 8198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "minimalRanges / *indexCorrelation",
            "indexRanges"
          ],
          "line": 8193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "indexRanges * qualSelectivity"
          ],
          "line": 8183
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "ceil((double) baserel->pages / statsData.pagesPerRange)",
            "1.0"
          ],
          "line": 8176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clauselist_selectivity",
          "args": [
            "root",
            "indexQuals",
            "baserel->relid",
            "JOIN_INNER",
            "NULL"
          ],
          "line": 8171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 8168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 8164
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Abs",
          "args": [
            "sslot.numbers[0]"
          ],
          "line": 8159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot",
            "vardata.statsTuple",
            "STATISTIC_KIND_CORRELATION",
            "InvalidOid",
            "ATTSTATSSLOT_NUMBERS"
          ],
          "line": 8152
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 8148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache3",
          "args": [
            "STATRELATTINH",
            "ObjectIdGetDatum(index->indexoid)",
            "Int16GetDatum(attnum)",
            "BoolGetDatum(false)"
          ],
          "line": 8140
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1133-1142",
          "snippet": "HeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "false"
          ],
          "line": 8143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "attnum"
          ],
          "line": 8142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "index->indexoid"
          ],
          "line": 8141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"no function provided to release variable stats with\""
          ],
          "line": 8136
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 8134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "root",
            "index->indexoid",
            "attnum",
            "&vardata"
          ],
          "line": 8128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "false"
          ],
          "line": 8113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "attnum"
          ],
          "line": 8112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "rte->relid"
          ],
          "line": 8111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 8103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "root",
            "rte",
            "attnum",
            "&vardata"
          ],
          "line": 8097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 8089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "qinfos"
          ],
          "line": 8087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_indexquals",
          "args": [
            "path"
          ],
          "line": 8086
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_indexquals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6565-6653",
          "snippet": "List *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_close",
          "args": [
            "indexRel",
            "AccessShareLock"
          ],
          "line": 8074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brinGetStats",
          "args": [
            "indexRel",
            "&statsData"
          ],
          "line": 8073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_open",
          "args": [
            "index->indexoid",
            "AccessShareLock"
          ],
          "line": 8072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tablespace_page_costs",
          "args": [
            "index->reltablespace",
            "&spc_random_page_cost",
            "&spc_seq_page_cost"
          ],
          "line": 8065
        },
        "resolved": true,
        "details": {
          "function_name": "get_tablespace_page_costs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
          "lines": "181-205",
          "snippet": "void\nget_tablespace_page_costs(Oid spcid,\n\t\t\t\t\t\t  double *spc_random_page_cost,\n\t\t\t\t\t\t  double *spc_seq_page_cost)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tAssert(spc != NULL);\n\n\tif (spc_random_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->random_page_cost < 0)\n\t\t\t*spc_random_page_cost = random_page_cost;\n\t\telse\n\t\t\t*spc_random_page_cost = spc->opts->random_page_cost;\n\t}\n\n\tif (spc_seq_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->seq_page_cost < 0)\n\t\t\t*spc_seq_page_cost = seq_page_cost;\n\t\telse\n\t\t\t*spc_seq_page_cost = spc->opts->seq_page_cost;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"storage/bufmgr.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"access/reloptions.h\"\n#include \"postgres.h\"\n\nvoid\nget_tablespace_page_costs(Oid spcid,\n\t\t\t\t\t\t  double *spc_random_page_cost,\n\t\t\t\t\t\t  double *spc_seq_page_cost)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tAssert(spc != NULL);\n\n\tif (spc_random_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->random_page_cost < 0)\n\t\t\t*spc_random_page_cost = random_page_cost;\n\t\telse\n\t\t\t*spc_random_page_cost = spc->opts->random_page_cost;\n\t}\n\n\tif (spc_seq_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->seq_page_cost < 0)\n\t\t\t*spc_seq_page_cost = seq_page_cost;\n\t\telse\n\t\t\t*spc_seq_page_cost = spc->opts->seq_page_cost;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rte->rtekind == RTE_RELATION"
          ],
          "line": 8062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "planner_rt_fetch",
          "args": [
            "baserel->relid",
            "root"
          ],
          "line": 8047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_relation_stats_hook_type get_relation_stats_hook = NULL;\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);\n\nvoid\nbrincostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t\t Cost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t\t Selectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t\t double *indexPages)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tdouble\t\tnumPages = index->pages;\n\tRelOptInfo *baserel = index->rel;\n\tRangeTblEntry *rte = planner_rt_fetch(baserel->relid, root);\n\tList\t   *qinfos;\n\tCost\t\tspc_seq_page_cost;\n\tCost\t\tspc_random_page_cost;\n\tdouble\t\tqual_arg_cost;\n\tdouble\t\tqualSelectivity;\n\tBrinStatsData statsData;\n\tdouble\t\tindexRanges;\n\tdouble\t\tminimalRanges;\n\tdouble\t\testimatedRanges;\n\tdouble\t\tselec;\n\tRelation\tindexRel;\n\tListCell   *l;\n\tVariableStatData vardata;\n\n\tAssert(rte->rtekind == RTE_RELATION);\n\n\t/* fetch estimated page cost for the tablespace containing the index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  &spc_seq_page_cost);\n\n\t/*\n\t * Obtain some data from the index itself.\n\t */\n\tindexRel = index_open(index->indexoid, AccessShareLock);\n\tbrinGetStats(indexRel, &statsData);\n\tindex_close(indexRel, AccessShareLock);\n\n\t/*\n\t * Compute index correlation\n\t *\n\t * Because we can use all index quals equally when scanning, we can use\n\t * the largest correlation (in absolute value) among columns used by the\n\t * query.  Start at zero, the worst possible case.  If we cannot find any\n\t * correlation statistics, we will keep it as 0.\n\t */\n\t*indexCorrelation = 0;\n\n\tqinfos = deconstruct_indexquals(path);\n\tforeach(l, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(l);\n\t\tAttrNumber\tattnum = index->indexkeys[qinfo->indexcol];\n\n\t\t/* attempt to lookup stats in relation for this index column */\n\t\tif (attnum != 0)\n\t\t{\n\t\t\t/* Simple variable -- look to stats for the underlying table */\n\t\t\tif (get_relation_stats_hook &&\n\t\t\t\t(*get_relation_stats_hook) (root, rte, attnum, &vardata))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The hook took control of acquiring a stats tuple.  If it\n\t\t\t\t * did supply a tuple, it'd better have supplied a freefunc.\n\t\t\t\t */\n\t\t\t\tif (HeapTupleIsValid(vardata.statsTuple) && !vardata.freefunc)\n\t\t\t\t\telog(ERROR,\n\t\t\t\t\t\t \"no function provided to release variable stats with\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvardata.statsTuple =\n\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\tObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\tInt16GetDatum(attnum),\n\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\tvardata.freefunc = ReleaseSysCache;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Looks like we've found an expression column in the index. Let's\n\t\t\t * see if there's any stats for it.\n\t\t\t */\n\n\t\t\t/* get the attnum from the 0-based index. */\n\t\t\tattnum = qinfo->indexcol + 1;\n\n\t\t\tif (get_index_stats_hook &&\n\t\t\t\t(*get_index_stats_hook) (root, index->indexoid, attnum, &vardata))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The hook took control of acquiring a stats tuple.  If it\n\t\t\t\t * did supply a tuple, it'd better have supplied a freefunc.\n\t\t\t\t */\n\t\t\t\tif (HeapTupleIsValid(vardata.statsTuple) &&\n\t\t\t\t\t!vardata.freefunc)\n\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvardata.statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\t\t Int16GetDatum(attnum),\n\t\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(false));\n\t\t\t\tvardata.freefunc = ReleaseSysCache;\n\t\t\t}\n\t\t}\n\n\t\tif (HeapTupleIsValid(vardata.statsTuple))\n\t\t{\n\t\t\tAttStatsSlot sslot;\n\n\t\t\tif (get_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t\t STATISTIC_KIND_CORRELATION, InvalidOid,\n\t\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t\t{\n\t\t\t\tdouble\t\tvarCorrelation = 0.0;\n\n\t\t\t\tif (sslot.nnumbers > 0)\n\t\t\t\t\tvarCorrelation = Abs(sslot.numbers[0]);\n\n\t\t\t\tif (varCorrelation > *indexCorrelation)\n\t\t\t\t\t*indexCorrelation = varCorrelation;\n\n\t\t\t\tfree_attstatsslot(&sslot);\n\t\t\t}\n\t\t}\n\n\t\tReleaseVariableStats(vardata);\n\t}\n\n\tqualSelectivity = clauselist_selectivity(root, indexQuals,\n\t\t\t\t\t\t\t\t\t\t\t baserel->relid,\n\t\t\t\t\t\t\t\t\t\t\t JOIN_INNER, NULL);\n\n\t/* work out the actual number of ranges in the index */\n\tindexRanges = Max(ceil((double) baserel->pages / statsData.pagesPerRange),\n\t\t\t\t\t  1.0);\n\n\t/*\n\t * Now calculate the minimum possible ranges we could match with if all of\n\t * the rows were in the perfect order in the table's heap.\n\t */\n\tminimalRanges = ceil(indexRanges * qualSelectivity);\n\n\t/*\n\t * Now estimate the number of ranges that we'll touch by using the\n\t * indexCorrelation from the stats. Careful not to divide by zero (note\n\t * we're using the absolute value of the correlation).\n\t */\n\tif (*indexCorrelation < 1.0e-10)\n\t\testimatedRanges = indexRanges;\n\telse\n\t\testimatedRanges = Min(minimalRanges / *indexCorrelation, indexRanges);\n\n\t/* we expect to visit this portion of the table */\n\tselec = estimatedRanges / indexRanges;\n\n\tCLAMP_PROBABILITY(selec);\n\n\t*indexSelectivity = selec;\n\n\t/*\n\t * Compute the index qual costs, much as in genericcostestimate, to add to\n\t * the index costs.\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\n\t/*\n\t * Compute the startup cost as the cost to read the whole revmap\n\t * sequentially, including the cost to execute the index quals.\n\t */\n\t*indexStartupCost =\n\t\tspc_seq_page_cost * statsData.revmapNumPages * loop_count;\n\t*indexStartupCost += qual_arg_cost;\n\n\t/*\n\t * To read a BRIN index there might be a bit of back and forth over\n\t * regular pages, as revmap might point to them out of sequential order;\n\t * calculate the total cost as reading the whole index in random order.\n\t */\n\t*indexTotalCost = *indexStartupCost +\n\t\tspc_random_page_cost * (numPages - statsData.revmapNumPages) * loop_count;\n\n\t/*\n\t * Charge a small amount per range tuple which we expect to match to. This\n\t * is meant to reflect the costs of manipulating the bitmap. The BRIN scan\n\t * will set a bit for each page in the range when we find a matching\n\t * range, so we must multiply the charge by the number of pages in the\n\t * range.\n\t */\n\t*indexTotalCost += 0.1 * cpu_operator_cost * estimatedRanges *\n\t\tstatsData.pagesPerRange;\n\n\t*indexPages = index->pages;\n}"
  },
  {
    "function_name": "gincostestimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "7712-8032",
    "snippet": "void\ngincostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t\tCost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t\tSelectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t\tdouble *indexPages)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tList\t   *qinfos;\n\tListCell   *l;\n\tList\t   *selectivityQuals;\n\tdouble\t\tnumPages = index->pages,\n\t\t\t\tnumTuples = index->tuples;\n\tdouble\t\tnumEntryPages,\n\t\t\t\tnumDataPages,\n\t\t\t\tnumPendingPages,\n\t\t\t\tnumEntries;\n\tGinQualCounts counts;\n\tbool\t\tmatchPossible;\n\tdouble\t\tpartialScale;\n\tdouble\t\tentryPagesFetched,\n\t\t\t\tdataPagesFetched,\n\t\t\t\tdataPagesFetchedBySel;\n\tdouble\t\tqual_op_cost,\n\t\t\t\tqual_arg_cost,\n\t\t\t\tspc_random_page_cost,\n\t\t\t\touter_scans;\n\tRelation\tindexRel;\n\tGinStatsData ginStats;\n\n\t/* Do preliminary analysis of indexquals */\n\tqinfos = deconstruct_indexquals(path);\n\n\t/*\n\t * Obtain statistical information from the meta page, if possible.  Else\n\t * set ginStats to zeroes, and we'll cope below.\n\t */\n\tif (!index->hypothetical)\n\t{\n\t\tindexRel = index_open(index->indexoid, AccessShareLock);\n\t\tginGetStats(indexRel, &ginStats);\n\t\tindex_close(indexRel, AccessShareLock);\n\t}\n\telse\n\t{\n\t\tmemset(&ginStats, 0, sizeof(ginStats));\n\t}\n\n\t/*\n\t * Assuming we got valid (nonzero) stats at all, nPendingPages can be\n\t * trusted, but the other fields are data as of the last VACUUM.  We can\n\t * scale them up to account for growth since then, but that method only\n\t * goes so far; in the worst case, the stats might be for a completely\n\t * empty index, and scaling them will produce pretty bogus numbers.\n\t * Somewhat arbitrarily, set the cutoff for doing scaling at 4X growth; if\n\t * it's grown more than that, fall back to estimating things only from the\n\t * assumed-accurate index size.  But we'll trust nPendingPages in any case\n\t * so long as it's not clearly insane, ie, more than the index size.\n\t */\n\tif (ginStats.nPendingPages < numPages)\n\t\tnumPendingPages = ginStats.nPendingPages;\n\telse\n\t\tnumPendingPages = 0;\n\n\tif (numPages > 0 && ginStats.nTotalPages <= numPages &&\n\t\tginStats.nTotalPages > numPages / 4 &&\n\t\tginStats.nEntryPages > 0 && ginStats.nEntries > 0)\n\t{\n\t\t/*\n\t\t * OK, the stats seem close enough to sane to be trusted.  But we\n\t\t * still need to scale them by the ratio numPages / nTotalPages to\n\t\t * account for growth since the last VACUUM.\n\t\t */\n\t\tdouble\t\tscale = numPages / ginStats.nTotalPages;\n\n\t\tnumEntryPages = ceil(ginStats.nEntryPages * scale);\n\t\tnumDataPages = ceil(ginStats.nDataPages * scale);\n\t\tnumEntries = ceil(ginStats.nEntries * scale);\n\t\t/* ensure we didn't round up too much */\n\t\tnumEntryPages = Min(numEntryPages, numPages - numPendingPages);\n\t\tnumDataPages = Min(numDataPages,\n\t\t\t\t\t\t   numPages - numPendingPages - numEntryPages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We might get here because it's a hypothetical index, or an index\n\t\t * created pre-9.1 and never vacuumed since upgrading (in which case\n\t\t * its stats would read as zeroes), or just because it's grown too\n\t\t * much since the last VACUUM for us to put our faith in scaling.\n\t\t *\n\t\t * Invent some plausible internal statistics based on the index page\n\t\t * count (and clamp that to at least 10 pages, just in case).  We\n\t\t * estimate that 90% of the index is entry pages, and the rest is data\n\t\t * pages.  Estimate 100 entries per entry page; this is rather bogus\n\t\t * since it'll depend on the size of the keys, but it's more robust\n\t\t * than trying to predict the number of entries per heap tuple.\n\t\t */\n\t\tnumPages = Max(numPages, 10);\n\t\tnumEntryPages = floor((numPages - numPendingPages) * 0.90);\n\t\tnumDataPages = numPages - numPendingPages - numEntryPages;\n\t\tnumEntries = floor(numEntryPages * 100);\n\t}\n\n\t/* In an empty index, numEntries could be zero.  Avoid divide-by-zero */\n\tif (numEntries < 1)\n\t\tnumEntries = 1;\n\n\t/*\n\t * Include predicate in selectivityQuals (should match\n\t * genericcostestimate)\n\t */\n\tif (index->indpred != NIL)\n\t{\n\t\tList\t   *predExtraQuals = NIL;\n\n\t\tforeach(l, index->indpred)\n\t\t{\n\t\t\tNode\t   *predQual = (Node *) lfirst(l);\n\t\t\tList\t   *oneQual = list_make1(predQual);\n\n\t\t\tif (!predicate_implied_by(oneQual, indexQuals, false))\n\t\t\t\tpredExtraQuals = list_concat(predExtraQuals, oneQual);\n\t\t}\n\t\t/* list_concat avoids modifying the passed-in indexQuals list */\n\t\tselectivityQuals = list_concat(predExtraQuals, indexQuals);\n\t}\n\telse\n\t\tselectivityQuals = indexQuals;\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\t*indexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t   index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t   JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\t*indexCorrelation = 0.0;\n\n\t/*\n\t * Examine quals to estimate number of search entries & partial matches\n\t */\n\tmemset(&counts, 0, sizeof(counts));\n\tcounts.arrayScans = 1;\n\tmatchPossible = true;\n\n\tforeach(l, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(l);\n\t\tExpr\t   *clause = qinfo->rinfo->clause;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tmatchPossible = gincost_opexpr(root,\n\t\t\t\t\t\t\t\t\t\t   index,\n\t\t\t\t\t\t\t\t\t\t   qinfo,\n\t\t\t\t\t\t\t\t\t\t   &counts);\n\t\t\tif (!matchPossible)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tmatchPossible = gincost_scalararrayopexpr(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  index,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  qinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  numEntries,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &counts);\n\t\t\tif (!matchPossible)\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* shouldn't be anything else for a GIN index */\n\t\t\telog(ERROR, \"unsupported GIN indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\t}\n\n\t/* Fall out if there were any provably-unsatisfiable quals */\n\tif (!matchPossible)\n\t{\n\t\t*indexStartupCost = 0;\n\t\t*indexTotalCost = 0;\n\t\t*indexSelectivity = 0;\n\t\treturn;\n\t}\n\n\tif (counts.haveFullScan || indexQuals == NIL)\n\t{\n\t\t/*\n\t\t * Full index scan will be required.  We treat this as if every key in\n\t\t * the index had been listed in the query; is that reasonable?\n\t\t */\n\t\tcounts.partialEntries = 0;\n\t\tcounts.exactEntries = numEntries;\n\t\tcounts.searchEntries = numEntries;\n\t}\n\n\t/* Will we have more than one iteration of a nestloop scan? */\n\touter_scans = loop_count;\n\n\t/*\n\t * Compute cost to begin scan, first of all, pay attention to pending\n\t * list.\n\t */\n\tentryPagesFetched = numPendingPages;\n\n\t/*\n\t * Estimate number of entry pages read.  We need to do\n\t * counts.searchEntries searches.  Use a power function as it should be,\n\t * but tuples on leaf pages usually is much greater. Here we include all\n\t * searches in entry tree, including search of first entry in partial\n\t * match algorithm\n\t */\n\tentryPagesFetched += ceil(counts.searchEntries * rint(pow(numEntryPages, 0.15)));\n\n\t/*\n\t * Add an estimate of entry pages read by partial match algorithm. It's a\n\t * scan over leaf pages in entry tree.  We haven't any useful stats here,\n\t * so estimate it as proportion.  Because counts.partialEntries is really\n\t * pretty bogus (see code above), it's possible that it is more than\n\t * numEntries; clamp the proportion to ensure sanity.\n\t */\n\tpartialScale = counts.partialEntries / numEntries;\n\tpartialScale = Min(partialScale, 1.0);\n\n\tentryPagesFetched += ceil(numEntryPages * partialScale);\n\n\t/*\n\t * Partial match algorithm reads all data pages before doing actual scan,\n\t * so it's a startup cost.  Again, we haven't any useful stats here, so\n\t * estimate it as proportion.\n\t */\n\tdataPagesFetched = ceil(numDataPages * partialScale);\n\n\t/*\n\t * Calculate cache effects if more than one scan due to nestloops or array\n\t * quals.  The result is pro-rated per nestloop scan, but the array qual\n\t * factor shouldn't be pro-rated (compare genericcostestimate).\n\t */\n\tif (outer_scans > 1 || counts.arrayScans > 1)\n\t{\n\t\tentryPagesFetched *= outer_scans * counts.arrayScans;\n\t\tentryPagesFetched = index_pages_fetched(entryPagesFetched,\n\t\t\t\t\t\t\t\t\t\t\t\t(BlockNumber) numEntryPages,\n\t\t\t\t\t\t\t\t\t\t\t\tnumEntryPages, root);\n\t\tentryPagesFetched /= outer_scans;\n\t\tdataPagesFetched *= outer_scans * counts.arrayScans;\n\t\tdataPagesFetched = index_pages_fetched(dataPagesFetched,\n\t\t\t\t\t\t\t\t\t\t\t   (BlockNumber) numDataPages,\n\t\t\t\t\t\t\t\t\t\t\t   numDataPages, root);\n\t\tdataPagesFetched /= outer_scans;\n\t}\n\n\t/*\n\t * Here we use random page cost because logically-close pages could be far\n\t * apart on disk.\n\t */\n\t*indexStartupCost = (entryPagesFetched + dataPagesFetched) * spc_random_page_cost;\n\n\t/*\n\t * Now compute the number of data pages fetched during the scan.\n\t *\n\t * We assume every entry to have the same number of items, and that there\n\t * is no overlap between them. (XXX: tsvector and array opclasses collect\n\t * statistics on the frequency of individual keys; it would be nice to use\n\t * those here.)\n\t */\n\tdataPagesFetched = ceil(numDataPages * counts.exactEntries / numEntries);\n\n\t/*\n\t * If there is a lot of overlap among the entries, in particular if one of\n\t * the entries is very frequent, the above calculation can grossly\n\t * under-estimate.  As a simple cross-check, calculate a lower bound based\n\t * on the overall selectivity of the quals.  At a minimum, we must read\n\t * one item pointer for each matching entry.\n\t *\n\t * The width of each item pointer varies, based on the level of\n\t * compression.  We don't have statistics on that, but an average of\n\t * around 3 bytes per item is fairly typical.\n\t */\n\tdataPagesFetchedBySel = ceil(*indexSelectivity *\n\t\t\t\t\t\t\t\t (numTuples / (BLCKSZ / 3)));\n\tif (dataPagesFetchedBySel > dataPagesFetched)\n\t\tdataPagesFetched = dataPagesFetchedBySel;\n\n\t/* Account for cache effects, the same as above */\n\tif (outer_scans > 1 || counts.arrayScans > 1)\n\t{\n\t\tdataPagesFetched *= outer_scans * counts.arrayScans;\n\t\tdataPagesFetched = index_pages_fetched(dataPagesFetched,\n\t\t\t\t\t\t\t\t\t\t\t   (BlockNumber) numDataPages,\n\t\t\t\t\t\t\t\t\t\t\t   numDataPages, root);\n\t\tdataPagesFetched /= outer_scans;\n\t}\n\n\t/* And apply random_page_cost as the cost per page */\n\t*indexTotalCost = *indexStartupCost +\n\t\tdataPagesFetched * spc_random_page_cost;\n\n\t/*\n\t * Add on index qual eval costs, much as in genericcostestimate\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\t*indexStartupCost += qual_arg_cost;\n\t*indexTotalCost += qual_arg_cost;\n\t*indexTotalCost += (numTuples * *indexSelectivity) * (cpu_index_tuple_cost + qual_op_cost);\n\t*indexPages = dataPagesFetched;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "indexOrderBys"
          ],
          "line": 8026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "indexQuals"
          ],
          "line": 8026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orderby_operands_eval_cost",
          "args": [
            "root",
            "path"
          ],
          "line": 8024
        },
        "resolved": true,
        "details": {
          "function_name": "orderby_operands_eval_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6685-6712",
          "snippet": "static Cost\norderby_operands_eval_cost(PlannerInfo *root, IndexPath *path)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, path->indexorderbys)\n\t{\n\t\tExpr\t   *clause = (Expr *) lfirst(lc);\n\t\tNode\t   *other_operand;\n\t\tQualCost\tindex_qual_cost;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tother_operand = get_rightop(clause);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexorderby type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t\tother_operand = NULL;\t/* keep compiler quiet */\n\t\t}\n\n\t\tcost_qual_eval_node(&index_qual_cost, other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Cost\norderby_operands_eval_cost(PlannerInfo *root, IndexPath *path)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, path->indexorderbys)\n\t{\n\t\tExpr\t   *clause = (Expr *) lfirst(lc);\n\t\tNode\t   *other_operand;\n\t\tQualCost\tindex_qual_cost;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tother_operand = get_rightop(clause);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexorderby type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t\tother_operand = NULL;\t/* keep compiler quiet */\n\t\t}\n\n\t\tcost_qual_eval_node(&index_qual_cost, other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}"
        }
      },
      {
        "call_info": {
          "callee": "other_operands_eval_cost",
          "args": [
            "root",
            "qinfos"
          ],
          "line": 8023
        },
        "resolved": true,
        "details": {
          "function_name": "other_operands_eval_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6660-6675",
          "snippet": "static Cost\nother_operands_eval_cost(PlannerInfo *root, List *qinfos)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(lc);\n\t\tQualCost\tindex_qual_cost;\n\n\t\tcost_qual_eval_node(&index_qual_cost, qinfo->other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Cost\nother_operands_eval_cost(PlannerInfo *root, List *qinfos)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(lc);\n\t\tQualCost\tindex_qual_cost;\n\n\t\tcost_qual_eval_node(&index_qual_cost, qinfo->other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_pages_fetched",
          "args": [
            "dataPagesFetched",
            "(BlockNumber) numDataPages",
            "numDataPages",
            "root"
          ],
          "line": 8010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "*indexSelectivity *\n\t\t\t\t\t\t\t\t (numTuples / (BLCKSZ / 3))"
          ],
          "line": 8001
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_pages_fetched",
          "args": [
            "dataPagesFetched",
            "(BlockNumber) numDataPages",
            "numDataPages",
            "root"
          ],
          "line": 7968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_pages_fetched",
          "args": [
            "entryPagesFetched",
            "(BlockNumber) numEntryPages",
            "numEntryPages",
            "root"
          ],
          "line": 7963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "partialScale",
            "1.0"
          ],
          "line": 7944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "pow(numEntryPages, 0.15)"
          ],
          "line": 7934
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "numEntryPages",
            "0.15"
          ],
          "line": 7934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unsupported GIN indexqual type: %d\"",
            "(int) nodeTag(clause)"
          ],
          "line": 7893
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeTag",
          "args": [
            "clause"
          ],
          "line": 7894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gincost_scalararrayopexpr",
          "args": [
            "root",
            "index",
            "qinfo",
            "numEntries",
            "&counts"
          ],
          "line": 7882
        },
        "resolved": true,
        "details": {
          "function_name": "gincost_scalararrayopexpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "7597-7707",
          "snippet": "static bool\ngincost_scalararrayopexpr(PlannerInfo *root,\n\t\t\t\t\t\t  IndexOptInfo *index,\n\t\t\t\t\t\t  IndexQualInfo *qinfo,\n\t\t\t\t\t\t  double numIndexEntries,\n\t\t\t\t\t\t  GinQualCounts *counts)\n{\n\tint\t\t\tindexcol = qinfo->indexcol;\n\tOid\t\t\tclause_op = qinfo->clause_op;\n\tNode\t   *rightop = qinfo->other_operand;\n\tArrayType  *arrayval;\n\tint16\t\telmlen;\n\tbool\t\telmbyval;\n\tchar\t\telmalign;\n\tint\t\t\tnumElems;\n\tDatum\t   *elemValues;\n\tbool\t   *elemNulls;\n\tGinQualCounts arraycounts;\n\tint\t\t\tnumPossible = 0;\n\tint\t\t\ti;\n\n\tAssert(((ScalarArrayOpExpr *) qinfo->rinfo->clause)->useOr);\n\n\t/* aggressively reduce to a constant, and look through relabeling */\n\trightop = estimate_expression_value(root, rightop);\n\n\tif (IsA(rightop, RelabelType))\n\t\trightop = (Node *) ((RelabelType *) rightop)->arg;\n\n\t/*\n\t * It's impossible to call extractQuery method for unknown operand. So\n\t * unless operand is a Const we can't do much; just assume there will be\n\t * one ordinary search entry from each array entry at runtime, and fall\n\t * back on a probably-bad estimate of the number of array entries.\n\t */\n\tif (!IsA(rightop, Const))\n\t{\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t\tcounts->arrayScans *= estimate_array_length(rightop);\n\t\treturn true;\n\t}\n\n\t/* If Const is null, there can be no matches */\n\tif (((Const *) rightop)->constisnull)\n\t\treturn false;\n\n\t/* Otherwise, extract the array elements and iterate over them */\n\tarrayval = DatumGetArrayTypeP(((Const *) rightop)->constvalue);\n\tget_typlenbyvalalign(ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t\t &elmlen, &elmbyval, &elmalign);\n\tdeconstruct_array(arrayval,\n\t\t\t\t\t  ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t  &elemValues, &elemNulls, &numElems);\n\n\tmemset(&arraycounts, 0, sizeof(arraycounts));\n\n\tfor (i = 0; i < numElems; i++)\n\t{\n\t\tGinQualCounts elemcounts;\n\n\t\t/* NULL can't match anything, so ignore, as the executor will */\n\t\tif (elemNulls[i])\n\t\t\tcontinue;\n\n\t\t/* Otherwise, apply extractQuery and get the actual term counts */\n\t\tmemset(&elemcounts, 0, sizeof(elemcounts));\n\n\t\tif (gincost_pattern(index, indexcol, clause_op, elemValues[i],\n\t\t\t\t\t\t\t&elemcounts))\n\t\t{\n\t\t\t/* We ignore array elements that are unsatisfiable patterns */\n\t\t\tnumPossible++;\n\n\t\t\tif (elemcounts.haveFullScan)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Full index scan will be required.  We treat this as if\n\t\t\t\t * every key in the index had been listed in the query; is\n\t\t\t\t * that reasonable?\n\t\t\t\t */\n\t\t\t\telemcounts.partialEntries = 0;\n\t\t\t\telemcounts.exactEntries = numIndexEntries;\n\t\t\t\telemcounts.searchEntries = numIndexEntries;\n\t\t\t}\n\t\t\tarraycounts.partialEntries += elemcounts.partialEntries;\n\t\t\tarraycounts.exactEntries += elemcounts.exactEntries;\n\t\t\tarraycounts.searchEntries += elemcounts.searchEntries;\n\t\t}\n\t}\n\n\tif (numPossible == 0)\n\t{\n\t\t/* No satisfiable patterns in the array */\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now add the averages to the global counts.  This will give us an\n\t * estimate of the average number of terms searched for in each indexscan,\n\t * including contributions from both array and non-array quals.\n\t */\n\tcounts->partialEntries += arraycounts.partialEntries / numPossible;\n\tcounts->exactEntries += arraycounts.exactEntries / numPossible;\n\tcounts->searchEntries += arraycounts.searchEntries / numPossible;\n\n\tcounts->arrayScans *= numPossible;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ngincost_scalararrayopexpr(PlannerInfo *root,\n\t\t\t\t\t\t  IndexOptInfo *index,\n\t\t\t\t\t\t  IndexQualInfo *qinfo,\n\t\t\t\t\t\t  double numIndexEntries,\n\t\t\t\t\t\t  GinQualCounts *counts)\n{\n\tint\t\t\tindexcol = qinfo->indexcol;\n\tOid\t\t\tclause_op = qinfo->clause_op;\n\tNode\t   *rightop = qinfo->other_operand;\n\tArrayType  *arrayval;\n\tint16\t\telmlen;\n\tbool\t\telmbyval;\n\tchar\t\telmalign;\n\tint\t\t\tnumElems;\n\tDatum\t   *elemValues;\n\tbool\t   *elemNulls;\n\tGinQualCounts arraycounts;\n\tint\t\t\tnumPossible = 0;\n\tint\t\t\ti;\n\n\tAssert(((ScalarArrayOpExpr *) qinfo->rinfo->clause)->useOr);\n\n\t/* aggressively reduce to a constant, and look through relabeling */\n\trightop = estimate_expression_value(root, rightop);\n\n\tif (IsA(rightop, RelabelType))\n\t\trightop = (Node *) ((RelabelType *) rightop)->arg;\n\n\t/*\n\t * It's impossible to call extractQuery method for unknown operand. So\n\t * unless operand is a Const we can't do much; just assume there will be\n\t * one ordinary search entry from each array entry at runtime, and fall\n\t * back on a probably-bad estimate of the number of array entries.\n\t */\n\tif (!IsA(rightop, Const))\n\t{\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t\tcounts->arrayScans *= estimate_array_length(rightop);\n\t\treturn true;\n\t}\n\n\t/* If Const is null, there can be no matches */\n\tif (((Const *) rightop)->constisnull)\n\t\treturn false;\n\n\t/* Otherwise, extract the array elements and iterate over them */\n\tarrayval = DatumGetArrayTypeP(((Const *) rightop)->constvalue);\n\tget_typlenbyvalalign(ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t\t &elmlen, &elmbyval, &elmalign);\n\tdeconstruct_array(arrayval,\n\t\t\t\t\t  ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t  &elemValues, &elemNulls, &numElems);\n\n\tmemset(&arraycounts, 0, sizeof(arraycounts));\n\n\tfor (i = 0; i < numElems; i++)\n\t{\n\t\tGinQualCounts elemcounts;\n\n\t\t/* NULL can't match anything, so ignore, as the executor will */\n\t\tif (elemNulls[i])\n\t\t\tcontinue;\n\n\t\t/* Otherwise, apply extractQuery and get the actual term counts */\n\t\tmemset(&elemcounts, 0, sizeof(elemcounts));\n\n\t\tif (gincost_pattern(index, indexcol, clause_op, elemValues[i],\n\t\t\t\t\t\t\t&elemcounts))\n\t\t{\n\t\t\t/* We ignore array elements that are unsatisfiable patterns */\n\t\t\tnumPossible++;\n\n\t\t\tif (elemcounts.haveFullScan)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Full index scan will be required.  We treat this as if\n\t\t\t\t * every key in the index had been listed in the query; is\n\t\t\t\t * that reasonable?\n\t\t\t\t */\n\t\t\t\telemcounts.partialEntries = 0;\n\t\t\t\telemcounts.exactEntries = numIndexEntries;\n\t\t\t\telemcounts.searchEntries = numIndexEntries;\n\t\t\t}\n\t\t\tarraycounts.partialEntries += elemcounts.partialEntries;\n\t\t\tarraycounts.exactEntries += elemcounts.exactEntries;\n\t\t\tarraycounts.searchEntries += elemcounts.searchEntries;\n\t\t}\n\t}\n\n\tif (numPossible == 0)\n\t{\n\t\t/* No satisfiable patterns in the array */\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now add the averages to the global counts.  This will give us an\n\t * estimate of the average number of terms searched for in each indexscan,\n\t * including contributions from both array and non-array quals.\n\t */\n\tcounts->partialEntries += arraycounts.partialEntries / numPossible;\n\tcounts->exactEntries += arraycounts.exactEntries / numPossible;\n\tcounts->searchEntries += arraycounts.searchEntries / numPossible;\n\n\tcounts->arrayScans *= numPossible;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "clause",
            "ScalarArrayOpExpr"
          ],
          "line": 7880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gincost_opexpr",
          "args": [
            "root",
            "index",
            "qinfo",
            "&counts"
          ],
          "line": 7873
        },
        "resolved": true,
        "details": {
          "function_name": "gincost_opexpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "7541-7583",
          "snippet": "static bool\ngincost_opexpr(PlannerInfo *root,\n\t\t\t   IndexOptInfo *index,\n\t\t\t   IndexQualInfo *qinfo,\n\t\t\t   GinQualCounts *counts)\n{\n\tint\t\t\tindexcol = qinfo->indexcol;\n\tOid\t\t\tclause_op = qinfo->clause_op;\n\tNode\t   *operand = qinfo->other_operand;\n\n\tif (!qinfo->varonleft)\n\t{\n\t\t/* must commute the operator */\n\t\tclause_op = get_commutator(clause_op);\n\t}\n\n\t/* aggressively reduce to a constant, and look through relabeling */\n\toperand = estimate_expression_value(root, operand);\n\n\tif (IsA(operand, RelabelType))\n\t\toperand = (Node *) ((RelabelType *) operand)->arg;\n\n\t/*\n\t * It's impossible to call extractQuery method for unknown operand. So\n\t * unless operand is a Const we can't do much; just assume there will be\n\t * one ordinary search entry from the operand at runtime.\n\t */\n\tif (!IsA(operand, Const))\n\t{\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t\treturn true;\n\t}\n\n\t/* If Const is null, there can be no matches */\n\tif (((Const *) operand)->constisnull)\n\t\treturn false;\n\n\t/* Otherwise, apply extractQuery and get the actual term counts */\n\treturn gincost_pattern(index, indexcol, clause_op,\n\t\t\t\t\t\t   ((Const *) operand)->constvalue,\n\t\t\t\t\t\t   counts);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ngincost_opexpr(PlannerInfo *root,\n\t\t\t   IndexOptInfo *index,\n\t\t\t   IndexQualInfo *qinfo,\n\t\t\t   GinQualCounts *counts)\n{\n\tint\t\t\tindexcol = qinfo->indexcol;\n\tOid\t\t\tclause_op = qinfo->clause_op;\n\tNode\t   *operand = qinfo->other_operand;\n\n\tif (!qinfo->varonleft)\n\t{\n\t\t/* must commute the operator */\n\t\tclause_op = get_commutator(clause_op);\n\t}\n\n\t/* aggressively reduce to a constant, and look through relabeling */\n\toperand = estimate_expression_value(root, operand);\n\n\tif (IsA(operand, RelabelType))\n\t\toperand = (Node *) ((RelabelType *) operand)->arg;\n\n\t/*\n\t * It's impossible to call extractQuery method for unknown operand. So\n\t * unless operand is a Const we can't do much; just assume there will be\n\t * one ordinary search entry from the operand at runtime.\n\t */\n\tif (!IsA(operand, Const))\n\t{\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t\treturn true;\n\t}\n\n\t/* If Const is null, there can be no matches */\n\tif (((Const *) operand)->constisnull)\n\t\treturn false;\n\n\t/* Otherwise, apply extractQuery and get the actual term counts */\n\treturn gincost_pattern(index, indexcol, clause_op,\n\t\t\t\t\t\t   ((Const *) operand)->constvalue,\n\t\t\t\t\t\t   counts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "clause",
            "OpExpr"
          ],
          "line": 7871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 7868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "qinfos"
          ],
          "line": 7866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&counts",
            "0",
            "sizeof(counts)"
          ],
          "line": 7862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tablespace_page_costs",
          "args": [
            "index->reltablespace",
            "&spc_random_page_cost",
            "NULL"
          ],
          "line": 7850
        },
        "resolved": true,
        "details": {
          "function_name": "get_tablespace_page_costs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
          "lines": "181-205",
          "snippet": "void\nget_tablespace_page_costs(Oid spcid,\n\t\t\t\t\t\t  double *spc_random_page_cost,\n\t\t\t\t\t\t  double *spc_seq_page_cost)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tAssert(spc != NULL);\n\n\tif (spc_random_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->random_page_cost < 0)\n\t\t\t*spc_random_page_cost = random_page_cost;\n\t\telse\n\t\t\t*spc_random_page_cost = spc->opts->random_page_cost;\n\t}\n\n\tif (spc_seq_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->seq_page_cost < 0)\n\t\t\t*spc_seq_page_cost = seq_page_cost;\n\t\telse\n\t\t\t*spc_seq_page_cost = spc->opts->seq_page_cost;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"storage/bufmgr.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"access/reloptions.h\"\n#include \"postgres.h\"\n\nvoid\nget_tablespace_page_costs(Oid spcid,\n\t\t\t\t\t\t  double *spc_random_page_cost,\n\t\t\t\t\t\t  double *spc_seq_page_cost)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tAssert(spc != NULL);\n\n\tif (spc_random_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->random_page_cost < 0)\n\t\t\t*spc_random_page_cost = random_page_cost;\n\t\telse\n\t\t\t*spc_random_page_cost = spc->opts->random_page_cost;\n\t}\n\n\tif (spc_seq_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->seq_page_cost < 0)\n\t\t\t*spc_seq_page_cost = seq_page_cost;\n\t\telse\n\t\t\t*spc_seq_page_cost = spc->opts->seq_page_cost;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clauselist_selectivity",
          "args": [
            "root",
            "selectivityQuals",
            "index->rel->relid",
            "JOIN_INNER",
            "NULL"
          ],
          "line": 7844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_concat",
          "args": [
            "predExtraQuals",
            "indexQuals"
          ],
          "line": 7838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_concat",
          "args": [
            "predExtraQuals",
            "oneQual"
          ],
          "line": 7835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "predicate_implied_by",
          "args": [
            "oneQual",
            "indexQuals",
            "false"
          ],
          "line": 7834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make1",
          "args": [
            "predQual"
          ],
          "line": 7832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 7831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "index->indpred"
          ],
          "line": 7829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "floor",
          "args": [
            "numEntryPages * 100"
          ],
          "line": 7814
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "numPages",
            "10"
          ],
          "line": 7811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "numDataPages",
            "numPages - numPendingPages - numEntryPages"
          ],
          "line": 7793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "numEntryPages",
            "numPages - numPendingPages"
          ],
          "line": 7792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ginStats",
            "0",
            "sizeof(ginStats)"
          ],
          "line": 7758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_close",
          "args": [
            "indexRel",
            "AccessShareLock"
          ],
          "line": 7754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ginGetStats",
          "args": [
            "indexRel",
            "&ginStats"
          ],
          "line": 7753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_open",
          "args": [
            "index->indexoid",
            "AccessShareLock"
          ],
          "line": 7752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_indexquals",
          "args": [
            "path"
          ],
          "line": 7744
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_indexquals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6565-6653",
          "snippet": "List *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);\n\nvoid\ngincostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t\tCost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t\tSelectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t\tdouble *indexPages)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tList\t   *qinfos;\n\tListCell   *l;\n\tList\t   *selectivityQuals;\n\tdouble\t\tnumPages = index->pages,\n\t\t\t\tnumTuples = index->tuples;\n\tdouble\t\tnumEntryPages,\n\t\t\t\tnumDataPages,\n\t\t\t\tnumPendingPages,\n\t\t\t\tnumEntries;\n\tGinQualCounts counts;\n\tbool\t\tmatchPossible;\n\tdouble\t\tpartialScale;\n\tdouble\t\tentryPagesFetched,\n\t\t\t\tdataPagesFetched,\n\t\t\t\tdataPagesFetchedBySel;\n\tdouble\t\tqual_op_cost,\n\t\t\t\tqual_arg_cost,\n\t\t\t\tspc_random_page_cost,\n\t\t\t\touter_scans;\n\tRelation\tindexRel;\n\tGinStatsData ginStats;\n\n\t/* Do preliminary analysis of indexquals */\n\tqinfos = deconstruct_indexquals(path);\n\n\t/*\n\t * Obtain statistical information from the meta page, if possible.  Else\n\t * set ginStats to zeroes, and we'll cope below.\n\t */\n\tif (!index->hypothetical)\n\t{\n\t\tindexRel = index_open(index->indexoid, AccessShareLock);\n\t\tginGetStats(indexRel, &ginStats);\n\t\tindex_close(indexRel, AccessShareLock);\n\t}\n\telse\n\t{\n\t\tmemset(&ginStats, 0, sizeof(ginStats));\n\t}\n\n\t/*\n\t * Assuming we got valid (nonzero) stats at all, nPendingPages can be\n\t * trusted, but the other fields are data as of the last VACUUM.  We can\n\t * scale them up to account for growth since then, but that method only\n\t * goes so far; in the worst case, the stats might be for a completely\n\t * empty index, and scaling them will produce pretty bogus numbers.\n\t * Somewhat arbitrarily, set the cutoff for doing scaling at 4X growth; if\n\t * it's grown more than that, fall back to estimating things only from the\n\t * assumed-accurate index size.  But we'll trust nPendingPages in any case\n\t * so long as it's not clearly insane, ie, more than the index size.\n\t */\n\tif (ginStats.nPendingPages < numPages)\n\t\tnumPendingPages = ginStats.nPendingPages;\n\telse\n\t\tnumPendingPages = 0;\n\n\tif (numPages > 0 && ginStats.nTotalPages <= numPages &&\n\t\tginStats.nTotalPages > numPages / 4 &&\n\t\tginStats.nEntryPages > 0 && ginStats.nEntries > 0)\n\t{\n\t\t/*\n\t\t * OK, the stats seem close enough to sane to be trusted.  But we\n\t\t * still need to scale them by the ratio numPages / nTotalPages to\n\t\t * account for growth since the last VACUUM.\n\t\t */\n\t\tdouble\t\tscale = numPages / ginStats.nTotalPages;\n\n\t\tnumEntryPages = ceil(ginStats.nEntryPages * scale);\n\t\tnumDataPages = ceil(ginStats.nDataPages * scale);\n\t\tnumEntries = ceil(ginStats.nEntries * scale);\n\t\t/* ensure we didn't round up too much */\n\t\tnumEntryPages = Min(numEntryPages, numPages - numPendingPages);\n\t\tnumDataPages = Min(numDataPages,\n\t\t\t\t\t\t   numPages - numPendingPages - numEntryPages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We might get here because it's a hypothetical index, or an index\n\t\t * created pre-9.1 and never vacuumed since upgrading (in which case\n\t\t * its stats would read as zeroes), or just because it's grown too\n\t\t * much since the last VACUUM for us to put our faith in scaling.\n\t\t *\n\t\t * Invent some plausible internal statistics based on the index page\n\t\t * count (and clamp that to at least 10 pages, just in case).  We\n\t\t * estimate that 90% of the index is entry pages, and the rest is data\n\t\t * pages.  Estimate 100 entries per entry page; this is rather bogus\n\t\t * since it'll depend on the size of the keys, but it's more robust\n\t\t * than trying to predict the number of entries per heap tuple.\n\t\t */\n\t\tnumPages = Max(numPages, 10);\n\t\tnumEntryPages = floor((numPages - numPendingPages) * 0.90);\n\t\tnumDataPages = numPages - numPendingPages - numEntryPages;\n\t\tnumEntries = floor(numEntryPages * 100);\n\t}\n\n\t/* In an empty index, numEntries could be zero.  Avoid divide-by-zero */\n\tif (numEntries < 1)\n\t\tnumEntries = 1;\n\n\t/*\n\t * Include predicate in selectivityQuals (should match\n\t * genericcostestimate)\n\t */\n\tif (index->indpred != NIL)\n\t{\n\t\tList\t   *predExtraQuals = NIL;\n\n\t\tforeach(l, index->indpred)\n\t\t{\n\t\t\tNode\t   *predQual = (Node *) lfirst(l);\n\t\t\tList\t   *oneQual = list_make1(predQual);\n\n\t\t\tif (!predicate_implied_by(oneQual, indexQuals, false))\n\t\t\t\tpredExtraQuals = list_concat(predExtraQuals, oneQual);\n\t\t}\n\t\t/* list_concat avoids modifying the passed-in indexQuals list */\n\t\tselectivityQuals = list_concat(predExtraQuals, indexQuals);\n\t}\n\telse\n\t\tselectivityQuals = indexQuals;\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\t*indexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t   index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t   JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t   NULL);\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\t*indexCorrelation = 0.0;\n\n\t/*\n\t * Examine quals to estimate number of search entries & partial matches\n\t */\n\tmemset(&counts, 0, sizeof(counts));\n\tcounts.arrayScans = 1;\n\tmatchPossible = true;\n\n\tforeach(l, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(l);\n\t\tExpr\t   *clause = qinfo->rinfo->clause;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tmatchPossible = gincost_opexpr(root,\n\t\t\t\t\t\t\t\t\t\t   index,\n\t\t\t\t\t\t\t\t\t\t   qinfo,\n\t\t\t\t\t\t\t\t\t\t   &counts);\n\t\t\tif (!matchPossible)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tmatchPossible = gincost_scalararrayopexpr(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  index,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  qinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  numEntries,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &counts);\n\t\t\tif (!matchPossible)\n\t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* shouldn't be anything else for a GIN index */\n\t\t\telog(ERROR, \"unsupported GIN indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\t}\n\n\t/* Fall out if there were any provably-unsatisfiable quals */\n\tif (!matchPossible)\n\t{\n\t\t*indexStartupCost = 0;\n\t\t*indexTotalCost = 0;\n\t\t*indexSelectivity = 0;\n\t\treturn;\n\t}\n\n\tif (counts.haveFullScan || indexQuals == NIL)\n\t{\n\t\t/*\n\t\t * Full index scan will be required.  We treat this as if every key in\n\t\t * the index had been listed in the query; is that reasonable?\n\t\t */\n\t\tcounts.partialEntries = 0;\n\t\tcounts.exactEntries = numEntries;\n\t\tcounts.searchEntries = numEntries;\n\t}\n\n\t/* Will we have more than one iteration of a nestloop scan? */\n\touter_scans = loop_count;\n\n\t/*\n\t * Compute cost to begin scan, first of all, pay attention to pending\n\t * list.\n\t */\n\tentryPagesFetched = numPendingPages;\n\n\t/*\n\t * Estimate number of entry pages read.  We need to do\n\t * counts.searchEntries searches.  Use a power function as it should be,\n\t * but tuples on leaf pages usually is much greater. Here we include all\n\t * searches in entry tree, including search of first entry in partial\n\t * match algorithm\n\t */\n\tentryPagesFetched += ceil(counts.searchEntries * rint(pow(numEntryPages, 0.15)));\n\n\t/*\n\t * Add an estimate of entry pages read by partial match algorithm. It's a\n\t * scan over leaf pages in entry tree.  We haven't any useful stats here,\n\t * so estimate it as proportion.  Because counts.partialEntries is really\n\t * pretty bogus (see code above), it's possible that it is more than\n\t * numEntries; clamp the proportion to ensure sanity.\n\t */\n\tpartialScale = counts.partialEntries / numEntries;\n\tpartialScale = Min(partialScale, 1.0);\n\n\tentryPagesFetched += ceil(numEntryPages * partialScale);\n\n\t/*\n\t * Partial match algorithm reads all data pages before doing actual scan,\n\t * so it's a startup cost.  Again, we haven't any useful stats here, so\n\t * estimate it as proportion.\n\t */\n\tdataPagesFetched = ceil(numDataPages * partialScale);\n\n\t/*\n\t * Calculate cache effects if more than one scan due to nestloops or array\n\t * quals.  The result is pro-rated per nestloop scan, but the array qual\n\t * factor shouldn't be pro-rated (compare genericcostestimate).\n\t */\n\tif (outer_scans > 1 || counts.arrayScans > 1)\n\t{\n\t\tentryPagesFetched *= outer_scans * counts.arrayScans;\n\t\tentryPagesFetched = index_pages_fetched(entryPagesFetched,\n\t\t\t\t\t\t\t\t\t\t\t\t(BlockNumber) numEntryPages,\n\t\t\t\t\t\t\t\t\t\t\t\tnumEntryPages, root);\n\t\tentryPagesFetched /= outer_scans;\n\t\tdataPagesFetched *= outer_scans * counts.arrayScans;\n\t\tdataPagesFetched = index_pages_fetched(dataPagesFetched,\n\t\t\t\t\t\t\t\t\t\t\t   (BlockNumber) numDataPages,\n\t\t\t\t\t\t\t\t\t\t\t   numDataPages, root);\n\t\tdataPagesFetched /= outer_scans;\n\t}\n\n\t/*\n\t * Here we use random page cost because logically-close pages could be far\n\t * apart on disk.\n\t */\n\t*indexStartupCost = (entryPagesFetched + dataPagesFetched) * spc_random_page_cost;\n\n\t/*\n\t * Now compute the number of data pages fetched during the scan.\n\t *\n\t * We assume every entry to have the same number of items, and that there\n\t * is no overlap between them. (XXX: tsvector and array opclasses collect\n\t * statistics on the frequency of individual keys; it would be nice to use\n\t * those here.)\n\t */\n\tdataPagesFetched = ceil(numDataPages * counts.exactEntries / numEntries);\n\n\t/*\n\t * If there is a lot of overlap among the entries, in particular if one of\n\t * the entries is very frequent, the above calculation can grossly\n\t * under-estimate.  As a simple cross-check, calculate a lower bound based\n\t * on the overall selectivity of the quals.  At a minimum, we must read\n\t * one item pointer for each matching entry.\n\t *\n\t * The width of each item pointer varies, based on the level of\n\t * compression.  We don't have statistics on that, but an average of\n\t * around 3 bytes per item is fairly typical.\n\t */\n\tdataPagesFetchedBySel = ceil(*indexSelectivity *\n\t\t\t\t\t\t\t\t (numTuples / (BLCKSZ / 3)));\n\tif (dataPagesFetchedBySel > dataPagesFetched)\n\t\tdataPagesFetched = dataPagesFetchedBySel;\n\n\t/* Account for cache effects, the same as above */\n\tif (outer_scans > 1 || counts.arrayScans > 1)\n\t{\n\t\tdataPagesFetched *= outer_scans * counts.arrayScans;\n\t\tdataPagesFetched = index_pages_fetched(dataPagesFetched,\n\t\t\t\t\t\t\t\t\t\t\t   (BlockNumber) numDataPages,\n\t\t\t\t\t\t\t\t\t\t\t   numDataPages, root);\n\t\tdataPagesFetched /= outer_scans;\n\t}\n\n\t/* And apply random_page_cost as the cost per page */\n\t*indexTotalCost = *indexStartupCost +\n\t\tdataPagesFetched * spc_random_page_cost;\n\n\t/*\n\t * Add on index qual eval costs, much as in genericcostestimate\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\t*indexStartupCost += qual_arg_cost;\n\t*indexTotalCost += qual_arg_cost;\n\t*indexTotalCost += (numTuples * *indexSelectivity) * (cpu_index_tuple_cost + qual_op_cost);\n\t*indexPages = dataPagesFetched;\n}"
  },
  {
    "function_name": "gincost_scalararrayopexpr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "7597-7707",
    "snippet": "static bool\ngincost_scalararrayopexpr(PlannerInfo *root,\n\t\t\t\t\t\t  IndexOptInfo *index,\n\t\t\t\t\t\t  IndexQualInfo *qinfo,\n\t\t\t\t\t\t  double numIndexEntries,\n\t\t\t\t\t\t  GinQualCounts *counts)\n{\n\tint\t\t\tindexcol = qinfo->indexcol;\n\tOid\t\t\tclause_op = qinfo->clause_op;\n\tNode\t   *rightop = qinfo->other_operand;\n\tArrayType  *arrayval;\n\tint16\t\telmlen;\n\tbool\t\telmbyval;\n\tchar\t\telmalign;\n\tint\t\t\tnumElems;\n\tDatum\t   *elemValues;\n\tbool\t   *elemNulls;\n\tGinQualCounts arraycounts;\n\tint\t\t\tnumPossible = 0;\n\tint\t\t\ti;\n\n\tAssert(((ScalarArrayOpExpr *) qinfo->rinfo->clause)->useOr);\n\n\t/* aggressively reduce to a constant, and look through relabeling */\n\trightop = estimate_expression_value(root, rightop);\n\n\tif (IsA(rightop, RelabelType))\n\t\trightop = (Node *) ((RelabelType *) rightop)->arg;\n\n\t/*\n\t * It's impossible to call extractQuery method for unknown operand. So\n\t * unless operand is a Const we can't do much; just assume there will be\n\t * one ordinary search entry from each array entry at runtime, and fall\n\t * back on a probably-bad estimate of the number of array entries.\n\t */\n\tif (!IsA(rightop, Const))\n\t{\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t\tcounts->arrayScans *= estimate_array_length(rightop);\n\t\treturn true;\n\t}\n\n\t/* If Const is null, there can be no matches */\n\tif (((Const *) rightop)->constisnull)\n\t\treturn false;\n\n\t/* Otherwise, extract the array elements and iterate over them */\n\tarrayval = DatumGetArrayTypeP(((Const *) rightop)->constvalue);\n\tget_typlenbyvalalign(ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t\t &elmlen, &elmbyval, &elmalign);\n\tdeconstruct_array(arrayval,\n\t\t\t\t\t  ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t  &elemValues, &elemNulls, &numElems);\n\n\tmemset(&arraycounts, 0, sizeof(arraycounts));\n\n\tfor (i = 0; i < numElems; i++)\n\t{\n\t\tGinQualCounts elemcounts;\n\n\t\t/* NULL can't match anything, so ignore, as the executor will */\n\t\tif (elemNulls[i])\n\t\t\tcontinue;\n\n\t\t/* Otherwise, apply extractQuery and get the actual term counts */\n\t\tmemset(&elemcounts, 0, sizeof(elemcounts));\n\n\t\tif (gincost_pattern(index, indexcol, clause_op, elemValues[i],\n\t\t\t\t\t\t\t&elemcounts))\n\t\t{\n\t\t\t/* We ignore array elements that are unsatisfiable patterns */\n\t\t\tnumPossible++;\n\n\t\t\tif (elemcounts.haveFullScan)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Full index scan will be required.  We treat this as if\n\t\t\t\t * every key in the index had been listed in the query; is\n\t\t\t\t * that reasonable?\n\t\t\t\t */\n\t\t\t\telemcounts.partialEntries = 0;\n\t\t\t\telemcounts.exactEntries = numIndexEntries;\n\t\t\t\telemcounts.searchEntries = numIndexEntries;\n\t\t\t}\n\t\t\tarraycounts.partialEntries += elemcounts.partialEntries;\n\t\t\tarraycounts.exactEntries += elemcounts.exactEntries;\n\t\t\tarraycounts.searchEntries += elemcounts.searchEntries;\n\t\t}\n\t}\n\n\tif (numPossible == 0)\n\t{\n\t\t/* No satisfiable patterns in the array */\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now add the averages to the global counts.  This will give us an\n\t * estimate of the average number of terms searched for in each indexscan,\n\t * including contributions from both array and non-array quals.\n\t */\n\tcounts->partialEntries += arraycounts.partialEntries / numPossible;\n\tcounts->exactEntries += arraycounts.exactEntries / numPossible;\n\tcounts->searchEntries += arraycounts.searchEntries / numPossible;\n\n\tcounts->arrayScans *= numPossible;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gincost_pattern",
          "args": [
            "index",
            "indexcol",
            "clause_op",
            "elemValues[i]",
            "&elemcounts"
          ],
          "line": 7666
        },
        "resolved": true,
        "details": {
          "function_name": "gincost_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "7437-7534",
          "snippet": "static bool\ngincost_pattern(IndexOptInfo *index, int indexcol,\n\t\t\t\tOid clause_op, Datum query,\n\t\t\t\tGinQualCounts *counts)\n{\n\tOid\t\t\textractProcOid;\n\tOid\t\t\tcollation;\n\tint\t\t\tstrategy_op;\n\tOid\t\t\tlefttype,\n\t\t\t\trighttype;\n\tint32\t\tnentries = 0;\n\tbool\t   *partial_matches = NULL;\n\tPointer    *extra_data = NULL;\n\tbool\t   *nullFlags = NULL;\n\tint32\t\tsearchMode = GIN_SEARCH_MODE_DEFAULT;\n\tint32\t\ti;\n\n\tAssert(indexcol < index->nkeycolumns);\n\n\t/*\n\t * Get the operator's strategy number and declared input data types within\n\t * the index opfamily.  (We don't need the latter, but we use\n\t * get_op_opfamily_properties because it will throw error if it fails to\n\t * find a matching pg_amop entry.)\n\t */\n\tget_op_opfamily_properties(clause_op, index->opfamily[indexcol], false,\n\t\t\t\t\t\t\t   &strategy_op, &lefttype, &righttype);\n\n\t/*\n\t * GIN always uses the \"default\" support functions, which are those with\n\t * lefttype == righttype == the opclass' opcintype (see\n\t * IndexSupportInitialize in relcache.c).\n\t */\n\textractProcOid = get_opfamily_proc(index->opfamily[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   GIN_EXTRACTQUERY_PROC);\n\n\tif (!OidIsValid(extractProcOid))\n\t{\n\t\t/* should not happen; throw same error as index_getprocinfo */\n\t\telog(ERROR, \"missing support function %d for attribute %d of index \\\"%s\\\"\",\n\t\t\t GIN_EXTRACTQUERY_PROC, indexcol + 1,\n\t\t\t get_rel_name(index->indexoid));\n\t}\n\n\t/*\n\t * Choose collation to pass to extractProc (should match initGinState).\n\t */\n\tif (OidIsValid(index->indexcollations[indexcol]))\n\t\tcollation = index->indexcollations[indexcol];\n\telse\n\t\tcollation = DEFAULT_COLLATION_OID;\n\n\tOidFunctionCall7Coll(extractProcOid,\n\t\t\t\t\t\t collation,\n\t\t\t\t\t\t query,\n\t\t\t\t\t\t PointerGetDatum(&nentries),\n\t\t\t\t\t\t UInt16GetDatum(strategy_op),\n\t\t\t\t\t\t PointerGetDatum(&partial_matches),\n\t\t\t\t\t\t PointerGetDatum(&extra_data),\n\t\t\t\t\t\t PointerGetDatum(&nullFlags),\n\t\t\t\t\t\t PointerGetDatum(&searchMode));\n\n\tif (nentries <= 0 && searchMode == GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* No match is possible */\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < nentries; i++)\n\t{\n\t\t/*\n\t\t * For partial match we haven't any information to estimate number of\n\t\t * matched entries in index, so, we just estimate it as 100\n\t\t */\n\t\tif (partial_matches && partial_matches[i])\n\t\t\tcounts->partialEntries += 100;\n\t\telse\n\t\t\tcounts->exactEntries++;\n\n\t\tcounts->searchEntries++;\n\t}\n\n\tif (searchMode == GIN_SEARCH_MODE_INCLUDE_EMPTY)\n\t{\n\t\t/* Treat \"include empty\" like an exact-match item */\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t}\n\telse if (searchMode != GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* It's GIN_SEARCH_MODE_ALL */\n\t\tcounts->haveFullScan = true;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ngincost_pattern(IndexOptInfo *index, int indexcol,\n\t\t\t\tOid clause_op, Datum query,\n\t\t\t\tGinQualCounts *counts)\n{\n\tOid\t\t\textractProcOid;\n\tOid\t\t\tcollation;\n\tint\t\t\tstrategy_op;\n\tOid\t\t\tlefttype,\n\t\t\t\trighttype;\n\tint32\t\tnentries = 0;\n\tbool\t   *partial_matches = NULL;\n\tPointer    *extra_data = NULL;\n\tbool\t   *nullFlags = NULL;\n\tint32\t\tsearchMode = GIN_SEARCH_MODE_DEFAULT;\n\tint32\t\ti;\n\n\tAssert(indexcol < index->nkeycolumns);\n\n\t/*\n\t * Get the operator's strategy number and declared input data types within\n\t * the index opfamily.  (We don't need the latter, but we use\n\t * get_op_opfamily_properties because it will throw error if it fails to\n\t * find a matching pg_amop entry.)\n\t */\n\tget_op_opfamily_properties(clause_op, index->opfamily[indexcol], false,\n\t\t\t\t\t\t\t   &strategy_op, &lefttype, &righttype);\n\n\t/*\n\t * GIN always uses the \"default\" support functions, which are those with\n\t * lefttype == righttype == the opclass' opcintype (see\n\t * IndexSupportInitialize in relcache.c).\n\t */\n\textractProcOid = get_opfamily_proc(index->opfamily[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   GIN_EXTRACTQUERY_PROC);\n\n\tif (!OidIsValid(extractProcOid))\n\t{\n\t\t/* should not happen; throw same error as index_getprocinfo */\n\t\telog(ERROR, \"missing support function %d for attribute %d of index \\\"%s\\\"\",\n\t\t\t GIN_EXTRACTQUERY_PROC, indexcol + 1,\n\t\t\t get_rel_name(index->indexoid));\n\t}\n\n\t/*\n\t * Choose collation to pass to extractProc (should match initGinState).\n\t */\n\tif (OidIsValid(index->indexcollations[indexcol]))\n\t\tcollation = index->indexcollations[indexcol];\n\telse\n\t\tcollation = DEFAULT_COLLATION_OID;\n\n\tOidFunctionCall7Coll(extractProcOid,\n\t\t\t\t\t\t collation,\n\t\t\t\t\t\t query,\n\t\t\t\t\t\t PointerGetDatum(&nentries),\n\t\t\t\t\t\t UInt16GetDatum(strategy_op),\n\t\t\t\t\t\t PointerGetDatum(&partial_matches),\n\t\t\t\t\t\t PointerGetDatum(&extra_data),\n\t\t\t\t\t\t PointerGetDatum(&nullFlags),\n\t\t\t\t\t\t PointerGetDatum(&searchMode));\n\n\tif (nentries <= 0 && searchMode == GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* No match is possible */\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < nentries; i++)\n\t{\n\t\t/*\n\t\t * For partial match we haven't any information to estimate number of\n\t\t * matched entries in index, so, we just estimate it as 100\n\t\t */\n\t\tif (partial_matches && partial_matches[i])\n\t\t\tcounts->partialEntries += 100;\n\t\telse\n\t\t\tcounts->exactEntries++;\n\n\t\tcounts->searchEntries++;\n\t}\n\n\tif (searchMode == GIN_SEARCH_MODE_INCLUDE_EMPTY)\n\t{\n\t\t/* Treat \"include empty\" like an exact-match item */\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t}\n\telse if (searchMode != GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* It's GIN_SEARCH_MODE_ALL */\n\t\tcounts->haveFullScan = true;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&elemcounts",
            "0",
            "sizeof(elemcounts)"
          ],
          "line": 7664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&arraycounts",
            "0",
            "sizeof(arraycounts)"
          ],
          "line": 7653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "arrayval",
            "ARR_ELEMTYPE(arrayval)",
            "elmlen",
            "elmbyval",
            "elmalign",
            "&elemValues",
            "&elemNulls",
            "&numElems"
          ],
          "line": 7648
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arrayval"
          ],
          "line": 7649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "ARR_ELEMTYPE(arrayval)",
            "&elmlen",
            "&elmbyval",
            "&elmalign"
          ],
          "line": 7646
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arrayval"
          ],
          "line": 7646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "((Const *) rightop)->constvalue"
          ],
          "line": 7645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimate_array_length",
          "args": [
            "rightop"
          ],
          "line": 7636
        },
        "resolved": true,
        "details": {
          "function_name": "estimate_array_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2178-2205",
          "snippet": "int\nestimate_array_length(Node *arrayexpr)\n{\n\t/* look through any binary-compatible relabeling of arrayexpr */\n\tarrayexpr = strip_array_coercion(arrayexpr);\n\n\tif (arrayexpr && IsA(arrayexpr, Const))\n\t{\n\t\tDatum\t\tarraydatum = ((Const *) arrayexpr)->constvalue;\n\t\tbool\t\tarrayisnull = ((Const *) arrayexpr)->constisnull;\n\t\tArrayType  *arrayval;\n\n\t\tif (arrayisnull)\n\t\t\treturn 0;\n\t\tarrayval = DatumGetArrayTypeP(arraydatum);\n\t\treturn ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));\n\t}\n\telse if (arrayexpr && IsA(arrayexpr, ArrayExpr) &&\n\t\t\t !((ArrayExpr *) arrayexpr)->multidims)\n\t{\n\t\treturn list_length(((ArrayExpr *) arrayexpr)->elements);\n\t}\n\telse\n\t{\n\t\t/* default guess --- see also scalararraysel */\n\t\treturn 10;\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nestimate_array_length(Node *arrayexpr)\n{\n\t/* look through any binary-compatible relabeling of arrayexpr */\n\tarrayexpr = strip_array_coercion(arrayexpr);\n\n\tif (arrayexpr && IsA(arrayexpr, Const))\n\t{\n\t\tDatum\t\tarraydatum = ((Const *) arrayexpr)->constvalue;\n\t\tbool\t\tarrayisnull = ((Const *) arrayexpr)->constisnull;\n\t\tArrayType  *arrayval;\n\n\t\tif (arrayisnull)\n\t\t\treturn 0;\n\t\tarrayval = DatumGetArrayTypeP(arraydatum);\n\t\treturn ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));\n\t}\n\telse if (arrayexpr && IsA(arrayexpr, ArrayExpr) &&\n\t\t\t !((ArrayExpr *) arrayexpr)->multidims)\n\t{\n\t\treturn list_length(((ArrayExpr *) arrayexpr)->elements);\n\t}\n\telse\n\t{\n\t\t/* default guess --- see also scalararraysel */\n\t\treturn 10;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rightop",
            "Const"
          ],
          "line": 7632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rightop",
            "RelabelType"
          ],
          "line": 7623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimate_expression_value",
          "args": [
            "root",
            "rightop"
          ],
          "line": 7621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "((ScalarArrayOpExpr *) qinfo->rinfo->clause)->useOr"
          ],
          "line": 7618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ngincost_scalararrayopexpr(PlannerInfo *root,\n\t\t\t\t\t\t  IndexOptInfo *index,\n\t\t\t\t\t\t  IndexQualInfo *qinfo,\n\t\t\t\t\t\t  double numIndexEntries,\n\t\t\t\t\t\t  GinQualCounts *counts)\n{\n\tint\t\t\tindexcol = qinfo->indexcol;\n\tOid\t\t\tclause_op = qinfo->clause_op;\n\tNode\t   *rightop = qinfo->other_operand;\n\tArrayType  *arrayval;\n\tint16\t\telmlen;\n\tbool\t\telmbyval;\n\tchar\t\telmalign;\n\tint\t\t\tnumElems;\n\tDatum\t   *elemValues;\n\tbool\t   *elemNulls;\n\tGinQualCounts arraycounts;\n\tint\t\t\tnumPossible = 0;\n\tint\t\t\ti;\n\n\tAssert(((ScalarArrayOpExpr *) qinfo->rinfo->clause)->useOr);\n\n\t/* aggressively reduce to a constant, and look through relabeling */\n\trightop = estimate_expression_value(root, rightop);\n\n\tif (IsA(rightop, RelabelType))\n\t\trightop = (Node *) ((RelabelType *) rightop)->arg;\n\n\t/*\n\t * It's impossible to call extractQuery method for unknown operand. So\n\t * unless operand is a Const we can't do much; just assume there will be\n\t * one ordinary search entry from each array entry at runtime, and fall\n\t * back on a probably-bad estimate of the number of array entries.\n\t */\n\tif (!IsA(rightop, Const))\n\t{\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t\tcounts->arrayScans *= estimate_array_length(rightop);\n\t\treturn true;\n\t}\n\n\t/* If Const is null, there can be no matches */\n\tif (((Const *) rightop)->constisnull)\n\t\treturn false;\n\n\t/* Otherwise, extract the array elements and iterate over them */\n\tarrayval = DatumGetArrayTypeP(((Const *) rightop)->constvalue);\n\tget_typlenbyvalalign(ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t\t &elmlen, &elmbyval, &elmalign);\n\tdeconstruct_array(arrayval,\n\t\t\t\t\t  ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t  &elemValues, &elemNulls, &numElems);\n\n\tmemset(&arraycounts, 0, sizeof(arraycounts));\n\n\tfor (i = 0; i < numElems; i++)\n\t{\n\t\tGinQualCounts elemcounts;\n\n\t\t/* NULL can't match anything, so ignore, as the executor will */\n\t\tif (elemNulls[i])\n\t\t\tcontinue;\n\n\t\t/* Otherwise, apply extractQuery and get the actual term counts */\n\t\tmemset(&elemcounts, 0, sizeof(elemcounts));\n\n\t\tif (gincost_pattern(index, indexcol, clause_op, elemValues[i],\n\t\t\t\t\t\t\t&elemcounts))\n\t\t{\n\t\t\t/* We ignore array elements that are unsatisfiable patterns */\n\t\t\tnumPossible++;\n\n\t\t\tif (elemcounts.haveFullScan)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Full index scan will be required.  We treat this as if\n\t\t\t\t * every key in the index had been listed in the query; is\n\t\t\t\t * that reasonable?\n\t\t\t\t */\n\t\t\t\telemcounts.partialEntries = 0;\n\t\t\t\telemcounts.exactEntries = numIndexEntries;\n\t\t\t\telemcounts.searchEntries = numIndexEntries;\n\t\t\t}\n\t\t\tarraycounts.partialEntries += elemcounts.partialEntries;\n\t\t\tarraycounts.exactEntries += elemcounts.exactEntries;\n\t\t\tarraycounts.searchEntries += elemcounts.searchEntries;\n\t\t}\n\t}\n\n\tif (numPossible == 0)\n\t{\n\t\t/* No satisfiable patterns in the array */\n\t\treturn false;\n\t}\n\n\t/*\n\t * Now add the averages to the global counts.  This will give us an\n\t * estimate of the average number of terms searched for in each indexscan,\n\t * including contributions from both array and non-array quals.\n\t */\n\tcounts->partialEntries += arraycounts.partialEntries / numPossible;\n\tcounts->exactEntries += arraycounts.exactEntries / numPossible;\n\tcounts->searchEntries += arraycounts.searchEntries / numPossible;\n\n\tcounts->arrayScans *= numPossible;\n\n\treturn true;\n}"
  },
  {
    "function_name": "gincost_opexpr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "7541-7583",
    "snippet": "static bool\ngincost_opexpr(PlannerInfo *root,\n\t\t\t   IndexOptInfo *index,\n\t\t\t   IndexQualInfo *qinfo,\n\t\t\t   GinQualCounts *counts)\n{\n\tint\t\t\tindexcol = qinfo->indexcol;\n\tOid\t\t\tclause_op = qinfo->clause_op;\n\tNode\t   *operand = qinfo->other_operand;\n\n\tif (!qinfo->varonleft)\n\t{\n\t\t/* must commute the operator */\n\t\tclause_op = get_commutator(clause_op);\n\t}\n\n\t/* aggressively reduce to a constant, and look through relabeling */\n\toperand = estimate_expression_value(root, operand);\n\n\tif (IsA(operand, RelabelType))\n\t\toperand = (Node *) ((RelabelType *) operand)->arg;\n\n\t/*\n\t * It's impossible to call extractQuery method for unknown operand. So\n\t * unless operand is a Const we can't do much; just assume there will be\n\t * one ordinary search entry from the operand at runtime.\n\t */\n\tif (!IsA(operand, Const))\n\t{\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t\treturn true;\n\t}\n\n\t/* If Const is null, there can be no matches */\n\tif (((Const *) operand)->constisnull)\n\t\treturn false;\n\n\t/* Otherwise, apply extractQuery and get the actual term counts */\n\treturn gincost_pattern(index, indexcol, clause_op,\n\t\t\t\t\t\t   ((Const *) operand)->constvalue,\n\t\t\t\t\t\t   counts);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gincost_pattern",
          "args": [
            "index",
            "indexcol",
            "clause_op",
            "((Const *) operand)->constvalue",
            "counts"
          ],
          "line": 7580
        },
        "resolved": true,
        "details": {
          "function_name": "gincost_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "7437-7534",
          "snippet": "static bool\ngincost_pattern(IndexOptInfo *index, int indexcol,\n\t\t\t\tOid clause_op, Datum query,\n\t\t\t\tGinQualCounts *counts)\n{\n\tOid\t\t\textractProcOid;\n\tOid\t\t\tcollation;\n\tint\t\t\tstrategy_op;\n\tOid\t\t\tlefttype,\n\t\t\t\trighttype;\n\tint32\t\tnentries = 0;\n\tbool\t   *partial_matches = NULL;\n\tPointer    *extra_data = NULL;\n\tbool\t   *nullFlags = NULL;\n\tint32\t\tsearchMode = GIN_SEARCH_MODE_DEFAULT;\n\tint32\t\ti;\n\n\tAssert(indexcol < index->nkeycolumns);\n\n\t/*\n\t * Get the operator's strategy number and declared input data types within\n\t * the index opfamily.  (We don't need the latter, but we use\n\t * get_op_opfamily_properties because it will throw error if it fails to\n\t * find a matching pg_amop entry.)\n\t */\n\tget_op_opfamily_properties(clause_op, index->opfamily[indexcol], false,\n\t\t\t\t\t\t\t   &strategy_op, &lefttype, &righttype);\n\n\t/*\n\t * GIN always uses the \"default\" support functions, which are those with\n\t * lefttype == righttype == the opclass' opcintype (see\n\t * IndexSupportInitialize in relcache.c).\n\t */\n\textractProcOid = get_opfamily_proc(index->opfamily[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   GIN_EXTRACTQUERY_PROC);\n\n\tif (!OidIsValid(extractProcOid))\n\t{\n\t\t/* should not happen; throw same error as index_getprocinfo */\n\t\telog(ERROR, \"missing support function %d for attribute %d of index \\\"%s\\\"\",\n\t\t\t GIN_EXTRACTQUERY_PROC, indexcol + 1,\n\t\t\t get_rel_name(index->indexoid));\n\t}\n\n\t/*\n\t * Choose collation to pass to extractProc (should match initGinState).\n\t */\n\tif (OidIsValid(index->indexcollations[indexcol]))\n\t\tcollation = index->indexcollations[indexcol];\n\telse\n\t\tcollation = DEFAULT_COLLATION_OID;\n\n\tOidFunctionCall7Coll(extractProcOid,\n\t\t\t\t\t\t collation,\n\t\t\t\t\t\t query,\n\t\t\t\t\t\t PointerGetDatum(&nentries),\n\t\t\t\t\t\t UInt16GetDatum(strategy_op),\n\t\t\t\t\t\t PointerGetDatum(&partial_matches),\n\t\t\t\t\t\t PointerGetDatum(&extra_data),\n\t\t\t\t\t\t PointerGetDatum(&nullFlags),\n\t\t\t\t\t\t PointerGetDatum(&searchMode));\n\n\tif (nentries <= 0 && searchMode == GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* No match is possible */\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < nentries; i++)\n\t{\n\t\t/*\n\t\t * For partial match we haven't any information to estimate number of\n\t\t * matched entries in index, so, we just estimate it as 100\n\t\t */\n\t\tif (partial_matches && partial_matches[i])\n\t\t\tcounts->partialEntries += 100;\n\t\telse\n\t\t\tcounts->exactEntries++;\n\n\t\tcounts->searchEntries++;\n\t}\n\n\tif (searchMode == GIN_SEARCH_MODE_INCLUDE_EMPTY)\n\t{\n\t\t/* Treat \"include empty\" like an exact-match item */\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t}\n\telse if (searchMode != GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* It's GIN_SEARCH_MODE_ALL */\n\t\tcounts->haveFullScan = true;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ngincost_pattern(IndexOptInfo *index, int indexcol,\n\t\t\t\tOid clause_op, Datum query,\n\t\t\t\tGinQualCounts *counts)\n{\n\tOid\t\t\textractProcOid;\n\tOid\t\t\tcollation;\n\tint\t\t\tstrategy_op;\n\tOid\t\t\tlefttype,\n\t\t\t\trighttype;\n\tint32\t\tnentries = 0;\n\tbool\t   *partial_matches = NULL;\n\tPointer    *extra_data = NULL;\n\tbool\t   *nullFlags = NULL;\n\tint32\t\tsearchMode = GIN_SEARCH_MODE_DEFAULT;\n\tint32\t\ti;\n\n\tAssert(indexcol < index->nkeycolumns);\n\n\t/*\n\t * Get the operator's strategy number and declared input data types within\n\t * the index opfamily.  (We don't need the latter, but we use\n\t * get_op_opfamily_properties because it will throw error if it fails to\n\t * find a matching pg_amop entry.)\n\t */\n\tget_op_opfamily_properties(clause_op, index->opfamily[indexcol], false,\n\t\t\t\t\t\t\t   &strategy_op, &lefttype, &righttype);\n\n\t/*\n\t * GIN always uses the \"default\" support functions, which are those with\n\t * lefttype == righttype == the opclass' opcintype (see\n\t * IndexSupportInitialize in relcache.c).\n\t */\n\textractProcOid = get_opfamily_proc(index->opfamily[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   GIN_EXTRACTQUERY_PROC);\n\n\tif (!OidIsValid(extractProcOid))\n\t{\n\t\t/* should not happen; throw same error as index_getprocinfo */\n\t\telog(ERROR, \"missing support function %d for attribute %d of index \\\"%s\\\"\",\n\t\t\t GIN_EXTRACTQUERY_PROC, indexcol + 1,\n\t\t\t get_rel_name(index->indexoid));\n\t}\n\n\t/*\n\t * Choose collation to pass to extractProc (should match initGinState).\n\t */\n\tif (OidIsValid(index->indexcollations[indexcol]))\n\t\tcollation = index->indexcollations[indexcol];\n\telse\n\t\tcollation = DEFAULT_COLLATION_OID;\n\n\tOidFunctionCall7Coll(extractProcOid,\n\t\t\t\t\t\t collation,\n\t\t\t\t\t\t query,\n\t\t\t\t\t\t PointerGetDatum(&nentries),\n\t\t\t\t\t\t UInt16GetDatum(strategy_op),\n\t\t\t\t\t\t PointerGetDatum(&partial_matches),\n\t\t\t\t\t\t PointerGetDatum(&extra_data),\n\t\t\t\t\t\t PointerGetDatum(&nullFlags),\n\t\t\t\t\t\t PointerGetDatum(&searchMode));\n\n\tif (nentries <= 0 && searchMode == GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* No match is possible */\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < nentries; i++)\n\t{\n\t\t/*\n\t\t * For partial match we haven't any information to estimate number of\n\t\t * matched entries in index, so, we just estimate it as 100\n\t\t */\n\t\tif (partial_matches && partial_matches[i])\n\t\t\tcounts->partialEntries += 100;\n\t\telse\n\t\t\tcounts->exactEntries++;\n\n\t\tcounts->searchEntries++;\n\t}\n\n\tif (searchMode == GIN_SEARCH_MODE_INCLUDE_EMPTY)\n\t{\n\t\t/* Treat \"include empty\" like an exact-match item */\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t}\n\telse if (searchMode != GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* It's GIN_SEARCH_MODE_ALL */\n\t\tcounts->haveFullScan = true;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "operand",
            "Const"
          ],
          "line": 7568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "operand",
            "RelabelType"
          ],
          "line": 7560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimate_expression_value",
          "args": [
            "root",
            "operand"
          ],
          "line": 7558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_commutator",
          "args": [
            "clause_op"
          ],
          "line": 7554
        },
        "resolved": true,
        "details": {
          "function_name": "get_commutator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1297-1314",
          "snippet": "Oid\nget_commutator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprcom;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_commutator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprcom;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ngincost_opexpr(PlannerInfo *root,\n\t\t\t   IndexOptInfo *index,\n\t\t\t   IndexQualInfo *qinfo,\n\t\t\t   GinQualCounts *counts)\n{\n\tint\t\t\tindexcol = qinfo->indexcol;\n\tOid\t\t\tclause_op = qinfo->clause_op;\n\tNode\t   *operand = qinfo->other_operand;\n\n\tif (!qinfo->varonleft)\n\t{\n\t\t/* must commute the operator */\n\t\tclause_op = get_commutator(clause_op);\n\t}\n\n\t/* aggressively reduce to a constant, and look through relabeling */\n\toperand = estimate_expression_value(root, operand);\n\n\tif (IsA(operand, RelabelType))\n\t\toperand = (Node *) ((RelabelType *) operand)->arg;\n\n\t/*\n\t * It's impossible to call extractQuery method for unknown operand. So\n\t * unless operand is a Const we can't do much; just assume there will be\n\t * one ordinary search entry from the operand at runtime.\n\t */\n\tif (!IsA(operand, Const))\n\t{\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t\treturn true;\n\t}\n\n\t/* If Const is null, there can be no matches */\n\tif (((Const *) operand)->constisnull)\n\t\treturn false;\n\n\t/* Otherwise, apply extractQuery and get the actual term counts */\n\treturn gincost_pattern(index, indexcol, clause_op,\n\t\t\t\t\t\t   ((Const *) operand)->constvalue,\n\t\t\t\t\t\t   counts);\n}"
  },
  {
    "function_name": "gincost_pattern",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "7437-7534",
    "snippet": "static bool\ngincost_pattern(IndexOptInfo *index, int indexcol,\n\t\t\t\tOid clause_op, Datum query,\n\t\t\t\tGinQualCounts *counts)\n{\n\tOid\t\t\textractProcOid;\n\tOid\t\t\tcollation;\n\tint\t\t\tstrategy_op;\n\tOid\t\t\tlefttype,\n\t\t\t\trighttype;\n\tint32\t\tnentries = 0;\n\tbool\t   *partial_matches = NULL;\n\tPointer    *extra_data = NULL;\n\tbool\t   *nullFlags = NULL;\n\tint32\t\tsearchMode = GIN_SEARCH_MODE_DEFAULT;\n\tint32\t\ti;\n\n\tAssert(indexcol < index->nkeycolumns);\n\n\t/*\n\t * Get the operator's strategy number and declared input data types within\n\t * the index opfamily.  (We don't need the latter, but we use\n\t * get_op_opfamily_properties because it will throw error if it fails to\n\t * find a matching pg_amop entry.)\n\t */\n\tget_op_opfamily_properties(clause_op, index->opfamily[indexcol], false,\n\t\t\t\t\t\t\t   &strategy_op, &lefttype, &righttype);\n\n\t/*\n\t * GIN always uses the \"default\" support functions, which are those with\n\t * lefttype == righttype == the opclass' opcintype (see\n\t * IndexSupportInitialize in relcache.c).\n\t */\n\textractProcOid = get_opfamily_proc(index->opfamily[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   GIN_EXTRACTQUERY_PROC);\n\n\tif (!OidIsValid(extractProcOid))\n\t{\n\t\t/* should not happen; throw same error as index_getprocinfo */\n\t\telog(ERROR, \"missing support function %d for attribute %d of index \\\"%s\\\"\",\n\t\t\t GIN_EXTRACTQUERY_PROC, indexcol + 1,\n\t\t\t get_rel_name(index->indexoid));\n\t}\n\n\t/*\n\t * Choose collation to pass to extractProc (should match initGinState).\n\t */\n\tif (OidIsValid(index->indexcollations[indexcol]))\n\t\tcollation = index->indexcollations[indexcol];\n\telse\n\t\tcollation = DEFAULT_COLLATION_OID;\n\n\tOidFunctionCall7Coll(extractProcOid,\n\t\t\t\t\t\t collation,\n\t\t\t\t\t\t query,\n\t\t\t\t\t\t PointerGetDatum(&nentries),\n\t\t\t\t\t\t UInt16GetDatum(strategy_op),\n\t\t\t\t\t\t PointerGetDatum(&partial_matches),\n\t\t\t\t\t\t PointerGetDatum(&extra_data),\n\t\t\t\t\t\t PointerGetDatum(&nullFlags),\n\t\t\t\t\t\t PointerGetDatum(&searchMode));\n\n\tif (nentries <= 0 && searchMode == GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* No match is possible */\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < nentries; i++)\n\t{\n\t\t/*\n\t\t * For partial match we haven't any information to estimate number of\n\t\t * matched entries in index, so, we just estimate it as 100\n\t\t */\n\t\tif (partial_matches && partial_matches[i])\n\t\t\tcounts->partialEntries += 100;\n\t\telse\n\t\t\tcounts->exactEntries++;\n\n\t\tcounts->searchEntries++;\n\t}\n\n\tif (searchMode == GIN_SEARCH_MODE_INCLUDE_EMPTY)\n\t{\n\t\t/* Treat \"include empty\" like an exact-match item */\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t}\n\telse if (searchMode != GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* It's GIN_SEARCH_MODE_ALL */\n\t\tcounts->haveFullScan = true;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OidFunctionCall7Coll",
          "args": [
            "extractProcOid",
            "collation",
            "query",
            "PointerGetDatum(&nentries)",
            "UInt16GetDatum(strategy_op)",
            "PointerGetDatum(&partial_matches)",
            "PointerGetDatum(&extra_data)",
            "PointerGetDatum(&nullFlags)",
            "PointerGetDatum(&searchMode)"
          ],
          "line": 7491
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall7Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1577-1612",
          "snippet": "Datum\nOidFunctionCall7Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 7, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall7Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 7, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "&searchMode"
          ],
          "line": 7499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "&nullFlags"
          ],
          "line": 7498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "&extra_data"
          ],
          "line": 7497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "&partial_matches"
          ],
          "line": 7496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UInt16GetDatum",
          "args": [
            "strategy_op"
          ],
          "line": 7495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "&nentries"
          ],
          "line": 7494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "index->indexcollations[indexcol]"
          ],
          "line": 7486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"missing support function %d for attribute %d of index \\\"%s\\\"\"",
            "GIN_EXTRACTQUERY_PROC",
            "indexcol + 1",
            "get_rel_name(index->indexoid)"
          ],
          "line": 7478
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rel_name",
          "args": [
            "index->indexoid"
          ],
          "line": 7480
        },
        "resolved": true,
        "details": {
          "function_name": "get_rel_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1753-1770",
          "snippet": "Oid\nget_rel_namespace(Oid relid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = reltup->relnamespace;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_rel_namespace(Oid relid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_class reltup = (Form_pg_class) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = reltup->relnamespace;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "extractProcOid"
          ],
          "line": 7475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_opfamily_proc",
          "args": [
            "index->opfamily[indexcol]",
            "index->opcintype[indexcol]",
            "index->opcintype[indexcol]",
            "GIN_EXTRACTQUERY_PROC"
          ],
          "line": 7470
        },
        "resolved": true,
        "details": {
          "function_name": "get_opfamily_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "743-761",
          "snippet": "Oid\nget_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amproc amproc_tup;\n\tRegProcedure result;\n\n\ttp = SearchSysCache4(AMPROCNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(procnum));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamproc_tup = (Form_pg_amproc) GETSTRUCT(tp);\n\tresult = amproc_tup->amproc;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opfamily_proc(Oid opfamily, Oid lefttype, Oid righttype, int16 procnum)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amproc amproc_tup;\n\tRegProcedure result;\n\n\ttp = SearchSysCache4(AMPROCNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(procnum));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamproc_tup = (Form_pg_amproc) GETSTRUCT(tp);\n\tresult = amproc_tup->amproc;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_op_opfamily_properties",
          "args": [
            "clause_op",
            "index->opfamily[indexcol]",
            "false",
            "&strategy_op",
            "&lefttype",
            "&righttype"
          ],
          "line": 7462
        },
        "resolved": true,
        "details": {
          "function_name": "get_op_opfamily_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "132-153",
          "snippet": "void\nget_op_opfamily_properties(Oid opno, Oid opfamily, bool ordering_op,\n\t\t\t\t\t\t   int *strategy,\n\t\t\t\t\t\t   Oid *lefttype,\n\t\t\t\t\t\t   Oid *righttype)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(ordering_op ? AMOP_ORDER : AMOP_SEARCH),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"operator %u is not a member of opfamily %u\",\n\t\t\t opno, opfamily);\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\t*strategy = amop_tup->amopstrategy;\n\t*lefttype = amop_tup->amoplefttype;\n\t*righttype = amop_tup->amoprighttype;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_op_opfamily_properties(Oid opno, Oid opfamily, bool ordering_op,\n\t\t\t\t\t\t   int *strategy,\n\t\t\t\t\t\t   Oid *lefttype,\n\t\t\t\t\t\t   Oid *righttype)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(ordering_op ? AMOP_ORDER : AMOP_SEARCH),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"operator %u is not a member of opfamily %u\",\n\t\t\t opno, opfamily);\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\t*strategy = amop_tup->amopstrategy;\n\t*lefttype = amop_tup->amoplefttype;\n\t*righttype = amop_tup->amoprighttype;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "indexcol < index->nkeycolumns"
          ],
          "line": 7454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ngincost_pattern(IndexOptInfo *index, int indexcol,\n\t\t\t\tOid clause_op, Datum query,\n\t\t\t\tGinQualCounts *counts)\n{\n\tOid\t\t\textractProcOid;\n\tOid\t\t\tcollation;\n\tint\t\t\tstrategy_op;\n\tOid\t\t\tlefttype,\n\t\t\t\trighttype;\n\tint32\t\tnentries = 0;\n\tbool\t   *partial_matches = NULL;\n\tPointer    *extra_data = NULL;\n\tbool\t   *nullFlags = NULL;\n\tint32\t\tsearchMode = GIN_SEARCH_MODE_DEFAULT;\n\tint32\t\ti;\n\n\tAssert(indexcol < index->nkeycolumns);\n\n\t/*\n\t * Get the operator's strategy number and declared input data types within\n\t * the index opfamily.  (We don't need the latter, but we use\n\t * get_op_opfamily_properties because it will throw error if it fails to\n\t * find a matching pg_amop entry.)\n\t */\n\tget_op_opfamily_properties(clause_op, index->opfamily[indexcol], false,\n\t\t\t\t\t\t\t   &strategy_op, &lefttype, &righttype);\n\n\t/*\n\t * GIN always uses the \"default\" support functions, which are those with\n\t * lefttype == righttype == the opclass' opcintype (see\n\t * IndexSupportInitialize in relcache.c).\n\t */\n\textractProcOid = get_opfamily_proc(index->opfamily[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   index->opcintype[indexcol],\n\t\t\t\t\t\t\t\t\t   GIN_EXTRACTQUERY_PROC);\n\n\tif (!OidIsValid(extractProcOid))\n\t{\n\t\t/* should not happen; throw same error as index_getprocinfo */\n\t\telog(ERROR, \"missing support function %d for attribute %d of index \\\"%s\\\"\",\n\t\t\t GIN_EXTRACTQUERY_PROC, indexcol + 1,\n\t\t\t get_rel_name(index->indexoid));\n\t}\n\n\t/*\n\t * Choose collation to pass to extractProc (should match initGinState).\n\t */\n\tif (OidIsValid(index->indexcollations[indexcol]))\n\t\tcollation = index->indexcollations[indexcol];\n\telse\n\t\tcollation = DEFAULT_COLLATION_OID;\n\n\tOidFunctionCall7Coll(extractProcOid,\n\t\t\t\t\t\t collation,\n\t\t\t\t\t\t query,\n\t\t\t\t\t\t PointerGetDatum(&nentries),\n\t\t\t\t\t\t UInt16GetDatum(strategy_op),\n\t\t\t\t\t\t PointerGetDatum(&partial_matches),\n\t\t\t\t\t\t PointerGetDatum(&extra_data),\n\t\t\t\t\t\t PointerGetDatum(&nullFlags),\n\t\t\t\t\t\t PointerGetDatum(&searchMode));\n\n\tif (nentries <= 0 && searchMode == GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* No match is possible */\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < nentries; i++)\n\t{\n\t\t/*\n\t\t * For partial match we haven't any information to estimate number of\n\t\t * matched entries in index, so, we just estimate it as 100\n\t\t */\n\t\tif (partial_matches && partial_matches[i])\n\t\t\tcounts->partialEntries += 100;\n\t\telse\n\t\t\tcounts->exactEntries++;\n\n\t\tcounts->searchEntries++;\n\t}\n\n\tif (searchMode == GIN_SEARCH_MODE_INCLUDE_EMPTY)\n\t{\n\t\t/* Treat \"include empty\" like an exact-match item */\n\t\tcounts->exactEntries++;\n\t\tcounts->searchEntries++;\n\t}\n\telse if (searchMode != GIN_SEARCH_MODE_DEFAULT)\n\t{\n\t\t/* It's GIN_SEARCH_MODE_ALL */\n\t\tcounts->haveFullScan = true;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "spgcostestimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "7357-7416",
    "snippet": "void\nspgcostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t\tCost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t\tSelectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t\tdouble *indexPages)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *qinfos;\n\tGenericCosts costs;\n\tCost\t\tdescentCost;\n\n\t/* Do preliminary analysis of indexquals */\n\tqinfos = deconstruct_indexquals(path);\n\n\tMemSet(&costs, 0, sizeof(costs));\n\n\tgenericcostestimate(root, path, loop_count, qinfos, &costs);\n\n\t/*\n\t * We model index descent costs similarly to those for btree, but to do\n\t * that we first need an idea of the tree height.  We somewhat arbitrarily\n\t * assume that the fanout is 100, meaning the tree height is at most\n\t * log100(index->pages).\n\t *\n\t * Although this computation isn't really expensive enough to require\n\t * caching, we might as well use index->tree_height to cache it.\n\t */\n\tif (index->tree_height < 0) /* unknown? */\n\t{\n\t\tif (index->pages > 1)\t/* avoid computing log(0) */\n\t\t\tindex->tree_height = (int) (log(index->pages) / log(100.0));\n\t\telse\n\t\t\tindex->tree_height = 0;\n\t}\n\n\t/*\n\t * Add a CPU-cost component to represent the costs of initial descent. We\n\t * just use log(N) here not log2(N) since the branching factor isn't\n\t * necessarily two anyway.  As for btree, charge once per SA scan.\n\t */\n\tif (index->tuples > 1)\t\t/* avoid computing log(0) */\n\t{\n\t\tdescentCost = ceil(log(index->tuples)) * cpu_operator_cost;\n\t\tcosts.indexStartupCost += descentCost;\n\t\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\t}\n\n\t/*\n\t * Likewise add a per-page charge, calculated the same as for btrees.\n\t */\n\tdescentCost = (index->tree_height + 1) * 50.0 * cpu_operator_cost;\n\tcosts.indexStartupCost += descentCost;\n\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\n\t*indexStartupCost = costs.indexStartupCost;\n\t*indexTotalCost = costs.indexTotalCost;\n\t*indexSelectivity = costs.indexSelectivity;\n\t*indexCorrelation = costs.indexCorrelation;\n\t*indexPages = costs.numIndexPages;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "log(index->tuples)"
          ],
          "line": 7399
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "index->tuples"
          ],
          "line": 7399
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "genericcostestimate",
          "args": [
            "root",
            "path",
            "loop_count",
            "qinfos",
            "&costs"
          ],
          "line": 7373
        },
        "resolved": true,
        "details": {
          "function_name": "genericcostestimate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6714-6912",
          "snippet": "void\ngenericcostestimate(PlannerInfo *root,\n\t\t\t\t\tIndexPath *path,\n\t\t\t\t\tdouble loop_count,\n\t\t\t\t\tList *qinfos,\n\t\t\t\t\tGenericCosts *costs)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tCost\t\tindexStartupCost;\n\tCost\t\tindexTotalCost;\n\tSelectivity indexSelectivity;\n\tdouble\t\tindexCorrelation;\n\tdouble\t\tnumIndexPages;\n\tdouble\t\tnumIndexTuples;\n\tdouble\t\tspc_random_page_cost;\n\tdouble\t\tnum_sa_scans;\n\tdouble\t\tnum_outer_scans;\n\tdouble\t\tnum_scans;\n\tdouble\t\tqual_op_cost;\n\tdouble\t\tqual_arg_cost;\n\tList\t   *selectivityQuals;\n\tListCell   *l;\n\n\t/*\n\t * If the index is partial, AND the index predicate with the explicitly\n\t * given indexquals to produce a more accurate idea of the index\n\t * selectivity.\n\t */\n\tselectivityQuals = add_predicate_to_quals(index, indexQuals);\n\n\t/*\n\t * Check for ScalarArrayOpExpr index quals, and estimate the number of\n\t * index scans that will be performed.\n\t */\n\tnum_sa_scans = 1;\n\tforeach(l, indexQuals)\n\t{\n\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(l);\n\n\t\tif (IsA(rinfo->clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo->clause;\n\t\t\tint\t\t\talength = estimate_array_length(lsecond(saop->args));\n\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t}\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\tindexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * If caller didn't give us an estimate, estimate the number of index\n\t * tuples that will be visited.  We do it in this rather peculiar-looking\n\t * way in order to get the right answer for partial indexes.\n\t */\n\tnumIndexTuples = costs->numIndexTuples;\n\tif (numIndexTuples <= 0.0)\n\t{\n\t\tnumIndexTuples = indexSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * The above calculation counts all the tuples visited across all\n\t\t * scans induced by ScalarArrayOpExpr nodes.  We want to consider the\n\t\t * average per-indexscan number, so adjust.  This is a handy place to\n\t\t * round to integer, too.  (If caller supplied tuple estimate, it's\n\t\t * responsible for handling these considerations.)\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * We can bound the number of tuples by the index size in any case. Also,\n\t * always estimate at least one tuple is touched, even when\n\t * indexSelectivity estimate is tiny.\n\t */\n\tif (numIndexTuples > index->tuples)\n\t\tnumIndexTuples = index->tuples;\n\tif (numIndexTuples < 1.0)\n\t\tnumIndexTuples = 1.0;\n\n\t/*\n\t * Estimate the number of index pages that will be retrieved.\n\t *\n\t * We use the simplistic method of taking a pro-rata fraction of the total\n\t * number of index pages.  In effect, this counts only leaf pages and not\n\t * any overhead such as index metapage or upper tree levels.\n\t *\n\t * In practice access to upper index levels is often nearly free because\n\t * those tend to stay in cache under load; moreover, the cost involved is\n\t * highly dependent on index type.  We therefore ignore such costs here\n\t * and leave it to the caller to add a suitable charge if needed.\n\t */\n\tif (index->pages > 1 && index->tuples > 1)\n\t\tnumIndexPages = ceil(numIndexTuples * index->pages / index->tuples);\n\telse\n\t\tnumIndexPages = 1.0;\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Now compute the disk access costs.\n\t *\n\t * The above calculations are all per-index-scan.  However, if we are in a\n\t * nestloop inner scan, we can expect the scan to be repeated (with\n\t * different search keys) for each row of the outer relation.  Likewise,\n\t * ScalarArrayOpExpr quals result in multiple index scans.  This creates\n\t * the potential for cache effects to reduce the number of disk page\n\t * fetches needed.  We want to estimate the average per-scan I/O cost in\n\t * the presence of caching.\n\t *\n\t * We use the Mackert-Lohman formula (see costsize.c for details) to\n\t * estimate the total number of page fetches that occur.  While this\n\t * wasn't what it was designed for, it seems a reasonable model anyway.\n\t * Note that we are counting pages not tuples anymore, so we take N = T =\n\t * index size, as if there were one \"tuple\" per page.\n\t */\n\tnum_outer_scans = loop_count;\n\tnum_scans = num_sa_scans * num_outer_scans;\n\n\tif (num_scans > 1)\n\t{\n\t\tdouble\t\tpages_fetched;\n\n\t\t/* total page fetches ignoring cache effects */\n\t\tpages_fetched = numIndexPages * num_scans;\n\n\t\t/* use Mackert and Lohman formula to adjust for cache effects */\n\t\tpages_fetched = index_pages_fetched(pages_fetched,\n\t\t\t\t\t\t\t\t\t\t\tindex->pages,\n\t\t\t\t\t\t\t\t\t\t\t(double) index->pages,\n\t\t\t\t\t\t\t\t\t\t\troot);\n\n\t\t/*\n\t\t * Now compute the total disk access cost, and then report a pro-rated\n\t\t * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,\n\t\t * since that's internal to the indexscan.)\n\t\t */\n\t\tindexTotalCost = (pages_fetched * spc_random_page_cost)\n\t\t\t/ num_outer_scans;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For a single index scan, we just charge spc_random_page_cost per\n\t\t * page touched.\n\t\t */\n\t\tindexTotalCost = numIndexPages * spc_random_page_cost;\n\t}\n\n\t/*\n\t * CPU cost: any complex expressions in the indexquals will need to be\n\t * evaluated once at the start of the scan to reduce them to runtime keys\n\t * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple\n\t * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per\n\t * indexqual operator.  Because we have numIndexTuples as a per-scan\n\t * number, we have to multiply by num_sa_scans to get the correct result\n\t * for ScalarArrayOpExpr cases.  Similarly add in costs for any index\n\t * ORDER BY expressions.\n\t *\n\t * Note: this neglects the possible costs of rechecking lossy operators.\n\t * Detecting that that might be needed seems more expensive than it's\n\t * worth, though, considering all the other inaccuracies here ...\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\tindexStartupCost = qual_arg_cost;\n\tindexTotalCost += qual_arg_cost;\n\tindexTotalCost += numIndexTuples * num_sa_scans * (cpu_index_tuple_cost + qual_op_cost);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\tindexCorrelation = 0.0;\n\n\t/*\n\t * Return everything to caller.\n\t */\n\tcosts->indexStartupCost = indexStartupCost;\n\tcosts->indexTotalCost = indexTotalCost;\n\tcosts->indexSelectivity = indexSelectivity;\n\tcosts->indexCorrelation = indexCorrelation;\n\tcosts->numIndexPages = numIndexPages;\n\tcosts->numIndexTuples = numIndexTuples;\n\tcosts->spc_random_page_cost = spc_random_page_cost;\n\tcosts->num_sa_scans = num_sa_scans;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);\n\nvoid\ngenericcostestimate(PlannerInfo *root,\n\t\t\t\t\tIndexPath *path,\n\t\t\t\t\tdouble loop_count,\n\t\t\t\t\tList *qinfos,\n\t\t\t\t\tGenericCosts *costs)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tCost\t\tindexStartupCost;\n\tCost\t\tindexTotalCost;\n\tSelectivity indexSelectivity;\n\tdouble\t\tindexCorrelation;\n\tdouble\t\tnumIndexPages;\n\tdouble\t\tnumIndexTuples;\n\tdouble\t\tspc_random_page_cost;\n\tdouble\t\tnum_sa_scans;\n\tdouble\t\tnum_outer_scans;\n\tdouble\t\tnum_scans;\n\tdouble\t\tqual_op_cost;\n\tdouble\t\tqual_arg_cost;\n\tList\t   *selectivityQuals;\n\tListCell   *l;\n\n\t/*\n\t * If the index is partial, AND the index predicate with the explicitly\n\t * given indexquals to produce a more accurate idea of the index\n\t * selectivity.\n\t */\n\tselectivityQuals = add_predicate_to_quals(index, indexQuals);\n\n\t/*\n\t * Check for ScalarArrayOpExpr index quals, and estimate the number of\n\t * index scans that will be performed.\n\t */\n\tnum_sa_scans = 1;\n\tforeach(l, indexQuals)\n\t{\n\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(l);\n\n\t\tif (IsA(rinfo->clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo->clause;\n\t\t\tint\t\t\talength = estimate_array_length(lsecond(saop->args));\n\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t}\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\tindexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * If caller didn't give us an estimate, estimate the number of index\n\t * tuples that will be visited.  We do it in this rather peculiar-looking\n\t * way in order to get the right answer for partial indexes.\n\t */\n\tnumIndexTuples = costs->numIndexTuples;\n\tif (numIndexTuples <= 0.0)\n\t{\n\t\tnumIndexTuples = indexSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * The above calculation counts all the tuples visited across all\n\t\t * scans induced by ScalarArrayOpExpr nodes.  We want to consider the\n\t\t * average per-indexscan number, so adjust.  This is a handy place to\n\t\t * round to integer, too.  (If caller supplied tuple estimate, it's\n\t\t * responsible for handling these considerations.)\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * We can bound the number of tuples by the index size in any case. Also,\n\t * always estimate at least one tuple is touched, even when\n\t * indexSelectivity estimate is tiny.\n\t */\n\tif (numIndexTuples > index->tuples)\n\t\tnumIndexTuples = index->tuples;\n\tif (numIndexTuples < 1.0)\n\t\tnumIndexTuples = 1.0;\n\n\t/*\n\t * Estimate the number of index pages that will be retrieved.\n\t *\n\t * We use the simplistic method of taking a pro-rata fraction of the total\n\t * number of index pages.  In effect, this counts only leaf pages and not\n\t * any overhead such as index metapage or upper tree levels.\n\t *\n\t * In practice access to upper index levels is often nearly free because\n\t * those tend to stay in cache under load; moreover, the cost involved is\n\t * highly dependent on index type.  We therefore ignore such costs here\n\t * and leave it to the caller to add a suitable charge if needed.\n\t */\n\tif (index->pages > 1 && index->tuples > 1)\n\t\tnumIndexPages = ceil(numIndexTuples * index->pages / index->tuples);\n\telse\n\t\tnumIndexPages = 1.0;\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Now compute the disk access costs.\n\t *\n\t * The above calculations are all per-index-scan.  However, if we are in a\n\t * nestloop inner scan, we can expect the scan to be repeated (with\n\t * different search keys) for each row of the outer relation.  Likewise,\n\t * ScalarArrayOpExpr quals result in multiple index scans.  This creates\n\t * the potential for cache effects to reduce the number of disk page\n\t * fetches needed.  We want to estimate the average per-scan I/O cost in\n\t * the presence of caching.\n\t *\n\t * We use the Mackert-Lohman formula (see costsize.c for details) to\n\t * estimate the total number of page fetches that occur.  While this\n\t * wasn't what it was designed for, it seems a reasonable model anyway.\n\t * Note that we are counting pages not tuples anymore, so we take N = T =\n\t * index size, as if there were one \"tuple\" per page.\n\t */\n\tnum_outer_scans = loop_count;\n\tnum_scans = num_sa_scans * num_outer_scans;\n\n\tif (num_scans > 1)\n\t{\n\t\tdouble\t\tpages_fetched;\n\n\t\t/* total page fetches ignoring cache effects */\n\t\tpages_fetched = numIndexPages * num_scans;\n\n\t\t/* use Mackert and Lohman formula to adjust for cache effects */\n\t\tpages_fetched = index_pages_fetched(pages_fetched,\n\t\t\t\t\t\t\t\t\t\t\tindex->pages,\n\t\t\t\t\t\t\t\t\t\t\t(double) index->pages,\n\t\t\t\t\t\t\t\t\t\t\troot);\n\n\t\t/*\n\t\t * Now compute the total disk access cost, and then report a pro-rated\n\t\t * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,\n\t\t * since that's internal to the indexscan.)\n\t\t */\n\t\tindexTotalCost = (pages_fetched * spc_random_page_cost)\n\t\t\t/ num_outer_scans;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For a single index scan, we just charge spc_random_page_cost per\n\t\t * page touched.\n\t\t */\n\t\tindexTotalCost = numIndexPages * spc_random_page_cost;\n\t}\n\n\t/*\n\t * CPU cost: any complex expressions in the indexquals will need to be\n\t * evaluated once at the start of the scan to reduce them to runtime keys\n\t * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple\n\t * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per\n\t * indexqual operator.  Because we have numIndexTuples as a per-scan\n\t * number, we have to multiply by num_sa_scans to get the correct result\n\t * for ScalarArrayOpExpr cases.  Similarly add in costs for any index\n\t * ORDER BY expressions.\n\t *\n\t * Note: this neglects the possible costs of rechecking lossy operators.\n\t * Detecting that that might be needed seems more expensive than it's\n\t * worth, though, considering all the other inaccuracies here ...\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\tindexStartupCost = qual_arg_cost;\n\tindexTotalCost += qual_arg_cost;\n\tindexTotalCost += numIndexTuples * num_sa_scans * (cpu_index_tuple_cost + qual_op_cost);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\tindexCorrelation = 0.0;\n\n\t/*\n\t * Return everything to caller.\n\t */\n\tcosts->indexStartupCost = indexStartupCost;\n\tcosts->indexTotalCost = indexTotalCost;\n\tcosts->indexSelectivity = indexSelectivity;\n\tcosts->indexCorrelation = indexCorrelation;\n\tcosts->numIndexPages = numIndexPages;\n\tcosts->numIndexTuples = numIndexTuples;\n\tcosts->spc_random_page_cost = spc_random_page_cost;\n\tcosts->num_sa_scans = num_sa_scans;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&costs",
            "0",
            "sizeof(costs)"
          ],
          "line": 7371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_indexquals",
          "args": [
            "path"
          ],
          "line": 7369
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_indexquals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6565-6653",
          "snippet": "List *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nspgcostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t\tCost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t\tSelectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t\tdouble *indexPages)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *qinfos;\n\tGenericCosts costs;\n\tCost\t\tdescentCost;\n\n\t/* Do preliminary analysis of indexquals */\n\tqinfos = deconstruct_indexquals(path);\n\n\tMemSet(&costs, 0, sizeof(costs));\n\n\tgenericcostestimate(root, path, loop_count, qinfos, &costs);\n\n\t/*\n\t * We model index descent costs similarly to those for btree, but to do\n\t * that we first need an idea of the tree height.  We somewhat arbitrarily\n\t * assume that the fanout is 100, meaning the tree height is at most\n\t * log100(index->pages).\n\t *\n\t * Although this computation isn't really expensive enough to require\n\t * caching, we might as well use index->tree_height to cache it.\n\t */\n\tif (index->tree_height < 0) /* unknown? */\n\t{\n\t\tif (index->pages > 1)\t/* avoid computing log(0) */\n\t\t\tindex->tree_height = (int) (log(index->pages) / log(100.0));\n\t\telse\n\t\t\tindex->tree_height = 0;\n\t}\n\n\t/*\n\t * Add a CPU-cost component to represent the costs of initial descent. We\n\t * just use log(N) here not log2(N) since the branching factor isn't\n\t * necessarily two anyway.  As for btree, charge once per SA scan.\n\t */\n\tif (index->tuples > 1)\t\t/* avoid computing log(0) */\n\t{\n\t\tdescentCost = ceil(log(index->tuples)) * cpu_operator_cost;\n\t\tcosts.indexStartupCost += descentCost;\n\t\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\t}\n\n\t/*\n\t * Likewise add a per-page charge, calculated the same as for btrees.\n\t */\n\tdescentCost = (index->tree_height + 1) * 50.0 * cpu_operator_cost;\n\tcosts.indexStartupCost += descentCost;\n\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\n\t*indexStartupCost = costs.indexStartupCost;\n\t*indexTotalCost = costs.indexTotalCost;\n\t*indexSelectivity = costs.indexSelectivity;\n\t*indexCorrelation = costs.indexCorrelation;\n\t*indexPages = costs.numIndexPages;\n}"
  },
  {
    "function_name": "gistcostestimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "7296-7355",
    "snippet": "void\ngistcostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t\t Cost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t\t Selectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t\t double *indexPages)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *qinfos;\n\tGenericCosts costs;\n\tCost\t\tdescentCost;\n\n\t/* Do preliminary analysis of indexquals */\n\tqinfos = deconstruct_indexquals(path);\n\n\tMemSet(&costs, 0, sizeof(costs));\n\n\tgenericcostestimate(root, path, loop_count, qinfos, &costs);\n\n\t/*\n\t * We model index descent costs similarly to those for btree, but to do\n\t * that we first need an idea of the tree height.  We somewhat arbitrarily\n\t * assume that the fanout is 100, meaning the tree height is at most\n\t * log100(index->pages).\n\t *\n\t * Although this computation isn't really expensive enough to require\n\t * caching, we might as well use index->tree_height to cache it.\n\t */\n\tif (index->tree_height < 0) /* unknown? */\n\t{\n\t\tif (index->pages > 1)\t/* avoid computing log(0) */\n\t\t\tindex->tree_height = (int) (log(index->pages) / log(100.0));\n\t\telse\n\t\t\tindex->tree_height = 0;\n\t}\n\n\t/*\n\t * Add a CPU-cost component to represent the costs of initial descent. We\n\t * just use log(N) here not log2(N) since the branching factor isn't\n\t * necessarily two anyway.  As for btree, charge once per SA scan.\n\t */\n\tif (index->tuples > 1)\t\t/* avoid computing log(0) */\n\t{\n\t\tdescentCost = ceil(log(index->tuples)) * cpu_operator_cost;\n\t\tcosts.indexStartupCost += descentCost;\n\t\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\t}\n\n\t/*\n\t * Likewise add a per-page charge, calculated the same as for btrees.\n\t */\n\tdescentCost = (index->tree_height + 1) * 50.0 * cpu_operator_cost;\n\tcosts.indexStartupCost += descentCost;\n\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\n\t*indexStartupCost = costs.indexStartupCost;\n\t*indexTotalCost = costs.indexTotalCost;\n\t*indexSelectivity = costs.indexSelectivity;\n\t*indexCorrelation = costs.indexCorrelation;\n\t*indexPages = costs.numIndexPages;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "log(index->tuples)"
          ],
          "line": 7338
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "index->tuples"
          ],
          "line": 7338
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "genericcostestimate",
          "args": [
            "root",
            "path",
            "loop_count",
            "qinfos",
            "&costs"
          ],
          "line": 7312
        },
        "resolved": true,
        "details": {
          "function_name": "genericcostestimate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6714-6912",
          "snippet": "void\ngenericcostestimate(PlannerInfo *root,\n\t\t\t\t\tIndexPath *path,\n\t\t\t\t\tdouble loop_count,\n\t\t\t\t\tList *qinfos,\n\t\t\t\t\tGenericCosts *costs)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tCost\t\tindexStartupCost;\n\tCost\t\tindexTotalCost;\n\tSelectivity indexSelectivity;\n\tdouble\t\tindexCorrelation;\n\tdouble\t\tnumIndexPages;\n\tdouble\t\tnumIndexTuples;\n\tdouble\t\tspc_random_page_cost;\n\tdouble\t\tnum_sa_scans;\n\tdouble\t\tnum_outer_scans;\n\tdouble\t\tnum_scans;\n\tdouble\t\tqual_op_cost;\n\tdouble\t\tqual_arg_cost;\n\tList\t   *selectivityQuals;\n\tListCell   *l;\n\n\t/*\n\t * If the index is partial, AND the index predicate with the explicitly\n\t * given indexquals to produce a more accurate idea of the index\n\t * selectivity.\n\t */\n\tselectivityQuals = add_predicate_to_quals(index, indexQuals);\n\n\t/*\n\t * Check for ScalarArrayOpExpr index quals, and estimate the number of\n\t * index scans that will be performed.\n\t */\n\tnum_sa_scans = 1;\n\tforeach(l, indexQuals)\n\t{\n\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(l);\n\n\t\tif (IsA(rinfo->clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo->clause;\n\t\t\tint\t\t\talength = estimate_array_length(lsecond(saop->args));\n\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t}\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\tindexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * If caller didn't give us an estimate, estimate the number of index\n\t * tuples that will be visited.  We do it in this rather peculiar-looking\n\t * way in order to get the right answer for partial indexes.\n\t */\n\tnumIndexTuples = costs->numIndexTuples;\n\tif (numIndexTuples <= 0.0)\n\t{\n\t\tnumIndexTuples = indexSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * The above calculation counts all the tuples visited across all\n\t\t * scans induced by ScalarArrayOpExpr nodes.  We want to consider the\n\t\t * average per-indexscan number, so adjust.  This is a handy place to\n\t\t * round to integer, too.  (If caller supplied tuple estimate, it's\n\t\t * responsible for handling these considerations.)\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * We can bound the number of tuples by the index size in any case. Also,\n\t * always estimate at least one tuple is touched, even when\n\t * indexSelectivity estimate is tiny.\n\t */\n\tif (numIndexTuples > index->tuples)\n\t\tnumIndexTuples = index->tuples;\n\tif (numIndexTuples < 1.0)\n\t\tnumIndexTuples = 1.0;\n\n\t/*\n\t * Estimate the number of index pages that will be retrieved.\n\t *\n\t * We use the simplistic method of taking a pro-rata fraction of the total\n\t * number of index pages.  In effect, this counts only leaf pages and not\n\t * any overhead such as index metapage or upper tree levels.\n\t *\n\t * In practice access to upper index levels is often nearly free because\n\t * those tend to stay in cache under load; moreover, the cost involved is\n\t * highly dependent on index type.  We therefore ignore such costs here\n\t * and leave it to the caller to add a suitable charge if needed.\n\t */\n\tif (index->pages > 1 && index->tuples > 1)\n\t\tnumIndexPages = ceil(numIndexTuples * index->pages / index->tuples);\n\telse\n\t\tnumIndexPages = 1.0;\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Now compute the disk access costs.\n\t *\n\t * The above calculations are all per-index-scan.  However, if we are in a\n\t * nestloop inner scan, we can expect the scan to be repeated (with\n\t * different search keys) for each row of the outer relation.  Likewise,\n\t * ScalarArrayOpExpr quals result in multiple index scans.  This creates\n\t * the potential for cache effects to reduce the number of disk page\n\t * fetches needed.  We want to estimate the average per-scan I/O cost in\n\t * the presence of caching.\n\t *\n\t * We use the Mackert-Lohman formula (see costsize.c for details) to\n\t * estimate the total number of page fetches that occur.  While this\n\t * wasn't what it was designed for, it seems a reasonable model anyway.\n\t * Note that we are counting pages not tuples anymore, so we take N = T =\n\t * index size, as if there were one \"tuple\" per page.\n\t */\n\tnum_outer_scans = loop_count;\n\tnum_scans = num_sa_scans * num_outer_scans;\n\n\tif (num_scans > 1)\n\t{\n\t\tdouble\t\tpages_fetched;\n\n\t\t/* total page fetches ignoring cache effects */\n\t\tpages_fetched = numIndexPages * num_scans;\n\n\t\t/* use Mackert and Lohman formula to adjust for cache effects */\n\t\tpages_fetched = index_pages_fetched(pages_fetched,\n\t\t\t\t\t\t\t\t\t\t\tindex->pages,\n\t\t\t\t\t\t\t\t\t\t\t(double) index->pages,\n\t\t\t\t\t\t\t\t\t\t\troot);\n\n\t\t/*\n\t\t * Now compute the total disk access cost, and then report a pro-rated\n\t\t * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,\n\t\t * since that's internal to the indexscan.)\n\t\t */\n\t\tindexTotalCost = (pages_fetched * spc_random_page_cost)\n\t\t\t/ num_outer_scans;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For a single index scan, we just charge spc_random_page_cost per\n\t\t * page touched.\n\t\t */\n\t\tindexTotalCost = numIndexPages * spc_random_page_cost;\n\t}\n\n\t/*\n\t * CPU cost: any complex expressions in the indexquals will need to be\n\t * evaluated once at the start of the scan to reduce them to runtime keys\n\t * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple\n\t * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per\n\t * indexqual operator.  Because we have numIndexTuples as a per-scan\n\t * number, we have to multiply by num_sa_scans to get the correct result\n\t * for ScalarArrayOpExpr cases.  Similarly add in costs for any index\n\t * ORDER BY expressions.\n\t *\n\t * Note: this neglects the possible costs of rechecking lossy operators.\n\t * Detecting that that might be needed seems more expensive than it's\n\t * worth, though, considering all the other inaccuracies here ...\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\tindexStartupCost = qual_arg_cost;\n\tindexTotalCost += qual_arg_cost;\n\tindexTotalCost += numIndexTuples * num_sa_scans * (cpu_index_tuple_cost + qual_op_cost);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\tindexCorrelation = 0.0;\n\n\t/*\n\t * Return everything to caller.\n\t */\n\tcosts->indexStartupCost = indexStartupCost;\n\tcosts->indexTotalCost = indexTotalCost;\n\tcosts->indexSelectivity = indexSelectivity;\n\tcosts->indexCorrelation = indexCorrelation;\n\tcosts->numIndexPages = numIndexPages;\n\tcosts->numIndexTuples = numIndexTuples;\n\tcosts->spc_random_page_cost = spc_random_page_cost;\n\tcosts->num_sa_scans = num_sa_scans;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);\n\nvoid\ngenericcostestimate(PlannerInfo *root,\n\t\t\t\t\tIndexPath *path,\n\t\t\t\t\tdouble loop_count,\n\t\t\t\t\tList *qinfos,\n\t\t\t\t\tGenericCosts *costs)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tCost\t\tindexStartupCost;\n\tCost\t\tindexTotalCost;\n\tSelectivity indexSelectivity;\n\tdouble\t\tindexCorrelation;\n\tdouble\t\tnumIndexPages;\n\tdouble\t\tnumIndexTuples;\n\tdouble\t\tspc_random_page_cost;\n\tdouble\t\tnum_sa_scans;\n\tdouble\t\tnum_outer_scans;\n\tdouble\t\tnum_scans;\n\tdouble\t\tqual_op_cost;\n\tdouble\t\tqual_arg_cost;\n\tList\t   *selectivityQuals;\n\tListCell   *l;\n\n\t/*\n\t * If the index is partial, AND the index predicate with the explicitly\n\t * given indexquals to produce a more accurate idea of the index\n\t * selectivity.\n\t */\n\tselectivityQuals = add_predicate_to_quals(index, indexQuals);\n\n\t/*\n\t * Check for ScalarArrayOpExpr index quals, and estimate the number of\n\t * index scans that will be performed.\n\t */\n\tnum_sa_scans = 1;\n\tforeach(l, indexQuals)\n\t{\n\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(l);\n\n\t\tif (IsA(rinfo->clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo->clause;\n\t\t\tint\t\t\talength = estimate_array_length(lsecond(saop->args));\n\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t}\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\tindexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * If caller didn't give us an estimate, estimate the number of index\n\t * tuples that will be visited.  We do it in this rather peculiar-looking\n\t * way in order to get the right answer for partial indexes.\n\t */\n\tnumIndexTuples = costs->numIndexTuples;\n\tif (numIndexTuples <= 0.0)\n\t{\n\t\tnumIndexTuples = indexSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * The above calculation counts all the tuples visited across all\n\t\t * scans induced by ScalarArrayOpExpr nodes.  We want to consider the\n\t\t * average per-indexscan number, so adjust.  This is a handy place to\n\t\t * round to integer, too.  (If caller supplied tuple estimate, it's\n\t\t * responsible for handling these considerations.)\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * We can bound the number of tuples by the index size in any case. Also,\n\t * always estimate at least one tuple is touched, even when\n\t * indexSelectivity estimate is tiny.\n\t */\n\tif (numIndexTuples > index->tuples)\n\t\tnumIndexTuples = index->tuples;\n\tif (numIndexTuples < 1.0)\n\t\tnumIndexTuples = 1.0;\n\n\t/*\n\t * Estimate the number of index pages that will be retrieved.\n\t *\n\t * We use the simplistic method of taking a pro-rata fraction of the total\n\t * number of index pages.  In effect, this counts only leaf pages and not\n\t * any overhead such as index metapage or upper tree levels.\n\t *\n\t * In practice access to upper index levels is often nearly free because\n\t * those tend to stay in cache under load; moreover, the cost involved is\n\t * highly dependent on index type.  We therefore ignore such costs here\n\t * and leave it to the caller to add a suitable charge if needed.\n\t */\n\tif (index->pages > 1 && index->tuples > 1)\n\t\tnumIndexPages = ceil(numIndexTuples * index->pages / index->tuples);\n\telse\n\t\tnumIndexPages = 1.0;\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Now compute the disk access costs.\n\t *\n\t * The above calculations are all per-index-scan.  However, if we are in a\n\t * nestloop inner scan, we can expect the scan to be repeated (with\n\t * different search keys) for each row of the outer relation.  Likewise,\n\t * ScalarArrayOpExpr quals result in multiple index scans.  This creates\n\t * the potential for cache effects to reduce the number of disk page\n\t * fetches needed.  We want to estimate the average per-scan I/O cost in\n\t * the presence of caching.\n\t *\n\t * We use the Mackert-Lohman formula (see costsize.c for details) to\n\t * estimate the total number of page fetches that occur.  While this\n\t * wasn't what it was designed for, it seems a reasonable model anyway.\n\t * Note that we are counting pages not tuples anymore, so we take N = T =\n\t * index size, as if there were one \"tuple\" per page.\n\t */\n\tnum_outer_scans = loop_count;\n\tnum_scans = num_sa_scans * num_outer_scans;\n\n\tif (num_scans > 1)\n\t{\n\t\tdouble\t\tpages_fetched;\n\n\t\t/* total page fetches ignoring cache effects */\n\t\tpages_fetched = numIndexPages * num_scans;\n\n\t\t/* use Mackert and Lohman formula to adjust for cache effects */\n\t\tpages_fetched = index_pages_fetched(pages_fetched,\n\t\t\t\t\t\t\t\t\t\t\tindex->pages,\n\t\t\t\t\t\t\t\t\t\t\t(double) index->pages,\n\t\t\t\t\t\t\t\t\t\t\troot);\n\n\t\t/*\n\t\t * Now compute the total disk access cost, and then report a pro-rated\n\t\t * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,\n\t\t * since that's internal to the indexscan.)\n\t\t */\n\t\tindexTotalCost = (pages_fetched * spc_random_page_cost)\n\t\t\t/ num_outer_scans;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For a single index scan, we just charge spc_random_page_cost per\n\t\t * page touched.\n\t\t */\n\t\tindexTotalCost = numIndexPages * spc_random_page_cost;\n\t}\n\n\t/*\n\t * CPU cost: any complex expressions in the indexquals will need to be\n\t * evaluated once at the start of the scan to reduce them to runtime keys\n\t * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple\n\t * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per\n\t * indexqual operator.  Because we have numIndexTuples as a per-scan\n\t * number, we have to multiply by num_sa_scans to get the correct result\n\t * for ScalarArrayOpExpr cases.  Similarly add in costs for any index\n\t * ORDER BY expressions.\n\t *\n\t * Note: this neglects the possible costs of rechecking lossy operators.\n\t * Detecting that that might be needed seems more expensive than it's\n\t * worth, though, considering all the other inaccuracies here ...\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\tindexStartupCost = qual_arg_cost;\n\tindexTotalCost += qual_arg_cost;\n\tindexTotalCost += numIndexTuples * num_sa_scans * (cpu_index_tuple_cost + qual_op_cost);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\tindexCorrelation = 0.0;\n\n\t/*\n\t * Return everything to caller.\n\t */\n\tcosts->indexStartupCost = indexStartupCost;\n\tcosts->indexTotalCost = indexTotalCost;\n\tcosts->indexSelectivity = indexSelectivity;\n\tcosts->indexCorrelation = indexCorrelation;\n\tcosts->numIndexPages = numIndexPages;\n\tcosts->numIndexTuples = numIndexTuples;\n\tcosts->spc_random_page_cost = spc_random_page_cost;\n\tcosts->num_sa_scans = num_sa_scans;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&costs",
            "0",
            "sizeof(costs)"
          ],
          "line": 7310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_indexquals",
          "args": [
            "path"
          ],
          "line": 7308
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_indexquals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6565-6653",
          "snippet": "List *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\ngistcostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t\t Cost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t\t Selectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t\t double *indexPages)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *qinfos;\n\tGenericCosts costs;\n\tCost\t\tdescentCost;\n\n\t/* Do preliminary analysis of indexquals */\n\tqinfos = deconstruct_indexquals(path);\n\n\tMemSet(&costs, 0, sizeof(costs));\n\n\tgenericcostestimate(root, path, loop_count, qinfos, &costs);\n\n\t/*\n\t * We model index descent costs similarly to those for btree, but to do\n\t * that we first need an idea of the tree height.  We somewhat arbitrarily\n\t * assume that the fanout is 100, meaning the tree height is at most\n\t * log100(index->pages).\n\t *\n\t * Although this computation isn't really expensive enough to require\n\t * caching, we might as well use index->tree_height to cache it.\n\t */\n\tif (index->tree_height < 0) /* unknown? */\n\t{\n\t\tif (index->pages > 1)\t/* avoid computing log(0) */\n\t\t\tindex->tree_height = (int) (log(index->pages) / log(100.0));\n\t\telse\n\t\t\tindex->tree_height = 0;\n\t}\n\n\t/*\n\t * Add a CPU-cost component to represent the costs of initial descent. We\n\t * just use log(N) here not log2(N) since the branching factor isn't\n\t * necessarily two anyway.  As for btree, charge once per SA scan.\n\t */\n\tif (index->tuples > 1)\t\t/* avoid computing log(0) */\n\t{\n\t\tdescentCost = ceil(log(index->tuples)) * cpu_operator_cost;\n\t\tcosts.indexStartupCost += descentCost;\n\t\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\t}\n\n\t/*\n\t * Likewise add a per-page charge, calculated the same as for btrees.\n\t */\n\tdescentCost = (index->tree_height + 1) * 50.0 * cpu_operator_cost;\n\tcosts.indexStartupCost += descentCost;\n\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\n\t*indexStartupCost = costs.indexStartupCost;\n\t*indexTotalCost = costs.indexTotalCost;\n\t*indexSelectivity = costs.indexSelectivity;\n\t*indexCorrelation = costs.indexCorrelation;\n\t*indexPages = costs.numIndexPages;\n}"
  },
  {
    "function_name": "hashcostestimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "7248-7294",
    "snippet": "void\nhashcostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t\t Cost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t\t Selectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t\t double *indexPages)\n{\n\tList\t   *qinfos;\n\tGenericCosts costs;\n\n\t/* Do preliminary analysis of indexquals */\n\tqinfos = deconstruct_indexquals(path);\n\n\tMemSet(&costs, 0, sizeof(costs));\n\n\tgenericcostestimate(root, path, loop_count, qinfos, &costs);\n\n\t/*\n\t * A hash index has no descent costs as such, since the index AM can go\n\t * directly to the target bucket after computing the hash value.  There\n\t * are a couple of other hash-specific costs that we could conceivably add\n\t * here, though:\n\t *\n\t * Ideally we'd charge spc_random_page_cost for each page in the target\n\t * bucket, not just the numIndexPages pages that genericcostestimate\n\t * thought we'd visit.  However in most cases we don't know which bucket\n\t * that will be.  There's no point in considering the average bucket size\n\t * because the hash AM makes sure that's always one page.\n\t *\n\t * Likewise, we could consider charging some CPU for each index tuple in\n\t * the bucket, if we knew how many there were.  But the per-tuple cost is\n\t * just a hash value comparison, not a general datatype-dependent\n\t * comparison, so any such charge ought to be quite a bit less than\n\t * cpu_operator_cost; which makes it probably not worth worrying about.\n\t *\n\t * A bigger issue is that chance hash-value collisions will result in\n\t * wasted probes into the heap.  We don't currently attempt to model this\n\t * cost on the grounds that it's rare, but maybe it's not rare enough.\n\t * (Any fix for this ought to consider the generic lossy-operator problem,\n\t * though; it's not entirely hash-specific.)\n\t */\n\n\t*indexStartupCost = costs.indexStartupCost;\n\t*indexTotalCost = costs.indexTotalCost;\n\t*indexSelectivity = costs.indexSelectivity;\n\t*indexCorrelation = costs.indexCorrelation;\n\t*indexPages = costs.numIndexPages;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum string_to_datum(const char *str, Oid datatype);",
      "static Const *string_to_const(const char *str, Oid datatype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "genericcostestimate",
          "args": [
            "root",
            "path",
            "loop_count",
            "qinfos",
            "&costs"
          ],
          "line": 7262
        },
        "resolved": true,
        "details": {
          "function_name": "genericcostestimate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6714-6912",
          "snippet": "void\ngenericcostestimate(PlannerInfo *root,\n\t\t\t\t\tIndexPath *path,\n\t\t\t\t\tdouble loop_count,\n\t\t\t\t\tList *qinfos,\n\t\t\t\t\tGenericCosts *costs)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tCost\t\tindexStartupCost;\n\tCost\t\tindexTotalCost;\n\tSelectivity indexSelectivity;\n\tdouble\t\tindexCorrelation;\n\tdouble\t\tnumIndexPages;\n\tdouble\t\tnumIndexTuples;\n\tdouble\t\tspc_random_page_cost;\n\tdouble\t\tnum_sa_scans;\n\tdouble\t\tnum_outer_scans;\n\tdouble\t\tnum_scans;\n\tdouble\t\tqual_op_cost;\n\tdouble\t\tqual_arg_cost;\n\tList\t   *selectivityQuals;\n\tListCell   *l;\n\n\t/*\n\t * If the index is partial, AND the index predicate with the explicitly\n\t * given indexquals to produce a more accurate idea of the index\n\t * selectivity.\n\t */\n\tselectivityQuals = add_predicate_to_quals(index, indexQuals);\n\n\t/*\n\t * Check for ScalarArrayOpExpr index quals, and estimate the number of\n\t * index scans that will be performed.\n\t */\n\tnum_sa_scans = 1;\n\tforeach(l, indexQuals)\n\t{\n\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(l);\n\n\t\tif (IsA(rinfo->clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo->clause;\n\t\t\tint\t\t\talength = estimate_array_length(lsecond(saop->args));\n\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t}\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\tindexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * If caller didn't give us an estimate, estimate the number of index\n\t * tuples that will be visited.  We do it in this rather peculiar-looking\n\t * way in order to get the right answer for partial indexes.\n\t */\n\tnumIndexTuples = costs->numIndexTuples;\n\tif (numIndexTuples <= 0.0)\n\t{\n\t\tnumIndexTuples = indexSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * The above calculation counts all the tuples visited across all\n\t\t * scans induced by ScalarArrayOpExpr nodes.  We want to consider the\n\t\t * average per-indexscan number, so adjust.  This is a handy place to\n\t\t * round to integer, too.  (If caller supplied tuple estimate, it's\n\t\t * responsible for handling these considerations.)\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * We can bound the number of tuples by the index size in any case. Also,\n\t * always estimate at least one tuple is touched, even when\n\t * indexSelectivity estimate is tiny.\n\t */\n\tif (numIndexTuples > index->tuples)\n\t\tnumIndexTuples = index->tuples;\n\tif (numIndexTuples < 1.0)\n\t\tnumIndexTuples = 1.0;\n\n\t/*\n\t * Estimate the number of index pages that will be retrieved.\n\t *\n\t * We use the simplistic method of taking a pro-rata fraction of the total\n\t * number of index pages.  In effect, this counts only leaf pages and not\n\t * any overhead such as index metapage or upper tree levels.\n\t *\n\t * In practice access to upper index levels is often nearly free because\n\t * those tend to stay in cache under load; moreover, the cost involved is\n\t * highly dependent on index type.  We therefore ignore such costs here\n\t * and leave it to the caller to add a suitable charge if needed.\n\t */\n\tif (index->pages > 1 && index->tuples > 1)\n\t\tnumIndexPages = ceil(numIndexTuples * index->pages / index->tuples);\n\telse\n\t\tnumIndexPages = 1.0;\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Now compute the disk access costs.\n\t *\n\t * The above calculations are all per-index-scan.  However, if we are in a\n\t * nestloop inner scan, we can expect the scan to be repeated (with\n\t * different search keys) for each row of the outer relation.  Likewise,\n\t * ScalarArrayOpExpr quals result in multiple index scans.  This creates\n\t * the potential for cache effects to reduce the number of disk page\n\t * fetches needed.  We want to estimate the average per-scan I/O cost in\n\t * the presence of caching.\n\t *\n\t * We use the Mackert-Lohman formula (see costsize.c for details) to\n\t * estimate the total number of page fetches that occur.  While this\n\t * wasn't what it was designed for, it seems a reasonable model anyway.\n\t * Note that we are counting pages not tuples anymore, so we take N = T =\n\t * index size, as if there were one \"tuple\" per page.\n\t */\n\tnum_outer_scans = loop_count;\n\tnum_scans = num_sa_scans * num_outer_scans;\n\n\tif (num_scans > 1)\n\t{\n\t\tdouble\t\tpages_fetched;\n\n\t\t/* total page fetches ignoring cache effects */\n\t\tpages_fetched = numIndexPages * num_scans;\n\n\t\t/* use Mackert and Lohman formula to adjust for cache effects */\n\t\tpages_fetched = index_pages_fetched(pages_fetched,\n\t\t\t\t\t\t\t\t\t\t\tindex->pages,\n\t\t\t\t\t\t\t\t\t\t\t(double) index->pages,\n\t\t\t\t\t\t\t\t\t\t\troot);\n\n\t\t/*\n\t\t * Now compute the total disk access cost, and then report a pro-rated\n\t\t * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,\n\t\t * since that's internal to the indexscan.)\n\t\t */\n\t\tindexTotalCost = (pages_fetched * spc_random_page_cost)\n\t\t\t/ num_outer_scans;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For a single index scan, we just charge spc_random_page_cost per\n\t\t * page touched.\n\t\t */\n\t\tindexTotalCost = numIndexPages * spc_random_page_cost;\n\t}\n\n\t/*\n\t * CPU cost: any complex expressions in the indexquals will need to be\n\t * evaluated once at the start of the scan to reduce them to runtime keys\n\t * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple\n\t * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per\n\t * indexqual operator.  Because we have numIndexTuples as a per-scan\n\t * number, we have to multiply by num_sa_scans to get the correct result\n\t * for ScalarArrayOpExpr cases.  Similarly add in costs for any index\n\t * ORDER BY expressions.\n\t *\n\t * Note: this neglects the possible costs of rechecking lossy operators.\n\t * Detecting that that might be needed seems more expensive than it's\n\t * worth, though, considering all the other inaccuracies here ...\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\tindexStartupCost = qual_arg_cost;\n\tindexTotalCost += qual_arg_cost;\n\tindexTotalCost += numIndexTuples * num_sa_scans * (cpu_index_tuple_cost + qual_op_cost);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\tindexCorrelation = 0.0;\n\n\t/*\n\t * Return everything to caller.\n\t */\n\tcosts->indexStartupCost = indexStartupCost;\n\tcosts->indexTotalCost = indexTotalCost;\n\tcosts->indexSelectivity = indexSelectivity;\n\tcosts->indexCorrelation = indexCorrelation;\n\tcosts->numIndexPages = numIndexPages;\n\tcosts->numIndexTuples = numIndexTuples;\n\tcosts->spc_random_page_cost = spc_random_page_cost;\n\tcosts->num_sa_scans = num_sa_scans;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);\n\nvoid\ngenericcostestimate(PlannerInfo *root,\n\t\t\t\t\tIndexPath *path,\n\t\t\t\t\tdouble loop_count,\n\t\t\t\t\tList *qinfos,\n\t\t\t\t\tGenericCosts *costs)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tCost\t\tindexStartupCost;\n\tCost\t\tindexTotalCost;\n\tSelectivity indexSelectivity;\n\tdouble\t\tindexCorrelation;\n\tdouble\t\tnumIndexPages;\n\tdouble\t\tnumIndexTuples;\n\tdouble\t\tspc_random_page_cost;\n\tdouble\t\tnum_sa_scans;\n\tdouble\t\tnum_outer_scans;\n\tdouble\t\tnum_scans;\n\tdouble\t\tqual_op_cost;\n\tdouble\t\tqual_arg_cost;\n\tList\t   *selectivityQuals;\n\tListCell   *l;\n\n\t/*\n\t * If the index is partial, AND the index predicate with the explicitly\n\t * given indexquals to produce a more accurate idea of the index\n\t * selectivity.\n\t */\n\tselectivityQuals = add_predicate_to_quals(index, indexQuals);\n\n\t/*\n\t * Check for ScalarArrayOpExpr index quals, and estimate the number of\n\t * index scans that will be performed.\n\t */\n\tnum_sa_scans = 1;\n\tforeach(l, indexQuals)\n\t{\n\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(l);\n\n\t\tif (IsA(rinfo->clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo->clause;\n\t\t\tint\t\t\talength = estimate_array_length(lsecond(saop->args));\n\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t}\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\tindexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * If caller didn't give us an estimate, estimate the number of index\n\t * tuples that will be visited.  We do it in this rather peculiar-looking\n\t * way in order to get the right answer for partial indexes.\n\t */\n\tnumIndexTuples = costs->numIndexTuples;\n\tif (numIndexTuples <= 0.0)\n\t{\n\t\tnumIndexTuples = indexSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * The above calculation counts all the tuples visited across all\n\t\t * scans induced by ScalarArrayOpExpr nodes.  We want to consider the\n\t\t * average per-indexscan number, so adjust.  This is a handy place to\n\t\t * round to integer, too.  (If caller supplied tuple estimate, it's\n\t\t * responsible for handling these considerations.)\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * We can bound the number of tuples by the index size in any case. Also,\n\t * always estimate at least one tuple is touched, even when\n\t * indexSelectivity estimate is tiny.\n\t */\n\tif (numIndexTuples > index->tuples)\n\t\tnumIndexTuples = index->tuples;\n\tif (numIndexTuples < 1.0)\n\t\tnumIndexTuples = 1.0;\n\n\t/*\n\t * Estimate the number of index pages that will be retrieved.\n\t *\n\t * We use the simplistic method of taking a pro-rata fraction of the total\n\t * number of index pages.  In effect, this counts only leaf pages and not\n\t * any overhead such as index metapage or upper tree levels.\n\t *\n\t * In practice access to upper index levels is often nearly free because\n\t * those tend to stay in cache under load; moreover, the cost involved is\n\t * highly dependent on index type.  We therefore ignore such costs here\n\t * and leave it to the caller to add a suitable charge if needed.\n\t */\n\tif (index->pages > 1 && index->tuples > 1)\n\t\tnumIndexPages = ceil(numIndexTuples * index->pages / index->tuples);\n\telse\n\t\tnumIndexPages = 1.0;\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Now compute the disk access costs.\n\t *\n\t * The above calculations are all per-index-scan.  However, if we are in a\n\t * nestloop inner scan, we can expect the scan to be repeated (with\n\t * different search keys) for each row of the outer relation.  Likewise,\n\t * ScalarArrayOpExpr quals result in multiple index scans.  This creates\n\t * the potential for cache effects to reduce the number of disk page\n\t * fetches needed.  We want to estimate the average per-scan I/O cost in\n\t * the presence of caching.\n\t *\n\t * We use the Mackert-Lohman formula (see costsize.c for details) to\n\t * estimate the total number of page fetches that occur.  While this\n\t * wasn't what it was designed for, it seems a reasonable model anyway.\n\t * Note that we are counting pages not tuples anymore, so we take N = T =\n\t * index size, as if there were one \"tuple\" per page.\n\t */\n\tnum_outer_scans = loop_count;\n\tnum_scans = num_sa_scans * num_outer_scans;\n\n\tif (num_scans > 1)\n\t{\n\t\tdouble\t\tpages_fetched;\n\n\t\t/* total page fetches ignoring cache effects */\n\t\tpages_fetched = numIndexPages * num_scans;\n\n\t\t/* use Mackert and Lohman formula to adjust for cache effects */\n\t\tpages_fetched = index_pages_fetched(pages_fetched,\n\t\t\t\t\t\t\t\t\t\t\tindex->pages,\n\t\t\t\t\t\t\t\t\t\t\t(double) index->pages,\n\t\t\t\t\t\t\t\t\t\t\troot);\n\n\t\t/*\n\t\t * Now compute the total disk access cost, and then report a pro-rated\n\t\t * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,\n\t\t * since that's internal to the indexscan.)\n\t\t */\n\t\tindexTotalCost = (pages_fetched * spc_random_page_cost)\n\t\t\t/ num_outer_scans;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For a single index scan, we just charge spc_random_page_cost per\n\t\t * page touched.\n\t\t */\n\t\tindexTotalCost = numIndexPages * spc_random_page_cost;\n\t}\n\n\t/*\n\t * CPU cost: any complex expressions in the indexquals will need to be\n\t * evaluated once at the start of the scan to reduce them to runtime keys\n\t * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple\n\t * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per\n\t * indexqual operator.  Because we have numIndexTuples as a per-scan\n\t * number, we have to multiply by num_sa_scans to get the correct result\n\t * for ScalarArrayOpExpr cases.  Similarly add in costs for any index\n\t * ORDER BY expressions.\n\t *\n\t * Note: this neglects the possible costs of rechecking lossy operators.\n\t * Detecting that that might be needed seems more expensive than it's\n\t * worth, though, considering all the other inaccuracies here ...\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\tindexStartupCost = qual_arg_cost;\n\tindexTotalCost += qual_arg_cost;\n\tindexTotalCost += numIndexTuples * num_sa_scans * (cpu_index_tuple_cost + qual_op_cost);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\tindexCorrelation = 0.0;\n\n\t/*\n\t * Return everything to caller.\n\t */\n\tcosts->indexStartupCost = indexStartupCost;\n\tcosts->indexTotalCost = indexTotalCost;\n\tcosts->indexSelectivity = indexSelectivity;\n\tcosts->indexCorrelation = indexCorrelation;\n\tcosts->numIndexPages = numIndexPages;\n\tcosts->numIndexTuples = numIndexTuples;\n\tcosts->spc_random_page_cost = spc_random_page_cost;\n\tcosts->num_sa_scans = num_sa_scans;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&costs",
            "0",
            "sizeof(costs)"
          ],
          "line": 7260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_indexquals",
          "args": [
            "path"
          ],
          "line": 7258
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_indexquals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6565-6653",
          "snippet": "List *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum string_to_datum(const char *str, Oid datatype);\nstatic Const *string_to_const(const char *str, Oid datatype);\n\nvoid\nhashcostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t\t Cost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t\t Selectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t\t double *indexPages)\n{\n\tList\t   *qinfos;\n\tGenericCosts costs;\n\n\t/* Do preliminary analysis of indexquals */\n\tqinfos = deconstruct_indexquals(path);\n\n\tMemSet(&costs, 0, sizeof(costs));\n\n\tgenericcostestimate(root, path, loop_count, qinfos, &costs);\n\n\t/*\n\t * A hash index has no descent costs as such, since the index AM can go\n\t * directly to the target bucket after computing the hash value.  There\n\t * are a couple of other hash-specific costs that we could conceivably add\n\t * here, though:\n\t *\n\t * Ideally we'd charge spc_random_page_cost for each page in the target\n\t * bucket, not just the numIndexPages pages that genericcostestimate\n\t * thought we'd visit.  However in most cases we don't know which bucket\n\t * that will be.  There's no point in considering the average bucket size\n\t * because the hash AM makes sure that's always one page.\n\t *\n\t * Likewise, we could consider charging some CPU for each index tuple in\n\t * the bucket, if we knew how many there were.  But the per-tuple cost is\n\t * just a hash value comparison, not a general datatype-dependent\n\t * comparison, so any such charge ought to be quite a bit less than\n\t * cpu_operator_cost; which makes it probably not worth worrying about.\n\t *\n\t * A bigger issue is that chance hash-value collisions will result in\n\t * wasted probes into the heap.  We don't currently attempt to model this\n\t * cost on the grounds that it's rare, but maybe it's not rare enough.\n\t * (Any fix for this ought to consider the generic lossy-operator problem,\n\t * though; it's not entirely hash-specific.)\n\t */\n\n\t*indexStartupCost = costs.indexStartupCost;\n\t*indexTotalCost = costs.indexTotalCost;\n\t*indexSelectivity = costs.indexSelectivity;\n\t*indexCorrelation = costs.indexCorrelation;\n\t*indexPages = costs.numIndexPages;\n}"
  },
  {
    "function_name": "btcostestimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6955-7246",
    "snippet": "void\nbtcostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t   Cost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t   Selectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t   double *indexPages)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *qinfos;\n\tGenericCosts costs;\n\tOid\t\t\trelid;\n\tAttrNumber\tcolnum;\n\tVariableStatData vardata;\n\tdouble\t\tnumIndexTuples;\n\tCost\t\tdescentCost;\n\tList\t   *indexBoundQuals;\n\tint\t\t\tindexcol;\n\tbool\t\teqQualHere;\n\tbool\t\tfound_saop;\n\tbool\t\tfound_is_null_op;\n\tdouble\t\tnum_sa_scans;\n\tListCell   *lc;\n\n\t/* Do preliminary analysis of indexquals */\n\tqinfos = deconstruct_indexquals(path);\n\n\t/*\n\t * For a btree scan, only leading '=' quals plus inequality quals for the\n\t * immediately next attribute contribute to index selectivity (these are\n\t * the \"boundary quals\" that determine the starting and stopping points of\n\t * the index scan).  Additional quals can suppress visits to the heap, so\n\t * it's OK to count them in indexSelectivity, but they should not count\n\t * for estimating numIndexTuples.  So we must examine the given indexquals\n\t * to find out which ones count as boundary quals.  We rely on the\n\t * knowledge that they are given in index column order.\n\t *\n\t * For a RowCompareExpr, we consider only the first column, just as\n\t * rowcomparesel() does.\n\t *\n\t * If there's a ScalarArrayOpExpr in the quals, we'll actually perform N\n\t * index scans not one, but the ScalarArrayOpExpr's operator can be\n\t * considered to act the same as it normally does.\n\t */\n\tindexBoundQuals = NIL;\n\tindexcol = 0;\n\teqQualHere = false;\n\tfound_saop = false;\n\tfound_is_null_op = false;\n\tnum_sa_scans = 1;\n\tforeach(lc, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(lc);\n\t\tRestrictInfo *rinfo = qinfo->rinfo;\n\t\tExpr\t   *clause = rinfo->clause;\n\t\tOid\t\t\tclause_op;\n\t\tint\t\t\top_strategy;\n\n\t\tif (indexcol != qinfo->indexcol)\n\t\t{\n\t\t\t/* Beginning of a new column's quals */\n\t\t\tif (!eqQualHere)\n\t\t\t\tbreak;\t\t\t/* done if no '=' qual for indexcol */\n\t\t\teqQualHere = false;\n\t\t\tindexcol++;\n\t\t\tif (indexcol != qinfo->indexcol)\n\t\t\t\tbreak;\t\t\t/* no quals at all for indexcol */\n\t\t}\n\n\t\tif (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tint\t\t\talength = estimate_array_length(qinfo->other_operand);\n\n\t\t\tfound_saop = true;\n\t\t\t/* count up number of SA scans induced by indexBoundQuals only */\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tNullTest   *nt = (NullTest *) clause;\n\n\t\t\tif (nt->nulltesttype == IS_NULL)\n\t\t\t{\n\t\t\t\tfound_is_null_op = true;\n\t\t\t\t/* IS NULL is like = for selectivity determination purposes */\n\t\t\t\teqQualHere = true;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We would need to commute the clause_op if not varonleft, except\n\t\t * that we only care if it's equality or not, so that refinement is\n\t\t * unnecessary.\n\t\t */\n\t\tclause_op = qinfo->clause_op;\n\n\t\t/* check for equality operator */\n\t\tif (OidIsValid(clause_op))\n\t\t{\n\t\t\top_strategy = get_op_opfamily_strategy(clause_op,\n\t\t\t\t\t\t\t\t\t\t\t\t   index->opfamily[indexcol]);\n\t\t\tAssert(op_strategy != 0);\t/* not a member of opfamily?? */\n\t\t\tif (op_strategy == BTEqualStrategyNumber)\n\t\t\t\teqQualHere = true;\n\t\t}\n\n\t\tindexBoundQuals = lappend(indexBoundQuals, rinfo);\n\t}\n\n\t/*\n\t * If index is unique and we found an '=' clause for each column, we can\n\t * just assume numIndexTuples = 1 and skip the expensive\n\t * clauselist_selectivity calculations.  However, a ScalarArrayOp or\n\t * NullTest invalidates that theory, even though it sets eqQualHere.\n\t */\n\tif (index->unique &&\n\t\tindexcol == index->nkeycolumns - 1 &&\n\t\teqQualHere &&\n\t\t!found_saop &&\n\t\t!found_is_null_op)\n\t\tnumIndexTuples = 1.0;\n\telse\n\t{\n\t\tList\t   *selectivityQuals;\n\t\tSelectivity btreeSelectivity;\n\n\t\t/*\n\t\t * If the index is partial, AND the index predicate with the\n\t\t * index-bound quals to produce a more accurate idea of the number of\n\t\t * rows covered by the bound conditions.\n\t\t */\n\t\tselectivityQuals = add_predicate_to_quals(index, indexBoundQuals);\n\n\t\tbtreeSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\t\tnumIndexTuples = btreeSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * As in genericcostestimate(), we have to adjust for any\n\t\t * ScalarArrayOpExpr quals included in indexBoundQuals, and then round\n\t\t * to integer.\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * Now do generic index cost estimation.\n\t */\n\tMemSet(&costs, 0, sizeof(costs));\n\tcosts.numIndexTuples = numIndexTuples;\n\n\tgenericcostestimate(root, path, loop_count, qinfos, &costs);\n\n\t/*\n\t * Add a CPU-cost component to represent the costs of initial btree\n\t * descent.  We don't charge any I/O cost for touching upper btree levels,\n\t * since they tend to stay in cache, but we still have to do about log2(N)\n\t * comparisons to descend a btree of N leaf tuples.  We charge one\n\t * cpu_operator_cost per comparison.\n\t *\n\t * If there are ScalarArrayOpExprs, charge this once per SA scan.  The\n\t * ones after the first one are not startup cost so far as the overall\n\t * plan is concerned, so add them only to \"total\" cost.\n\t */\n\tif (index->tuples > 1)\t\t/* avoid computing log(0) */\n\t{\n\t\tdescentCost = ceil(log(index->tuples) / log(2.0)) * cpu_operator_cost;\n\t\tcosts.indexStartupCost += descentCost;\n\t\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\t}\n\n\t/*\n\t * Even though we're not charging I/O cost for touching upper btree pages,\n\t * it's still reasonable to charge some CPU cost per page descended\n\t * through.  Moreover, if we had no such charge at all, bloated indexes\n\t * would appear to have the same search cost as unbloated ones, at least\n\t * in cases where only a single leaf page is expected to be visited.  This\n\t * cost is somewhat arbitrarily set at 50x cpu_operator_cost per page\n\t * touched.  The number of such pages is btree tree height plus one (ie,\n\t * we charge for the leaf page too).  As above, charge once per SA scan.\n\t */\n\tdescentCost = (index->tree_height + 1) * 50.0 * cpu_operator_cost;\n\tcosts.indexStartupCost += descentCost;\n\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\n\t/*\n\t * If we can get an estimate of the first column's ordering correlation C\n\t * from pg_statistic, estimate the index correlation as C for a\n\t * single-column index, or C * 0.75 for multiple columns. (The idea here\n\t * is that multiple columns dilute the importance of the first column's\n\t * ordering, but don't negate it entirely.  Before 8.0 we divided the\n\t * correlation by the number of columns, but that seems too strong.)\n\t */\n\tMemSet(&vardata, 0, sizeof(vardata));\n\n\tif (index->indexkeys[0] != 0)\n\t{\n\t\t/* Simple variable --- look to stats for the underlying table */\n\t\tRangeTblEntry *rte = planner_rt_fetch(index->rel->relid, root);\n\n\t\tAssert(rte->rtekind == RTE_RELATION);\n\t\trelid = rte->relid;\n\t\tAssert(relid != InvalidOid);\n\t\tcolnum = index->indexkeys[0];\n\n\t\tif (get_relation_stats_hook &&\n\t\t\t(*get_relation_stats_hook) (root, rte, colnum, &vardata))\n\t\t{\n\t\t\t/*\n\t\t\t * The hook took control of acquiring a stats tuple.  If it did\n\t\t\t * supply a tuple, it'd better have supplied a freefunc.\n\t\t\t */\n\t\t\tif (HeapTupleIsValid(vardata.statsTuple) &&\n\t\t\t\t!vardata.freefunc)\n\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvardata.statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid),\n\t\t\t\t\t\t\t\t\t\t\t\t Int16GetDatum(colnum),\n\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(rte->inh));\n\t\t\tvardata.freefunc = ReleaseSysCache;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Expression --- maybe there are stats for the index itself */\n\t\trelid = index->indexoid;\n\t\tcolnum = 1;\n\n\t\tif (get_index_stats_hook &&\n\t\t\t(*get_index_stats_hook) (root, relid, colnum, &vardata))\n\t\t{\n\t\t\t/*\n\t\t\t * The hook took control of acquiring a stats tuple.  If it did\n\t\t\t * supply a tuple, it'd better have supplied a freefunc.\n\t\t\t */\n\t\t\tif (HeapTupleIsValid(vardata.statsTuple) &&\n\t\t\t\t!vardata.freefunc)\n\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvardata.statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid),\n\t\t\t\t\t\t\t\t\t\t\t\t Int16GetDatum(colnum),\n\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(false));\n\t\t\tvardata.freefunc = ReleaseSysCache;\n\t\t}\n\t}\n\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tOid\t\t\tsortop;\n\t\tAttStatsSlot sslot;\n\n\t\tsortop = get_opfamily_member(index->opfamily[0],\n\t\t\t\t\t\t\t\t\t index->opcintype[0],\n\t\t\t\t\t\t\t\t\t index->opcintype[0],\n\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\t\tif (OidIsValid(sortop) &&\n\t\t\tget_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_CORRELATION, sortop,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tdouble\t\tvarCorrelation;\n\n\t\t\tAssert(sslot.nnumbers == 1);\n\t\t\tvarCorrelation = sslot.numbers[0];\n\n\t\t\tif (index->reverse_sort[0])\n\t\t\t\tvarCorrelation = -varCorrelation;\n\n\t\t\tif (index->nkeycolumns > 1)\n\t\t\t\tcosts.indexCorrelation = varCorrelation * 0.75;\n\t\t\telse\n\t\t\t\tcosts.indexCorrelation = varCorrelation;\n\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\t*indexStartupCost = costs.indexStartupCost;\n\t*indexTotalCost = costs.indexTotalCost;\n\t*indexSelectivity = costs.indexSelectivity;\n\t*indexCorrelation = costs.indexCorrelation;\n\t*indexPages = costs.numIndexPages;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "get_relation_stats_hook_type get_relation_stats_hook = NULL;",
      "get_index_stats_hook_type get_index_stats_hook = NULL;",
      "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
      "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
      "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 7239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 7235
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "sslot.nnumbers == 1"
          ],
          "line": 7224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot",
            "vardata.statsTuple",
            "STATISTIC_KIND_CORRELATION",
            "sortop",
            "ATTSTATSSLOT_NUMBERS"
          ],
          "line": 7218
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "sortop"
          ],
          "line": 7217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_opfamily_member",
          "args": [
            "index->opfamily[0]",
            "index->opcintype[0]",
            "index->opcintype[0]",
            "BTLessStrategyNumber"
          ],
          "line": 7213
        },
        "resolved": true,
        "details": {
          "function_name": "get_opfamily_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "162-181",
          "snippet": "Oid\nget_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,\n\t\t\t\t\tint16 strategy)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache4(AMOPSTRATEGY,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(strategy));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopopr;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,\n\t\t\t\t\tint16 strategy)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache4(AMOPSTRATEGY,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(strategy));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopopr;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 7208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache3",
          "args": [
            "STATRELATTINH",
            "ObjectIdGetDatum(relid)",
            "Int16GetDatum(colnum)",
            "BoolGetDatum(false)"
          ],
          "line": 7200
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1133-1142",
          "snippet": "HeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "false"
          ],
          "line": 7203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "colnum"
          ],
          "line": 7202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "relid"
          ],
          "line": 7201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"no function provided to release variable stats with\""
          ],
          "line": 7196
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 7194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "root",
            "relid",
            "colnum",
            "&vardata"
          ],
          "line": 7188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "rte->inh"
          ],
          "line": 7177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "colnum"
          ],
          "line": 7176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "relid"
          ],
          "line": 7175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 7168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "root",
            "rte",
            "colnum",
            "&vardata"
          ],
          "line": 7162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relid != InvalidOid"
          ],
          "line": 7158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rte->rtekind == RTE_RELATION"
          ],
          "line": 7156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "planner_rt_fetch",
          "args": [
            "index->rel->relid",
            "root"
          ],
          "line": 7154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&vardata",
            "0",
            "sizeof(vardata)"
          ],
          "line": 7149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "log(index->tuples) / log(2.0)"
          ],
          "line": 7122
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "2.0"
          ],
          "line": 7122
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "genericcostestimate",
          "args": [
            "root",
            "path",
            "loop_count",
            "qinfos",
            "&costs"
          ],
          "line": 7107
        },
        "resolved": true,
        "details": {
          "function_name": "genericcostestimate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6714-6912",
          "snippet": "void\ngenericcostestimate(PlannerInfo *root,\n\t\t\t\t\tIndexPath *path,\n\t\t\t\t\tdouble loop_count,\n\t\t\t\t\tList *qinfos,\n\t\t\t\t\tGenericCosts *costs)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tCost\t\tindexStartupCost;\n\tCost\t\tindexTotalCost;\n\tSelectivity indexSelectivity;\n\tdouble\t\tindexCorrelation;\n\tdouble\t\tnumIndexPages;\n\tdouble\t\tnumIndexTuples;\n\tdouble\t\tspc_random_page_cost;\n\tdouble\t\tnum_sa_scans;\n\tdouble\t\tnum_outer_scans;\n\tdouble\t\tnum_scans;\n\tdouble\t\tqual_op_cost;\n\tdouble\t\tqual_arg_cost;\n\tList\t   *selectivityQuals;\n\tListCell   *l;\n\n\t/*\n\t * If the index is partial, AND the index predicate with the explicitly\n\t * given indexquals to produce a more accurate idea of the index\n\t * selectivity.\n\t */\n\tselectivityQuals = add_predicate_to_quals(index, indexQuals);\n\n\t/*\n\t * Check for ScalarArrayOpExpr index quals, and estimate the number of\n\t * index scans that will be performed.\n\t */\n\tnum_sa_scans = 1;\n\tforeach(l, indexQuals)\n\t{\n\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(l);\n\n\t\tif (IsA(rinfo->clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo->clause;\n\t\t\tint\t\t\talength = estimate_array_length(lsecond(saop->args));\n\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t}\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\tindexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * If caller didn't give us an estimate, estimate the number of index\n\t * tuples that will be visited.  We do it in this rather peculiar-looking\n\t * way in order to get the right answer for partial indexes.\n\t */\n\tnumIndexTuples = costs->numIndexTuples;\n\tif (numIndexTuples <= 0.0)\n\t{\n\t\tnumIndexTuples = indexSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * The above calculation counts all the tuples visited across all\n\t\t * scans induced by ScalarArrayOpExpr nodes.  We want to consider the\n\t\t * average per-indexscan number, so adjust.  This is a handy place to\n\t\t * round to integer, too.  (If caller supplied tuple estimate, it's\n\t\t * responsible for handling these considerations.)\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * We can bound the number of tuples by the index size in any case. Also,\n\t * always estimate at least one tuple is touched, even when\n\t * indexSelectivity estimate is tiny.\n\t */\n\tif (numIndexTuples > index->tuples)\n\t\tnumIndexTuples = index->tuples;\n\tif (numIndexTuples < 1.0)\n\t\tnumIndexTuples = 1.0;\n\n\t/*\n\t * Estimate the number of index pages that will be retrieved.\n\t *\n\t * We use the simplistic method of taking a pro-rata fraction of the total\n\t * number of index pages.  In effect, this counts only leaf pages and not\n\t * any overhead such as index metapage or upper tree levels.\n\t *\n\t * In practice access to upper index levels is often nearly free because\n\t * those tend to stay in cache under load; moreover, the cost involved is\n\t * highly dependent on index type.  We therefore ignore such costs here\n\t * and leave it to the caller to add a suitable charge if needed.\n\t */\n\tif (index->pages > 1 && index->tuples > 1)\n\t\tnumIndexPages = ceil(numIndexTuples * index->pages / index->tuples);\n\telse\n\t\tnumIndexPages = 1.0;\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Now compute the disk access costs.\n\t *\n\t * The above calculations are all per-index-scan.  However, if we are in a\n\t * nestloop inner scan, we can expect the scan to be repeated (with\n\t * different search keys) for each row of the outer relation.  Likewise,\n\t * ScalarArrayOpExpr quals result in multiple index scans.  This creates\n\t * the potential for cache effects to reduce the number of disk page\n\t * fetches needed.  We want to estimate the average per-scan I/O cost in\n\t * the presence of caching.\n\t *\n\t * We use the Mackert-Lohman formula (see costsize.c for details) to\n\t * estimate the total number of page fetches that occur.  While this\n\t * wasn't what it was designed for, it seems a reasonable model anyway.\n\t * Note that we are counting pages not tuples anymore, so we take N = T =\n\t * index size, as if there were one \"tuple\" per page.\n\t */\n\tnum_outer_scans = loop_count;\n\tnum_scans = num_sa_scans * num_outer_scans;\n\n\tif (num_scans > 1)\n\t{\n\t\tdouble\t\tpages_fetched;\n\n\t\t/* total page fetches ignoring cache effects */\n\t\tpages_fetched = numIndexPages * num_scans;\n\n\t\t/* use Mackert and Lohman formula to adjust for cache effects */\n\t\tpages_fetched = index_pages_fetched(pages_fetched,\n\t\t\t\t\t\t\t\t\t\t\tindex->pages,\n\t\t\t\t\t\t\t\t\t\t\t(double) index->pages,\n\t\t\t\t\t\t\t\t\t\t\troot);\n\n\t\t/*\n\t\t * Now compute the total disk access cost, and then report a pro-rated\n\t\t * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,\n\t\t * since that's internal to the indexscan.)\n\t\t */\n\t\tindexTotalCost = (pages_fetched * spc_random_page_cost)\n\t\t\t/ num_outer_scans;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For a single index scan, we just charge spc_random_page_cost per\n\t\t * page touched.\n\t\t */\n\t\tindexTotalCost = numIndexPages * spc_random_page_cost;\n\t}\n\n\t/*\n\t * CPU cost: any complex expressions in the indexquals will need to be\n\t * evaluated once at the start of the scan to reduce them to runtime keys\n\t * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple\n\t * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per\n\t * indexqual operator.  Because we have numIndexTuples as a per-scan\n\t * number, we have to multiply by num_sa_scans to get the correct result\n\t * for ScalarArrayOpExpr cases.  Similarly add in costs for any index\n\t * ORDER BY expressions.\n\t *\n\t * Note: this neglects the possible costs of rechecking lossy operators.\n\t * Detecting that that might be needed seems more expensive than it's\n\t * worth, though, considering all the other inaccuracies here ...\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\tindexStartupCost = qual_arg_cost;\n\tindexTotalCost += qual_arg_cost;\n\tindexTotalCost += numIndexTuples * num_sa_scans * (cpu_index_tuple_cost + qual_op_cost);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\tindexCorrelation = 0.0;\n\n\t/*\n\t * Return everything to caller.\n\t */\n\tcosts->indexStartupCost = indexStartupCost;\n\tcosts->indexTotalCost = indexTotalCost;\n\tcosts->indexSelectivity = indexSelectivity;\n\tcosts->indexCorrelation = indexCorrelation;\n\tcosts->numIndexPages = numIndexPages;\n\tcosts->numIndexTuples = numIndexTuples;\n\tcosts->spc_random_page_cost = spc_random_page_cost;\n\tcosts->num_sa_scans = num_sa_scans;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);\n\nvoid\ngenericcostestimate(PlannerInfo *root,\n\t\t\t\t\tIndexPath *path,\n\t\t\t\t\tdouble loop_count,\n\t\t\t\t\tList *qinfos,\n\t\t\t\t\tGenericCosts *costs)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tCost\t\tindexStartupCost;\n\tCost\t\tindexTotalCost;\n\tSelectivity indexSelectivity;\n\tdouble\t\tindexCorrelation;\n\tdouble\t\tnumIndexPages;\n\tdouble\t\tnumIndexTuples;\n\tdouble\t\tspc_random_page_cost;\n\tdouble\t\tnum_sa_scans;\n\tdouble\t\tnum_outer_scans;\n\tdouble\t\tnum_scans;\n\tdouble\t\tqual_op_cost;\n\tdouble\t\tqual_arg_cost;\n\tList\t   *selectivityQuals;\n\tListCell   *l;\n\n\t/*\n\t * If the index is partial, AND the index predicate with the explicitly\n\t * given indexquals to produce a more accurate idea of the index\n\t * selectivity.\n\t */\n\tselectivityQuals = add_predicate_to_quals(index, indexQuals);\n\n\t/*\n\t * Check for ScalarArrayOpExpr index quals, and estimate the number of\n\t * index scans that will be performed.\n\t */\n\tnum_sa_scans = 1;\n\tforeach(l, indexQuals)\n\t{\n\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(l);\n\n\t\tif (IsA(rinfo->clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo->clause;\n\t\t\tint\t\t\talength = estimate_array_length(lsecond(saop->args));\n\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t}\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\tindexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * If caller didn't give us an estimate, estimate the number of index\n\t * tuples that will be visited.  We do it in this rather peculiar-looking\n\t * way in order to get the right answer for partial indexes.\n\t */\n\tnumIndexTuples = costs->numIndexTuples;\n\tif (numIndexTuples <= 0.0)\n\t{\n\t\tnumIndexTuples = indexSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * The above calculation counts all the tuples visited across all\n\t\t * scans induced by ScalarArrayOpExpr nodes.  We want to consider the\n\t\t * average per-indexscan number, so adjust.  This is a handy place to\n\t\t * round to integer, too.  (If caller supplied tuple estimate, it's\n\t\t * responsible for handling these considerations.)\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * We can bound the number of tuples by the index size in any case. Also,\n\t * always estimate at least one tuple is touched, even when\n\t * indexSelectivity estimate is tiny.\n\t */\n\tif (numIndexTuples > index->tuples)\n\t\tnumIndexTuples = index->tuples;\n\tif (numIndexTuples < 1.0)\n\t\tnumIndexTuples = 1.0;\n\n\t/*\n\t * Estimate the number of index pages that will be retrieved.\n\t *\n\t * We use the simplistic method of taking a pro-rata fraction of the total\n\t * number of index pages.  In effect, this counts only leaf pages and not\n\t * any overhead such as index metapage or upper tree levels.\n\t *\n\t * In practice access to upper index levels is often nearly free because\n\t * those tend to stay in cache under load; moreover, the cost involved is\n\t * highly dependent on index type.  We therefore ignore such costs here\n\t * and leave it to the caller to add a suitable charge if needed.\n\t */\n\tif (index->pages > 1 && index->tuples > 1)\n\t\tnumIndexPages = ceil(numIndexTuples * index->pages / index->tuples);\n\telse\n\t\tnumIndexPages = 1.0;\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Now compute the disk access costs.\n\t *\n\t * The above calculations are all per-index-scan.  However, if we are in a\n\t * nestloop inner scan, we can expect the scan to be repeated (with\n\t * different search keys) for each row of the outer relation.  Likewise,\n\t * ScalarArrayOpExpr quals result in multiple index scans.  This creates\n\t * the potential for cache effects to reduce the number of disk page\n\t * fetches needed.  We want to estimate the average per-scan I/O cost in\n\t * the presence of caching.\n\t *\n\t * We use the Mackert-Lohman formula (see costsize.c for details) to\n\t * estimate the total number of page fetches that occur.  While this\n\t * wasn't what it was designed for, it seems a reasonable model anyway.\n\t * Note that we are counting pages not tuples anymore, so we take N = T =\n\t * index size, as if there were one \"tuple\" per page.\n\t */\n\tnum_outer_scans = loop_count;\n\tnum_scans = num_sa_scans * num_outer_scans;\n\n\tif (num_scans > 1)\n\t{\n\t\tdouble\t\tpages_fetched;\n\n\t\t/* total page fetches ignoring cache effects */\n\t\tpages_fetched = numIndexPages * num_scans;\n\n\t\t/* use Mackert and Lohman formula to adjust for cache effects */\n\t\tpages_fetched = index_pages_fetched(pages_fetched,\n\t\t\t\t\t\t\t\t\t\t\tindex->pages,\n\t\t\t\t\t\t\t\t\t\t\t(double) index->pages,\n\t\t\t\t\t\t\t\t\t\t\troot);\n\n\t\t/*\n\t\t * Now compute the total disk access cost, and then report a pro-rated\n\t\t * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,\n\t\t * since that's internal to the indexscan.)\n\t\t */\n\t\tindexTotalCost = (pages_fetched * spc_random_page_cost)\n\t\t\t/ num_outer_scans;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For a single index scan, we just charge spc_random_page_cost per\n\t\t * page touched.\n\t\t */\n\t\tindexTotalCost = numIndexPages * spc_random_page_cost;\n\t}\n\n\t/*\n\t * CPU cost: any complex expressions in the indexquals will need to be\n\t * evaluated once at the start of the scan to reduce them to runtime keys\n\t * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple\n\t * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per\n\t * indexqual operator.  Because we have numIndexTuples as a per-scan\n\t * number, we have to multiply by num_sa_scans to get the correct result\n\t * for ScalarArrayOpExpr cases.  Similarly add in costs for any index\n\t * ORDER BY expressions.\n\t *\n\t * Note: this neglects the possible costs of rechecking lossy operators.\n\t * Detecting that that might be needed seems more expensive than it's\n\t * worth, though, considering all the other inaccuracies here ...\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\tindexStartupCost = qual_arg_cost;\n\tindexTotalCost += qual_arg_cost;\n\tindexTotalCost += numIndexTuples * num_sa_scans * (cpu_index_tuple_cost + qual_op_cost);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\tindexCorrelation = 0.0;\n\n\t/*\n\t * Return everything to caller.\n\t */\n\tcosts->indexStartupCost = indexStartupCost;\n\tcosts->indexTotalCost = indexTotalCost;\n\tcosts->indexSelectivity = indexSelectivity;\n\tcosts->indexCorrelation = indexCorrelation;\n\tcosts->numIndexPages = numIndexPages;\n\tcosts->numIndexTuples = numIndexTuples;\n\tcosts->spc_random_page_cost = spc_random_page_cost;\n\tcosts->num_sa_scans = num_sa_scans;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&costs",
            "0",
            "sizeof(costs)"
          ],
          "line": 7104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "numIndexTuples / num_sa_scans"
          ],
          "line": 7098
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clauselist_selectivity",
          "args": [
            "root",
            "selectivityQuals",
            "index->rel->relid",
            "JOIN_INNER",
            "NULL"
          ],
          "line": 7087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_predicate_to_quals",
          "args": [
            "index",
            "indexBoundQuals"
          ],
          "line": 7085
        },
        "resolved": true,
        "details": {
          "function_name": "add_predicate_to_quals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6933-6952",
          "snippet": "static List *\nadd_predicate_to_quals(IndexOptInfo *index, List *indexQuals)\n{\n\tList\t   *predExtraQuals = NIL;\n\tListCell   *lc;\n\n\tif (index->indpred == NIL)\n\t\treturn indexQuals;\n\n\tforeach(lc, index->indpred)\n\t{\n\t\tNode\t   *predQual = (Node *) lfirst(lc);\n\t\tList\t   *oneQual = list_make1(predQual);\n\n\t\tif (!predicate_implied_by(oneQual, indexQuals, false))\n\t\t\tpredExtraQuals = list_concat(predExtraQuals, oneQual);\n\t}\n\t/* list_concat avoids modifying the passed-in indexQuals list */\n\treturn list_concat(predExtraQuals, indexQuals);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);\n\nstatic List *\nadd_predicate_to_quals(IndexOptInfo *index, List *indexQuals)\n{\n\tList\t   *predExtraQuals = NIL;\n\tListCell   *lc;\n\n\tif (index->indpred == NIL)\n\t\treturn indexQuals;\n\n\tforeach(lc, index->indpred)\n\t{\n\t\tNode\t   *predQual = (Node *) lfirst(lc);\n\t\tList\t   *oneQual = list_make1(predQual);\n\n\t\tif (!predicate_implied_by(oneQual, indexQuals, false))\n\t\t\tpredExtraQuals = list_concat(predExtraQuals, oneQual);\n\t}\n\t/* list_concat avoids modifying the passed-in indexQuals list */\n\treturn list_concat(predExtraQuals, indexQuals);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "indexBoundQuals",
            "rinfo"
          ],
          "line": 7060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "op_strategy != 0"
          ],
          "line": 7055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_op_opfamily_strategy",
          "args": [
            "clause_op",
            "index->opfamily[indexcol]"
          ],
          "line": 7053
        },
        "resolved": true,
        "details": {
          "function_name": "get_op_opfamily_strategy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "79-96",
          "snippet": "int\nget_op_opfamily_strategy(Oid opno, Oid opfamily)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tint\t\t\tresult;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(AMOP_SEARCH),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn 0;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopstrategy;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nint\nget_op_opfamily_strategy(Oid opno, Oid opfamily)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tint\t\t\tresult;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(AMOP_SEARCH),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn 0;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopstrategy;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "clause_op"
          ],
          "line": 7051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "clause",
            "NullTest"
          ],
          "line": 7031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimate_array_length",
          "args": [
            "qinfo->other_operand"
          ],
          "line": 7024
        },
        "resolved": true,
        "details": {
          "function_name": "estimate_array_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2178-2205",
          "snippet": "int\nestimate_array_length(Node *arrayexpr)\n{\n\t/* look through any binary-compatible relabeling of arrayexpr */\n\tarrayexpr = strip_array_coercion(arrayexpr);\n\n\tif (arrayexpr && IsA(arrayexpr, Const))\n\t{\n\t\tDatum\t\tarraydatum = ((Const *) arrayexpr)->constvalue;\n\t\tbool\t\tarrayisnull = ((Const *) arrayexpr)->constisnull;\n\t\tArrayType  *arrayval;\n\n\t\tif (arrayisnull)\n\t\t\treturn 0;\n\t\tarrayval = DatumGetArrayTypeP(arraydatum);\n\t\treturn ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));\n\t}\n\telse if (arrayexpr && IsA(arrayexpr, ArrayExpr) &&\n\t\t\t !((ArrayExpr *) arrayexpr)->multidims)\n\t{\n\t\treturn list_length(((ArrayExpr *) arrayexpr)->elements);\n\t}\n\telse\n\t{\n\t\t/* default guess --- see also scalararraysel */\n\t\treturn 10;\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nestimate_array_length(Node *arrayexpr)\n{\n\t/* look through any binary-compatible relabeling of arrayexpr */\n\tarrayexpr = strip_array_coercion(arrayexpr);\n\n\tif (arrayexpr && IsA(arrayexpr, Const))\n\t{\n\t\tDatum\t\tarraydatum = ((Const *) arrayexpr)->constvalue;\n\t\tbool\t\tarrayisnull = ((Const *) arrayexpr)->constisnull;\n\t\tArrayType  *arrayval;\n\n\t\tif (arrayisnull)\n\t\t\treturn 0;\n\t\tarrayval = DatumGetArrayTypeP(arraydatum);\n\t\treturn ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));\n\t}\n\telse if (arrayexpr && IsA(arrayexpr, ArrayExpr) &&\n\t\t\t !((ArrayExpr *) arrayexpr)->multidims)\n\t{\n\t\treturn list_length(((ArrayExpr *) arrayexpr)->elements);\n\t}\n\telse\n\t{\n\t\t/* default guess --- see also scalararraysel */\n\t\treturn 10;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "clause",
            "ScalarArrayOpExpr"
          ],
          "line": 7022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 7005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "qinfos"
          ],
          "line": 7003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_indexquals",
          "args": [
            "path"
          ],
          "line": 6978
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_indexquals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6565-6653",
          "snippet": "List *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_relation_stats_hook_type get_relation_stats_hook = NULL;\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nbtcostestimate(PlannerInfo *root, IndexPath *path, double loop_count,\n\t\t\t   Cost *indexStartupCost, Cost *indexTotalCost,\n\t\t\t   Selectivity *indexSelectivity, double *indexCorrelation,\n\t\t\t   double *indexPages)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *qinfos;\n\tGenericCosts costs;\n\tOid\t\t\trelid;\n\tAttrNumber\tcolnum;\n\tVariableStatData vardata;\n\tdouble\t\tnumIndexTuples;\n\tCost\t\tdescentCost;\n\tList\t   *indexBoundQuals;\n\tint\t\t\tindexcol;\n\tbool\t\teqQualHere;\n\tbool\t\tfound_saop;\n\tbool\t\tfound_is_null_op;\n\tdouble\t\tnum_sa_scans;\n\tListCell   *lc;\n\n\t/* Do preliminary analysis of indexquals */\n\tqinfos = deconstruct_indexquals(path);\n\n\t/*\n\t * For a btree scan, only leading '=' quals plus inequality quals for the\n\t * immediately next attribute contribute to index selectivity (these are\n\t * the \"boundary quals\" that determine the starting and stopping points of\n\t * the index scan).  Additional quals can suppress visits to the heap, so\n\t * it's OK to count them in indexSelectivity, but they should not count\n\t * for estimating numIndexTuples.  So we must examine the given indexquals\n\t * to find out which ones count as boundary quals.  We rely on the\n\t * knowledge that they are given in index column order.\n\t *\n\t * For a RowCompareExpr, we consider only the first column, just as\n\t * rowcomparesel() does.\n\t *\n\t * If there's a ScalarArrayOpExpr in the quals, we'll actually perform N\n\t * index scans not one, but the ScalarArrayOpExpr's operator can be\n\t * considered to act the same as it normally does.\n\t */\n\tindexBoundQuals = NIL;\n\tindexcol = 0;\n\teqQualHere = false;\n\tfound_saop = false;\n\tfound_is_null_op = false;\n\tnum_sa_scans = 1;\n\tforeach(lc, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(lc);\n\t\tRestrictInfo *rinfo = qinfo->rinfo;\n\t\tExpr\t   *clause = rinfo->clause;\n\t\tOid\t\t\tclause_op;\n\t\tint\t\t\top_strategy;\n\n\t\tif (indexcol != qinfo->indexcol)\n\t\t{\n\t\t\t/* Beginning of a new column's quals */\n\t\t\tif (!eqQualHere)\n\t\t\t\tbreak;\t\t\t/* done if no '=' qual for indexcol */\n\t\t\teqQualHere = false;\n\t\t\tindexcol++;\n\t\t\tif (indexcol != qinfo->indexcol)\n\t\t\t\tbreak;\t\t\t/* no quals at all for indexcol */\n\t\t}\n\n\t\tif (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tint\t\t\talength = estimate_array_length(qinfo->other_operand);\n\n\t\t\tfound_saop = true;\n\t\t\t/* count up number of SA scans induced by indexBoundQuals only */\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tNullTest   *nt = (NullTest *) clause;\n\n\t\t\tif (nt->nulltesttype == IS_NULL)\n\t\t\t{\n\t\t\t\tfound_is_null_op = true;\n\t\t\t\t/* IS NULL is like = for selectivity determination purposes */\n\t\t\t\teqQualHere = true;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We would need to commute the clause_op if not varonleft, except\n\t\t * that we only care if it's equality or not, so that refinement is\n\t\t * unnecessary.\n\t\t */\n\t\tclause_op = qinfo->clause_op;\n\n\t\t/* check for equality operator */\n\t\tif (OidIsValid(clause_op))\n\t\t{\n\t\t\top_strategy = get_op_opfamily_strategy(clause_op,\n\t\t\t\t\t\t\t\t\t\t\t\t   index->opfamily[indexcol]);\n\t\t\tAssert(op_strategy != 0);\t/* not a member of opfamily?? */\n\t\t\tif (op_strategy == BTEqualStrategyNumber)\n\t\t\t\teqQualHere = true;\n\t\t}\n\n\t\tindexBoundQuals = lappend(indexBoundQuals, rinfo);\n\t}\n\n\t/*\n\t * If index is unique and we found an '=' clause for each column, we can\n\t * just assume numIndexTuples = 1 and skip the expensive\n\t * clauselist_selectivity calculations.  However, a ScalarArrayOp or\n\t * NullTest invalidates that theory, even though it sets eqQualHere.\n\t */\n\tif (index->unique &&\n\t\tindexcol == index->nkeycolumns - 1 &&\n\t\teqQualHere &&\n\t\t!found_saop &&\n\t\t!found_is_null_op)\n\t\tnumIndexTuples = 1.0;\n\telse\n\t{\n\t\tList\t   *selectivityQuals;\n\t\tSelectivity btreeSelectivity;\n\n\t\t/*\n\t\t * If the index is partial, AND the index predicate with the\n\t\t * index-bound quals to produce a more accurate idea of the number of\n\t\t * rows covered by the bound conditions.\n\t\t */\n\t\tselectivityQuals = add_predicate_to_quals(index, indexBoundQuals);\n\n\t\tbtreeSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\t\tnumIndexTuples = btreeSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * As in genericcostestimate(), we have to adjust for any\n\t\t * ScalarArrayOpExpr quals included in indexBoundQuals, and then round\n\t\t * to integer.\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * Now do generic index cost estimation.\n\t */\n\tMemSet(&costs, 0, sizeof(costs));\n\tcosts.numIndexTuples = numIndexTuples;\n\n\tgenericcostestimate(root, path, loop_count, qinfos, &costs);\n\n\t/*\n\t * Add a CPU-cost component to represent the costs of initial btree\n\t * descent.  We don't charge any I/O cost for touching upper btree levels,\n\t * since they tend to stay in cache, but we still have to do about log2(N)\n\t * comparisons to descend a btree of N leaf tuples.  We charge one\n\t * cpu_operator_cost per comparison.\n\t *\n\t * If there are ScalarArrayOpExprs, charge this once per SA scan.  The\n\t * ones after the first one are not startup cost so far as the overall\n\t * plan is concerned, so add them only to \"total\" cost.\n\t */\n\tif (index->tuples > 1)\t\t/* avoid computing log(0) */\n\t{\n\t\tdescentCost = ceil(log(index->tuples) / log(2.0)) * cpu_operator_cost;\n\t\tcosts.indexStartupCost += descentCost;\n\t\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\t}\n\n\t/*\n\t * Even though we're not charging I/O cost for touching upper btree pages,\n\t * it's still reasonable to charge some CPU cost per page descended\n\t * through.  Moreover, if we had no such charge at all, bloated indexes\n\t * would appear to have the same search cost as unbloated ones, at least\n\t * in cases where only a single leaf page is expected to be visited.  This\n\t * cost is somewhat arbitrarily set at 50x cpu_operator_cost per page\n\t * touched.  The number of such pages is btree tree height plus one (ie,\n\t * we charge for the leaf page too).  As above, charge once per SA scan.\n\t */\n\tdescentCost = (index->tree_height + 1) * 50.0 * cpu_operator_cost;\n\tcosts.indexStartupCost += descentCost;\n\tcosts.indexTotalCost += costs.num_sa_scans * descentCost;\n\n\t/*\n\t * If we can get an estimate of the first column's ordering correlation C\n\t * from pg_statistic, estimate the index correlation as C for a\n\t * single-column index, or C * 0.75 for multiple columns. (The idea here\n\t * is that multiple columns dilute the importance of the first column's\n\t * ordering, but don't negate it entirely.  Before 8.0 we divided the\n\t * correlation by the number of columns, but that seems too strong.)\n\t */\n\tMemSet(&vardata, 0, sizeof(vardata));\n\n\tif (index->indexkeys[0] != 0)\n\t{\n\t\t/* Simple variable --- look to stats for the underlying table */\n\t\tRangeTblEntry *rte = planner_rt_fetch(index->rel->relid, root);\n\n\t\tAssert(rte->rtekind == RTE_RELATION);\n\t\trelid = rte->relid;\n\t\tAssert(relid != InvalidOid);\n\t\tcolnum = index->indexkeys[0];\n\n\t\tif (get_relation_stats_hook &&\n\t\t\t(*get_relation_stats_hook) (root, rte, colnum, &vardata))\n\t\t{\n\t\t\t/*\n\t\t\t * The hook took control of acquiring a stats tuple.  If it did\n\t\t\t * supply a tuple, it'd better have supplied a freefunc.\n\t\t\t */\n\t\t\tif (HeapTupleIsValid(vardata.statsTuple) &&\n\t\t\t\t!vardata.freefunc)\n\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvardata.statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid),\n\t\t\t\t\t\t\t\t\t\t\t\t Int16GetDatum(colnum),\n\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(rte->inh));\n\t\t\tvardata.freefunc = ReleaseSysCache;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Expression --- maybe there are stats for the index itself */\n\t\trelid = index->indexoid;\n\t\tcolnum = 1;\n\n\t\tif (get_index_stats_hook &&\n\t\t\t(*get_index_stats_hook) (root, relid, colnum, &vardata))\n\t\t{\n\t\t\t/*\n\t\t\t * The hook took control of acquiring a stats tuple.  If it did\n\t\t\t * supply a tuple, it'd better have supplied a freefunc.\n\t\t\t */\n\t\t\tif (HeapTupleIsValid(vardata.statsTuple) &&\n\t\t\t\t!vardata.freefunc)\n\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvardata.statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(relid),\n\t\t\t\t\t\t\t\t\t\t\t\t Int16GetDatum(colnum),\n\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(false));\n\t\t\tvardata.freefunc = ReleaseSysCache;\n\t\t}\n\t}\n\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tOid\t\t\tsortop;\n\t\tAttStatsSlot sslot;\n\n\t\tsortop = get_opfamily_member(index->opfamily[0],\n\t\t\t\t\t\t\t\t\t index->opcintype[0],\n\t\t\t\t\t\t\t\t\t index->opcintype[0],\n\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\t\tif (OidIsValid(sortop) &&\n\t\t\tget_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_CORRELATION, sortop,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tdouble\t\tvarCorrelation;\n\n\t\t\tAssert(sslot.nnumbers == 1);\n\t\t\tvarCorrelation = sslot.numbers[0];\n\n\t\t\tif (index->reverse_sort[0])\n\t\t\t\tvarCorrelation = -varCorrelation;\n\n\t\t\tif (index->nkeycolumns > 1)\n\t\t\t\tcosts.indexCorrelation = varCorrelation * 0.75;\n\t\t\telse\n\t\t\t\tcosts.indexCorrelation = varCorrelation;\n\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\t*indexStartupCost = costs.indexStartupCost;\n\t*indexTotalCost = costs.indexTotalCost;\n\t*indexSelectivity = costs.indexSelectivity;\n\t*indexCorrelation = costs.indexCorrelation;\n\t*indexPages = costs.numIndexPages;\n}"
  },
  {
    "function_name": "add_predicate_to_quals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6933-6952",
    "snippet": "static List *\nadd_predicate_to_quals(IndexOptInfo *index, List *indexQuals)\n{\n\tList\t   *predExtraQuals = NIL;\n\tListCell   *lc;\n\n\tif (index->indpred == NIL)\n\t\treturn indexQuals;\n\n\tforeach(lc, index->indpred)\n\t{\n\t\tNode\t   *predQual = (Node *) lfirst(lc);\n\t\tList\t   *oneQual = list_make1(predQual);\n\n\t\tif (!predicate_implied_by(oneQual, indexQuals, false))\n\t\t\tpredExtraQuals = list_concat(predExtraQuals, oneQual);\n\t}\n\t/* list_concat avoids modifying the passed-in indexQuals list */\n\treturn list_concat(predExtraQuals, indexQuals);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_concat",
          "args": [
            "predExtraQuals",
            "indexQuals"
          ],
          "line": 6951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_concat",
          "args": [
            "predExtraQuals",
            "oneQual"
          ],
          "line": 6948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "predicate_implied_by",
          "args": [
            "oneQual",
            "indexQuals",
            "false"
          ],
          "line": 6947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make1",
          "args": [
            "predQual"
          ],
          "line": 6945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 6944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "index->indpred"
          ],
          "line": 6942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);\n\nstatic List *\nadd_predicate_to_quals(IndexOptInfo *index, List *indexQuals)\n{\n\tList\t   *predExtraQuals = NIL;\n\tListCell   *lc;\n\n\tif (index->indpred == NIL)\n\t\treturn indexQuals;\n\n\tforeach(lc, index->indpred)\n\t{\n\t\tNode\t   *predQual = (Node *) lfirst(lc);\n\t\tList\t   *oneQual = list_make1(predQual);\n\n\t\tif (!predicate_implied_by(oneQual, indexQuals, false))\n\t\t\tpredExtraQuals = list_concat(predExtraQuals, oneQual);\n\t}\n\t/* list_concat avoids modifying the passed-in indexQuals list */\n\treturn list_concat(predExtraQuals, indexQuals);\n}"
  },
  {
    "function_name": "genericcostestimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6714-6912",
    "snippet": "void\ngenericcostestimate(PlannerInfo *root,\n\t\t\t\t\tIndexPath *path,\n\t\t\t\t\tdouble loop_count,\n\t\t\t\t\tList *qinfos,\n\t\t\t\t\tGenericCosts *costs)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tCost\t\tindexStartupCost;\n\tCost\t\tindexTotalCost;\n\tSelectivity indexSelectivity;\n\tdouble\t\tindexCorrelation;\n\tdouble\t\tnumIndexPages;\n\tdouble\t\tnumIndexTuples;\n\tdouble\t\tspc_random_page_cost;\n\tdouble\t\tnum_sa_scans;\n\tdouble\t\tnum_outer_scans;\n\tdouble\t\tnum_scans;\n\tdouble\t\tqual_op_cost;\n\tdouble\t\tqual_arg_cost;\n\tList\t   *selectivityQuals;\n\tListCell   *l;\n\n\t/*\n\t * If the index is partial, AND the index predicate with the explicitly\n\t * given indexquals to produce a more accurate idea of the index\n\t * selectivity.\n\t */\n\tselectivityQuals = add_predicate_to_quals(index, indexQuals);\n\n\t/*\n\t * Check for ScalarArrayOpExpr index quals, and estimate the number of\n\t * index scans that will be performed.\n\t */\n\tnum_sa_scans = 1;\n\tforeach(l, indexQuals)\n\t{\n\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(l);\n\n\t\tif (IsA(rinfo->clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo->clause;\n\t\t\tint\t\t\talength = estimate_array_length(lsecond(saop->args));\n\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t}\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\tindexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * If caller didn't give us an estimate, estimate the number of index\n\t * tuples that will be visited.  We do it in this rather peculiar-looking\n\t * way in order to get the right answer for partial indexes.\n\t */\n\tnumIndexTuples = costs->numIndexTuples;\n\tif (numIndexTuples <= 0.0)\n\t{\n\t\tnumIndexTuples = indexSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * The above calculation counts all the tuples visited across all\n\t\t * scans induced by ScalarArrayOpExpr nodes.  We want to consider the\n\t\t * average per-indexscan number, so adjust.  This is a handy place to\n\t\t * round to integer, too.  (If caller supplied tuple estimate, it's\n\t\t * responsible for handling these considerations.)\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * We can bound the number of tuples by the index size in any case. Also,\n\t * always estimate at least one tuple is touched, even when\n\t * indexSelectivity estimate is tiny.\n\t */\n\tif (numIndexTuples > index->tuples)\n\t\tnumIndexTuples = index->tuples;\n\tif (numIndexTuples < 1.0)\n\t\tnumIndexTuples = 1.0;\n\n\t/*\n\t * Estimate the number of index pages that will be retrieved.\n\t *\n\t * We use the simplistic method of taking a pro-rata fraction of the total\n\t * number of index pages.  In effect, this counts only leaf pages and not\n\t * any overhead such as index metapage or upper tree levels.\n\t *\n\t * In practice access to upper index levels is often nearly free because\n\t * those tend to stay in cache under load; moreover, the cost involved is\n\t * highly dependent on index type.  We therefore ignore such costs here\n\t * and leave it to the caller to add a suitable charge if needed.\n\t */\n\tif (index->pages > 1 && index->tuples > 1)\n\t\tnumIndexPages = ceil(numIndexTuples * index->pages / index->tuples);\n\telse\n\t\tnumIndexPages = 1.0;\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Now compute the disk access costs.\n\t *\n\t * The above calculations are all per-index-scan.  However, if we are in a\n\t * nestloop inner scan, we can expect the scan to be repeated (with\n\t * different search keys) for each row of the outer relation.  Likewise,\n\t * ScalarArrayOpExpr quals result in multiple index scans.  This creates\n\t * the potential for cache effects to reduce the number of disk page\n\t * fetches needed.  We want to estimate the average per-scan I/O cost in\n\t * the presence of caching.\n\t *\n\t * We use the Mackert-Lohman formula (see costsize.c for details) to\n\t * estimate the total number of page fetches that occur.  While this\n\t * wasn't what it was designed for, it seems a reasonable model anyway.\n\t * Note that we are counting pages not tuples anymore, so we take N = T =\n\t * index size, as if there were one \"tuple\" per page.\n\t */\n\tnum_outer_scans = loop_count;\n\tnum_scans = num_sa_scans * num_outer_scans;\n\n\tif (num_scans > 1)\n\t{\n\t\tdouble\t\tpages_fetched;\n\n\t\t/* total page fetches ignoring cache effects */\n\t\tpages_fetched = numIndexPages * num_scans;\n\n\t\t/* use Mackert and Lohman formula to adjust for cache effects */\n\t\tpages_fetched = index_pages_fetched(pages_fetched,\n\t\t\t\t\t\t\t\t\t\t\tindex->pages,\n\t\t\t\t\t\t\t\t\t\t\t(double) index->pages,\n\t\t\t\t\t\t\t\t\t\t\troot);\n\n\t\t/*\n\t\t * Now compute the total disk access cost, and then report a pro-rated\n\t\t * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,\n\t\t * since that's internal to the indexscan.)\n\t\t */\n\t\tindexTotalCost = (pages_fetched * spc_random_page_cost)\n\t\t\t/ num_outer_scans;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For a single index scan, we just charge spc_random_page_cost per\n\t\t * page touched.\n\t\t */\n\t\tindexTotalCost = numIndexPages * spc_random_page_cost;\n\t}\n\n\t/*\n\t * CPU cost: any complex expressions in the indexquals will need to be\n\t * evaluated once at the start of the scan to reduce them to runtime keys\n\t * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple\n\t * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per\n\t * indexqual operator.  Because we have numIndexTuples as a per-scan\n\t * number, we have to multiply by num_sa_scans to get the correct result\n\t * for ScalarArrayOpExpr cases.  Similarly add in costs for any index\n\t * ORDER BY expressions.\n\t *\n\t * Note: this neglects the possible costs of rechecking lossy operators.\n\t * Detecting that that might be needed seems more expensive than it's\n\t * worth, though, considering all the other inaccuracies here ...\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\tindexStartupCost = qual_arg_cost;\n\tindexTotalCost += qual_arg_cost;\n\tindexTotalCost += numIndexTuples * num_sa_scans * (cpu_index_tuple_cost + qual_op_cost);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\tindexCorrelation = 0.0;\n\n\t/*\n\t * Return everything to caller.\n\t */\n\tcosts->indexStartupCost = indexStartupCost;\n\tcosts->indexTotalCost = indexTotalCost;\n\tcosts->indexSelectivity = indexSelectivity;\n\tcosts->indexCorrelation = indexCorrelation;\n\tcosts->numIndexPages = numIndexPages;\n\tcosts->numIndexTuples = numIndexTuples;\n\tcosts->spc_random_page_cost = spc_random_page_cost;\n\tcosts->num_sa_scans = num_sa_scans;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "indexOrderBys"
          ],
          "line": 6890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "indexQuals"
          ],
          "line": 6890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orderby_operands_eval_cost",
          "args": [
            "root",
            "path"
          ],
          "line": 6888
        },
        "resolved": true,
        "details": {
          "function_name": "orderby_operands_eval_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6685-6712",
          "snippet": "static Cost\norderby_operands_eval_cost(PlannerInfo *root, IndexPath *path)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, path->indexorderbys)\n\t{\n\t\tExpr\t   *clause = (Expr *) lfirst(lc);\n\t\tNode\t   *other_operand;\n\t\tQualCost\tindex_qual_cost;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tother_operand = get_rightop(clause);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexorderby type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t\tother_operand = NULL;\t/* keep compiler quiet */\n\t\t}\n\n\t\tcost_qual_eval_node(&index_qual_cost, other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Cost\norderby_operands_eval_cost(PlannerInfo *root, IndexPath *path)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, path->indexorderbys)\n\t{\n\t\tExpr\t   *clause = (Expr *) lfirst(lc);\n\t\tNode\t   *other_operand;\n\t\tQualCost\tindex_qual_cost;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tother_operand = get_rightop(clause);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexorderby type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t\tother_operand = NULL;\t/* keep compiler quiet */\n\t\t}\n\n\t\tcost_qual_eval_node(&index_qual_cost, other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}"
        }
      },
      {
        "call_info": {
          "callee": "other_operands_eval_cost",
          "args": [
            "root",
            "qinfos"
          ],
          "line": 6887
        },
        "resolved": true,
        "details": {
          "function_name": "other_operands_eval_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6660-6675",
          "snippet": "static Cost\nother_operands_eval_cost(PlannerInfo *root, List *qinfos)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(lc);\n\t\tQualCost\tindex_qual_cost;\n\n\t\tcost_qual_eval_node(&index_qual_cost, qinfo->other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Cost\nother_operands_eval_cost(PlannerInfo *root, List *qinfos)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(lc);\n\t\tQualCost\tindex_qual_cost;\n\n\t\tcost_qual_eval_node(&index_qual_cost, qinfo->other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_pages_fetched",
          "args": [
            "pages_fetched",
            "index->pages",
            "(double) index->pages",
            "root"
          ],
          "line": 6851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tablespace_page_costs",
          "args": [
            "index->reltablespace",
            "&spc_random_page_cost",
            "NULL"
          ],
          "line": 6819
        },
        "resolved": true,
        "details": {
          "function_name": "get_tablespace_page_costs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/spccache.c",
          "lines": "181-205",
          "snippet": "void\nget_tablespace_page_costs(Oid spcid,\n\t\t\t\t\t\t  double *spc_random_page_cost,\n\t\t\t\t\t\t  double *spc_seq_page_cost)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tAssert(spc != NULL);\n\n\tif (spc_random_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->random_page_cost < 0)\n\t\t\t*spc_random_page_cost = random_page_cost;\n\t\telse\n\t\t\t*spc_random_page_cost = spc->opts->random_page_cost;\n\t}\n\n\tif (spc_seq_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->seq_page_cost < 0)\n\t\t\t*spc_seq_page_cost = seq_page_cost;\n\t\telse\n\t\t\t*spc_seq_page_cost = spc->opts->seq_page_cost;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"storage/bufmgr.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"access/reloptions.h\"\n#include \"postgres.h\"\n\nvoid\nget_tablespace_page_costs(Oid spcid,\n\t\t\t\t\t\t  double *spc_random_page_cost,\n\t\t\t\t\t\t  double *spc_seq_page_cost)\n{\n\tTableSpaceCacheEntry *spc = get_tablespace(spcid);\n\n\tAssert(spc != NULL);\n\n\tif (spc_random_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->random_page_cost < 0)\n\t\t\t*spc_random_page_cost = random_page_cost;\n\t\telse\n\t\t\t*spc_random_page_cost = spc->opts->random_page_cost;\n\t}\n\n\tif (spc_seq_page_cost)\n\t{\n\t\tif (!spc->opts || spc->opts->seq_page_cost < 0)\n\t\t\t*spc_seq_page_cost = seq_page_cost;\n\t\telse\n\t\t\t*spc_seq_page_cost = spc->opts->seq_page_cost;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "numIndexTuples * index->pages / index->tuples"
          ],
          "line": 6814
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "numIndexTuples / num_sa_scans"
          ],
          "line": 6788
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clauselist_selectivity",
          "args": [
            "root",
            "selectivityQuals",
            "index->rel->relid",
            "JOIN_INNER",
            "NULL"
          ],
          "line": 6766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimate_array_length",
          "args": [
            "lsecond(saop->args)"
          ],
          "line": 6758
        },
        "resolved": true,
        "details": {
          "function_name": "estimate_array_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2178-2205",
          "snippet": "int\nestimate_array_length(Node *arrayexpr)\n{\n\t/* look through any binary-compatible relabeling of arrayexpr */\n\tarrayexpr = strip_array_coercion(arrayexpr);\n\n\tif (arrayexpr && IsA(arrayexpr, Const))\n\t{\n\t\tDatum\t\tarraydatum = ((Const *) arrayexpr)->constvalue;\n\t\tbool\t\tarrayisnull = ((Const *) arrayexpr)->constisnull;\n\t\tArrayType  *arrayval;\n\n\t\tif (arrayisnull)\n\t\t\treturn 0;\n\t\tarrayval = DatumGetArrayTypeP(arraydatum);\n\t\treturn ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));\n\t}\n\telse if (arrayexpr && IsA(arrayexpr, ArrayExpr) &&\n\t\t\t !((ArrayExpr *) arrayexpr)->multidims)\n\t{\n\t\treturn list_length(((ArrayExpr *) arrayexpr)->elements);\n\t}\n\telse\n\t{\n\t\t/* default guess --- see also scalararraysel */\n\t\treturn 10;\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nestimate_array_length(Node *arrayexpr)\n{\n\t/* look through any binary-compatible relabeling of arrayexpr */\n\tarrayexpr = strip_array_coercion(arrayexpr);\n\n\tif (arrayexpr && IsA(arrayexpr, Const))\n\t{\n\t\tDatum\t\tarraydatum = ((Const *) arrayexpr)->constvalue;\n\t\tbool\t\tarrayisnull = ((Const *) arrayexpr)->constisnull;\n\t\tArrayType  *arrayval;\n\n\t\tif (arrayisnull)\n\t\t\treturn 0;\n\t\tarrayval = DatumGetArrayTypeP(arraydatum);\n\t\treturn ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));\n\t}\n\telse if (arrayexpr && IsA(arrayexpr, ArrayExpr) &&\n\t\t\t !((ArrayExpr *) arrayexpr)->multidims)\n\t{\n\t\treturn list_length(((ArrayExpr *) arrayexpr)->elements);\n\t}\n\telse\n\t{\n\t\t/* default guess --- see also scalararraysel */\n\t\treturn 10;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lsecond",
          "args": [
            "saop->args"
          ],
          "line": 6758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rinfo->clause",
            "ScalarArrayOpExpr"
          ],
          "line": 6755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 6753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "indexQuals"
          ],
          "line": 6751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_predicate_to_quals",
          "args": [
            "index",
            "indexQuals"
          ],
          "line": 6744
        },
        "resolved": true,
        "details": {
          "function_name": "add_predicate_to_quals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6933-6952",
          "snippet": "static List *\nadd_predicate_to_quals(IndexOptInfo *index, List *indexQuals)\n{\n\tList\t   *predExtraQuals = NIL;\n\tListCell   *lc;\n\n\tif (index->indpred == NIL)\n\t\treturn indexQuals;\n\n\tforeach(lc, index->indpred)\n\t{\n\t\tNode\t   *predQual = (Node *) lfirst(lc);\n\t\tList\t   *oneQual = list_make1(predQual);\n\n\t\tif (!predicate_implied_by(oneQual, indexQuals, false))\n\t\t\tpredExtraQuals = list_concat(predExtraQuals, oneQual);\n\t}\n\t/* list_concat avoids modifying the passed-in indexQuals list */\n\treturn list_concat(predExtraQuals, indexQuals);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);\n\nstatic List *\nadd_predicate_to_quals(IndexOptInfo *index, List *indexQuals)\n{\n\tList\t   *predExtraQuals = NIL;\n\tListCell   *lc;\n\n\tif (index->indpred == NIL)\n\t\treturn indexQuals;\n\n\tforeach(lc, index->indpred)\n\t{\n\t\tNode\t   *predQual = (Node *) lfirst(lc);\n\t\tList\t   *oneQual = list_make1(predQual);\n\n\t\tif (!predicate_implied_by(oneQual, indexQuals, false))\n\t\t\tpredExtraQuals = list_concat(predExtraQuals, oneQual);\n\t}\n\t/* list_concat avoids modifying the passed-in indexQuals list */\n\treturn list_concat(predExtraQuals, indexQuals);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic List *add_predicate_to_quals(IndexOptInfo *index, List *indexQuals);\n\nvoid\ngenericcostestimate(PlannerInfo *root,\n\t\t\t\t\tIndexPath *path,\n\t\t\t\t\tdouble loop_count,\n\t\t\t\t\tList *qinfos,\n\t\t\t\t\tGenericCosts *costs)\n{\n\tIndexOptInfo *index = path->indexinfo;\n\tList\t   *indexQuals = path->indexquals;\n\tList\t   *indexOrderBys = path->indexorderbys;\n\tCost\t\tindexStartupCost;\n\tCost\t\tindexTotalCost;\n\tSelectivity indexSelectivity;\n\tdouble\t\tindexCorrelation;\n\tdouble\t\tnumIndexPages;\n\tdouble\t\tnumIndexTuples;\n\tdouble\t\tspc_random_page_cost;\n\tdouble\t\tnum_sa_scans;\n\tdouble\t\tnum_outer_scans;\n\tdouble\t\tnum_scans;\n\tdouble\t\tqual_op_cost;\n\tdouble\t\tqual_arg_cost;\n\tList\t   *selectivityQuals;\n\tListCell   *l;\n\n\t/*\n\t * If the index is partial, AND the index predicate with the explicitly\n\t * given indexquals to produce a more accurate idea of the index\n\t * selectivity.\n\t */\n\tselectivityQuals = add_predicate_to_quals(index, indexQuals);\n\n\t/*\n\t * Check for ScalarArrayOpExpr index quals, and estimate the number of\n\t * index scans that will be performed.\n\t */\n\tnum_sa_scans = 1;\n\tforeach(l, indexQuals)\n\t{\n\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(l);\n\n\t\tif (IsA(rinfo->clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) rinfo->clause;\n\t\t\tint\t\t\talength = estimate_array_length(lsecond(saop->args));\n\n\t\t\tif (alength > 1)\n\t\t\t\tnum_sa_scans *= alength;\n\t\t}\n\t}\n\n\t/* Estimate the fraction of main-table tuples that will be visited */\n\tindexSelectivity = clauselist_selectivity(root, selectivityQuals,\n\t\t\t\t\t\t\t\t\t\t\t  index->rel->relid,\n\t\t\t\t\t\t\t\t\t\t\t  JOIN_INNER,\n\t\t\t\t\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * If caller didn't give us an estimate, estimate the number of index\n\t * tuples that will be visited.  We do it in this rather peculiar-looking\n\t * way in order to get the right answer for partial indexes.\n\t */\n\tnumIndexTuples = costs->numIndexTuples;\n\tif (numIndexTuples <= 0.0)\n\t{\n\t\tnumIndexTuples = indexSelectivity * index->rel->tuples;\n\n\t\t/*\n\t\t * The above calculation counts all the tuples visited across all\n\t\t * scans induced by ScalarArrayOpExpr nodes.  We want to consider the\n\t\t * average per-indexscan number, so adjust.  This is a handy place to\n\t\t * round to integer, too.  (If caller supplied tuple estimate, it's\n\t\t * responsible for handling these considerations.)\n\t\t */\n\t\tnumIndexTuples = rint(numIndexTuples / num_sa_scans);\n\t}\n\n\t/*\n\t * We can bound the number of tuples by the index size in any case. Also,\n\t * always estimate at least one tuple is touched, even when\n\t * indexSelectivity estimate is tiny.\n\t */\n\tif (numIndexTuples > index->tuples)\n\t\tnumIndexTuples = index->tuples;\n\tif (numIndexTuples < 1.0)\n\t\tnumIndexTuples = 1.0;\n\n\t/*\n\t * Estimate the number of index pages that will be retrieved.\n\t *\n\t * We use the simplistic method of taking a pro-rata fraction of the total\n\t * number of index pages.  In effect, this counts only leaf pages and not\n\t * any overhead such as index metapage or upper tree levels.\n\t *\n\t * In practice access to upper index levels is often nearly free because\n\t * those tend to stay in cache under load; moreover, the cost involved is\n\t * highly dependent on index type.  We therefore ignore such costs here\n\t * and leave it to the caller to add a suitable charge if needed.\n\t */\n\tif (index->pages > 1 && index->tuples > 1)\n\t\tnumIndexPages = ceil(numIndexTuples * index->pages / index->tuples);\n\telse\n\t\tnumIndexPages = 1.0;\n\n\t/* fetch estimated page cost for tablespace containing index */\n\tget_tablespace_page_costs(index->reltablespace,\n\t\t\t\t\t\t\t  &spc_random_page_cost,\n\t\t\t\t\t\t\t  NULL);\n\n\t/*\n\t * Now compute the disk access costs.\n\t *\n\t * The above calculations are all per-index-scan.  However, if we are in a\n\t * nestloop inner scan, we can expect the scan to be repeated (with\n\t * different search keys) for each row of the outer relation.  Likewise,\n\t * ScalarArrayOpExpr quals result in multiple index scans.  This creates\n\t * the potential for cache effects to reduce the number of disk page\n\t * fetches needed.  We want to estimate the average per-scan I/O cost in\n\t * the presence of caching.\n\t *\n\t * We use the Mackert-Lohman formula (see costsize.c for details) to\n\t * estimate the total number of page fetches that occur.  While this\n\t * wasn't what it was designed for, it seems a reasonable model anyway.\n\t * Note that we are counting pages not tuples anymore, so we take N = T =\n\t * index size, as if there were one \"tuple\" per page.\n\t */\n\tnum_outer_scans = loop_count;\n\tnum_scans = num_sa_scans * num_outer_scans;\n\n\tif (num_scans > 1)\n\t{\n\t\tdouble\t\tpages_fetched;\n\n\t\t/* total page fetches ignoring cache effects */\n\t\tpages_fetched = numIndexPages * num_scans;\n\n\t\t/* use Mackert and Lohman formula to adjust for cache effects */\n\t\tpages_fetched = index_pages_fetched(pages_fetched,\n\t\t\t\t\t\t\t\t\t\t\tindex->pages,\n\t\t\t\t\t\t\t\t\t\t\t(double) index->pages,\n\t\t\t\t\t\t\t\t\t\t\troot);\n\n\t\t/*\n\t\t * Now compute the total disk access cost, and then report a pro-rated\n\t\t * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,\n\t\t * since that's internal to the indexscan.)\n\t\t */\n\t\tindexTotalCost = (pages_fetched * spc_random_page_cost)\n\t\t\t/ num_outer_scans;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For a single index scan, we just charge spc_random_page_cost per\n\t\t * page touched.\n\t\t */\n\t\tindexTotalCost = numIndexPages * spc_random_page_cost;\n\t}\n\n\t/*\n\t * CPU cost: any complex expressions in the indexquals will need to be\n\t * evaluated once at the start of the scan to reduce them to runtime keys\n\t * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple\n\t * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per\n\t * indexqual operator.  Because we have numIndexTuples as a per-scan\n\t * number, we have to multiply by num_sa_scans to get the correct result\n\t * for ScalarArrayOpExpr cases.  Similarly add in costs for any index\n\t * ORDER BY expressions.\n\t *\n\t * Note: this neglects the possible costs of rechecking lossy operators.\n\t * Detecting that that might be needed seems more expensive than it's\n\t * worth, though, considering all the other inaccuracies here ...\n\t */\n\tqual_arg_cost = other_operands_eval_cost(root, qinfos) +\n\t\torderby_operands_eval_cost(root, path);\n\tqual_op_cost = cpu_operator_cost *\n\t\t(list_length(indexQuals) + list_length(indexOrderBys));\n\n\tindexStartupCost = qual_arg_cost;\n\tindexTotalCost += qual_arg_cost;\n\tindexTotalCost += numIndexTuples * num_sa_scans * (cpu_index_tuple_cost + qual_op_cost);\n\n\t/*\n\t * Generic assumption about index correlation: there isn't any.\n\t */\n\tindexCorrelation = 0.0;\n\n\t/*\n\t * Return everything to caller.\n\t */\n\tcosts->indexStartupCost = indexStartupCost;\n\tcosts->indexTotalCost = indexTotalCost;\n\tcosts->indexSelectivity = indexSelectivity;\n\tcosts->indexCorrelation = indexCorrelation;\n\tcosts->numIndexPages = numIndexPages;\n\tcosts->numIndexTuples = numIndexTuples;\n\tcosts->spc_random_page_cost = spc_random_page_cost;\n\tcosts->num_sa_scans = num_sa_scans;\n}"
  },
  {
    "function_name": "orderby_operands_eval_cost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6685-6712",
    "snippet": "static Cost\norderby_operands_eval_cost(PlannerInfo *root, IndexPath *path)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, path->indexorderbys)\n\t{\n\t\tExpr\t   *clause = (Expr *) lfirst(lc);\n\t\tNode\t   *other_operand;\n\t\tQualCost\tindex_qual_cost;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tother_operand = get_rightop(clause);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexorderby type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t\tother_operand = NULL;\t/* keep compiler quiet */\n\t\t}\n\n\t\tcost_qual_eval_node(&index_qual_cost, other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cost_qual_eval_node",
          "args": [
            "&index_qual_cost",
            "other_operand",
            "root"
          ],
          "line": 6708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unsupported indexorderby type: %d\"",
            "(int) nodeTag(clause)"
          ],
          "line": 6703
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeTag",
          "args": [
            "clause"
          ],
          "line": 6704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rightop",
          "args": [
            "clause"
          ],
          "line": 6699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "clause",
            "OpExpr"
          ],
          "line": 6697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 6693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "path->indexorderbys"
          ],
          "line": 6691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Cost\norderby_operands_eval_cost(PlannerInfo *root, IndexPath *path)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, path->indexorderbys)\n\t{\n\t\tExpr\t   *clause = (Expr *) lfirst(lc);\n\t\tNode\t   *other_operand;\n\t\tQualCost\tindex_qual_cost;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tother_operand = get_rightop(clause);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexorderby type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t\tother_operand = NULL;\t/* keep compiler quiet */\n\t\t}\n\n\t\tcost_qual_eval_node(&index_qual_cost, other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}"
  },
  {
    "function_name": "other_operands_eval_cost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6660-6675",
    "snippet": "static Cost\nother_operands_eval_cost(PlannerInfo *root, List *qinfos)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(lc);\n\t\tQualCost\tindex_qual_cost;\n\n\t\tcost_qual_eval_node(&index_qual_cost, qinfo->other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cost_qual_eval_node",
          "args": [
            "&index_qual_cost",
            "qinfo->other_operand",
            "root"
          ],
          "line": 6671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 6668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "qinfos"
          ],
          "line": 6666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Cost\nother_operands_eval_cost(PlannerInfo *root, List *qinfos)\n{\n\tCost\t\tqual_arg_cost = 0;\n\tListCell   *lc;\n\n\tforeach(lc, qinfos)\n\t{\n\t\tIndexQualInfo *qinfo = (IndexQualInfo *) lfirst(lc);\n\t\tQualCost\tindex_qual_cost;\n\n\t\tcost_qual_eval_node(&index_qual_cost, qinfo->other_operand, root);\n\t\tqual_arg_cost += index_qual_cost.startup + index_qual_cost.per_tuple;\n\t}\n\treturn qual_arg_cost;\n}"
  },
  {
    "function_name": "deconstruct_indexquals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6565-6653",
    "snippet": "List *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "result",
            "qinfo"
          ],
          "line": 6650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unsupported indexqual type: %d\"",
            "(int) nodeTag(clause)"
          ],
          "line": 6646
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeTag",
          "args": [
            "clause"
          ],
          "line": 6647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index)"
          ],
          "line": 6639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_index_to_operand",
          "args": [
            "(Node *) ((NullTest *) clause)->arg",
            "indexcol",
            "index"
          ],
          "line": 6639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "clause",
            "NullTest"
          ],
          "line": 6636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsecond",
          "args": [
            "saop->args"
          ],
          "line": 6634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index)"
          ],
          "line": 6631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_index_to_operand",
          "args": [
            "(Node *) linitial(saop->args)",
            "indexcol",
            "index"
          ],
          "line": 6631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "saop->args"
          ],
          "line": 6631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "clause",
            "ScalarArrayOpExpr"
          ],
          "line": 6625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index)"
          ],
          "line": 6619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_index_to_operand",
          "args": [
            "(Node *) linitial(rc->rargs)",
            "indexcol",
            "index"
          ],
          "line": 6619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "rc->rargs"
          ],
          "line": 6619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_index_to_operand",
          "args": [
            "(Node *) linitial(rc->largs)",
            "indexcol",
            "index"
          ],
          "line": 6611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "rc->largs"
          ],
          "line": 6611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial_oid",
          "args": [
            "rc->opnos"
          ],
          "line": 6609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "clause",
            "RowCompareExpr"
          ],
          "line": 6605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "match_index_to_operand(rightop, indexcol, index)"
          ],
          "line": 6600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_index_to_operand",
          "args": [
            "rightop",
            "indexcol",
            "index"
          ],
          "line": 6600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_index_to_operand",
          "args": [
            "leftop",
            "indexcol",
            "index"
          ],
          "line": 6593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rightop",
          "args": [
            "clause"
          ],
          "line": 6592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_leftop",
          "args": [
            "clause"
          ],
          "line": 6591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "clause",
            "OpExpr"
          ],
          "line": 6588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(IndexQualInfo)"
          ],
          "line": 6584
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst_int",
          "args": [
            "lci"
          ],
          "line": 6576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "RestrictInfo",
            "lcc"
          ],
          "line": 6575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forboth",
          "args": [
            "lcc",
            "path->indexquals",
            "lci",
            "path->indexqualcols"
          ],
          "line": 6573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\ndeconstruct_indexquals(IndexPath *path)\n{\n\tList\t   *result = NIL;\n\tIndexOptInfo *index = path->indexinfo;\n\tListCell   *lcc,\n\t\t\t   *lci;\n\n\tforboth(lcc, path->indexquals, lci, path->indexqualcols)\n\t{\n\t\tRestrictInfo *rinfo = lfirst_node(RestrictInfo, lcc);\n\t\tint\t\t\tindexcol = lfirst_int(lci);\n\t\tExpr\t   *clause;\n\t\tNode\t   *leftop,\n\t\t\t\t   *rightop;\n\t\tIndexQualInfo *qinfo;\n\n\t\tclause = rinfo->clause;\n\n\t\tqinfo = (IndexQualInfo *) palloc(sizeof(IndexQualInfo));\n\t\tqinfo->rinfo = rinfo;\n\t\tqinfo->indexcol = indexcol;\n\n\t\tif (IsA(clause, OpExpr))\n\t\t{\n\t\t\tqinfo->clause_op = ((OpExpr *) clause)->opno;\n\t\t\tleftop = get_leftop(clause);\n\t\t\trightop = get_rightop(clause);\n\t\t\tif (match_index_to_operand(leftop, indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = rightop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand(rightop, indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = leftop;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, RowCompareExpr))\n\t\t{\n\t\t\tRowCompareExpr *rc = (RowCompareExpr *) clause;\n\n\t\t\tqinfo->clause_op = linitial_oid(rc->opnos);\n\t\t\t/* Examine only first columns to determine left/right sides */\n\t\t\tif (match_index_to_operand((Node *) linitial(rc->largs),\n\t\t\t\t\t\t\t\t\t   indexcol, index))\n\t\t\t{\n\t\t\t\tqinfo->varonleft = true;\n\t\t\t\tqinfo->other_operand = (Node *) rc->rargs;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tAssert(match_index_to_operand((Node *) linitial(rc->rargs),\n\t\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\t\tqinfo->varonleft = false;\n\t\t\t\tqinfo->other_operand = (Node *) rc->largs;\n\t\t\t}\n\t\t}\n\t\telse if (IsA(clause, ScalarArrayOpExpr))\n\t\t{\n\t\t\tScalarArrayOpExpr *saop = (ScalarArrayOpExpr *) clause;\n\n\t\t\tqinfo->clause_op = saop->opno;\n\t\t\t/* index column is always on the left in this case */\n\t\t\tAssert(match_index_to_operand((Node *) linitial(saop->args),\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = (Node *) lsecond(saop->args);\n\t\t}\n\t\telse if (IsA(clause, NullTest))\n\t\t{\n\t\t\tqinfo->clause_op = InvalidOid;\n\t\t\tAssert(match_index_to_operand((Node *) ((NullTest *) clause)->arg,\n\t\t\t\t\t\t\t\t\t\t  indexcol, index));\n\t\t\tqinfo->varonleft = true;\n\t\t\tqinfo->other_operand = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"unsupported indexqual type: %d\",\n\t\t\t\t (int) nodeTag(clause));\n\t\t}\n\n\t\tresult = lappend(result, qinfo);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "string_to_bytea_const",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6545-6556",
    "snippet": "static Const *\nstring_to_bytea_const(const char *str, size_t str_len)\n{\n\tbytea\t   *bstr = palloc(VARHDRSZ + str_len);\n\tDatum\t\tconval;\n\n\tmemcpy(VARDATA(bstr), str, str_len);\n\tSET_VARSIZE(bstr, VARHDRSZ + str_len);\n\tconval = PointerGetDatum(bstr);\n\n\treturn makeConst(BYTEAOID, -1, InvalidOid, -1, conval, false, false);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Const *string_to_bytea_const(const char *str, size_t str_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeConst",
          "args": [
            "BYTEAOID",
            "-1",
            "InvalidOid",
            "-1",
            "conval",
            "false",
            "false"
          ],
          "line": 6555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "bstr"
          ],
          "line": 6553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "bstr",
            "VARHDRSZ + str_len"
          ],
          "line": 6552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(bstr)",
            "str",
            "str_len"
          ],
          "line": 6551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "bstr"
          ],
          "line": 6551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + str_len"
          ],
          "line": 6548
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Const *string_to_bytea_const(const char *str, size_t str_len);\n\nstatic Const *\nstring_to_bytea_const(const char *str, size_t str_len)\n{\n\tbytea\t   *bstr = palloc(VARHDRSZ + str_len);\n\tDatum\t\tconval;\n\n\tmemcpy(VARDATA(bstr), str, str_len);\n\tSET_VARSIZE(bstr, VARHDRSZ + str_len);\n\tconval = PointerGetDatum(bstr);\n\n\treturn makeConst(BYTEAOID, -1, InvalidOid, -1, conval, false, false);\n}"
  },
  {
    "function_name": "string_to_const",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6502-6540",
    "snippet": "static Const *\nstring_to_const(const char *str, Oid datatype)\n{\n\tDatum\t\tconval = string_to_datum(str, datatype);\n\tOid\t\t\tcollation;\n\tint\t\t\tconstlen;\n\n\t/*\n\t * We only need to support a few datatypes here, so hard-wire properties\n\t * instead of incurring the expense of catalog lookups.\n\t */\n\tswitch (datatype)\n\t{\n\t\tcase TEXTOID:\n\t\tcase VARCHAROID:\n\t\tcase BPCHAROID:\n\t\t\tcollation = DEFAULT_COLLATION_OID;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tcase NAMEOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = NAMEDATALEN;\n\t\t\tbreak;\n\n\t\tcase BYTEAOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected datatype in string_to_const: %u\",\n\t\t\t\t datatype);\n\t\t\treturn NULL;\n\t}\n\n\treturn makeConst(datatype, -1, collation, constlen,\n\t\t\t\t\t conval, false, false);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum string_to_datum(const char *str, Oid datatype);",
      "static Const *string_to_const(const char *str, Oid datatype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeConst",
          "args": [
            "datatype",
            "-1",
            "collation",
            "constlen",
            "conval",
            "false",
            "false"
          ],
          "line": 6538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected datatype in string_to_const: %u\"",
            "datatype"
          ],
          "line": 6533
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_to_datum",
          "args": [
            "str",
            "datatype"
          ],
          "line": 6505
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_datum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6482-6497",
          "snippet": "static Datum\nstring_to_datum(const char *str, Oid datatype)\n{\n\tAssert(str != NULL);\n\n\t/*\n\t * We cheat a little by assuming that CStringGetTextDatum() will do for\n\t * bpchar and varchar constants too...\n\t */\n\tif (datatype == NAMEOID)\n\t\treturn DirectFunctionCall1(namein, CStringGetDatum(str));\n\telse if (datatype == BYTEAOID)\n\t\treturn DirectFunctionCall1(byteain, CStringGetDatum(str));\n\telse\n\t\treturn CStringGetTextDatum(str);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum string_to_datum(const char *str, Oid datatype);",
            "static Const *string_to_const(const char *str, Oid datatype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum string_to_datum(const char *str, Oid datatype);\nstatic Const *string_to_const(const char *str, Oid datatype);\n\nstatic Datum\nstring_to_datum(const char *str, Oid datatype)\n{\n\tAssert(str != NULL);\n\n\t/*\n\t * We cheat a little by assuming that CStringGetTextDatum() will do for\n\t * bpchar and varchar constants too...\n\t */\n\tif (datatype == NAMEOID)\n\t\treturn DirectFunctionCall1(namein, CStringGetDatum(str));\n\telse if (datatype == BYTEAOID)\n\t\treturn DirectFunctionCall1(byteain, CStringGetDatum(str));\n\telse\n\t\treturn CStringGetTextDatum(str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum string_to_datum(const char *str, Oid datatype);\nstatic Const *string_to_const(const char *str, Oid datatype);\n\nstatic Const *\nstring_to_const(const char *str, Oid datatype)\n{\n\tDatum\t\tconval = string_to_datum(str, datatype);\n\tOid\t\t\tcollation;\n\tint\t\t\tconstlen;\n\n\t/*\n\t * We only need to support a few datatypes here, so hard-wire properties\n\t * instead of incurring the expense of catalog lookups.\n\t */\n\tswitch (datatype)\n\t{\n\t\tcase TEXTOID:\n\t\tcase VARCHAROID:\n\t\tcase BPCHAROID:\n\t\t\tcollation = DEFAULT_COLLATION_OID;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tcase NAMEOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = NAMEDATALEN;\n\t\t\tbreak;\n\n\t\tcase BYTEAOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected datatype in string_to_const: %u\",\n\t\t\t\t datatype);\n\t\t\treturn NULL;\n\t}\n\n\treturn makeConst(datatype, -1, collation, constlen,\n\t\t\t\t\t conval, false, false);\n}"
  },
  {
    "function_name": "string_to_datum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6482-6497",
    "snippet": "static Datum\nstring_to_datum(const char *str, Oid datatype)\n{\n\tAssert(str != NULL);\n\n\t/*\n\t * We cheat a little by assuming that CStringGetTextDatum() will do for\n\t * bpchar and varchar constants too...\n\t */\n\tif (datatype == NAMEOID)\n\t\treturn DirectFunctionCall1(namein, CStringGetDatum(str));\n\telse if (datatype == BYTEAOID)\n\t\treturn DirectFunctionCall1(byteain, CStringGetDatum(str));\n\telse\n\t\treturn CStringGetTextDatum(str);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum string_to_datum(const char *str, Oid datatype);",
      "static Const *string_to_const(const char *str, Oid datatype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "str"
          ],
          "line": 6496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "byteain",
            "CStringGetDatum(str)"
          ],
          "line": 6494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "str"
          ],
          "line": 6494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "namein",
            "CStringGetDatum(str)"
          ],
          "line": 6492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "str"
          ],
          "line": 6492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "str != NULL"
          ],
          "line": 6485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum string_to_datum(const char *str, Oid datatype);\nstatic Const *string_to_const(const char *str, Oid datatype);\n\nstatic Datum\nstring_to_datum(const char *str, Oid datatype)\n{\n\tAssert(str != NULL);\n\n\t/*\n\t * We cheat a little by assuming that CStringGetTextDatum() will do for\n\t * bpchar and varchar constants too...\n\t */\n\tif (datatype == NAMEOID)\n\t\treturn DirectFunctionCall1(namein, CStringGetDatum(str));\n\telse if (datatype == BYTEAOID)\n\t\treturn DirectFunctionCall1(byteain, CStringGetDatum(str));\n\telse\n\t\treturn CStringGetTextDatum(str);\n}"
  },
  {
    "function_name": "make_greater_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6339-6475",
    "snippet": "Const *\nmake_greater_string(const Const *str_const, FmgrInfo *ltproc, Oid collation)\n{\n\tOid\t\t\tdatatype = str_const->consttype;\n\tchar\t   *workstr;\n\tint\t\t\tlen;\n\tDatum\t\tcmpstr;\n\ttext\t   *cmptxt = NULL;\n\tmbcharacter_incrementer charinc;\n\n\t/*\n\t * Get a modifiable copy of the prefix string in C-string format, and set\n\t * up the string we will compare to as a Datum.  In C locale this can just\n\t * be the given prefix string, otherwise we need to add a suffix.  Types\n\t * NAME and BYTEA sort bytewise so they don't need a suffix either.\n\t */\n\tif (datatype == NAMEOID)\n\t{\n\t\tworkstr = DatumGetCString(DirectFunctionCall1(nameout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  str_const->constvalue));\n\t\tlen = strlen(workstr);\n\t\tcmpstr = str_const->constvalue;\n\t}\n\telse if (datatype == BYTEAOID)\n\t{\n\t\tbytea\t   *bstr = DatumGetByteaPP(str_const->constvalue);\n\n\t\tlen = VARSIZE_ANY_EXHDR(bstr);\n\t\tworkstr = (char *) palloc(len);\n\t\tmemcpy(workstr, VARDATA_ANY(bstr), len);\n\t\tAssert((Pointer) bstr == DatumGetPointer(str_const->constvalue));\n\t\tcmpstr = str_const->constvalue;\n\t}\n\telse\n\t{\n\t\tworkstr = TextDatumGetCString(str_const->constvalue);\n\t\tlen = strlen(workstr);\n\t\tif (lc_collate_is_c(collation) || len == 0)\n\t\t\tcmpstr = str_const->constvalue;\n\t\telse\n\t\t{\n\t\t\t/* If first time through, determine the suffix to use */\n\t\t\tstatic char suffixchar = 0;\n\t\t\tstatic Oid\tsuffixcollation = 0;\n\n\t\t\tif (!suffixchar || suffixcollation != collation)\n\t\t\t{\n\t\t\t\tchar\t   *best;\n\n\t\t\t\tbest = \"Z\";\n\t\t\t\tif (varstr_cmp(best, 1, \"z\", 1, collation) < 0)\n\t\t\t\t\tbest = \"z\";\n\t\t\t\tif (varstr_cmp(best, 1, \"y\", 1, collation) < 0)\n\t\t\t\t\tbest = \"y\";\n\t\t\t\tif (varstr_cmp(best, 1, \"9\", 1, collation) < 0)\n\t\t\t\t\tbest = \"9\";\n\t\t\t\tsuffixchar = *best;\n\t\t\t\tsuffixcollation = collation;\n\t\t\t}\n\n\t\t\t/* And build the string to compare to */\n\t\t\tcmptxt = (text *) palloc(VARHDRSZ + len + 1);\n\t\t\tSET_VARSIZE(cmptxt, VARHDRSZ + len + 1);\n\t\t\tmemcpy(VARDATA(cmptxt), workstr, len);\n\t\t\t*(VARDATA(cmptxt) + len) = suffixchar;\n\t\t\tcmpstr = PointerGetDatum(cmptxt);\n\t\t}\n\t}\n\n\t/* Select appropriate character-incrementer function */\n\tif (datatype == BYTEAOID)\n\t\tcharinc = byte_increment;\n\telse\n\t\tcharinc = pg_database_encoding_character_incrementer();\n\n\t/* And search ... */\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tcharlen;\n\t\tunsigned char *lastchar;\n\n\t\t/* Identify the last character --- for bytea, just the last byte */\n\t\tif (datatype == BYTEAOID)\n\t\t\tcharlen = 1;\n\t\telse\n\t\t\tcharlen = len - pg_mbcliplen(workstr, len, len - 1);\n\t\tlastchar = (unsigned char *) (workstr + len - charlen);\n\n\t\t/*\n\t\t * Try to generate a larger string by incrementing the last character\n\t\t * (for BYTEA, we treat each byte as a character).\n\t\t *\n\t\t * Note: the incrementer function is expected to return true if it's\n\t\t * generated a valid-per-the-encoding new character, otherwise false.\n\t\t * The contents of the character on false return are unspecified.\n\t\t */\n\t\twhile (charinc(lastchar, charlen))\n\t\t{\n\t\t\tConst\t   *workstr_const;\n\n\t\t\tif (datatype == BYTEAOID)\n\t\t\t\tworkstr_const = string_to_bytea_const(workstr, len);\n\t\t\telse\n\t\t\t\tworkstr_const = string_to_const(workstr, datatype);\n\n\t\t\tif (DatumGetBool(FunctionCall2Coll(ltproc,\n\t\t\t\t\t\t\t\t\t\t\t   collation,\n\t\t\t\t\t\t\t\t\t\t\t   cmpstr,\n\t\t\t\t\t\t\t\t\t\t\t   workstr_const->constvalue)))\n\t\t\t{\n\t\t\t\t/* Successfully made a string larger than cmpstr */\n\t\t\t\tif (cmptxt)\n\t\t\t\t\tpfree(cmptxt);\n\t\t\t\tpfree(workstr);\n\t\t\t\treturn workstr_const;\n\t\t\t}\n\n\t\t\t/* No good, release unusable value and try again */\n\t\t\tpfree(DatumGetPointer(workstr_const->constvalue));\n\t\t\tpfree(workstr_const);\n\t\t}\n\n\t\t/*\n\t\t * No luck here, so truncate off the last character and try to\n\t\t * increment the next one.\n\t\t */\n\t\tlen -= charlen;\n\t\tworkstr[len] = '\\0';\n\t}\n\n\t/* Failed... */\n\tif (cmptxt)\n\t\tpfree(cmptxt);\n\tpfree(workstr);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
      "static Datum string_to_datum(const char *str, Oid datatype);",
      "static Const *string_to_const(const char *str, Oid datatype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "workstr"
          ],
          "line": 6472
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "workstr_const->constvalue"
          ],
          "line": 6457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(ltproc,\n\t\t\t\t\t\t\t\t\t\t\t   collation,\n\t\t\t\t\t\t\t\t\t\t\t   cmpstr,\n\t\t\t\t\t\t\t\t\t\t\t   workstr_const->constvalue)"
          ],
          "line": 6444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "ltproc",
            "collation",
            "cmpstr",
            "workstr_const->constvalue"
          ],
          "line": 6444
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_to_const",
          "args": [
            "workstr",
            "datatype"
          ],
          "line": 6442
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6502-6540",
          "snippet": "static Const *\nstring_to_const(const char *str, Oid datatype)\n{\n\tDatum\t\tconval = string_to_datum(str, datatype);\n\tOid\t\t\tcollation;\n\tint\t\t\tconstlen;\n\n\t/*\n\t * We only need to support a few datatypes here, so hard-wire properties\n\t * instead of incurring the expense of catalog lookups.\n\t */\n\tswitch (datatype)\n\t{\n\t\tcase TEXTOID:\n\t\tcase VARCHAROID:\n\t\tcase BPCHAROID:\n\t\t\tcollation = DEFAULT_COLLATION_OID;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tcase NAMEOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = NAMEDATALEN;\n\t\t\tbreak;\n\n\t\tcase BYTEAOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected datatype in string_to_const: %u\",\n\t\t\t\t datatype);\n\t\t\treturn NULL;\n\t}\n\n\treturn makeConst(datatype, -1, collation, constlen,\n\t\t\t\t\t conval, false, false);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum string_to_datum(const char *str, Oid datatype);",
            "static Const *string_to_const(const char *str, Oid datatype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum string_to_datum(const char *str, Oid datatype);\nstatic Const *string_to_const(const char *str, Oid datatype);\n\nstatic Const *\nstring_to_const(const char *str, Oid datatype)\n{\n\tDatum\t\tconval = string_to_datum(str, datatype);\n\tOid\t\t\tcollation;\n\tint\t\t\tconstlen;\n\n\t/*\n\t * We only need to support a few datatypes here, so hard-wire properties\n\t * instead of incurring the expense of catalog lookups.\n\t */\n\tswitch (datatype)\n\t{\n\t\tcase TEXTOID:\n\t\tcase VARCHAROID:\n\t\tcase BPCHAROID:\n\t\t\tcollation = DEFAULT_COLLATION_OID;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tcase NAMEOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = NAMEDATALEN;\n\t\t\tbreak;\n\n\t\tcase BYTEAOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected datatype in string_to_const: %u\",\n\t\t\t\t datatype);\n\t\t\treturn NULL;\n\t}\n\n\treturn makeConst(datatype, -1, collation, constlen,\n\t\t\t\t\t conval, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_to_bytea_const",
          "args": [
            "workstr",
            "len"
          ],
          "line": 6440
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_bytea_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6545-6556",
          "snippet": "static Const *\nstring_to_bytea_const(const char *str, size_t str_len)\n{\n\tbytea\t   *bstr = palloc(VARHDRSZ + str_len);\n\tDatum\t\tconval;\n\n\tmemcpy(VARDATA(bstr), str, str_len);\n\tSET_VARSIZE(bstr, VARHDRSZ + str_len);\n\tconval = PointerGetDatum(bstr);\n\n\treturn makeConst(BYTEAOID, -1, InvalidOid, -1, conval, false, false);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Const *string_to_bytea_const(const char *str, size_t str_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Const *string_to_bytea_const(const char *str, size_t str_len);\n\nstatic Const *\nstring_to_bytea_const(const char *str, size_t str_len)\n{\n\tbytea\t   *bstr = palloc(VARHDRSZ + str_len);\n\tDatum\t\tconval;\n\n\tmemcpy(VARDATA(bstr), str, str_len);\n\tSET_VARSIZE(bstr, VARHDRSZ + str_len);\n\tconval = PointerGetDatum(bstr);\n\n\treturn makeConst(BYTEAOID, -1, InvalidOid, -1, conval, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "charinc",
          "args": [
            "lastchar",
            "charlen"
          ],
          "line": 6435
        },
        "resolved": true,
        "details": {
          "function_name": "pg_generic_charinc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1526-1543",
          "snippet": "static bool\npg_generic_charinc(unsigned char *charptr, int len)\n{\n\tunsigned char *lastbyte = charptr + len - 1;\n\tmbverifier\tmbverify;\n\n\t/* We can just invoke the character verifier directly. */\n\tmbverify = pg_wchar_table[GetDatabaseEncoding()].mbverify;\n\n\twhile (*lastbyte < (unsigned char) 255)\n\t{\n\t\t(*lastbyte)++;\n\t\tif ((*mbverify) (charptr, len) == len)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nstatic bool\npg_generic_charinc(unsigned char *charptr, int len)\n{\n\tunsigned char *lastbyte = charptr + len - 1;\n\tmbverifier\tmbverify;\n\n\t/* We can just invoke the character verifier directly. */\n\tmbverify = pg_wchar_table[GetDatabaseEncoding()].mbverify;\n\n\twhile (*lastbyte < (unsigned char) 255)\n\t{\n\t\t(*lastbyte)++;\n\t\tif ((*mbverify) (charptr, len) == len)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbcliplen",
          "args": [
            "workstr",
            "len",
            "len - 1"
          ],
          "line": 6424
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "819-824",
          "snippet": "int\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_character_incrementer",
          "args": [],
          "line": 6412
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_character_incrementer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1841-1859",
          "snippet": "mbcharacter_incrementer\npg_database_encoding_character_incrementer(void)\n{\n\t/*\n\t * Eventually it might be best to add a field to pg_wchar_table[], but for\n\t * now we just use a switch.\n\t */\n\tswitch (GetDatabaseEncoding())\n\t{\n\t\tcase PG_UTF8:\n\t\t\treturn pg_utf8_increment;\n\n\t\tcase PG_EUC_JP:\n\t\t\treturn pg_eucjp_increment;\n\n\t\tdefault:\n\t\t\treturn pg_generic_charinc;\n\t}\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nmbcharacter_incrementer\npg_database_encoding_character_incrementer(void)\n{\n\t/*\n\t * Eventually it might be best to add a field to pg_wchar_table[], but for\n\t * now we just use a switch.\n\t */\n\tswitch (GetDatabaseEncoding())\n\t{\n\t\tcase PG_UTF8:\n\t\t\treturn pg_utf8_increment;\n\n\t\tcase PG_EUC_JP:\n\t\t\treturn pg_eucjp_increment;\n\n\t\tdefault:\n\t\t\treturn pg_generic_charinc;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "cmptxt"
          ],
          "line": 6404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "cmptxt"
          ],
          "line": 6403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(cmptxt)",
            "workstr",
            "len"
          ],
          "line": 6402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "cmptxt"
          ],
          "line": 6402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "cmptxt",
            "VARHDRSZ + len + 1"
          ],
          "line": 6401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + len + 1"
          ],
          "line": 6400
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "best",
            "1",
            "\"9\"",
            "1",
            "collation"
          ],
          "line": 6393
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lc_collate_is_c",
          "args": [
            "collation"
          ],
          "line": 6376
        },
        "resolved": true,
        "details": {
          "function_name": "lc_collate_is_c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1186-1231",
          "snippet": "bool\nlc_collate_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_COLLATE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_COLLATE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->collate_is_c;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_collate_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_COLLATE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_COLLATE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->collate_is_c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "workstr"
          ],
          "line": 6375
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "str_const->constvalue"
          ],
          "line": 6374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(Pointer) bstr == DatumGetPointer(str_const->constvalue)"
          ],
          "line": 6369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "str_const->constvalue"
          ],
          "line": 6369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "workstr",
            "VARDATA_ANY(bstr)",
            "len"
          ],
          "line": 6368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "bstr"
          ],
          "line": 6368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "bstr"
          ],
          "line": 6366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetByteaPP",
          "args": [
            "str_const->constvalue"
          ],
          "line": 6364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(nameout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  str_const->constvalue)"
          ],
          "line": 6357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "nameout",
            "str_const->constvalue"
          ],
          "line": 6357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic Datum string_to_datum(const char *str, Oid datatype);\nstatic Const *string_to_const(const char *str, Oid datatype);\n\nConst *\nmake_greater_string(const Const *str_const, FmgrInfo *ltproc, Oid collation)\n{\n\tOid\t\t\tdatatype = str_const->consttype;\n\tchar\t   *workstr;\n\tint\t\t\tlen;\n\tDatum\t\tcmpstr;\n\ttext\t   *cmptxt = NULL;\n\tmbcharacter_incrementer charinc;\n\n\t/*\n\t * Get a modifiable copy of the prefix string in C-string format, and set\n\t * up the string we will compare to as a Datum.  In C locale this can just\n\t * be the given prefix string, otherwise we need to add a suffix.  Types\n\t * NAME and BYTEA sort bytewise so they don't need a suffix either.\n\t */\n\tif (datatype == NAMEOID)\n\t{\n\t\tworkstr = DatumGetCString(DirectFunctionCall1(nameout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  str_const->constvalue));\n\t\tlen = strlen(workstr);\n\t\tcmpstr = str_const->constvalue;\n\t}\n\telse if (datatype == BYTEAOID)\n\t{\n\t\tbytea\t   *bstr = DatumGetByteaPP(str_const->constvalue);\n\n\t\tlen = VARSIZE_ANY_EXHDR(bstr);\n\t\tworkstr = (char *) palloc(len);\n\t\tmemcpy(workstr, VARDATA_ANY(bstr), len);\n\t\tAssert((Pointer) bstr == DatumGetPointer(str_const->constvalue));\n\t\tcmpstr = str_const->constvalue;\n\t}\n\telse\n\t{\n\t\tworkstr = TextDatumGetCString(str_const->constvalue);\n\t\tlen = strlen(workstr);\n\t\tif (lc_collate_is_c(collation) || len == 0)\n\t\t\tcmpstr = str_const->constvalue;\n\t\telse\n\t\t{\n\t\t\t/* If first time through, determine the suffix to use */\n\t\t\tstatic char suffixchar = 0;\n\t\t\tstatic Oid\tsuffixcollation = 0;\n\n\t\t\tif (!suffixchar || suffixcollation != collation)\n\t\t\t{\n\t\t\t\tchar\t   *best;\n\n\t\t\t\tbest = \"Z\";\n\t\t\t\tif (varstr_cmp(best, 1, \"z\", 1, collation) < 0)\n\t\t\t\t\tbest = \"z\";\n\t\t\t\tif (varstr_cmp(best, 1, \"y\", 1, collation) < 0)\n\t\t\t\t\tbest = \"y\";\n\t\t\t\tif (varstr_cmp(best, 1, \"9\", 1, collation) < 0)\n\t\t\t\t\tbest = \"9\";\n\t\t\t\tsuffixchar = *best;\n\t\t\t\tsuffixcollation = collation;\n\t\t\t}\n\n\t\t\t/* And build the string to compare to */\n\t\t\tcmptxt = (text *) palloc(VARHDRSZ + len + 1);\n\t\t\tSET_VARSIZE(cmptxt, VARHDRSZ + len + 1);\n\t\t\tmemcpy(VARDATA(cmptxt), workstr, len);\n\t\t\t*(VARDATA(cmptxt) + len) = suffixchar;\n\t\t\tcmpstr = PointerGetDatum(cmptxt);\n\t\t}\n\t}\n\n\t/* Select appropriate character-incrementer function */\n\tif (datatype == BYTEAOID)\n\t\tcharinc = byte_increment;\n\telse\n\t\tcharinc = pg_database_encoding_character_incrementer();\n\n\t/* And search ... */\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tcharlen;\n\t\tunsigned char *lastchar;\n\n\t\t/* Identify the last character --- for bytea, just the last byte */\n\t\tif (datatype == BYTEAOID)\n\t\t\tcharlen = 1;\n\t\telse\n\t\t\tcharlen = len - pg_mbcliplen(workstr, len, len - 1);\n\t\tlastchar = (unsigned char *) (workstr + len - charlen);\n\n\t\t/*\n\t\t * Try to generate a larger string by incrementing the last character\n\t\t * (for BYTEA, we treat each byte as a character).\n\t\t *\n\t\t * Note: the incrementer function is expected to return true if it's\n\t\t * generated a valid-per-the-encoding new character, otherwise false.\n\t\t * The contents of the character on false return are unspecified.\n\t\t */\n\t\twhile (charinc(lastchar, charlen))\n\t\t{\n\t\t\tConst\t   *workstr_const;\n\n\t\t\tif (datatype == BYTEAOID)\n\t\t\t\tworkstr_const = string_to_bytea_const(workstr, len);\n\t\t\telse\n\t\t\t\tworkstr_const = string_to_const(workstr, datatype);\n\n\t\t\tif (DatumGetBool(FunctionCall2Coll(ltproc,\n\t\t\t\t\t\t\t\t\t\t\t   collation,\n\t\t\t\t\t\t\t\t\t\t\t   cmpstr,\n\t\t\t\t\t\t\t\t\t\t\t   workstr_const->constvalue)))\n\t\t\t{\n\t\t\t\t/* Successfully made a string larger than cmpstr */\n\t\t\t\tif (cmptxt)\n\t\t\t\t\tpfree(cmptxt);\n\t\t\t\tpfree(workstr);\n\t\t\t\treturn workstr_const;\n\t\t\t}\n\n\t\t\t/* No good, release unusable value and try again */\n\t\t\tpfree(DatumGetPointer(workstr_const->constvalue));\n\t\t\tpfree(workstr_const);\n\t\t}\n\n\t\t/*\n\t\t * No luck here, so truncate off the last character and try to\n\t\t * increment the next one.\n\t\t */\n\t\tlen -= charlen;\n\t\tworkstr[len] = '\\0';\n\t}\n\n\t/* Failed... */\n\tif (cmptxt)\n\t\tpfree(cmptxt);\n\tpfree(workstr);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "byte_increment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6289-6296",
    "snippet": "static bool\nbyte_increment(unsigned char *ptr, int len)\n{\n\tif (*ptr >= 255)\n\t\treturn false;\n\t(*ptr)++;\n\treturn true;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\nbyte_increment(unsigned char *ptr, int len)\n{\n\tif (*ptr >= 255)\n\t\treturn false;\n\t(*ptr)++;\n\treturn true;\n}"
  },
  {
    "function_name": "regex_selectivity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6255-6282",
    "snippet": "static Selectivity\nregex_selectivity(const char *patt, int pattlen, bool case_insensitive,\n\t\t\t\t  int fixed_prefix_len)\n{\n\tSelectivity sel;\n\n\t/* If patt doesn't end with $, consider it to have a trailing wildcard */\n\tif (pattlen > 0 && patt[pattlen - 1] == '$' &&\n\t\t(pattlen == 1 || patt[pattlen - 2] != '\\\\'))\n\t{\n\t\t/* has trailing $ */\n\t\tsel = regex_selectivity_sub(patt, pattlen - 1, case_insensitive);\n\t}\n\telse\n\t{\n\t\t/* no trailing $ */\n\t\tsel = regex_selectivity_sub(patt, pattlen, case_insensitive);\n\t\tsel *= FULL_WILDCARD_SEL;\n\t}\n\n\t/* If there's a fixed prefix, discount its selectivity */\n\tif (fixed_prefix_len > 0)\n\t\tsel /= pow(FIXED_CHAR_SEL, fixed_prefix_len);\n\n\t/* Make sure result stays in range */\n\tCLAMP_PROBABILITY(sel);\n\treturn sel;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FULL_WILDCARD_SEL 5.0",
      "#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */"
    ],
    "globals_used": [
      "static Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);",
      "static Selectivity regex_selectivity(const char *patt, int pattlen,\n\t\t\t\t  bool case_insensitive,\n\t\t\t\t  int fixed_prefix_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "sel"
          ],
          "line": 6280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "FIXED_CHAR_SEL",
            "fixed_prefix_len"
          ],
          "line": 6277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regex_selectivity_sub",
          "args": [
            "patt",
            "pattlen",
            "case_insensitive"
          ],
          "line": 6271
        },
        "resolved": true,
        "details": {
          "function_name": "regex_selectivity_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6163-6253",
          "snippet": "static Selectivity\nregex_selectivity_sub(const char *patt, int pattlen, bool case_insensitive)\n{\n\tSelectivity sel = 1.0;\n\tint\t\t\tparen_depth = 0;\n\tint\t\t\tparen_pos = 0;\t/* dummy init to keep compiler quiet */\n\tint\t\t\tpos;\n\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\tif (patt[pos] == '(')\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tparen_pos = pos;\t/* remember start of parenthesized item */\n\t\t\tparen_depth++;\n\t\t}\n\t\telse if (patt[pos] == ')' && paren_depth > 0)\n\t\t{\n\t\t\tparen_depth--;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= regex_selectivity_sub(patt + (paren_pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t pos - (paren_pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t case_insensitive);\n\t\t}\n\t\telse if (patt[pos] == '|' && paren_depth == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * If unquoted | is present at paren level 0 in pattern, we have\n\t\t\t * multiple alternatives; sum their probabilities.\n\t\t\t */\n\t\t\tsel += regex_selectivity_sub(patt + (pos + 1),\n\t\t\t\t\t\t\t\t\t\t pattlen - (pos + 1),\n\t\t\t\t\t\t\t\t\t\t case_insensitive);\n\t\t\tbreak;\t\t\t\t/* rest of pattern is now processed */\n\t\t}\n\t\telse if (patt[pos] == '[')\n\t\t{\n\t\t\tbool\t\tnegclass = false;\n\n\t\t\tif (patt[++pos] == '^')\n\t\t\t{\n\t\t\t\tnegclass = true;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (patt[pos] == ']')\t/* ']' at start of class is not special */\n\t\t\t\tpos++;\n\t\t\twhile (pos < pattlen && patt[pos] != ']')\n\t\t\t\tpos++;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= (negclass ? (1.0 - CHAR_RANGE_SEL) : CHAR_RANGE_SEL);\n\t\t}\n\t\telse if (patt[pos] == '.')\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= ANY_CHAR_SEL;\n\t\t}\n\t\telse if (patt[pos] == '*' ||\n\t\t\t\t patt[pos] == '?' ||\n\t\t\t\t patt[pos] == '+')\n\t\t{\n\t\t\t/* Ought to be smarter about quantifiers... */\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= PARTIAL_WILDCARD_SEL;\n\t\t}\n\t\telse if (patt[pos] == '{')\n\t\t{\n\t\t\twhile (pos < pattlen && patt[pos] != '}')\n\t\t\t\tpos++;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= PARTIAL_WILDCARD_SEL;\n\t\t}\n\t\telse if (patt[pos] == '\\\\')\n\t\t{\n\t\t\t/* backslash quotes the next character */\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t}\n\t/* Could get sel > 1 if multiple wildcards */\n\tif (sel > 1.0)\n\t\tsel = 1.0;\n\treturn sel;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PARTIAL_WILDCARD_SEL 2.0",
            "#define ANY_CHAR_SEL\t0.9\t\t/* not 1, since it won't match end-of-string */",
            "#define CHAR_RANGE_SEL\t0.25",
            "#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */"
          ],
          "globals_used": [
            "static Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define PARTIAL_WILDCARD_SEL 2.0\n#define ANY_CHAR_SEL\t0.9\t\t/* not 1, since it won't match end-of-string */\n#define CHAR_RANGE_SEL\t0.25\n#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */\n\nstatic Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);\n\nstatic Selectivity\nregex_selectivity_sub(const char *patt, int pattlen, bool case_insensitive)\n{\n\tSelectivity sel = 1.0;\n\tint\t\t\tparen_depth = 0;\n\tint\t\t\tparen_pos = 0;\t/* dummy init to keep compiler quiet */\n\tint\t\t\tpos;\n\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\tif (patt[pos] == '(')\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tparen_pos = pos;\t/* remember start of parenthesized item */\n\t\t\tparen_depth++;\n\t\t}\n\t\telse if (patt[pos] == ')' && paren_depth > 0)\n\t\t{\n\t\t\tparen_depth--;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= regex_selectivity_sub(patt + (paren_pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t pos - (paren_pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t case_insensitive);\n\t\t}\n\t\telse if (patt[pos] == '|' && paren_depth == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * If unquoted | is present at paren level 0 in pattern, we have\n\t\t\t * multiple alternatives; sum their probabilities.\n\t\t\t */\n\t\t\tsel += regex_selectivity_sub(patt + (pos + 1),\n\t\t\t\t\t\t\t\t\t\t pattlen - (pos + 1),\n\t\t\t\t\t\t\t\t\t\t case_insensitive);\n\t\t\tbreak;\t\t\t\t/* rest of pattern is now processed */\n\t\t}\n\t\telse if (patt[pos] == '[')\n\t\t{\n\t\t\tbool\t\tnegclass = false;\n\n\t\t\tif (patt[++pos] == '^')\n\t\t\t{\n\t\t\t\tnegclass = true;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (patt[pos] == ']')\t/* ']' at start of class is not special */\n\t\t\t\tpos++;\n\t\t\twhile (pos < pattlen && patt[pos] != ']')\n\t\t\t\tpos++;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= (negclass ? (1.0 - CHAR_RANGE_SEL) : CHAR_RANGE_SEL);\n\t\t}\n\t\telse if (patt[pos] == '.')\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= ANY_CHAR_SEL;\n\t\t}\n\t\telse if (patt[pos] == '*' ||\n\t\t\t\t patt[pos] == '?' ||\n\t\t\t\t patt[pos] == '+')\n\t\t{\n\t\t\t/* Ought to be smarter about quantifiers... */\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= PARTIAL_WILDCARD_SEL;\n\t\t}\n\t\telse if (patt[pos] == '{')\n\t\t{\n\t\t\twhile (pos < pattlen && patt[pos] != '}')\n\t\t\t\tpos++;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= PARTIAL_WILDCARD_SEL;\n\t\t}\n\t\telse if (patt[pos] == '\\\\')\n\t\t{\n\t\t\t/* backslash quotes the next character */\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t}\n\t/* Could get sel > 1 if multiple wildcards */\n\tif (sel > 1.0)\n\t\tsel = 1.0;\n\treturn sel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define FULL_WILDCARD_SEL 5.0\n#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */\n\nstatic Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);\nstatic Selectivity regex_selectivity(const char *patt, int pattlen,\n\t\t\t\t  bool case_insensitive,\n\t\t\t\t  int fixed_prefix_len);\n\nstatic Selectivity\nregex_selectivity(const char *patt, int pattlen, bool case_insensitive,\n\t\t\t\t  int fixed_prefix_len)\n{\n\tSelectivity sel;\n\n\t/* If patt doesn't end with $, consider it to have a trailing wildcard */\n\tif (pattlen > 0 && patt[pattlen - 1] == '$' &&\n\t\t(pattlen == 1 || patt[pattlen - 2] != '\\\\'))\n\t{\n\t\t/* has trailing $ */\n\t\tsel = regex_selectivity_sub(patt, pattlen - 1, case_insensitive);\n\t}\n\telse\n\t{\n\t\t/* no trailing $ */\n\t\tsel = regex_selectivity_sub(patt, pattlen, case_insensitive);\n\t\tsel *= FULL_WILDCARD_SEL;\n\t}\n\n\t/* If there's a fixed prefix, discount its selectivity */\n\tif (fixed_prefix_len > 0)\n\t\tsel /= pow(FIXED_CHAR_SEL, fixed_prefix_len);\n\n\t/* Make sure result stays in range */\n\tCLAMP_PROBABILITY(sel);\n\treturn sel;\n}"
  },
  {
    "function_name": "regex_selectivity_sub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6163-6253",
    "snippet": "static Selectivity\nregex_selectivity_sub(const char *patt, int pattlen, bool case_insensitive)\n{\n\tSelectivity sel = 1.0;\n\tint\t\t\tparen_depth = 0;\n\tint\t\t\tparen_pos = 0;\t/* dummy init to keep compiler quiet */\n\tint\t\t\tpos;\n\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\tif (patt[pos] == '(')\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tparen_pos = pos;\t/* remember start of parenthesized item */\n\t\t\tparen_depth++;\n\t\t}\n\t\telse if (patt[pos] == ')' && paren_depth > 0)\n\t\t{\n\t\t\tparen_depth--;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= regex_selectivity_sub(patt + (paren_pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t pos - (paren_pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t case_insensitive);\n\t\t}\n\t\telse if (patt[pos] == '|' && paren_depth == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * If unquoted | is present at paren level 0 in pattern, we have\n\t\t\t * multiple alternatives; sum their probabilities.\n\t\t\t */\n\t\t\tsel += regex_selectivity_sub(patt + (pos + 1),\n\t\t\t\t\t\t\t\t\t\t pattlen - (pos + 1),\n\t\t\t\t\t\t\t\t\t\t case_insensitive);\n\t\t\tbreak;\t\t\t\t/* rest of pattern is now processed */\n\t\t}\n\t\telse if (patt[pos] == '[')\n\t\t{\n\t\t\tbool\t\tnegclass = false;\n\n\t\t\tif (patt[++pos] == '^')\n\t\t\t{\n\t\t\t\tnegclass = true;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (patt[pos] == ']')\t/* ']' at start of class is not special */\n\t\t\t\tpos++;\n\t\t\twhile (pos < pattlen && patt[pos] != ']')\n\t\t\t\tpos++;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= (negclass ? (1.0 - CHAR_RANGE_SEL) : CHAR_RANGE_SEL);\n\t\t}\n\t\telse if (patt[pos] == '.')\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= ANY_CHAR_SEL;\n\t\t}\n\t\telse if (patt[pos] == '*' ||\n\t\t\t\t patt[pos] == '?' ||\n\t\t\t\t patt[pos] == '+')\n\t\t{\n\t\t\t/* Ought to be smarter about quantifiers... */\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= PARTIAL_WILDCARD_SEL;\n\t\t}\n\t\telse if (patt[pos] == '{')\n\t\t{\n\t\t\twhile (pos < pattlen && patt[pos] != '}')\n\t\t\t\tpos++;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= PARTIAL_WILDCARD_SEL;\n\t\t}\n\t\telse if (patt[pos] == '\\\\')\n\t\t{\n\t\t\t/* backslash quotes the next character */\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t}\n\t/* Could get sel > 1 if multiple wildcards */\n\tif (sel > 1.0)\n\t\tsel = 1.0;\n\treturn sel;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define PARTIAL_WILDCARD_SEL 2.0",
      "#define ANY_CHAR_SEL\t0.9\t\t/* not 1, since it won't match end-of-string */",
      "#define CHAR_RANGE_SEL\t0.25",
      "#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */"
    ],
    "globals_used": [
      "static Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "regex_selectivity_sub",
          "args": [
            "patt + (pos + 1)",
            "pattlen - (pos + 1)",
            "case_insensitive"
          ],
          "line": 6193
        },
        "resolved": true,
        "details": {
          "function_name": "regex_selectivity_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6163-6253",
          "snippet": "static Selectivity\nregex_selectivity_sub(const char *patt, int pattlen, bool case_insensitive)\n{\n\tSelectivity sel = 1.0;\n\tint\t\t\tparen_depth = 0;\n\tint\t\t\tparen_pos = 0;\t/* dummy init to keep compiler quiet */\n\tint\t\t\tpos;\n\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\tif (patt[pos] == '(')\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tparen_pos = pos;\t/* remember start of parenthesized item */\n\t\t\tparen_depth++;\n\t\t}\n\t\telse if (patt[pos] == ')' && paren_depth > 0)\n\t\t{\n\t\t\tparen_depth--;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= regex_selectivity_sub(patt + (paren_pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t pos - (paren_pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t case_insensitive);\n\t\t}\n\t\telse if (patt[pos] == '|' && paren_depth == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * If unquoted | is present at paren level 0 in pattern, we have\n\t\t\t * multiple alternatives; sum their probabilities.\n\t\t\t */\n\t\t\tsel += regex_selectivity_sub(patt + (pos + 1),\n\t\t\t\t\t\t\t\t\t\t pattlen - (pos + 1),\n\t\t\t\t\t\t\t\t\t\t case_insensitive);\n\t\t\tbreak;\t\t\t\t/* rest of pattern is now processed */\n\t\t}\n\t\telse if (patt[pos] == '[')\n\t\t{\n\t\t\tbool\t\tnegclass = false;\n\n\t\t\tif (patt[++pos] == '^')\n\t\t\t{\n\t\t\t\tnegclass = true;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (patt[pos] == ']')\t/* ']' at start of class is not special */\n\t\t\t\tpos++;\n\t\t\twhile (pos < pattlen && patt[pos] != ']')\n\t\t\t\tpos++;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= (negclass ? (1.0 - CHAR_RANGE_SEL) : CHAR_RANGE_SEL);\n\t\t}\n\t\telse if (patt[pos] == '.')\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= ANY_CHAR_SEL;\n\t\t}\n\t\telse if (patt[pos] == '*' ||\n\t\t\t\t patt[pos] == '?' ||\n\t\t\t\t patt[pos] == '+')\n\t\t{\n\t\t\t/* Ought to be smarter about quantifiers... */\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= PARTIAL_WILDCARD_SEL;\n\t\t}\n\t\telse if (patt[pos] == '{')\n\t\t{\n\t\t\twhile (pos < pattlen && patt[pos] != '}')\n\t\t\t\tpos++;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= PARTIAL_WILDCARD_SEL;\n\t\t}\n\t\telse if (patt[pos] == '\\\\')\n\t\t{\n\t\t\t/* backslash quotes the next character */\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t}\n\t/* Could get sel > 1 if multiple wildcards */\n\tif (sel > 1.0)\n\t\tsel = 1.0;\n\treturn sel;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define PARTIAL_WILDCARD_SEL 2.0\n#define ANY_CHAR_SEL\t0.9\t\t/* not 1, since it won't match end-of-string */\n#define CHAR_RANGE_SEL\t0.25\n#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */\n\nstatic Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);\n\nstatic Selectivity\nregex_selectivity_sub(const char *patt, int pattlen, bool case_insensitive)\n{\n\tSelectivity sel = 1.0;\n\tint\t\t\tparen_depth = 0;\n\tint\t\t\tparen_pos = 0;\t/* dummy init to keep compiler quiet */\n\tint\t\t\tpos;\n\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\tif (patt[pos] == '(')\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tparen_pos = pos;\t/* remember start of parenthesized item */\n\t\t\tparen_depth++;\n\t\t}\n\t\telse if (patt[pos] == ')' && paren_depth > 0)\n\t\t{\n\t\t\tparen_depth--;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= regex_selectivity_sub(patt + (paren_pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t pos - (paren_pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t case_insensitive);\n\t\t}\n\t\telse if (patt[pos] == '|' && paren_depth == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * If unquoted | is present at paren level 0 in pattern, we have\n\t\t\t * multiple alternatives; sum their probabilities.\n\t\t\t */\n\t\t\tsel += regex_selectivity_sub(patt + (pos + 1),\n\t\t\t\t\t\t\t\t\t\t pattlen - (pos + 1),\n\t\t\t\t\t\t\t\t\t\t case_insensitive);\n\t\t\tbreak;\t\t\t\t/* rest of pattern is now processed */\n\t\t}\n\t\telse if (patt[pos] == '[')\n\t\t{\n\t\t\tbool\t\tnegclass = false;\n\n\t\t\tif (patt[++pos] == '^')\n\t\t\t{\n\t\t\t\tnegclass = true;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (patt[pos] == ']')\t/* ']' at start of class is not special */\n\t\t\t\tpos++;\n\t\t\twhile (pos < pattlen && patt[pos] != ']')\n\t\t\t\tpos++;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= (negclass ? (1.0 - CHAR_RANGE_SEL) : CHAR_RANGE_SEL);\n\t\t}\n\t\telse if (patt[pos] == '.')\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= ANY_CHAR_SEL;\n\t\t}\n\t\telse if (patt[pos] == '*' ||\n\t\t\t\t patt[pos] == '?' ||\n\t\t\t\t patt[pos] == '+')\n\t\t{\n\t\t\t/* Ought to be smarter about quantifiers... */\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= PARTIAL_WILDCARD_SEL;\n\t\t}\n\t\telse if (patt[pos] == '{')\n\t\t{\n\t\t\twhile (pos < pattlen && patt[pos] != '}')\n\t\t\t\tpos++;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= PARTIAL_WILDCARD_SEL;\n\t\t}\n\t\telse if (patt[pos] == '\\\\')\n\t\t{\n\t\t\t/* backslash quotes the next character */\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (paren_depth == 0)\n\t\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t}\n\t/* Could get sel > 1 if multiple wildcards */\n\tif (sel > 1.0)\n\t\tsel = 1.0;\n\treturn sel;\n}"
  },
  {
    "function_name": "like_selectivity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6126-6161",
    "snippet": "static Selectivity\nlike_selectivity(const char *patt, int pattlen, bool case_insensitive)\n{\n\tSelectivity sel = 1.0;\n\tint\t\t\tpos;\n\n\t/* Skip any leading wildcard; it's already factored into initial sel */\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\tif (patt[pos] != '%' && patt[pos] != '_')\n\t\t\tbreak;\n\t}\n\n\tfor (; pos < pattlen; pos++)\n\t{\n\t\t/* % and _ are wildcard characters in LIKE */\n\t\tif (patt[pos] == '%')\n\t\t\tsel *= FULL_WILDCARD_SEL;\n\t\telse if (patt[pos] == '_')\n\t\t\tsel *= ANY_CHAR_SEL;\n\t\telse if (patt[pos] == '\\\\')\n\t\t{\n\t\t\t/* Backslash quotes the next character */\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t\telse\n\t\t\tsel *= FIXED_CHAR_SEL;\n\t}\n\t/* Could get sel > 1 if multiple wildcards */\n\tif (sel > 1.0)\n\t\tsel = 1.0;\n\treturn sel;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FULL_WILDCARD_SEL 5.0",
      "#define ANY_CHAR_SEL\t0.9\t\t/* not 1, since it won't match end-of-string */",
      "#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */"
    ],
    "globals_used": [
      "static Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define FULL_WILDCARD_SEL 5.0\n#define ANY_CHAR_SEL\t0.9\t\t/* not 1, since it won't match end-of-string */\n#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */\n\nstatic Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);\n\nstatic Selectivity\nlike_selectivity(const char *patt, int pattlen, bool case_insensitive)\n{\n\tSelectivity sel = 1.0;\n\tint\t\t\tpos;\n\n\t/* Skip any leading wildcard; it's already factored into initial sel */\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\tif (patt[pos] != '%' && patt[pos] != '_')\n\t\t\tbreak;\n\t}\n\n\tfor (; pos < pattlen; pos++)\n\t{\n\t\t/* % and _ are wildcard characters in LIKE */\n\t\tif (patt[pos] == '%')\n\t\t\tsel *= FULL_WILDCARD_SEL;\n\t\telse if (patt[pos] == '_')\n\t\t\tsel *= ANY_CHAR_SEL;\n\t\telse if (patt[pos] == '\\\\')\n\t\t{\n\t\t\t/* Backslash quotes the next character */\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t\telse\n\t\t\tsel *= FIXED_CHAR_SEL;\n\t}\n\t/* Could get sel > 1 if multiple wildcards */\n\tif (sel > 1.0)\n\t\tsel = 1.0;\n\treturn sel;\n}"
  },
  {
    "function_name": "prefix_selectivity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "6024-6107",
    "snippet": "static Selectivity\nprefix_selectivity(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid vartype, Oid opfamily, Const *prefixcon)\n{\n\tSelectivity prefixsel;\n\tOid\t\t\tcmpopr;\n\tFmgrInfo\topproc;\n\tConst\t   *greaterstrcon;\n\tSelectivity eq_sel;\n\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTGreaterEqualStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no >= operator for opfamily %u\", opfamily);\n\tfmgr_info(get_opcode(cmpopr), &opproc);\n\n\tprefixsel = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t   &opproc, true, true,\n\t\t\t\t\t\t\t\t\t\t   prefixcon->constvalue,\n\t\t\t\t\t\t\t\t\t\t   prefixcon->consttype);\n\n\tif (prefixsel < 0.0)\n\t{\n\t\t/* No histogram is present ... return a suitable default estimate */\n\t\treturn DEFAULT_MATCH_SEL;\n\t}\n\n\t/*-------\n\t * If we can create a string larger than the prefix, say\n\t *\t\"x < greaterstr\".\n\t *-------\n\t */\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no < operator for opfamily %u\", opfamily);\n\tfmgr_info(get_opcode(cmpopr), &opproc);\n\tgreaterstrcon = make_greater_string(prefixcon, &opproc,\n\t\t\t\t\t\t\t\t\t\tDEFAULT_COLLATION_OID);\n\tif (greaterstrcon)\n\t{\n\t\tSelectivity topsel;\n\n\t\ttopsel = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t\t&opproc, false, false,\n\t\t\t\t\t\t\t\t\t\t\tgreaterstrcon->constvalue,\n\t\t\t\t\t\t\t\t\t\t\tgreaterstrcon->consttype);\n\n\t\t/* ineq_histogram_selectivity worked before, it shouldn't fail now */\n\t\tAssert(topsel >= 0.0);\n\n\t\t/*\n\t\t * Merge the two selectivities in the same way as for a range query\n\t\t * (see clauselist_selectivity()).  Note that we don't need to worry\n\t\t * about double-exclusion of nulls, since ineq_histogram_selectivity\n\t\t * doesn't count those anyway.\n\t\t */\n\t\tprefixsel = topsel + prefixsel - 1.0;\n\t}\n\n\t/*\n\t * If the prefix is long then the two bounding values might be too close\n\t * together for the histogram to distinguish them usefully, resulting in a\n\t * zero estimate (plus or minus roundoff error). To avoid returning a\n\t * ridiculously small estimate, compute the estimated selectivity for\n\t * \"variable = 'foo'\", and clamp to that. (Obviously, the resultant\n\t * estimate should be at least that.)\n\t *\n\t * We apply this even if we couldn't make a greater string.  That case\n\t * suggests that the prefix is near the maximum possible, and thus\n\t * probably off the end of the histogram, and thus we probably got a very\n\t * small estimate from the >= condition; so we still need to clamp.\n\t */\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\teq_sel = var_eq_const(vardata, cmpopr, prefixcon->constvalue,\n\t\t\t\t\t\t  false, true, false);\n\n\tprefixsel = Max(prefixsel, eq_sel);\n\n\treturn prefixsel;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
      "static Selectivity prefix_selectivity(PlannerInfo *root,\n\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t   Oid vartype, Oid opfamily, Const *prefixcon);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "prefixsel",
            "eq_sel"
          ],
          "line": 6104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var_eq_const",
          "args": [
            "vardata",
            "cmpopr",
            "prefixcon->constvalue",
            "false",
            "true",
            "false"
          ],
          "line": 6101
        },
        "resolved": true,
        "details": {
          "function_name": "var_eq_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "297-444",
          "snippet": "static double\nvar_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\tOid\t\t\topfuncoid;\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (constisnull)\n\t\treturn 0.0;\n\n\t/*\n\t * Grab the nullfrac for use below.  Note we allow use of nullfrac\n\t * regardless of security check.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(operator))))\n\t{\n\t\tAttStatsSlot sslot;\n\t\tbool\t\tmatch = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * Is the constant \"=\" to any of the column's most common values?\n\t\t * (Although the given operator may not really be \"=\", we will assume\n\t\t * that seeing whether it returns TRUE is an appropriate test.  If you\n\t\t * don't like this, maybe you shouldn't be using eqsel for your\n\t\t * operator...)\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tFmgrInfo\teqproc;\n\n\t\t\tfmgr_info(opfuncoid, &eqproc);\n\n\t\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t\t{\n\t\t\t\t/* be careful to apply operator right way 'round */\n\t\t\t\tif (varonleft)\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\telse\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i]));\n\t\t\t\tif (match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no most-common-value info available */\n\t\t\ti = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/*\n\t\t\t * Constant is \"=\" to this common value.  We know selectivity\n\t\t\t * exactly (or as exactly as ANALYZE could calculate it, anyway).\n\t\t\t */\n\t\t\tselec = sslot.numbers[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Comparison is against a constant that is neither NULL nor any\n\t\t\t * of the common values.  Its selectivity cannot be more than\n\t\t\t * this:\n\t\t\t */\n\t\t\tdouble\t\tsumcommon = 0.0;\n\t\t\tdouble\t\totherdistinct;\n\n\t\t\tfor (i = 0; i < sslot.nnumbers; i++)\n\t\t\t\tsumcommon += sslot.numbers[i];\n\t\t\tselec = 1.0 - sumcommon - nullfrac;\n\t\t\tCLAMP_PROBABILITY(selec);\n\n\t\t\t/*\n\t\t\t * and in fact it's probably a good deal less. We approximate that\n\t\t\t * all the not-common values share this remaining fraction\n\t\t\t * equally, so we divide by the number of other distinct values.\n\t\t\t */\n\t\t\totherdistinct = get_variable_numdistinct(vardata, &isdefault) -\n\t\t\t\tsslot.nnumbers;\n\t\t\tif (otherdistinct > 1)\n\t\t\t\tselec /= otherdistinct;\n\n\t\t\t/*\n\t\t\t * Another cross-check: selectivity shouldn't be estimated as more\n\t\t\t * than the least common \"most common value\".\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[sslot.nnumbers - 1])\n\t\t\t\tselec = sslot.numbers[sslot.nnumbers - 1];\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\nvar_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\tOid\t\t\topfuncoid;\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (constisnull)\n\t\treturn 0.0;\n\n\t/*\n\t * Grab the nullfrac for use below.  Note we allow use of nullfrac\n\t * regardless of security check.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(operator))))\n\t{\n\t\tAttStatsSlot sslot;\n\t\tbool\t\tmatch = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * Is the constant \"=\" to any of the column's most common values?\n\t\t * (Although the given operator may not really be \"=\", we will assume\n\t\t * that seeing whether it returns TRUE is an appropriate test.  If you\n\t\t * don't like this, maybe you shouldn't be using eqsel for your\n\t\t * operator...)\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tFmgrInfo\teqproc;\n\n\t\t\tfmgr_info(opfuncoid, &eqproc);\n\n\t\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t\t{\n\t\t\t\t/* be careful to apply operator right way 'round */\n\t\t\t\tif (varonleft)\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\telse\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i]));\n\t\t\t\tif (match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no most-common-value info available */\n\t\t\ti = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/*\n\t\t\t * Constant is \"=\" to this common value.  We know selectivity\n\t\t\t * exactly (or as exactly as ANALYZE could calculate it, anyway).\n\t\t\t */\n\t\t\tselec = sslot.numbers[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Comparison is against a constant that is neither NULL nor any\n\t\t\t * of the common values.  Its selectivity cannot be more than\n\t\t\t * this:\n\t\t\t */\n\t\t\tdouble\t\tsumcommon = 0.0;\n\t\t\tdouble\t\totherdistinct;\n\n\t\t\tfor (i = 0; i < sslot.nnumbers; i++)\n\t\t\t\tsumcommon += sslot.numbers[i];\n\t\t\tselec = 1.0 - sumcommon - nullfrac;\n\t\t\tCLAMP_PROBABILITY(selec);\n\n\t\t\t/*\n\t\t\t * and in fact it's probably a good deal less. We approximate that\n\t\t\t * all the not-common values share this remaining fraction\n\t\t\t * equally, so we divide by the number of other distinct values.\n\t\t\t */\n\t\t\totherdistinct = get_variable_numdistinct(vardata, &isdefault) -\n\t\t\t\tsslot.nnumbers;\n\t\t\tif (otherdistinct > 1)\n\t\t\t\tselec /= otherdistinct;\n\n\t\t\t/*\n\t\t\t * Another cross-check: selectivity shouldn't be estimated as more\n\t\t\t * than the least common \"most common value\".\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[sslot.nnumbers - 1])\n\t\t\t\tselec = sslot.numbers[sslot.nnumbers - 1];\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"no = operator for opfamily %u\"",
            "opfamily"
          ],
          "line": 6100
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opfamily_member",
          "args": [
            "opfamily",
            "vartype",
            "vartype",
            "BTEqualStrategyNumber"
          ],
          "line": 6097
        },
        "resolved": true,
        "details": {
          "function_name": "get_opfamily_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "162-181",
          "snippet": "Oid\nget_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,\n\t\t\t\t\tint16 strategy)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache4(AMOPSTRATEGY,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(strategy));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopopr;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,\n\t\t\t\t\tint16 strategy)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache4(AMOPSTRATEGY,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(strategy));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopopr;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "topsel >= 0.0"
          ],
          "line": 6073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ineq_histogram_selectivity",
          "args": [
            "root",
            "vardata",
            "&opproc",
            "false",
            "false",
            "greaterstrcon->constvalue",
            "greaterstrcon->consttype"
          ],
          "line": 6067
        },
        "resolved": true,
        "details": {
          "function_name": "ineq_histogram_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "776-1079",
          "snippet": "static double\nineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype)\n{\n\tdouble\t\thist_selec;\n\tAttStatsSlot sslot;\n\n\thist_selec = -1.0;\n\n\t/*\n\t * Someday, ANALYZE might store more than one histogram per rel/att,\n\t * corresponding to more than one possible sort ordering defined for the\n\t * column type.  However, to make that work we will need to figure out\n\t * which staop to search for --- it's not necessarily the one we have at\n\t * hand!  (For example, we might have a '<=' operator rather than the '<'\n\t * operator that will appear in staop.)  For now, assume that whatever\n\t * appears in pg_statistic is sorted the same way our operator sorts, or\n\t * the reverse way if isgt is true.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * Use binary search to find the desired location, namely the\n\t\t\t * right end of the histogram bin containing the comparison value,\n\t\t\t * which is the leftmost entry for which the comparison operator\n\t\t\t * succeeds (if isgt) or fails (if !isgt).  (If the given operator\n\t\t\t * isn't actually sort-compatible with the histogram, you'll get\n\t\t\t * garbage results ... but probably not any more garbage-y than\n\t\t\t * you would have from the old linear search.)\n\t\t\t *\n\t\t\t * In this loop, we pay no attention to whether the operator iseq\n\t\t\t * or not; that detail will be mopped up below.  (We cannot tell,\n\t\t\t * anyway, whether the operator thinks the values are equal.)\n\t\t\t *\n\t\t\t * If the binary search accesses the first or last histogram\n\t\t\t * entry, we try to replace that endpoint with the true column min\n\t\t\t * or max as found by get_actual_variable_range().  This\n\t\t\t * ameliorates misestimates when the min or max is moving as a\n\t\t\t * result of changes since the last ANALYZE.  Note that this could\n\t\t\t * result in effectively including MCVs into the histogram that\n\t\t\t * weren't there before, but we don't try to correct for that.\n\t\t\t */\n\t\t\tdouble\t\thistfrac;\n\t\t\tint\t\t\tlobound = 0;\t/* first possible slot to search */\n\t\t\tint\t\t\thibound = sslot.nvalues;\t/* last+1 slot to search */\n\t\t\tbool\t\thave_end = false;\n\n\t\t\t/*\n\t\t\t * If there are only two histogram entries, we'll want up-to-date\n\t\t\t * values for both.  (If there are more than two, we need at most\n\t\t\t * one of them to be updated, so we deal with that within the\n\t\t\t * loop.)\n\t\t\t */\n\t\t\tif (sslot.nvalues == 2)\n\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[1]);\n\n\t\t\twhile (lobound < hibound)\n\t\t\t{\n\t\t\t\tint\t\t\tprobe = (lobound + hibound) / 2;\n\t\t\t\tbool\t\tltcmp;\n\n\t\t\t\t/*\n\t\t\t\t * If we find ourselves about to compare to the first or last\n\t\t\t\t * histogram entry, first try to replace it with the actual\n\t\t\t\t * current min or max (unless we already did so above).\n\t\t\t\t */\n\t\t\t\tif (probe == 0 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\t\telse if (probe == sslot.nvalues - 1 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[probe]);\n\n\t\t\t\tltcmp = DatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[probe],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\tif (isgt)\n\t\t\t\t\tltcmp = !ltcmp;\n\t\t\t\tif (ltcmp)\n\t\t\t\t\tlobound = probe + 1;\n\t\t\t\telse\n\t\t\t\t\thibound = probe;\n\t\t\t}\n\n\t\t\tif (lobound <= 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Constant is below lower histogram boundary.  More\n\t\t\t\t * precisely, we have found that no entry in the histogram\n\t\t\t\t * satisfies the inequality clause (if !isgt) or they all do\n\t\t\t\t * (if isgt).  We estimate that that's true of the entire\n\t\t\t\t * table, so set histfrac to 0.0 (which we'll flip to 1.0\n\t\t\t\t * below, if isgt).\n\t\t\t\t */\n\t\t\t\thistfrac = 0.0;\n\t\t\t}\n\t\t\telse if (lobound >= sslot.nvalues)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Inverse case: constant is above upper histogram boundary.\n\t\t\t\t */\n\t\t\t\thistfrac = 1.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We have values[i-1] <= constant <= values[i]. */\n\t\t\t\tint\t\t\ti = lobound;\n\t\t\t\tdouble\t\teq_selec = 0;\n\t\t\t\tdouble\t\tval,\n\t\t\t\t\t\t\thigh,\n\t\t\t\t\t\t\tlow;\n\t\t\t\tdouble\t\tbinfrac;\n\n\t\t\t\t/*\n\t\t\t\t * In the cases where we'll need it below, obtain an estimate\n\t\t\t\t * of the selectivity of \"x = constval\".  We use a calculation\n\t\t\t\t * similar to what var_eq_const() does for a non-MCV constant,\n\t\t\t\t * ie, estimate that all distinct non-MCV values occur equally\n\t\t\t\t * often.  But multiplication by \"1.0 - sumcommon - nullfrac\"\n\t\t\t\t * will be done by our caller, so we shouldn't do that here.\n\t\t\t\t * Therefore we can't try to clamp the estimate by reference\n\t\t\t\t * to the least common MCV; the result would be too small.\n\t\t\t\t *\n\t\t\t\t * Note: since this is effectively assuming that constval\n\t\t\t\t * isn't an MCV, it's logically dubious if constval in fact is\n\t\t\t\t * one.  But we have to apply *some* correction for equality,\n\t\t\t\t * and anyway we cannot tell if constval is an MCV, since we\n\t\t\t\t * don't have a suitable equality operator at hand.\n\t\t\t\t */\n\t\t\t\tif (i == 1 || isgt == iseq)\n\t\t\t\t{\n\t\t\t\t\tdouble\t\totherdistinct;\n\t\t\t\t\tbool\t\tisdefault;\n\t\t\t\t\tAttStatsSlot mcvslot;\n\n\t\t\t\t\t/* Get estimated number of distinct values */\n\t\t\t\t\totherdistinct = get_variable_numdistinct(vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &isdefault);\n\n\t\t\t\t\t/* Subtract off the number of known MCVs */\n\t\t\t\t\tif (get_attstatsslot(&mcvslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t\t\t\t{\n\t\t\t\t\t\totherdistinct -= mcvslot.nnumbers;\n\t\t\t\t\t\tfree_attstatsslot(&mcvslot);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If result doesn't seem sane, leave eq_selec at 0 */\n\t\t\t\t\tif (otherdistinct > 1)\n\t\t\t\t\t\teq_selec = 1.0 / otherdistinct;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Convert the constant and the two nearest bin boundary\n\t\t\t\t * values to a uniform comparison scale, and do a linear\n\t\t\t\t * interpolation within this bin.\n\t\t\t\t */\n\t\t\t\tif (convert_to_scalar(constval, consttype, &val,\n\t\t\t\t\t\t\t\t\t  sslot.values[i - 1], sslot.values[i],\n\t\t\t\t\t\t\t\t\t  vardata->vartype,\n\t\t\t\t\t\t\t\t\t  &low, &high))\n\t\t\t\t{\n\t\t\t\t\tif (high <= low)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* cope if bin boundaries appear identical */\n\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t\telse if (val <= low)\n\t\t\t\t\t\tbinfrac = 0.0;\n\t\t\t\t\telse if (val >= high)\n\t\t\t\t\t\tbinfrac = 1.0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbinfrac = (val - low) / (high - low);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Watch out for the possibility that we got a NaN or\n\t\t\t\t\t\t * Infinity from the division.  This can happen\n\t\t\t\t\t\t * despite the previous checks, if for example \"low\"\n\t\t\t\t\t\t * is -Infinity.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (isnan(binfrac) ||\n\t\t\t\t\t\t\tbinfrac < 0.0 || binfrac > 1.0)\n\t\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Ideally we'd produce an error here, on the grounds that\n\t\t\t\t\t * the given operator shouldn't have scalarXXsel\n\t\t\t\t\t * registered as its selectivity func unless we can deal\n\t\t\t\t\t * with its operand types.  But currently, all manner of\n\t\t\t\t\t * stuff is invoking scalarXXsel, so give a default\n\t\t\t\t\t * estimate until that can be fixed.\n\t\t\t\t\t */\n\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Now, compute the overall selectivity across the values\n\t\t\t\t * represented by the histogram.  We have i-1 full bins and\n\t\t\t\t * binfrac partial bin below the constant.\n\t\t\t\t */\n\t\t\t\thistfrac = (double) (i - 1) + binfrac;\n\t\t\t\thistfrac /= (double) (sslot.nvalues - 1);\n\n\t\t\t\t/*\n\t\t\t\t * At this point, histfrac is an estimate of the fraction of\n\t\t\t\t * the population represented by the histogram that satisfies\n\t\t\t\t * \"x <= constval\".  Somewhat remarkably, this statement is\n\t\t\t\t * true regardless of which operator we were doing the probes\n\t\t\t\t * with, so long as convert_to_scalar() delivers reasonable\n\t\t\t\t * results.  If the probe constant is equal to some histogram\n\t\t\t\t * entry, we would have considered the bin to the left of that\n\t\t\t\t * entry if probing with \"<\" or \">=\", or the bin to the right\n\t\t\t\t * if probing with \"<=\" or \">\"; but binfrac would have come\n\t\t\t\t * out as 1.0 in the first case and 0.0 in the second, leading\n\t\t\t\t * to the same histfrac in either case.  For probe constants\n\t\t\t\t * between histogram entries, we find the same bin and get the\n\t\t\t\t * same estimate with any operator.\n\t\t\t\t *\n\t\t\t\t * The fact that the estimate corresponds to \"x <= constval\"\n\t\t\t\t * and not \"x < constval\" is because of the way that ANALYZE\n\t\t\t\t * constructs the histogram: each entry is, effectively, the\n\t\t\t\t * rightmost value in its sample bucket.  So selectivity\n\t\t\t\t * values that are exact multiples of 1/(histogram_size-1)\n\t\t\t\t * should be understood as estimates including a histogram\n\t\t\t\t * entry plus everything to its left.\n\t\t\t\t *\n\t\t\t\t * However, that breaks down for the first histogram entry,\n\t\t\t\t * which necessarily is the leftmost value in its sample\n\t\t\t\t * bucket.  That means the first histogram bin is slightly\n\t\t\t\t * narrower than the rest, by an amount equal to eq_selec.\n\t\t\t\t * Another way to say that is that we want \"x <= leftmost\" to\n\t\t\t\t * be estimated as eq_selec not zero.  So, if we're dealing\n\t\t\t\t * with the first bin (i==1), rescale to make that true while\n\t\t\t\t * adjusting the rest of that bin linearly.\n\t\t\t\t */\n\t\t\t\tif (i == 1)\n\t\t\t\t\thistfrac += eq_selec * (1.0 - binfrac);\n\n\t\t\t\t/*\n\t\t\t\t * \"x <= constval\" is good if we want an estimate for \"<=\" or\n\t\t\t\t * \">\", but if we are estimating for \"<\" or \">=\", we now need\n\t\t\t\t * to decrease the estimate by eq_selec.\n\t\t\t\t */\n\t\t\t\tif (isgt == iseq)\n\t\t\t\t\thistfrac -= eq_selec;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now the estimate is finished for \"<\" and \"<=\" cases.  If we are\n\t\t\t * estimating for \">\" or \">=\", flip it.\n\t\t\t */\n\t\t\thist_selec = isgt ? (1.0 - histfrac) : histfrac;\n\n\t\t\t/*\n\t\t\t * The histogram boundaries are only approximate to begin with,\n\t\t\t * and may well be out of date anyway.  Therefore, don't believe\n\t\t\t * extremely small or large selectivity estimates --- unless we\n\t\t\t * got actual current endpoint values from the table, in which\n\t\t\t * case just do the usual sanity clamp.  Somewhat arbitrarily, we\n\t\t\t * set the cutoff for other cases at a hundredth of the histogram\n\t\t\t * resolution.\n\t\t\t */\n\t\t\tif (have_end)\n\t\t\t\tCLAMP_PROBABILITY(hist_selec);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble\t\tcutoff = 0.01 / (double) (sslot.nvalues - 1);\n\n\t\t\t\tif (hist_selec < cutoff)\n\t\t\t\t\thist_selec = cutoff;\n\t\t\t\telse if (hist_selec > 1.0 - cutoff)\n\t\t\t\t\thist_selec = 1.0 - cutoff;\n\t\t\t}\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\treturn hist_selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
            "static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);",
            "static bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);\nstatic bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);\n\nstatic double\nineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype)\n{\n\tdouble\t\thist_selec;\n\tAttStatsSlot sslot;\n\n\thist_selec = -1.0;\n\n\t/*\n\t * Someday, ANALYZE might store more than one histogram per rel/att,\n\t * corresponding to more than one possible sort ordering defined for the\n\t * column type.  However, to make that work we will need to figure out\n\t * which staop to search for --- it's not necessarily the one we have at\n\t * hand!  (For example, we might have a '<=' operator rather than the '<'\n\t * operator that will appear in staop.)  For now, assume that whatever\n\t * appears in pg_statistic is sorted the same way our operator sorts, or\n\t * the reverse way if isgt is true.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * Use binary search to find the desired location, namely the\n\t\t\t * right end of the histogram bin containing the comparison value,\n\t\t\t * which is the leftmost entry for which the comparison operator\n\t\t\t * succeeds (if isgt) or fails (if !isgt).  (If the given operator\n\t\t\t * isn't actually sort-compatible with the histogram, you'll get\n\t\t\t * garbage results ... but probably not any more garbage-y than\n\t\t\t * you would have from the old linear search.)\n\t\t\t *\n\t\t\t * In this loop, we pay no attention to whether the operator iseq\n\t\t\t * or not; that detail will be mopped up below.  (We cannot tell,\n\t\t\t * anyway, whether the operator thinks the values are equal.)\n\t\t\t *\n\t\t\t * If the binary search accesses the first or last histogram\n\t\t\t * entry, we try to replace that endpoint with the true column min\n\t\t\t * or max as found by get_actual_variable_range().  This\n\t\t\t * ameliorates misestimates when the min or max is moving as a\n\t\t\t * result of changes since the last ANALYZE.  Note that this could\n\t\t\t * result in effectively including MCVs into the histogram that\n\t\t\t * weren't there before, but we don't try to correct for that.\n\t\t\t */\n\t\t\tdouble\t\thistfrac;\n\t\t\tint\t\t\tlobound = 0;\t/* first possible slot to search */\n\t\t\tint\t\t\thibound = sslot.nvalues;\t/* last+1 slot to search */\n\t\t\tbool\t\thave_end = false;\n\n\t\t\t/*\n\t\t\t * If there are only two histogram entries, we'll want up-to-date\n\t\t\t * values for both.  (If there are more than two, we need at most\n\t\t\t * one of them to be updated, so we deal with that within the\n\t\t\t * loop.)\n\t\t\t */\n\t\t\tif (sslot.nvalues == 2)\n\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[1]);\n\n\t\t\twhile (lobound < hibound)\n\t\t\t{\n\t\t\t\tint\t\t\tprobe = (lobound + hibound) / 2;\n\t\t\t\tbool\t\tltcmp;\n\n\t\t\t\t/*\n\t\t\t\t * If we find ourselves about to compare to the first or last\n\t\t\t\t * histogram entry, first try to replace it with the actual\n\t\t\t\t * current min or max (unless we already did so above).\n\t\t\t\t */\n\t\t\t\tif (probe == 0 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\t\telse if (probe == sslot.nvalues - 1 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[probe]);\n\n\t\t\t\tltcmp = DatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[probe],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\tif (isgt)\n\t\t\t\t\tltcmp = !ltcmp;\n\t\t\t\tif (ltcmp)\n\t\t\t\t\tlobound = probe + 1;\n\t\t\t\telse\n\t\t\t\t\thibound = probe;\n\t\t\t}\n\n\t\t\tif (lobound <= 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Constant is below lower histogram boundary.  More\n\t\t\t\t * precisely, we have found that no entry in the histogram\n\t\t\t\t * satisfies the inequality clause (if !isgt) or they all do\n\t\t\t\t * (if isgt).  We estimate that that's true of the entire\n\t\t\t\t * table, so set histfrac to 0.0 (which we'll flip to 1.0\n\t\t\t\t * below, if isgt).\n\t\t\t\t */\n\t\t\t\thistfrac = 0.0;\n\t\t\t}\n\t\t\telse if (lobound >= sslot.nvalues)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Inverse case: constant is above upper histogram boundary.\n\t\t\t\t */\n\t\t\t\thistfrac = 1.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We have values[i-1] <= constant <= values[i]. */\n\t\t\t\tint\t\t\ti = lobound;\n\t\t\t\tdouble\t\teq_selec = 0;\n\t\t\t\tdouble\t\tval,\n\t\t\t\t\t\t\thigh,\n\t\t\t\t\t\t\tlow;\n\t\t\t\tdouble\t\tbinfrac;\n\n\t\t\t\t/*\n\t\t\t\t * In the cases where we'll need it below, obtain an estimate\n\t\t\t\t * of the selectivity of \"x = constval\".  We use a calculation\n\t\t\t\t * similar to what var_eq_const() does for a non-MCV constant,\n\t\t\t\t * ie, estimate that all distinct non-MCV values occur equally\n\t\t\t\t * often.  But multiplication by \"1.0 - sumcommon - nullfrac\"\n\t\t\t\t * will be done by our caller, so we shouldn't do that here.\n\t\t\t\t * Therefore we can't try to clamp the estimate by reference\n\t\t\t\t * to the least common MCV; the result would be too small.\n\t\t\t\t *\n\t\t\t\t * Note: since this is effectively assuming that constval\n\t\t\t\t * isn't an MCV, it's logically dubious if constval in fact is\n\t\t\t\t * one.  But we have to apply *some* correction for equality,\n\t\t\t\t * and anyway we cannot tell if constval is an MCV, since we\n\t\t\t\t * don't have a suitable equality operator at hand.\n\t\t\t\t */\n\t\t\t\tif (i == 1 || isgt == iseq)\n\t\t\t\t{\n\t\t\t\t\tdouble\t\totherdistinct;\n\t\t\t\t\tbool\t\tisdefault;\n\t\t\t\t\tAttStatsSlot mcvslot;\n\n\t\t\t\t\t/* Get estimated number of distinct values */\n\t\t\t\t\totherdistinct = get_variable_numdistinct(vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &isdefault);\n\n\t\t\t\t\t/* Subtract off the number of known MCVs */\n\t\t\t\t\tif (get_attstatsslot(&mcvslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t\t\t\t{\n\t\t\t\t\t\totherdistinct -= mcvslot.nnumbers;\n\t\t\t\t\t\tfree_attstatsslot(&mcvslot);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If result doesn't seem sane, leave eq_selec at 0 */\n\t\t\t\t\tif (otherdistinct > 1)\n\t\t\t\t\t\teq_selec = 1.0 / otherdistinct;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Convert the constant and the two nearest bin boundary\n\t\t\t\t * values to a uniform comparison scale, and do a linear\n\t\t\t\t * interpolation within this bin.\n\t\t\t\t */\n\t\t\t\tif (convert_to_scalar(constval, consttype, &val,\n\t\t\t\t\t\t\t\t\t  sslot.values[i - 1], sslot.values[i],\n\t\t\t\t\t\t\t\t\t  vardata->vartype,\n\t\t\t\t\t\t\t\t\t  &low, &high))\n\t\t\t\t{\n\t\t\t\t\tif (high <= low)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* cope if bin boundaries appear identical */\n\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t\telse if (val <= low)\n\t\t\t\t\t\tbinfrac = 0.0;\n\t\t\t\t\telse if (val >= high)\n\t\t\t\t\t\tbinfrac = 1.0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbinfrac = (val - low) / (high - low);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Watch out for the possibility that we got a NaN or\n\t\t\t\t\t\t * Infinity from the division.  This can happen\n\t\t\t\t\t\t * despite the previous checks, if for example \"low\"\n\t\t\t\t\t\t * is -Infinity.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (isnan(binfrac) ||\n\t\t\t\t\t\t\tbinfrac < 0.0 || binfrac > 1.0)\n\t\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Ideally we'd produce an error here, on the grounds that\n\t\t\t\t\t * the given operator shouldn't have scalarXXsel\n\t\t\t\t\t * registered as its selectivity func unless we can deal\n\t\t\t\t\t * with its operand types.  But currently, all manner of\n\t\t\t\t\t * stuff is invoking scalarXXsel, so give a default\n\t\t\t\t\t * estimate until that can be fixed.\n\t\t\t\t\t */\n\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Now, compute the overall selectivity across the values\n\t\t\t\t * represented by the histogram.  We have i-1 full bins and\n\t\t\t\t * binfrac partial bin below the constant.\n\t\t\t\t */\n\t\t\t\thistfrac = (double) (i - 1) + binfrac;\n\t\t\t\thistfrac /= (double) (sslot.nvalues - 1);\n\n\t\t\t\t/*\n\t\t\t\t * At this point, histfrac is an estimate of the fraction of\n\t\t\t\t * the population represented by the histogram that satisfies\n\t\t\t\t * \"x <= constval\".  Somewhat remarkably, this statement is\n\t\t\t\t * true regardless of which operator we were doing the probes\n\t\t\t\t * with, so long as convert_to_scalar() delivers reasonable\n\t\t\t\t * results.  If the probe constant is equal to some histogram\n\t\t\t\t * entry, we would have considered the bin to the left of that\n\t\t\t\t * entry if probing with \"<\" or \">=\", or the bin to the right\n\t\t\t\t * if probing with \"<=\" or \">\"; but binfrac would have come\n\t\t\t\t * out as 1.0 in the first case and 0.0 in the second, leading\n\t\t\t\t * to the same histfrac in either case.  For probe constants\n\t\t\t\t * between histogram entries, we find the same bin and get the\n\t\t\t\t * same estimate with any operator.\n\t\t\t\t *\n\t\t\t\t * The fact that the estimate corresponds to \"x <= constval\"\n\t\t\t\t * and not \"x < constval\" is because of the way that ANALYZE\n\t\t\t\t * constructs the histogram: each entry is, effectively, the\n\t\t\t\t * rightmost value in its sample bucket.  So selectivity\n\t\t\t\t * values that are exact multiples of 1/(histogram_size-1)\n\t\t\t\t * should be understood as estimates including a histogram\n\t\t\t\t * entry plus everything to its left.\n\t\t\t\t *\n\t\t\t\t * However, that breaks down for the first histogram entry,\n\t\t\t\t * which necessarily is the leftmost value in its sample\n\t\t\t\t * bucket.  That means the first histogram bin is slightly\n\t\t\t\t * narrower than the rest, by an amount equal to eq_selec.\n\t\t\t\t * Another way to say that is that we want \"x <= leftmost\" to\n\t\t\t\t * be estimated as eq_selec not zero.  So, if we're dealing\n\t\t\t\t * with the first bin (i==1), rescale to make that true while\n\t\t\t\t * adjusting the rest of that bin linearly.\n\t\t\t\t */\n\t\t\t\tif (i == 1)\n\t\t\t\t\thistfrac += eq_selec * (1.0 - binfrac);\n\n\t\t\t\t/*\n\t\t\t\t * \"x <= constval\" is good if we want an estimate for \"<=\" or\n\t\t\t\t * \">\", but if we are estimating for \"<\" or \">=\", we now need\n\t\t\t\t * to decrease the estimate by eq_selec.\n\t\t\t\t */\n\t\t\t\tif (isgt == iseq)\n\t\t\t\t\thistfrac -= eq_selec;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now the estimate is finished for \"<\" and \"<=\" cases.  If we are\n\t\t\t * estimating for \">\" or \">=\", flip it.\n\t\t\t */\n\t\t\thist_selec = isgt ? (1.0 - histfrac) : histfrac;\n\n\t\t\t/*\n\t\t\t * The histogram boundaries are only approximate to begin with,\n\t\t\t * and may well be out of date anyway.  Therefore, don't believe\n\t\t\t * extremely small or large selectivity estimates --- unless we\n\t\t\t * got actual current endpoint values from the table, in which\n\t\t\t * case just do the usual sanity clamp.  Somewhat arbitrarily, we\n\t\t\t * set the cutoff for other cases at a hundredth of the histogram\n\t\t\t * resolution.\n\t\t\t */\n\t\t\tif (have_end)\n\t\t\t\tCLAMP_PROBABILITY(hist_selec);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble\t\tcutoff = 0.01 / (double) (sslot.nvalues - 1);\n\n\t\t\t\tif (hist_selec < cutoff)\n\t\t\t\t\thist_selec = cutoff;\n\t\t\t\telse if (hist_selec > 1.0 - cutoff)\n\t\t\t\t\thist_selec = 1.0 - cutoff;\n\t\t\t}\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\treturn hist_selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_greater_string",
          "args": [
            "prefixcon",
            "&opproc",
            "DEFAULT_COLLATION_OID"
          ],
          "line": 6061
        },
        "resolved": true,
        "details": {
          "function_name": "make_greater_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6339-6475",
          "snippet": "Const *\nmake_greater_string(const Const *str_const, FmgrInfo *ltproc, Oid collation)\n{\n\tOid\t\t\tdatatype = str_const->consttype;\n\tchar\t   *workstr;\n\tint\t\t\tlen;\n\tDatum\t\tcmpstr;\n\ttext\t   *cmptxt = NULL;\n\tmbcharacter_incrementer charinc;\n\n\t/*\n\t * Get a modifiable copy of the prefix string in C-string format, and set\n\t * up the string we will compare to as a Datum.  In C locale this can just\n\t * be the given prefix string, otherwise we need to add a suffix.  Types\n\t * NAME and BYTEA sort bytewise so they don't need a suffix either.\n\t */\n\tif (datatype == NAMEOID)\n\t{\n\t\tworkstr = DatumGetCString(DirectFunctionCall1(nameout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  str_const->constvalue));\n\t\tlen = strlen(workstr);\n\t\tcmpstr = str_const->constvalue;\n\t}\n\telse if (datatype == BYTEAOID)\n\t{\n\t\tbytea\t   *bstr = DatumGetByteaPP(str_const->constvalue);\n\n\t\tlen = VARSIZE_ANY_EXHDR(bstr);\n\t\tworkstr = (char *) palloc(len);\n\t\tmemcpy(workstr, VARDATA_ANY(bstr), len);\n\t\tAssert((Pointer) bstr == DatumGetPointer(str_const->constvalue));\n\t\tcmpstr = str_const->constvalue;\n\t}\n\telse\n\t{\n\t\tworkstr = TextDatumGetCString(str_const->constvalue);\n\t\tlen = strlen(workstr);\n\t\tif (lc_collate_is_c(collation) || len == 0)\n\t\t\tcmpstr = str_const->constvalue;\n\t\telse\n\t\t{\n\t\t\t/* If first time through, determine the suffix to use */\n\t\t\tstatic char suffixchar = 0;\n\t\t\tstatic Oid\tsuffixcollation = 0;\n\n\t\t\tif (!suffixchar || suffixcollation != collation)\n\t\t\t{\n\t\t\t\tchar\t   *best;\n\n\t\t\t\tbest = \"Z\";\n\t\t\t\tif (varstr_cmp(best, 1, \"z\", 1, collation) < 0)\n\t\t\t\t\tbest = \"z\";\n\t\t\t\tif (varstr_cmp(best, 1, \"y\", 1, collation) < 0)\n\t\t\t\t\tbest = \"y\";\n\t\t\t\tif (varstr_cmp(best, 1, \"9\", 1, collation) < 0)\n\t\t\t\t\tbest = \"9\";\n\t\t\t\tsuffixchar = *best;\n\t\t\t\tsuffixcollation = collation;\n\t\t\t}\n\n\t\t\t/* And build the string to compare to */\n\t\t\tcmptxt = (text *) palloc(VARHDRSZ + len + 1);\n\t\t\tSET_VARSIZE(cmptxt, VARHDRSZ + len + 1);\n\t\t\tmemcpy(VARDATA(cmptxt), workstr, len);\n\t\t\t*(VARDATA(cmptxt) + len) = suffixchar;\n\t\t\tcmpstr = PointerGetDatum(cmptxt);\n\t\t}\n\t}\n\n\t/* Select appropriate character-incrementer function */\n\tif (datatype == BYTEAOID)\n\t\tcharinc = byte_increment;\n\telse\n\t\tcharinc = pg_database_encoding_character_incrementer();\n\n\t/* And search ... */\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tcharlen;\n\t\tunsigned char *lastchar;\n\n\t\t/* Identify the last character --- for bytea, just the last byte */\n\t\tif (datatype == BYTEAOID)\n\t\t\tcharlen = 1;\n\t\telse\n\t\t\tcharlen = len - pg_mbcliplen(workstr, len, len - 1);\n\t\tlastchar = (unsigned char *) (workstr + len - charlen);\n\n\t\t/*\n\t\t * Try to generate a larger string by incrementing the last character\n\t\t * (for BYTEA, we treat each byte as a character).\n\t\t *\n\t\t * Note: the incrementer function is expected to return true if it's\n\t\t * generated a valid-per-the-encoding new character, otherwise false.\n\t\t * The contents of the character on false return are unspecified.\n\t\t */\n\t\twhile (charinc(lastchar, charlen))\n\t\t{\n\t\t\tConst\t   *workstr_const;\n\n\t\t\tif (datatype == BYTEAOID)\n\t\t\t\tworkstr_const = string_to_bytea_const(workstr, len);\n\t\t\telse\n\t\t\t\tworkstr_const = string_to_const(workstr, datatype);\n\n\t\t\tif (DatumGetBool(FunctionCall2Coll(ltproc,\n\t\t\t\t\t\t\t\t\t\t\t   collation,\n\t\t\t\t\t\t\t\t\t\t\t   cmpstr,\n\t\t\t\t\t\t\t\t\t\t\t   workstr_const->constvalue)))\n\t\t\t{\n\t\t\t\t/* Successfully made a string larger than cmpstr */\n\t\t\t\tif (cmptxt)\n\t\t\t\t\tpfree(cmptxt);\n\t\t\t\tpfree(workstr);\n\t\t\t\treturn workstr_const;\n\t\t\t}\n\n\t\t\t/* No good, release unusable value and try again */\n\t\t\tpfree(DatumGetPointer(workstr_const->constvalue));\n\t\t\tpfree(workstr_const);\n\t\t}\n\n\t\t/*\n\t\t * No luck here, so truncate off the last character and try to\n\t\t * increment the next one.\n\t\t */\n\t\tlen -= charlen;\n\t\tworkstr[len] = '\\0';\n\t}\n\n\t/* Failed... */\n\tif (cmptxt)\n\t\tpfree(cmptxt);\n\tpfree(workstr);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static Datum string_to_datum(const char *str, Oid datatype);",
            "static Const *string_to_const(const char *str, Oid datatype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic Datum string_to_datum(const char *str, Oid datatype);\nstatic Const *string_to_const(const char *str, Oid datatype);\n\nConst *\nmake_greater_string(const Const *str_const, FmgrInfo *ltproc, Oid collation)\n{\n\tOid\t\t\tdatatype = str_const->consttype;\n\tchar\t   *workstr;\n\tint\t\t\tlen;\n\tDatum\t\tcmpstr;\n\ttext\t   *cmptxt = NULL;\n\tmbcharacter_incrementer charinc;\n\n\t/*\n\t * Get a modifiable copy of the prefix string in C-string format, and set\n\t * up the string we will compare to as a Datum.  In C locale this can just\n\t * be the given prefix string, otherwise we need to add a suffix.  Types\n\t * NAME and BYTEA sort bytewise so they don't need a suffix either.\n\t */\n\tif (datatype == NAMEOID)\n\t{\n\t\tworkstr = DatumGetCString(DirectFunctionCall1(nameout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  str_const->constvalue));\n\t\tlen = strlen(workstr);\n\t\tcmpstr = str_const->constvalue;\n\t}\n\telse if (datatype == BYTEAOID)\n\t{\n\t\tbytea\t   *bstr = DatumGetByteaPP(str_const->constvalue);\n\n\t\tlen = VARSIZE_ANY_EXHDR(bstr);\n\t\tworkstr = (char *) palloc(len);\n\t\tmemcpy(workstr, VARDATA_ANY(bstr), len);\n\t\tAssert((Pointer) bstr == DatumGetPointer(str_const->constvalue));\n\t\tcmpstr = str_const->constvalue;\n\t}\n\telse\n\t{\n\t\tworkstr = TextDatumGetCString(str_const->constvalue);\n\t\tlen = strlen(workstr);\n\t\tif (lc_collate_is_c(collation) || len == 0)\n\t\t\tcmpstr = str_const->constvalue;\n\t\telse\n\t\t{\n\t\t\t/* If first time through, determine the suffix to use */\n\t\t\tstatic char suffixchar = 0;\n\t\t\tstatic Oid\tsuffixcollation = 0;\n\n\t\t\tif (!suffixchar || suffixcollation != collation)\n\t\t\t{\n\t\t\t\tchar\t   *best;\n\n\t\t\t\tbest = \"Z\";\n\t\t\t\tif (varstr_cmp(best, 1, \"z\", 1, collation) < 0)\n\t\t\t\t\tbest = \"z\";\n\t\t\t\tif (varstr_cmp(best, 1, \"y\", 1, collation) < 0)\n\t\t\t\t\tbest = \"y\";\n\t\t\t\tif (varstr_cmp(best, 1, \"9\", 1, collation) < 0)\n\t\t\t\t\tbest = \"9\";\n\t\t\t\tsuffixchar = *best;\n\t\t\t\tsuffixcollation = collation;\n\t\t\t}\n\n\t\t\t/* And build the string to compare to */\n\t\t\tcmptxt = (text *) palloc(VARHDRSZ + len + 1);\n\t\t\tSET_VARSIZE(cmptxt, VARHDRSZ + len + 1);\n\t\t\tmemcpy(VARDATA(cmptxt), workstr, len);\n\t\t\t*(VARDATA(cmptxt) + len) = suffixchar;\n\t\t\tcmpstr = PointerGetDatum(cmptxt);\n\t\t}\n\t}\n\n\t/* Select appropriate character-incrementer function */\n\tif (datatype == BYTEAOID)\n\t\tcharinc = byte_increment;\n\telse\n\t\tcharinc = pg_database_encoding_character_incrementer();\n\n\t/* And search ... */\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tcharlen;\n\t\tunsigned char *lastchar;\n\n\t\t/* Identify the last character --- for bytea, just the last byte */\n\t\tif (datatype == BYTEAOID)\n\t\t\tcharlen = 1;\n\t\telse\n\t\t\tcharlen = len - pg_mbcliplen(workstr, len, len - 1);\n\t\tlastchar = (unsigned char *) (workstr + len - charlen);\n\n\t\t/*\n\t\t * Try to generate a larger string by incrementing the last character\n\t\t * (for BYTEA, we treat each byte as a character).\n\t\t *\n\t\t * Note: the incrementer function is expected to return true if it's\n\t\t * generated a valid-per-the-encoding new character, otherwise false.\n\t\t * The contents of the character on false return are unspecified.\n\t\t */\n\t\twhile (charinc(lastchar, charlen))\n\t\t{\n\t\t\tConst\t   *workstr_const;\n\n\t\t\tif (datatype == BYTEAOID)\n\t\t\t\tworkstr_const = string_to_bytea_const(workstr, len);\n\t\t\telse\n\t\t\t\tworkstr_const = string_to_const(workstr, datatype);\n\n\t\t\tif (DatumGetBool(FunctionCall2Coll(ltproc,\n\t\t\t\t\t\t\t\t\t\t\t   collation,\n\t\t\t\t\t\t\t\t\t\t\t   cmpstr,\n\t\t\t\t\t\t\t\t\t\t\t   workstr_const->constvalue)))\n\t\t\t{\n\t\t\t\t/* Successfully made a string larger than cmpstr */\n\t\t\t\tif (cmptxt)\n\t\t\t\t\tpfree(cmptxt);\n\t\t\t\tpfree(workstr);\n\t\t\t\treturn workstr_const;\n\t\t\t}\n\n\t\t\t/* No good, release unusable value and try again */\n\t\t\tpfree(DatumGetPointer(workstr_const->constvalue));\n\t\t\tpfree(workstr_const);\n\t\t}\n\n\t\t/*\n\t\t * No luck here, so truncate off the last character and try to\n\t\t * increment the next one.\n\t\t */\n\t\tlen -= charlen;\n\t\tworkstr[len] = '\\0';\n\t}\n\n\t/* Failed... */\n\tif (cmptxt)\n\t\tpfree(cmptxt);\n\tpfree(workstr);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "get_opcode(cmpopr)",
            "&opproc"
          ],
          "line": 6060
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "cmpopr"
          ],
          "line": 6060
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic Selectivity prefix_selectivity(PlannerInfo *root,\n\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t   Oid vartype, Oid opfamily, Const *prefixcon);\n\nstatic Selectivity\nprefix_selectivity(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid vartype, Oid opfamily, Const *prefixcon)\n{\n\tSelectivity prefixsel;\n\tOid\t\t\tcmpopr;\n\tFmgrInfo\topproc;\n\tConst\t   *greaterstrcon;\n\tSelectivity eq_sel;\n\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTGreaterEqualStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no >= operator for opfamily %u\", opfamily);\n\tfmgr_info(get_opcode(cmpopr), &opproc);\n\n\tprefixsel = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t   &opproc, true, true,\n\t\t\t\t\t\t\t\t\t\t   prefixcon->constvalue,\n\t\t\t\t\t\t\t\t\t\t   prefixcon->consttype);\n\n\tif (prefixsel < 0.0)\n\t{\n\t\t/* No histogram is present ... return a suitable default estimate */\n\t\treturn DEFAULT_MATCH_SEL;\n\t}\n\n\t/*-------\n\t * If we can create a string larger than the prefix, say\n\t *\t\"x < greaterstr\".\n\t *-------\n\t */\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no < operator for opfamily %u\", opfamily);\n\tfmgr_info(get_opcode(cmpopr), &opproc);\n\tgreaterstrcon = make_greater_string(prefixcon, &opproc,\n\t\t\t\t\t\t\t\t\t\tDEFAULT_COLLATION_OID);\n\tif (greaterstrcon)\n\t{\n\t\tSelectivity topsel;\n\n\t\ttopsel = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t\t&opproc, false, false,\n\t\t\t\t\t\t\t\t\t\t\tgreaterstrcon->constvalue,\n\t\t\t\t\t\t\t\t\t\t\tgreaterstrcon->consttype);\n\n\t\t/* ineq_histogram_selectivity worked before, it shouldn't fail now */\n\t\tAssert(topsel >= 0.0);\n\n\t\t/*\n\t\t * Merge the two selectivities in the same way as for a range query\n\t\t * (see clauselist_selectivity()).  Note that we don't need to worry\n\t\t * about double-exclusion of nulls, since ineq_histogram_selectivity\n\t\t * doesn't count those anyway.\n\t\t */\n\t\tprefixsel = topsel + prefixsel - 1.0;\n\t}\n\n\t/*\n\t * If the prefix is long then the two bounding values might be too close\n\t * together for the histogram to distinguish them usefully, resulting in a\n\t * zero estimate (plus or minus roundoff error). To avoid returning a\n\t * ridiculously small estimate, compute the estimated selectivity for\n\t * \"variable = 'foo'\", and clamp to that. (Obviously, the resultant\n\t * estimate should be at least that.)\n\t *\n\t * We apply this even if we couldn't make a greater string.  That case\n\t * suggests that the prefix is near the maximum possible, and thus\n\t * probably off the end of the histogram, and thus we probably got a very\n\t * small estimate from the >= condition; so we still need to clamp.\n\t */\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\teq_sel = var_eq_const(vardata, cmpopr, prefixcon->constvalue,\n\t\t\t\t\t\t  false, true, false);\n\n\tprefixsel = Max(prefixsel, eq_sel);\n\n\treturn prefixsel;\n}"
  },
  {
    "function_name": "pattern_fixed_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "5959-6003",
    "snippet": "Pattern_Prefix_Status\npattern_fixed_prefix(Const *patt, Pattern_Type ptype, Oid collation,\n\t\t\t\t\t Const **prefix, Selectivity *rest_selec)\n{\n\tPattern_Prefix_Status result;\n\n\tswitch (ptype)\n\t{\n\t\tcase Pattern_Type_Like:\n\t\t\tresult = like_fixed_prefix(patt, false, collation,\n\t\t\t\t\t\t\t\t\t   prefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Like_IC:\n\t\t\tresult = like_fixed_prefix(patt, true, collation,\n\t\t\t\t\t\t\t\t\t   prefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Regex:\n\t\t\tresult = regex_fixed_prefix(patt, false, collation,\n\t\t\t\t\t\t\t\t\t\tprefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Regex_IC:\n\t\t\tresult = regex_fixed_prefix(patt, true, collation,\n\t\t\t\t\t\t\t\t\t\tprefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Prefix:\n\t\t\t/* Prefix type work is trivial.  */\n\t\t\tresult = Pattern_Prefix_Partial;\n\t\t\t*rest_selec = 1.0;\t/* all */\n\t\t\t*prefix = makeConst(patt->consttype,\n\t\t\t\t\t\t\t\tpatt->consttypmod,\n\t\t\t\t\t\t\t\tpatt->constcollid,\n\t\t\t\t\t\t\t\tpatt->constlen,\n\t\t\t\t\t\t\t\tdatumCopy(patt->constvalue,\n\t\t\t\t\t\t\t\t\t\t  patt->constbyval,\n\t\t\t\t\t\t\t\t\t\t  patt->constlen),\n\t\t\t\t\t\t\t\tpatt->constisnull,\n\t\t\t\t\t\t\t\tpatt->constbyval);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized ptype: %d\", (int) ptype);\n\t\t\tresult = Pattern_Prefix_None;\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized ptype: %d\"",
            "(int) ptype"
          ],
          "line": 5998
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeConst",
          "args": [
            "patt->consttype",
            "patt->consttypmod",
            "patt->constcollid",
            "patt->constlen",
            "datumCopy(patt->constvalue,\n\t\t\t\t\t\t\t\t\t\t  patt->constbyval,\n\t\t\t\t\t\t\t\t\t\t  patt->constlen)",
            "patt->constisnull",
            "patt->constbyval"
          ],
          "line": 5987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "patt->constvalue",
            "patt->constbyval",
            "patt->constlen"
          ],
          "line": 5991
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regex_fixed_prefix",
          "args": [
            "patt",
            "true",
            "collation",
            "prefix",
            "rest_selec"
          ],
          "line": 5980
        },
        "resolved": true,
        "details": {
          "function_name": "regex_fixed_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5891-5957",
          "snippet": "static Pattern_Prefix_Status\nregex_fixed_prefix(Const *patt_const, bool case_insensitive, Oid collation,\n\t\t\t\t   Const **prefix_const, Selectivity *rest_selec)\n{\n\tOid\t\t\ttypeid = patt_const->consttype;\n\tchar\t   *prefix;\n\tbool\t\texact;\n\n\t/*\n\t * Should be unnecessary, there are no bytea regex operators defined. As\n\t * such, it should be noted that the rest of this function has *not* been\n\t * made safe for binary (possibly NULL containing) strings.\n\t */\n\tif (typeid == BYTEAOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"regular-expression matching not supported on type bytea\")));\n\n\t/* Use the regexp machinery to extract the prefix, if any */\n\tprefix = regexp_fixed_prefix(DatumGetTextPP(patt_const->constvalue),\n\t\t\t\t\t\t\t\t case_insensitive, collation,\n\t\t\t\t\t\t\t\t &exact);\n\n\tif (prefix == NULL)\n\t{\n\t\t*prefix_const = NULL;\n\n\t\tif (rest_selec != NULL)\n\t\t{\n\t\t\tchar\t   *patt = TextDatumGetCString(patt_const->constvalue);\n\n\t\t\t*rest_selec = regex_selectivity(patt, strlen(patt),\n\t\t\t\t\t\t\t\t\t\t\tcase_insensitive,\n\t\t\t\t\t\t\t\t\t\t\t0);\n\t\t\tpfree(patt);\n\t\t}\n\n\t\treturn Pattern_Prefix_None;\n\t}\n\n\t*prefix_const = string_to_const(prefix, typeid);\n\n\tif (rest_selec != NULL)\n\t{\n\t\tif (exact)\n\t\t{\n\t\t\t/* Exact match, so there's no additional selectivity */\n\t\t\t*rest_selec = 1.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar\t   *patt = TextDatumGetCString(patt_const->constvalue);\n\n\t\t\t*rest_selec = regex_selectivity(patt, strlen(patt),\n\t\t\t\t\t\t\t\t\t\t\tcase_insensitive,\n\t\t\t\t\t\t\t\t\t\t\tstrlen(prefix));\n\t\t\tpfree(patt);\n\t\t}\n\t}\n\n\tpfree(prefix);\n\n\tif (exact)\n\t\treturn Pattern_Prefix_Exact;\t/* pattern specifies exact match */\n\telse\n\t\treturn Pattern_Prefix_Partial;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);\n\nstatic Pattern_Prefix_Status\nregex_fixed_prefix(Const *patt_const, bool case_insensitive, Oid collation,\n\t\t\t\t   Const **prefix_const, Selectivity *rest_selec)\n{\n\tOid\t\t\ttypeid = patt_const->consttype;\n\tchar\t   *prefix;\n\tbool\t\texact;\n\n\t/*\n\t * Should be unnecessary, there are no bytea regex operators defined. As\n\t * such, it should be noted that the rest of this function has *not* been\n\t * made safe for binary (possibly NULL containing) strings.\n\t */\n\tif (typeid == BYTEAOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"regular-expression matching not supported on type bytea\")));\n\n\t/* Use the regexp machinery to extract the prefix, if any */\n\tprefix = regexp_fixed_prefix(DatumGetTextPP(patt_const->constvalue),\n\t\t\t\t\t\t\t\t case_insensitive, collation,\n\t\t\t\t\t\t\t\t &exact);\n\n\tif (prefix == NULL)\n\t{\n\t\t*prefix_const = NULL;\n\n\t\tif (rest_selec != NULL)\n\t\t{\n\t\t\tchar\t   *patt = TextDatumGetCString(patt_const->constvalue);\n\n\t\t\t*rest_selec = regex_selectivity(patt, strlen(patt),\n\t\t\t\t\t\t\t\t\t\t\tcase_insensitive,\n\t\t\t\t\t\t\t\t\t\t\t0);\n\t\t\tpfree(patt);\n\t\t}\n\n\t\treturn Pattern_Prefix_None;\n\t}\n\n\t*prefix_const = string_to_const(prefix, typeid);\n\n\tif (rest_selec != NULL)\n\t{\n\t\tif (exact)\n\t\t{\n\t\t\t/* Exact match, so there's no additional selectivity */\n\t\t\t*rest_selec = 1.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar\t   *patt = TextDatumGetCString(patt_const->constvalue);\n\n\t\t\t*rest_selec = regex_selectivity(patt, strlen(patt),\n\t\t\t\t\t\t\t\t\t\t\tcase_insensitive,\n\t\t\t\t\t\t\t\t\t\t\tstrlen(prefix));\n\t\t\tpfree(patt);\n\t\t}\n\t}\n\n\tpfree(prefix);\n\n\tif (exact)\n\t\treturn Pattern_Prefix_Exact;\t/* pattern specifies exact match */\n\telse\n\t\treturn Pattern_Prefix_Partial;\n}"
        }
      },
      {
        "call_info": {
          "callee": "like_fixed_prefix",
          "args": [
            "patt",
            "true",
            "collation",
            "prefix",
            "rest_selec"
          ],
          "line": 5972
        },
        "resolved": true,
        "details": {
          "function_name": "like_fixed_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5783-5889",
          "snippet": "static Pattern_Prefix_Status\nlike_fixed_prefix(Const *patt_const, bool case_insensitive, Oid collation,\n\t\t\t\t  Const **prefix_const, Selectivity *rest_selec)\n{\n\tchar\t   *match;\n\tchar\t   *patt;\n\tint\t\t\tpattlen;\n\tOid\t\t\ttypeid = patt_const->consttype;\n\tint\t\t\tpos,\n\t\t\t\tmatch_pos;\n\tbool\t\tis_multibyte = (pg_database_encoding_max_length() > 1);\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\t/* the right-hand const is type text or bytea */\n\tAssert(typeid == BYTEAOID || typeid == TEXTOID);\n\n\tif (case_insensitive)\n\t{\n\t\tif (typeid == BYTEAOID)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"case insensitive matching not supported on type bytea\")));\n\n\t\t/* If case-insensitive, we need locale info */\n\t\tif (lc_ctype_is_c(collation))\n\t\t\tlocale_is_c = true;\n\t\telse if (collation != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collation))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collation);\n\t\t}\n\t}\n\n\tif (typeid != BYTEAOID)\n\t{\n\t\tpatt = TextDatumGetCString(patt_const->constvalue);\n\t\tpattlen = strlen(patt);\n\t}\n\telse\n\t{\n\t\tbytea\t   *bstr = DatumGetByteaPP(patt_const->constvalue);\n\n\t\tpattlen = VARSIZE_ANY_EXHDR(bstr);\n\t\tpatt = (char *) palloc(pattlen);\n\t\tmemcpy(patt, VARDATA_ANY(bstr), pattlen);\n\t\tAssert((Pointer) bstr == DatumGetPointer(patt_const->constvalue));\n\t}\n\n\tmatch = palloc(pattlen + 1);\n\tmatch_pos = 0;\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\t/* % and _ are wildcard characters in LIKE */\n\t\tif (patt[pos] == '%' ||\n\t\t\tpatt[pos] == '_')\n\t\t\tbreak;\n\n\t\t/* Backslash escapes the next character */\n\t\tif (patt[pos] == '\\\\')\n\t\t{\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Stop if case-varying character (it's sort of a wildcard) */\n\t\tif (case_insensitive &&\n\t\t\tpattern_char_isalpha(patt[pos], is_multibyte, locale, locale_is_c))\n\t\t\tbreak;\n\n\t\tmatch[match_pos++] = patt[pos];\n\t}\n\n\tmatch[match_pos] = '\\0';\n\n\tif (typeid != BYTEAOID)\n\t\t*prefix_const = string_to_const(match, typeid);\n\telse\n\t\t*prefix_const = string_to_bytea_const(match, match_pos);\n\n\tif (rest_selec != NULL)\n\t\t*rest_selec = like_selectivity(&patt[pos], pattlen - pos,\n\t\t\t\t\t\t\t\t\t   case_insensitive);\n\n\tpfree(patt);\n\tpfree(match);\n\n\t/* in LIKE, an empty pattern is an exact match! */\n\tif (pos == pattlen)\n\t\treturn Pattern_Prefix_Exact;\t/* reached end of pattern, so exact */\n\n\tif (match_pos > 0)\n\t\treturn Pattern_Prefix_Partial;\n\n\treturn Pattern_Prefix_None;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);\n\nstatic Pattern_Prefix_Status\nlike_fixed_prefix(Const *patt_const, bool case_insensitive, Oid collation,\n\t\t\t\t  Const **prefix_const, Selectivity *rest_selec)\n{\n\tchar\t   *match;\n\tchar\t   *patt;\n\tint\t\t\tpattlen;\n\tOid\t\t\ttypeid = patt_const->consttype;\n\tint\t\t\tpos,\n\t\t\t\tmatch_pos;\n\tbool\t\tis_multibyte = (pg_database_encoding_max_length() > 1);\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\t/* the right-hand const is type text or bytea */\n\tAssert(typeid == BYTEAOID || typeid == TEXTOID);\n\n\tif (case_insensitive)\n\t{\n\t\tif (typeid == BYTEAOID)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"case insensitive matching not supported on type bytea\")));\n\n\t\t/* If case-insensitive, we need locale info */\n\t\tif (lc_ctype_is_c(collation))\n\t\t\tlocale_is_c = true;\n\t\telse if (collation != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collation))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collation);\n\t\t}\n\t}\n\n\tif (typeid != BYTEAOID)\n\t{\n\t\tpatt = TextDatumGetCString(patt_const->constvalue);\n\t\tpattlen = strlen(patt);\n\t}\n\telse\n\t{\n\t\tbytea\t   *bstr = DatumGetByteaPP(patt_const->constvalue);\n\n\t\tpattlen = VARSIZE_ANY_EXHDR(bstr);\n\t\tpatt = (char *) palloc(pattlen);\n\t\tmemcpy(patt, VARDATA_ANY(bstr), pattlen);\n\t\tAssert((Pointer) bstr == DatumGetPointer(patt_const->constvalue));\n\t}\n\n\tmatch = palloc(pattlen + 1);\n\tmatch_pos = 0;\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\t/* % and _ are wildcard characters in LIKE */\n\t\tif (patt[pos] == '%' ||\n\t\t\tpatt[pos] == '_')\n\t\t\tbreak;\n\n\t\t/* Backslash escapes the next character */\n\t\tif (patt[pos] == '\\\\')\n\t\t{\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Stop if case-varying character (it's sort of a wildcard) */\n\t\tif (case_insensitive &&\n\t\t\tpattern_char_isalpha(patt[pos], is_multibyte, locale, locale_is_c))\n\t\t\tbreak;\n\n\t\tmatch[match_pos++] = patt[pos];\n\t}\n\n\tmatch[match_pos] = '\\0';\n\n\tif (typeid != BYTEAOID)\n\t\t*prefix_const = string_to_const(match, typeid);\n\telse\n\t\t*prefix_const = string_to_bytea_const(match, match_pos);\n\n\tif (rest_selec != NULL)\n\t\t*rest_selec = like_selectivity(&patt[pos], pattlen - pos,\n\t\t\t\t\t\t\t\t\t   case_insensitive);\n\n\tpfree(patt);\n\tpfree(match);\n\n\t/* in LIKE, an empty pattern is an exact match! */\n\tif (pos == pattlen)\n\t\treturn Pattern_Prefix_Exact;\t/* reached end of pattern, so exact */\n\n\tif (match_pos > 0)\n\t\treturn Pattern_Prefix_Partial;\n\n\treturn Pattern_Prefix_None;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\n\nPattern_Prefix_Status\npattern_fixed_prefix(Const *patt, Pattern_Type ptype, Oid collation,\n\t\t\t\t\t Const **prefix, Selectivity *rest_selec)\n{\n\tPattern_Prefix_Status result;\n\n\tswitch (ptype)\n\t{\n\t\tcase Pattern_Type_Like:\n\t\t\tresult = like_fixed_prefix(patt, false, collation,\n\t\t\t\t\t\t\t\t\t   prefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Like_IC:\n\t\t\tresult = like_fixed_prefix(patt, true, collation,\n\t\t\t\t\t\t\t\t\t   prefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Regex:\n\t\t\tresult = regex_fixed_prefix(patt, false, collation,\n\t\t\t\t\t\t\t\t\t\tprefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Regex_IC:\n\t\t\tresult = regex_fixed_prefix(patt, true, collation,\n\t\t\t\t\t\t\t\t\t\tprefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Prefix:\n\t\t\t/* Prefix type work is trivial.  */\n\t\t\tresult = Pattern_Prefix_Partial;\n\t\t\t*rest_selec = 1.0;\t/* all */\n\t\t\t*prefix = makeConst(patt->consttype,\n\t\t\t\t\t\t\t\tpatt->consttypmod,\n\t\t\t\t\t\t\t\tpatt->constcollid,\n\t\t\t\t\t\t\t\tpatt->constlen,\n\t\t\t\t\t\t\t\tdatumCopy(patt->constvalue,\n\t\t\t\t\t\t\t\t\t\t  patt->constbyval,\n\t\t\t\t\t\t\t\t\t\t  patt->constlen),\n\t\t\t\t\t\t\t\tpatt->constisnull,\n\t\t\t\t\t\t\t\tpatt->constbyval);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized ptype: %d\", (int) ptype);\n\t\t\tresult = Pattern_Prefix_None;\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "regex_fixed_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "5891-5957",
    "snippet": "static Pattern_Prefix_Status\nregex_fixed_prefix(Const *patt_const, bool case_insensitive, Oid collation,\n\t\t\t\t   Const **prefix_const, Selectivity *rest_selec)\n{\n\tOid\t\t\ttypeid = patt_const->consttype;\n\tchar\t   *prefix;\n\tbool\t\texact;\n\n\t/*\n\t * Should be unnecessary, there are no bytea regex operators defined. As\n\t * such, it should be noted that the rest of this function has *not* been\n\t * made safe for binary (possibly NULL containing) strings.\n\t */\n\tif (typeid == BYTEAOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"regular-expression matching not supported on type bytea\")));\n\n\t/* Use the regexp machinery to extract the prefix, if any */\n\tprefix = regexp_fixed_prefix(DatumGetTextPP(patt_const->constvalue),\n\t\t\t\t\t\t\t\t case_insensitive, collation,\n\t\t\t\t\t\t\t\t &exact);\n\n\tif (prefix == NULL)\n\t{\n\t\t*prefix_const = NULL;\n\n\t\tif (rest_selec != NULL)\n\t\t{\n\t\t\tchar\t   *patt = TextDatumGetCString(patt_const->constvalue);\n\n\t\t\t*rest_selec = regex_selectivity(patt, strlen(patt),\n\t\t\t\t\t\t\t\t\t\t\tcase_insensitive,\n\t\t\t\t\t\t\t\t\t\t\t0);\n\t\t\tpfree(patt);\n\t\t}\n\n\t\treturn Pattern_Prefix_None;\n\t}\n\n\t*prefix_const = string_to_const(prefix, typeid);\n\n\tif (rest_selec != NULL)\n\t{\n\t\tif (exact)\n\t\t{\n\t\t\t/* Exact match, so there's no additional selectivity */\n\t\t\t*rest_selec = 1.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar\t   *patt = TextDatumGetCString(patt_const->constvalue);\n\n\t\t\t*rest_selec = regex_selectivity(patt, strlen(patt),\n\t\t\t\t\t\t\t\t\t\t\tcase_insensitive,\n\t\t\t\t\t\t\t\t\t\t\tstrlen(prefix));\n\t\t\tpfree(patt);\n\t\t}\n\t}\n\n\tpfree(prefix);\n\n\tif (exact)\n\t\treturn Pattern_Prefix_Exact;\t/* pattern specifies exact match */\n\telse\n\t\treturn Pattern_Prefix_Partial;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
      "static Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "prefix"
          ],
          "line": 5951
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "regex_selectivity",
          "args": [
            "patt",
            "strlen(patt)",
            "case_insensitive",
            "strlen(prefix)"
          ],
          "line": 5944
        },
        "resolved": true,
        "details": {
          "function_name": "regex_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6255-6282",
          "snippet": "static Selectivity\nregex_selectivity(const char *patt, int pattlen, bool case_insensitive,\n\t\t\t\t  int fixed_prefix_len)\n{\n\tSelectivity sel;\n\n\t/* If patt doesn't end with $, consider it to have a trailing wildcard */\n\tif (pattlen > 0 && patt[pattlen - 1] == '$' &&\n\t\t(pattlen == 1 || patt[pattlen - 2] != '\\\\'))\n\t{\n\t\t/* has trailing $ */\n\t\tsel = regex_selectivity_sub(patt, pattlen - 1, case_insensitive);\n\t}\n\telse\n\t{\n\t\t/* no trailing $ */\n\t\tsel = regex_selectivity_sub(patt, pattlen, case_insensitive);\n\t\tsel *= FULL_WILDCARD_SEL;\n\t}\n\n\t/* If there's a fixed prefix, discount its selectivity */\n\tif (fixed_prefix_len > 0)\n\t\tsel /= pow(FIXED_CHAR_SEL, fixed_prefix_len);\n\n\t/* Make sure result stays in range */\n\tCLAMP_PROBABILITY(sel);\n\treturn sel;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FULL_WILDCARD_SEL 5.0",
            "#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */"
          ],
          "globals_used": [
            "static Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);",
            "static Selectivity regex_selectivity(const char *patt, int pattlen,\n\t\t\t\t  bool case_insensitive,\n\t\t\t\t  int fixed_prefix_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define FULL_WILDCARD_SEL 5.0\n#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */\n\nstatic Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);\nstatic Selectivity regex_selectivity(const char *patt, int pattlen,\n\t\t\t\t  bool case_insensitive,\n\t\t\t\t  int fixed_prefix_len);\n\nstatic Selectivity\nregex_selectivity(const char *patt, int pattlen, bool case_insensitive,\n\t\t\t\t  int fixed_prefix_len)\n{\n\tSelectivity sel;\n\n\t/* If patt doesn't end with $, consider it to have a trailing wildcard */\n\tif (pattlen > 0 && patt[pattlen - 1] == '$' &&\n\t\t(pattlen == 1 || patt[pattlen - 2] != '\\\\'))\n\t{\n\t\t/* has trailing $ */\n\t\tsel = regex_selectivity_sub(patt, pattlen - 1, case_insensitive);\n\t}\n\telse\n\t{\n\t\t/* no trailing $ */\n\t\tsel = regex_selectivity_sub(patt, pattlen, case_insensitive);\n\t\tsel *= FULL_WILDCARD_SEL;\n\t}\n\n\t/* If there's a fixed prefix, discount its selectivity */\n\tif (fixed_prefix_len > 0)\n\t\tsel /= pow(FIXED_CHAR_SEL, fixed_prefix_len);\n\n\t/* Make sure result stays in range */\n\tCLAMP_PROBABILITY(sel);\n\treturn sel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 5946
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "patt_const->constvalue"
          ],
          "line": 5942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_to_const",
          "args": [
            "prefix",
            "typeid"
          ],
          "line": 5931
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6502-6540",
          "snippet": "static Const *\nstring_to_const(const char *str, Oid datatype)\n{\n\tDatum\t\tconval = string_to_datum(str, datatype);\n\tOid\t\t\tcollation;\n\tint\t\t\tconstlen;\n\n\t/*\n\t * We only need to support a few datatypes here, so hard-wire properties\n\t * instead of incurring the expense of catalog lookups.\n\t */\n\tswitch (datatype)\n\t{\n\t\tcase TEXTOID:\n\t\tcase VARCHAROID:\n\t\tcase BPCHAROID:\n\t\t\tcollation = DEFAULT_COLLATION_OID;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tcase NAMEOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = NAMEDATALEN;\n\t\t\tbreak;\n\n\t\tcase BYTEAOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected datatype in string_to_const: %u\",\n\t\t\t\t datatype);\n\t\t\treturn NULL;\n\t}\n\n\treturn makeConst(datatype, -1, collation, constlen,\n\t\t\t\t\t conval, false, false);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum string_to_datum(const char *str, Oid datatype);",
            "static Const *string_to_const(const char *str, Oid datatype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum string_to_datum(const char *str, Oid datatype);\nstatic Const *string_to_const(const char *str, Oid datatype);\n\nstatic Const *\nstring_to_const(const char *str, Oid datatype)\n{\n\tDatum\t\tconval = string_to_datum(str, datatype);\n\tOid\t\t\tcollation;\n\tint\t\t\tconstlen;\n\n\t/*\n\t * We only need to support a few datatypes here, so hard-wire properties\n\t * instead of incurring the expense of catalog lookups.\n\t */\n\tswitch (datatype)\n\t{\n\t\tcase TEXTOID:\n\t\tcase VARCHAROID:\n\t\tcase BPCHAROID:\n\t\t\tcollation = DEFAULT_COLLATION_OID;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tcase NAMEOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = NAMEDATALEN;\n\t\t\tbreak;\n\n\t\tcase BYTEAOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected datatype in string_to_const: %u\",\n\t\t\t\t datatype);\n\t\t\treturn NULL;\n\t}\n\n\treturn makeConst(datatype, -1, collation, constlen,\n\t\t\t\t\t conval, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "patt_const->constvalue"
          ],
          "line": 5920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regexp_fixed_prefix",
          "args": [
            "DatumGetTextPP(patt_const->constvalue)",
            "case_insensitive",
            "collation",
            "&exact"
          ],
          "line": 5910
        },
        "resolved": true,
        "details": {
          "function_name": "regexp_fixed_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regexp.c",
          "lines": "1379-1437",
          "snippet": "char *\nregexp_fixed_prefix(text *text_re, bool case_insensitive, Oid collation,\n\t\t\t\t\tbool *exact)\n{\n\tchar\t   *result;\n\tregex_t    *re;\n\tint\t\t\tcflags;\n\tint\t\t\tre_result;\n\tpg_wchar   *str;\n\tsize_t\t\tslen;\n\tsize_t\t\tmaxlen;\n\tchar\t\terrMsg[100];\n\n\t*exact = false;\t\t\t\t/* default result */\n\n\t/* Compile RE */\n\tcflags = REG_ADVANCED;\n\tif (case_insensitive)\n\t\tcflags |= REG_ICASE;\n\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\t/* Examine it to see if there's a fixed prefix */\n\tre_result = pg_regprefix(re, &str, &slen);\n\n\tswitch (re_result)\n\t{\n\t\tcase REG_NOMATCH:\n\t\t\treturn NULL;\n\n\t\tcase REG_PREFIX:\n\t\t\t/* continue with wchar conversion */\n\t\t\tbreak;\n\n\t\tcase REG_EXACT:\n\t\t\t*exact = true;\n\t\t\t/* continue with wchar conversion */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* re failed??? */\n\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\tpg_regerror(re_result, re, errMsg, sizeof(errMsg));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t\t\tbreak;\n\t}\n\n\t/* Convert pg_wchar result back to database encoding */\n\tmaxlen = pg_database_encoding_max_length() * slen + 1;\n\tresult = (char *) palloc(maxlen);\n\tslen = pg_wchar2mb_with_len(str, result, slen);\n\tAssert(slen < maxlen);\n\n\tfree(str);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"regex/regex.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"regex/regex.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nchar *\nregexp_fixed_prefix(text *text_re, bool case_insensitive, Oid collation,\n\t\t\t\t\tbool *exact)\n{\n\tchar\t   *result;\n\tregex_t    *re;\n\tint\t\t\tcflags;\n\tint\t\t\tre_result;\n\tpg_wchar   *str;\n\tsize_t\t\tslen;\n\tsize_t\t\tmaxlen;\n\tchar\t\terrMsg[100];\n\n\t*exact = false;\t\t\t\t/* default result */\n\n\t/* Compile RE */\n\tcflags = REG_ADVANCED;\n\tif (case_insensitive)\n\t\tcflags |= REG_ICASE;\n\n\tre = RE_compile_and_cache(text_re, cflags, collation);\n\n\t/* Examine it to see if there's a fixed prefix */\n\tre_result = pg_regprefix(re, &str, &slen);\n\n\tswitch (re_result)\n\t{\n\t\tcase REG_NOMATCH:\n\t\t\treturn NULL;\n\n\t\tcase REG_PREFIX:\n\t\t\t/* continue with wchar conversion */\n\t\t\tbreak;\n\n\t\tcase REG_EXACT:\n\t\t\t*exact = true;\n\t\t\t/* continue with wchar conversion */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* re failed??? */\n\t\t\tCHECK_FOR_INTERRUPTS();\n\t\t\tpg_regerror(re_result, re, errMsg, sizeof(errMsg));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"regular expression failed: %s\", errMsg)));\n\t\t\tbreak;\n\t}\n\n\t/* Convert pg_wchar result back to database encoding */\n\tmaxlen = pg_database_encoding_max_length() * slen + 1;\n\tresult = (char *) palloc(maxlen);\n\tslen = pg_wchar2mb_with_len(str, result, slen);\n\tAssert(slen < maxlen);\n\n\tfree(str);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "patt_const->constvalue"
          ],
          "line": 5910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"regular-expression matching not supported on type bytea\"))"
          ],
          "line": 5905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"regular-expression matching not supported on type bytea\""
          ],
          "line": 5907
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 5906
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);\n\nstatic Pattern_Prefix_Status\nregex_fixed_prefix(Const *patt_const, bool case_insensitive, Oid collation,\n\t\t\t\t   Const **prefix_const, Selectivity *rest_selec)\n{\n\tOid\t\t\ttypeid = patt_const->consttype;\n\tchar\t   *prefix;\n\tbool\t\texact;\n\n\t/*\n\t * Should be unnecessary, there are no bytea regex operators defined. As\n\t * such, it should be noted that the rest of this function has *not* been\n\t * made safe for binary (possibly NULL containing) strings.\n\t */\n\tif (typeid == BYTEAOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"regular-expression matching not supported on type bytea\")));\n\n\t/* Use the regexp machinery to extract the prefix, if any */\n\tprefix = regexp_fixed_prefix(DatumGetTextPP(patt_const->constvalue),\n\t\t\t\t\t\t\t\t case_insensitive, collation,\n\t\t\t\t\t\t\t\t &exact);\n\n\tif (prefix == NULL)\n\t{\n\t\t*prefix_const = NULL;\n\n\t\tif (rest_selec != NULL)\n\t\t{\n\t\t\tchar\t   *patt = TextDatumGetCString(patt_const->constvalue);\n\n\t\t\t*rest_selec = regex_selectivity(patt, strlen(patt),\n\t\t\t\t\t\t\t\t\t\t\tcase_insensitive,\n\t\t\t\t\t\t\t\t\t\t\t0);\n\t\t\tpfree(patt);\n\t\t}\n\n\t\treturn Pattern_Prefix_None;\n\t}\n\n\t*prefix_const = string_to_const(prefix, typeid);\n\n\tif (rest_selec != NULL)\n\t{\n\t\tif (exact)\n\t\t{\n\t\t\t/* Exact match, so there's no additional selectivity */\n\t\t\t*rest_selec = 1.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar\t   *patt = TextDatumGetCString(patt_const->constvalue);\n\n\t\t\t*rest_selec = regex_selectivity(patt, strlen(patt),\n\t\t\t\t\t\t\t\t\t\t\tcase_insensitive,\n\t\t\t\t\t\t\t\t\t\t\tstrlen(prefix));\n\t\t\tpfree(patt);\n\t\t}\n\t}\n\n\tpfree(prefix);\n\n\tif (exact)\n\t\treturn Pattern_Prefix_Exact;\t/* pattern specifies exact match */\n\telse\n\t\treturn Pattern_Prefix_Partial;\n}"
  },
  {
    "function_name": "like_fixed_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "5783-5889",
    "snippet": "static Pattern_Prefix_Status\nlike_fixed_prefix(Const *patt_const, bool case_insensitive, Oid collation,\n\t\t\t\t  Const **prefix_const, Selectivity *rest_selec)\n{\n\tchar\t   *match;\n\tchar\t   *patt;\n\tint\t\t\tpattlen;\n\tOid\t\t\ttypeid = patt_const->consttype;\n\tint\t\t\tpos,\n\t\t\t\tmatch_pos;\n\tbool\t\tis_multibyte = (pg_database_encoding_max_length() > 1);\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\t/* the right-hand const is type text or bytea */\n\tAssert(typeid == BYTEAOID || typeid == TEXTOID);\n\n\tif (case_insensitive)\n\t{\n\t\tif (typeid == BYTEAOID)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"case insensitive matching not supported on type bytea\")));\n\n\t\t/* If case-insensitive, we need locale info */\n\t\tif (lc_ctype_is_c(collation))\n\t\t\tlocale_is_c = true;\n\t\telse if (collation != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collation))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collation);\n\t\t}\n\t}\n\n\tif (typeid != BYTEAOID)\n\t{\n\t\tpatt = TextDatumGetCString(patt_const->constvalue);\n\t\tpattlen = strlen(patt);\n\t}\n\telse\n\t{\n\t\tbytea\t   *bstr = DatumGetByteaPP(patt_const->constvalue);\n\n\t\tpattlen = VARSIZE_ANY_EXHDR(bstr);\n\t\tpatt = (char *) palloc(pattlen);\n\t\tmemcpy(patt, VARDATA_ANY(bstr), pattlen);\n\t\tAssert((Pointer) bstr == DatumGetPointer(patt_const->constvalue));\n\t}\n\n\tmatch = palloc(pattlen + 1);\n\tmatch_pos = 0;\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\t/* % and _ are wildcard characters in LIKE */\n\t\tif (patt[pos] == '%' ||\n\t\t\tpatt[pos] == '_')\n\t\t\tbreak;\n\n\t\t/* Backslash escapes the next character */\n\t\tif (patt[pos] == '\\\\')\n\t\t{\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Stop if case-varying character (it's sort of a wildcard) */\n\t\tif (case_insensitive &&\n\t\t\tpattern_char_isalpha(patt[pos], is_multibyte, locale, locale_is_c))\n\t\t\tbreak;\n\n\t\tmatch[match_pos++] = patt[pos];\n\t}\n\n\tmatch[match_pos] = '\\0';\n\n\tif (typeid != BYTEAOID)\n\t\t*prefix_const = string_to_const(match, typeid);\n\telse\n\t\t*prefix_const = string_to_bytea_const(match, match_pos);\n\n\tif (rest_selec != NULL)\n\t\t*rest_selec = like_selectivity(&patt[pos], pattlen - pos,\n\t\t\t\t\t\t\t\t\t   case_insensitive);\n\n\tpfree(patt);\n\tpfree(match);\n\n\t/* in LIKE, an empty pattern is an exact match! */\n\tif (pos == pattlen)\n\t\treturn Pattern_Prefix_Exact;\t/* reached end of pattern, so exact */\n\n\tif (match_pos > 0)\n\t\treturn Pattern_Prefix_Partial;\n\n\treturn Pattern_Prefix_None;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
      "static Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "match"
          ],
          "line": 5879
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "like_selectivity",
          "args": [
            "&patt[pos]",
            "pattlen - pos",
            "case_insensitive"
          ],
          "line": 5875
        },
        "resolved": true,
        "details": {
          "function_name": "like_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6126-6161",
          "snippet": "static Selectivity\nlike_selectivity(const char *patt, int pattlen, bool case_insensitive)\n{\n\tSelectivity sel = 1.0;\n\tint\t\t\tpos;\n\n\t/* Skip any leading wildcard; it's already factored into initial sel */\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\tif (patt[pos] != '%' && patt[pos] != '_')\n\t\t\tbreak;\n\t}\n\n\tfor (; pos < pattlen; pos++)\n\t{\n\t\t/* % and _ are wildcard characters in LIKE */\n\t\tif (patt[pos] == '%')\n\t\t\tsel *= FULL_WILDCARD_SEL;\n\t\telse if (patt[pos] == '_')\n\t\t\tsel *= ANY_CHAR_SEL;\n\t\telse if (patt[pos] == '\\\\')\n\t\t{\n\t\t\t/* Backslash quotes the next character */\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t\telse\n\t\t\tsel *= FIXED_CHAR_SEL;\n\t}\n\t/* Could get sel > 1 if multiple wildcards */\n\tif (sel > 1.0)\n\t\tsel = 1.0;\n\treturn sel;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FULL_WILDCARD_SEL 5.0",
            "#define ANY_CHAR_SEL\t0.9\t\t/* not 1, since it won't match end-of-string */",
            "#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */"
          ],
          "globals_used": [
            "static Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define FULL_WILDCARD_SEL 5.0\n#define ANY_CHAR_SEL\t0.9\t\t/* not 1, since it won't match end-of-string */\n#define FIXED_CHAR_SEL\t0.20\t/* about 1/5 */\n\nstatic Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);\n\nstatic Selectivity\nlike_selectivity(const char *patt, int pattlen, bool case_insensitive)\n{\n\tSelectivity sel = 1.0;\n\tint\t\t\tpos;\n\n\t/* Skip any leading wildcard; it's already factored into initial sel */\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\tif (patt[pos] != '%' && patt[pos] != '_')\n\t\t\tbreak;\n\t}\n\n\tfor (; pos < pattlen; pos++)\n\t{\n\t\t/* % and _ are wildcard characters in LIKE */\n\t\tif (patt[pos] == '%')\n\t\t\tsel *= FULL_WILDCARD_SEL;\n\t\telse if (patt[pos] == '_')\n\t\t\tsel *= ANY_CHAR_SEL;\n\t\telse if (patt[pos] == '\\\\')\n\t\t{\n\t\t\t/* Backslash quotes the next character */\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t\tsel *= FIXED_CHAR_SEL;\n\t\t}\n\t\telse\n\t\t\tsel *= FIXED_CHAR_SEL;\n\t}\n\t/* Could get sel > 1 if multiple wildcards */\n\tif (sel > 1.0)\n\t\tsel = 1.0;\n\treturn sel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_to_bytea_const",
          "args": [
            "match",
            "match_pos"
          ],
          "line": 5872
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_bytea_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6545-6556",
          "snippet": "static Const *\nstring_to_bytea_const(const char *str, size_t str_len)\n{\n\tbytea\t   *bstr = palloc(VARHDRSZ + str_len);\n\tDatum\t\tconval;\n\n\tmemcpy(VARDATA(bstr), str, str_len);\n\tSET_VARSIZE(bstr, VARHDRSZ + str_len);\n\tconval = PointerGetDatum(bstr);\n\n\treturn makeConst(BYTEAOID, -1, InvalidOid, -1, conval, false, false);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Const *string_to_bytea_const(const char *str, size_t str_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Const *string_to_bytea_const(const char *str, size_t str_len);\n\nstatic Const *\nstring_to_bytea_const(const char *str, size_t str_len)\n{\n\tbytea\t   *bstr = palloc(VARHDRSZ + str_len);\n\tDatum\t\tconval;\n\n\tmemcpy(VARDATA(bstr), str, str_len);\n\tSET_VARSIZE(bstr, VARHDRSZ + str_len);\n\tconval = PointerGetDatum(bstr);\n\n\treturn makeConst(BYTEAOID, -1, InvalidOid, -1, conval, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_to_const",
          "args": [
            "match",
            "typeid"
          ],
          "line": 5870
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6502-6540",
          "snippet": "static Const *\nstring_to_const(const char *str, Oid datatype)\n{\n\tDatum\t\tconval = string_to_datum(str, datatype);\n\tOid\t\t\tcollation;\n\tint\t\t\tconstlen;\n\n\t/*\n\t * We only need to support a few datatypes here, so hard-wire properties\n\t * instead of incurring the expense of catalog lookups.\n\t */\n\tswitch (datatype)\n\t{\n\t\tcase TEXTOID:\n\t\tcase VARCHAROID:\n\t\tcase BPCHAROID:\n\t\t\tcollation = DEFAULT_COLLATION_OID;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tcase NAMEOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = NAMEDATALEN;\n\t\t\tbreak;\n\n\t\tcase BYTEAOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected datatype in string_to_const: %u\",\n\t\t\t\t datatype);\n\t\t\treturn NULL;\n\t}\n\n\treturn makeConst(datatype, -1, collation, constlen,\n\t\t\t\t\t conval, false, false);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum string_to_datum(const char *str, Oid datatype);",
            "static Const *string_to_const(const char *str, Oid datatype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum string_to_datum(const char *str, Oid datatype);\nstatic Const *string_to_const(const char *str, Oid datatype);\n\nstatic Const *\nstring_to_const(const char *str, Oid datatype)\n{\n\tDatum\t\tconval = string_to_datum(str, datatype);\n\tOid\t\t\tcollation;\n\tint\t\t\tconstlen;\n\n\t/*\n\t * We only need to support a few datatypes here, so hard-wire properties\n\t * instead of incurring the expense of catalog lookups.\n\t */\n\tswitch (datatype)\n\t{\n\t\tcase TEXTOID:\n\t\tcase VARCHAROID:\n\t\tcase BPCHAROID:\n\t\t\tcollation = DEFAULT_COLLATION_OID;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tcase NAMEOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = NAMEDATALEN;\n\t\t\tbreak;\n\n\t\tcase BYTEAOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected datatype in string_to_const: %u\",\n\t\t\t\t datatype);\n\t\t\treturn NULL;\n\t}\n\n\treturn makeConst(datatype, -1, collation, constlen,\n\t\t\t\t\t conval, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pattern_char_isalpha",
          "args": [
            "patt[pos]",
            "is_multibyte",
            "locale",
            "locale_is_c"
          ],
          "line": 5861
        },
        "resolved": true,
        "details": {
          "function_name": "pattern_char_isalpha",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5752-5768",
          "snippet": "static int\npattern_char_isalpha(char c, bool is_multibyte,\n\t\t\t\t\t pg_locale_t locale, bool locale_is_c)\n{\n\tif (locale_is_c)\n\t\treturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n\telse if (is_multibyte && IS_HIGHBIT_SET(c))\n\t\treturn true;\n\telse if (locale && locale->provider == COLLPROVIDER_ICU)\n\t\treturn IS_HIGHBIT_SET(c) ? true : false;\n#ifdef HAVE_LOCALE_T\n\telse if (locale && locale->provider == COLLPROVIDER_LIBC)\n\t\treturn isalpha_l((unsigned char) c, locale->info.lt);\n#endif\n\telse\n\t\treturn isalpha((unsigned char) c);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\npattern_char_isalpha(char c, bool is_multibyte,\n\t\t\t\t\t pg_locale_t locale, bool locale_is_c)\n{\n\tif (locale_is_c)\n\t\treturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n\telse if (is_multibyte && IS_HIGHBIT_SET(c))\n\t\treturn true;\n\telse if (locale && locale->provider == COLLPROVIDER_ICU)\n\t\treturn IS_HIGHBIT_SET(c) ? true : false;\n#ifdef HAVE_LOCALE_T\n\telse if (locale && locale->provider == COLLPROVIDER_LIBC)\n\t\treturn isalpha_l((unsigned char) c, locale->info.lt);\n#endif\n\telse\n\t\treturn isalpha((unsigned char) c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "pattlen + 1"
          ],
          "line": 5842
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(Pointer) bstr == DatumGetPointer(patt_const->constvalue)"
          ],
          "line": 5839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "patt_const->constvalue"
          ],
          "line": 5839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "patt",
            "VARDATA_ANY(bstr)",
            "pattlen"
          ],
          "line": 5838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "bstr"
          ],
          "line": 5838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "bstr"
          ],
          "line": 5836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetByteaPP",
          "args": [
            "patt_const->constvalue"
          ],
          "line": 5834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "patt"
          ],
          "line": 5830
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "patt_const->constvalue"
          ],
          "line": 5829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_newlocale_from_collation",
          "args": [
            "collation"
          ],
          "line": 5823
        },
        "resolved": true,
        "details": {
          "function_name": "pg_newlocale_from_collation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1333-1500",
          "snippet": "pg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\npg_locale_t\npg_newlocale_from_collation(Oid collid)\n{\n\tcollation_cache_entry *cache_entry;\n\n\t/* Callers must pass a valid OID */\n\tAssert(OidIsValid(collid));\n\n\t/* Return 0 for \"default\" collation, just in case caller forgets */\n\tif (collid == DEFAULT_COLLATION_OID)\n\t\treturn (pg_locale_t) 0;\n\n\tcache_entry = lookup_collation_cache(collid, false);\n\n\tif (cache_entry->locale == 0)\n\t{\n\t\t/* We haven't computed this yet in this session, so do it */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_collation collform;\n\t\tconst char *collcollate;\n\t\tconst char *collctype pg_attribute_unused();\n\t\tstruct pg_locale_struct result;\n\t\tpg_locale_t resultp;\n\t\tDatum\t\tcollversion;\n\t\tbool\t\tisnull;\n\n\t\ttp = SearchSysCache1(COLLOID, ObjectIdGetDatum(collid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for collation %u\", collid);\n\t\tcollform = (Form_pg_collation) GETSTRUCT(tp);\n\n\t\tcollcollate = NameStr(collform->collcollate);\n\t\tcollctype = NameStr(collform->collctype);\n\n\t\t/* We'll fill in the result struct locally before allocating memory */\n\t\tmemset(&result, 0, sizeof(result));\n\t\tresult.provider = collform->collprovider;\n\n\t\tif (collform->collprovider == COLLPROVIDER_LIBC)\n\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\tlocale_t\tloc;\n\n\t\t\tif (strcmp(collcollate, collctype) == 0)\n\t\t\t{\n\t\t\t\t/* Normal case where they're the same */\n\t\t\t\terrno = 0;\n#ifndef WIN32\n\t\t\t\tloc = newlocale(LC_COLLATE_MASK | LC_CTYPE_MASK, collcollate,\n\t\t\t\t\t\t\t\tNULL);\n#else\n\t\t\t\tloc = _create_locale(LC_ALL, collcollate);\n#endif\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifndef WIN32\n\t\t\t\t/* We need two newlocale() steps */\n\t\t\t\tlocale_t\tloc1;\n\n\t\t\t\terrno = 0;\n\t\t\t\tloc1 = newlocale(LC_COLLATE_MASK, collcollate, NULL);\n\t\t\t\tif (!loc1)\n\t\t\t\t\treport_newlocale_failure(collcollate);\n\t\t\t\terrno = 0;\n\t\t\t\tloc = newlocale(LC_CTYPE_MASK, collctype, loc1);\n\t\t\t\tif (!loc)\n\t\t\t\t\treport_newlocale_failure(collctype);\n#else\n\n\t\t\t\t/*\n\t\t\t\t * XXX The _create_locale() API doesn't appear to support\n\t\t\t\t * this. Could perhaps be worked around by changing\n\t\t\t\t * pg_locale_t to contain two separate fields.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported on this platform\")));\n#endif\n\t\t\t}\n\n\t\t\tresult.info.lt = loc;\n#else\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t\t/* platform that doesn't support locale_t */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"collation provider LIBC is not supported on this platform\")));\n#endif\t\t\t\t\t\t\t/* not HAVE_LOCALE_T */\n\t\t}\n\t\telse if (collform->collprovider == COLLPROVIDER_ICU)\n\t\t{\n#ifdef USE_ICU\n\t\t\tUCollator  *collator;\n\t\t\tUErrorCode\tstatus;\n\n\t\t\tif (strcmp(collcollate, collctype) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"collations with different collate and ctype values are not supported by ICU\")));\n\n\t\t\tstatus = U_ZERO_ERROR;\n\t\t\tcollator = ucol_open(collcollate, &status);\n\t\t\tif (U_FAILURE(status))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not open collator for locale \\\"%s\\\": %s\",\n\t\t\t\t\t\t\t\tcollcollate, u_errorName(status))));\n\n\t\t\t/* We will leak this string if we get an error below :-( */\n\t\t\tresult.info.icu.locale = MemoryContextStrdup(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t collcollate);\n\t\t\tresult.info.icu.ucol = collator;\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t/* could get here if a collation was created by a build with ICU */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"ICU is not supported in this build\"), \\\n\t\t\t\t\t errhint(\"You need to rebuild PostgreSQL using --with-icu.\")));\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t}\n\n\t\tcollversion = SysCacheGetAttr(COLLOID, tp, Anum_pg_collation_collversion,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tchar\t   *actual_versionstr;\n\t\t\tchar\t   *collversionstr;\n\n\t\t\tactual_versionstr = get_collation_actual_version(collform->collprovider, collcollate);\n\t\t\tif (!actual_versionstr)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This could happen when specifying a version in CREATE\n\t\t\t\t * COLLATION for a libc locale, or manually creating a mess in\n\t\t\t\t * the catalogs.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has no actual version, but a version was specified\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname))));\n\t\t\t}\n\t\t\tcollversionstr = TextDatumGetCString(collversion);\n\n\t\t\tif (strcmp(actual_versionstr, collversionstr) != 0)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errmsg(\"collation \\\"%s\\\" has version mismatch\",\n\t\t\t\t\t\t\t\tNameStr(collform->collname)),\n\t\t\t\t\t\t errdetail(\"The collation in the database was created using version %s, \"\n\t\t\t\t\t\t\t\t   \"but the operating system provides version %s.\",\n\t\t\t\t\t\t\t\t   collversionstr, actual_versionstr),\n\t\t\t\t\t\t errhint(\"Rebuild all objects affected by this collation and run \"\n\t\t\t\t\t\t\t\t \"ALTER COLLATION %s REFRESH VERSION, \"\n\t\t\t\t\t\t\t\t \"or build PostgreSQL with the right library version.\",\n\t\t\t\t\t\t\t\t quote_qualified_identifier(get_namespace_name(collform->collnamespace),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNameStr(collform->collname)))));\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\t/* We'll keep the pg_locale_t structures in TopMemoryContext */\n\t\tresultp = MemoryContextAlloc(TopMemoryContext, sizeof(*resultp));\n\t\t*resultp = result;\n\n\t\tcache_entry->locale = resultp;\n\t}\n\n\treturn cache_entry->locale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\"))"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Use the COLLATE clause to set the collation explicitly.\""
          ],
          "line": 5821
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine which collation to use for ILIKE\""
          ],
          "line": 5820
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INDETERMINATE_COLLATION"
          ],
          "line": 5819
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "collation"
          ],
          "line": 5812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lc_ctype_is_c",
          "args": [
            "collation"
          ],
          "line": 5808
        },
        "resolved": true,
        "details": {
          "function_name": "lc_ctype_is_c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1236-1281",
          "snippet": "bool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_ctype_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_CTYPE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_CTYPE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->ctype_is_c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"case insensitive matching not supported on type bytea\"))"
          ],
          "line": 5803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "typeid == BYTEAOID || typeid == TEXTOID"
          ],
          "line": 5798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 5793
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic Selectivity like_selectivity(const char *patt, int pattlen,\n\t\t\t\t bool case_insensitive);\n\nstatic Pattern_Prefix_Status\nlike_fixed_prefix(Const *patt_const, bool case_insensitive, Oid collation,\n\t\t\t\t  Const **prefix_const, Selectivity *rest_selec)\n{\n\tchar\t   *match;\n\tchar\t   *patt;\n\tint\t\t\tpattlen;\n\tOid\t\t\ttypeid = patt_const->consttype;\n\tint\t\t\tpos,\n\t\t\t\tmatch_pos;\n\tbool\t\tis_multibyte = (pg_database_encoding_max_length() > 1);\n\tpg_locale_t locale = 0;\n\tbool\t\tlocale_is_c = false;\n\n\t/* the right-hand const is type text or bytea */\n\tAssert(typeid == BYTEAOID || typeid == TEXTOID);\n\n\tif (case_insensitive)\n\t{\n\t\tif (typeid == BYTEAOID)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"case insensitive matching not supported on type bytea\")));\n\n\t\t/* If case-insensitive, we need locale info */\n\t\tif (lc_ctype_is_c(collation))\n\t\t\tlocale_is_c = true;\n\t\telse if (collation != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collation))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for ILIKE\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tlocale = pg_newlocale_from_collation(collation);\n\t\t}\n\t}\n\n\tif (typeid != BYTEAOID)\n\t{\n\t\tpatt = TextDatumGetCString(patt_const->constvalue);\n\t\tpattlen = strlen(patt);\n\t}\n\telse\n\t{\n\t\tbytea\t   *bstr = DatumGetByteaPP(patt_const->constvalue);\n\n\t\tpattlen = VARSIZE_ANY_EXHDR(bstr);\n\t\tpatt = (char *) palloc(pattlen);\n\t\tmemcpy(patt, VARDATA_ANY(bstr), pattlen);\n\t\tAssert((Pointer) bstr == DatumGetPointer(patt_const->constvalue));\n\t}\n\n\tmatch = palloc(pattlen + 1);\n\tmatch_pos = 0;\n\tfor (pos = 0; pos < pattlen; pos++)\n\t{\n\t\t/* % and _ are wildcard characters in LIKE */\n\t\tif (patt[pos] == '%' ||\n\t\t\tpatt[pos] == '_')\n\t\t\tbreak;\n\n\t\t/* Backslash escapes the next character */\n\t\tif (patt[pos] == '\\\\')\n\t\t{\n\t\t\tpos++;\n\t\t\tif (pos >= pattlen)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Stop if case-varying character (it's sort of a wildcard) */\n\t\tif (case_insensitive &&\n\t\t\tpattern_char_isalpha(patt[pos], is_multibyte, locale, locale_is_c))\n\t\t\tbreak;\n\n\t\tmatch[match_pos++] = patt[pos];\n\t}\n\n\tmatch[match_pos] = '\\0';\n\n\tif (typeid != BYTEAOID)\n\t\t*prefix_const = string_to_const(match, typeid);\n\telse\n\t\t*prefix_const = string_to_bytea_const(match, match_pos);\n\n\tif (rest_selec != NULL)\n\t\t*rest_selec = like_selectivity(&patt[pos], pattlen - pos,\n\t\t\t\t\t\t\t\t\t   case_insensitive);\n\n\tpfree(patt);\n\tpfree(match);\n\n\t/* in LIKE, an empty pattern is an exact match! */\n\tif (pos == pattlen)\n\t\treturn Pattern_Prefix_Exact;\t/* reached end of pattern, so exact */\n\n\tif (match_pos > 0)\n\t\treturn Pattern_Prefix_Partial;\n\n\treturn Pattern_Prefix_None;\n}"
  },
  {
    "function_name": "pattern_char_isalpha",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "5752-5768",
    "snippet": "static int\npattern_char_isalpha(char c, bool is_multibyte,\n\t\t\t\t\t pg_locale_t locale, bool locale_is_c)\n{\n\tif (locale_is_c)\n\t\treturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n\telse if (is_multibyte && IS_HIGHBIT_SET(c))\n\t\treturn true;\n\telse if (locale && locale->provider == COLLPROVIDER_ICU)\n\t\treturn IS_HIGHBIT_SET(c) ? true : false;\n#ifdef HAVE_LOCALE_T\n\telse if (locale && locale->provider == COLLPROVIDER_LIBC)\n\t\treturn isalpha_l((unsigned char) c, locale->info.lt);\n#endif\n\telse\n\t\treturn isalpha((unsigned char) c);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char) c"
          ],
          "line": 5767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha_l",
          "args": [
            "(unsigned char) c, locale->info.lt"
          ],
          "line": 5764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c"
          ],
          "line": 5761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "c"
          ],
          "line": 5758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\npattern_char_isalpha(char c, bool is_multibyte,\n\t\t\t\t\t pg_locale_t locale, bool locale_is_c)\n{\n\tif (locale_is_c)\n\t\treturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n\telse if (is_multibyte && IS_HIGHBIT_SET(c))\n\t\treturn true;\n\telse if (locale && locale->provider == COLLPROVIDER_ICU)\n\t\treturn IS_HIGHBIT_SET(c) ? true : false;\n#ifdef HAVE_LOCALE_T\n\telse if (locale && locale->provider == COLLPROVIDER_LIBC)\n\t\treturn isalpha_l((unsigned char) c, locale->info.lt);\n#endif\n\telse\n\t\treturn isalpha((unsigned char) c);\n}"
  },
  {
    "function_name": "find_join_input_rel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "5702-5724",
    "snippet": "static RelOptInfo *\nfind_join_input_rel(PlannerInfo *root, Relids relids)\n{\n\tRelOptInfo *rel = NULL;\n\n\tswitch (bms_membership(relids))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* should not happen */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\trel = find_base_rel(root, bms_singleton_member(relids));\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\trel = find_join_rel(root, relids);\n\t\t\tbreak;\n\t}\n\n\tif (rel == NULL)\n\t\telog(ERROR, \"could not find RelOptInfo for given relids\");\n\n\treturn rel;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not find RelOptInfo for given relids\""
          ],
          "line": 5721
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_join_rel",
          "args": [
            "root",
            "relids"
          ],
          "line": 5716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_base_rel",
          "args": [
            "root",
            "bms_singleton_member(relids)"
          ],
          "line": 5713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_singleton_member",
          "args": [
            "relids"
          ],
          "line": 5713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_membership",
          "args": [
            "relids"
          ],
          "line": 5707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);\n\nstatic RelOptInfo *\nfind_join_input_rel(PlannerInfo *root, Relids relids)\n{\n\tRelOptInfo *rel = NULL;\n\n\tswitch (bms_membership(relids))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* should not happen */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\trel = find_base_rel(root, bms_singleton_member(relids));\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\trel = find_join_rel(root, relids);\n\t\t\tbreak;\n\t}\n\n\tif (rel == NULL)\n\t\telog(ERROR, \"could not find RelOptInfo for given relids\");\n\n\treturn rel;\n}"
  },
  {
    "function_name": "get_actual_variable_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "5463-5693",
    "snippet": "static bool\nget_actual_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max)\n{\n\tbool\t\thave_data = false;\n\tRelOptInfo *rel = vardata->rel;\n\tRangeTblEntry *rte;\n\tListCell   *lc;\n\n\t/* No hope if no relation or it doesn't have indexes */\n\tif (rel == NULL || rel->indexlist == NIL)\n\t\treturn false;\n\t/* If it has indexes it must be a plain relation */\n\trte = root->simple_rte_array[rel->relid];\n\tAssert(rte->rtekind == RTE_RELATION);\n\n\t/* Search through the indexes to see if any match our problem */\n\tforeach(lc, rel->indexlist)\n\t{\n\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(lc);\n\t\tScanDirection indexscandir;\n\n\t\t/* Ignore non-btree indexes */\n\t\tif (index->relam != BTREE_AM_OID)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore partial indexes --- we only want stats that cover the entire\n\t\t * relation.\n\t\t */\n\t\tif (index->indpred != NIL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The index list might include hypothetical indexes inserted by a\n\t\t * get_relation_info hook --- don't try to access them.\n\t\t */\n\t\tif (index->hypothetical)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The first index column must match the desired variable and sort\n\t\t * operator --- but we can use a descending-order index.\n\t\t */\n\t\tif (!match_index_to_operand(vardata->var, 0, index))\n\t\t\tcontinue;\n\t\tswitch (get_op_opfamily_strategy(sortop, index->sortopfamily[0]))\n\t\t{\n\t\t\tcase BTLessStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tcase BTGreaterStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* index doesn't match the sortop */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Found a suitable index to extract data from.  We'll need an EState\n\t\t * and a bunch of other infrastructure.\n\t\t */\n\t\t{\n\t\t\tEState\t   *estate;\n\t\t\tExprContext *econtext;\n\t\t\tMemoryContext tmpcontext;\n\t\t\tMemoryContext oldcontext;\n\t\t\tRelation\theapRel;\n\t\t\tRelation\tindexRel;\n\t\t\tIndexInfo  *indexInfo;\n\t\t\tTupleTableSlot *slot;\n\t\t\tint16\t\ttypLen;\n\t\t\tbool\t\ttypByVal;\n\t\t\tScanKeyData scankeys[1];\n\t\t\tIndexScanDesc index_scan;\n\t\t\tHeapTuple\ttup;\n\t\t\tDatum\t\tvalues[INDEX_MAX_KEYS];\n\t\t\tbool\t\tisnull[INDEX_MAX_KEYS];\n\t\t\tSnapshotData SnapshotNonVacuumable;\n\n\t\t\testate = CreateExecutorState();\n\t\t\tecontext = GetPerTupleExprContext(estate);\n\t\t\t/* Make sure any cruft is generated in the econtext's memory */\n\t\t\ttmpcontext = econtext->ecxt_per_tuple_memory;\n\t\t\toldcontext = MemoryContextSwitchTo(tmpcontext);\n\n\t\t\t/*\n\t\t\t * Open the table and index so we can read from them.  We should\n\t\t\t * already have at least AccessShareLock on the table, but not\n\t\t\t * necessarily on the index.\n\t\t\t */\n\t\t\theapRel = heap_open(rte->relid, NoLock);\n\t\t\tindexRel = index_open(index->indexoid, AccessShareLock);\n\n\t\t\t/* extract index key information from the index's pg_index info */\n\t\t\tindexInfo = BuildIndexInfo(indexRel);\n\n\t\t\t/* some other stuff */\n\t\t\tslot = MakeSingleTupleTableSlot(RelationGetDescr(heapRel));\n\t\t\tecontext->ecxt_scantuple = slot;\n\t\t\tget_typlenbyval(vardata->atttype, &typLen, &typByVal);\n\t\t\tInitNonVacuumableSnapshot(SnapshotNonVacuumable, RecentGlobalXmin);\n\n\t\t\t/* set up an IS NOT NULL scan key so that we ignore nulls */\n\t\t\tScanKeyEntryInitialize(&scankeys[0],\n\t\t\t\t\t\t\t\t   SK_ISNULL | SK_SEARCHNOTNULL,\n\t\t\t\t\t\t\t\t   1,\t/* index col to scan */\n\t\t\t\t\t\t\t\t   InvalidStrategy, /* no strategy */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no strategy subtype */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no collation */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no reg proc for this */\n\t\t\t\t\t\t\t\t   (Datum) 0);\t/* constant */\n\n\t\t\thave_data = true;\n\n\t\t\t/* If min is requested ... */\n\t\t\tif (min)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * In principle, we should scan the index with our current\n\t\t\t\t * active snapshot, which is the best approximation we've got\n\t\t\t\t * to what the query will see when executed.  But that won't\n\t\t\t\t * be exact if a new snap is taken before running the query,\n\t\t\t\t * and it can be very expensive if a lot of recently-dead or\n\t\t\t\t * uncommitted rows exist at the beginning or end of the index\n\t\t\t\t * (because we'll laboriously fetch each one and reject it).\n\t\t\t\t * Instead, we use SnapshotNonVacuumable.  That will accept\n\t\t\t\t * recently-dead and uncommitted rows as well as normal\n\t\t\t\t * visible rows.  On the other hand, it will reject known-dead\n\t\t\t\t * rows, and thus not give a bogus answer when the extreme\n\t\t\t\t * value has been deleted (unless the deletion was quite\n\t\t\t\t * recent); that case motivates not using SnapshotAny here.\n\t\t\t\t *\n\t\t\t\t * A crucial point here is that SnapshotNonVacuumable, with\n\t\t\t\t * RecentGlobalXmin as horizon, yields the inverse of the\n\t\t\t\t * condition that the indexscan will use to decide that index\n\t\t\t\t * entries are killable (see heap_hot_search_buffer()).\n\t\t\t\t * Therefore, if the snapshot rejects a tuple and we have to\n\t\t\t\t * continue scanning past it, we know that the indexscan will\n\t\t\t\t * mark that index entry killed.  That means that the next\n\t\t\t\t * get_actual_variable_range() call will not have to visit\n\t\t\t\t * that heap entry.  In this way we avoid repetitive work when\n\t\t\t\t * this function is used a lot during planning.\n\t\t\t\t */\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in sortop's direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*min = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* If max is requested, and we didn't find the index is empty */\n\t\t\tif (max && have_data)\n\t\t\t{\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in reverse direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t -indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*max = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* Clean everything up */\n\t\t\tExecDropSingleTupleTableSlot(slot);\n\n\t\t\tindex_close(indexRel, AccessShareLock);\n\t\t\theap_close(heapRel, NoLock);\n\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\tFreeExecutorState(estate);\n\n\t\t\t/* And we're done */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn have_data;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
      "static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);",
      "static bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeExecutorState",
          "args": [
            "estate"
          ],
          "line": 5685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 5684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "heapRel",
            "NoLock"
          ],
          "line": 5682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_close",
          "args": [
            "indexRel",
            "AccessShareLock"
          ],
          "line": 5681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecDropSingleTupleTableSlot",
          "args": [
            "slot"
          ],
          "line": 5679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_endscan",
          "args": [
            "index_scan"
          ],
          "line": 5675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "tmpcontext"
          ],
          "line": 5670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "values[0]",
            "typByVal",
            "typLen"
          ],
          "line": 5669
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 5668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"found unexpected null value in index \\\"%s\\\"\"",
            "RelationGetRelationName(indexRel)"
          ],
          "line": 5664
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "indexRel"
          ],
          "line": 5665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormIndexDatum",
          "args": [
            "indexInfo",
            "slot",
            "estate",
            "values",
            "isnull"
          ],
          "line": 5659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecStoreTuple",
          "args": [
            "tup",
            "slot",
            "InvalidBuffer",
            "false"
          ],
          "line": 5658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_getnext",
          "args": [
            "index_scan",
            "-indexscandir"
          ],
          "line": 5654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_rescan",
          "args": [
            "index_scan",
            "scankeys",
            "1",
            "NULL",
            "0"
          ],
          "line": 5651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_beginscan",
          "args": [
            "heapRel",
            "indexRel",
            "&SnapshotNonVacuumable",
            "1",
            "0"
          ],
          "line": 5648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_endscan",
          "args": [
            "index_scan"
          ],
          "line": 5642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "tmpcontext"
          ],
          "line": 5637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 5635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "indexRel"
          ],
          "line": 5632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormIndexDatum",
          "args": [
            "indexInfo",
            "slot",
            "estate",
            "values",
            "isnull"
          ],
          "line": 5626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecStoreTuple",
          "args": [
            "tup",
            "slot",
            "InvalidBuffer",
            "false"
          ],
          "line": 5625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_getnext",
          "args": [
            "index_scan",
            "indexscandir"
          ],
          "line": 5621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_rescan",
          "args": [
            "index_scan",
            "scankeys",
            "1",
            "NULL",
            "0"
          ],
          "line": 5618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_beginscan",
          "args": [
            "heapRel",
            "indexRel",
            "&SnapshotNonVacuumable",
            "1",
            "0"
          ],
          "line": 5615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyEntryInitialize",
          "args": [
            "&scankeys[0]",
            "SK_ISNULL | SK_SEARCHNOTNULL",
            "1",
            "/* index col to scan */InvalidStrategy",
            "/* no strategy */InvalidOid",
            "/* no strategy subtype */InvalidOid",
            "/* no collation */InvalidOid",
            "/* no reg proc for this */(Datum) 0"
          ],
          "line": 5575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitNonVacuumableSnapshot",
          "args": [
            "SnapshotNonVacuumable",
            "RecentGlobalXmin"
          ],
          "line": 5572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typlenbyval",
          "args": [
            "vardata->atttype",
            "&typLen",
            "&typByVal"
          ],
          "line": 5571
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2028-2041",
          "snippet": "void\nget_typlenbyval(Oid typid, int16 *typlen, bool *typbyval)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyval(Oid typid, int16 *typlen, bool *typbyval)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeSingleTupleTableSlot",
          "args": [
            "RelationGetDescr(heapRel)"
          ],
          "line": 5569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "heapRel"
          ],
          "line": 5569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BuildIndexInfo",
          "args": [
            "indexRel"
          ],
          "line": 5566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_open",
          "args": [
            "index->indexoid",
            "AccessShareLock"
          ],
          "line": 5563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "rte->relid",
            "NoLock"
          ],
          "line": 5562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "tmpcontext"
          ],
          "line": 5555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPerTupleExprContext",
          "args": [
            "estate"
          ],
          "line": 5552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateExecutorState",
          "args": [],
          "line": 5551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_op_opfamily_strategy",
          "args": [
            "sortop",
            "index->sortopfamily[0]"
          ],
          "line": 5510
        },
        "resolved": true,
        "details": {
          "function_name": "get_op_opfamily_strategy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "79-96",
          "snippet": "int\nget_op_opfamily_strategy(Oid opno, Oid opfamily)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tint\t\t\tresult;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(AMOP_SEARCH),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn 0;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopstrategy;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nint\nget_op_opfamily_strategy(Oid opno, Oid opfamily)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tint\t\t\tresult;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(AMOP_SEARCH),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn 0;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopstrategy;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_index_to_operand",
          "args": [
            "vardata->var",
            "0",
            "index"
          ],
          "line": 5508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 5483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "rel->indexlist"
          ],
          "line": 5481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rte->rtekind == RTE_RELATION"
          ],
          "line": 5478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);\nstatic bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);\n\nstatic bool\nget_actual_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max)\n{\n\tbool\t\thave_data = false;\n\tRelOptInfo *rel = vardata->rel;\n\tRangeTblEntry *rte;\n\tListCell   *lc;\n\n\t/* No hope if no relation or it doesn't have indexes */\n\tif (rel == NULL || rel->indexlist == NIL)\n\t\treturn false;\n\t/* If it has indexes it must be a plain relation */\n\trte = root->simple_rte_array[rel->relid];\n\tAssert(rte->rtekind == RTE_RELATION);\n\n\t/* Search through the indexes to see if any match our problem */\n\tforeach(lc, rel->indexlist)\n\t{\n\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(lc);\n\t\tScanDirection indexscandir;\n\n\t\t/* Ignore non-btree indexes */\n\t\tif (index->relam != BTREE_AM_OID)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore partial indexes --- we only want stats that cover the entire\n\t\t * relation.\n\t\t */\n\t\tif (index->indpred != NIL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The index list might include hypothetical indexes inserted by a\n\t\t * get_relation_info hook --- don't try to access them.\n\t\t */\n\t\tif (index->hypothetical)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The first index column must match the desired variable and sort\n\t\t * operator --- but we can use a descending-order index.\n\t\t */\n\t\tif (!match_index_to_operand(vardata->var, 0, index))\n\t\t\tcontinue;\n\t\tswitch (get_op_opfamily_strategy(sortop, index->sortopfamily[0]))\n\t\t{\n\t\t\tcase BTLessStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tcase BTGreaterStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* index doesn't match the sortop */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Found a suitable index to extract data from.  We'll need an EState\n\t\t * and a bunch of other infrastructure.\n\t\t */\n\t\t{\n\t\t\tEState\t   *estate;\n\t\t\tExprContext *econtext;\n\t\t\tMemoryContext tmpcontext;\n\t\t\tMemoryContext oldcontext;\n\t\t\tRelation\theapRel;\n\t\t\tRelation\tindexRel;\n\t\t\tIndexInfo  *indexInfo;\n\t\t\tTupleTableSlot *slot;\n\t\t\tint16\t\ttypLen;\n\t\t\tbool\t\ttypByVal;\n\t\t\tScanKeyData scankeys[1];\n\t\t\tIndexScanDesc index_scan;\n\t\t\tHeapTuple\ttup;\n\t\t\tDatum\t\tvalues[INDEX_MAX_KEYS];\n\t\t\tbool\t\tisnull[INDEX_MAX_KEYS];\n\t\t\tSnapshotData SnapshotNonVacuumable;\n\n\t\t\testate = CreateExecutorState();\n\t\t\tecontext = GetPerTupleExprContext(estate);\n\t\t\t/* Make sure any cruft is generated in the econtext's memory */\n\t\t\ttmpcontext = econtext->ecxt_per_tuple_memory;\n\t\t\toldcontext = MemoryContextSwitchTo(tmpcontext);\n\n\t\t\t/*\n\t\t\t * Open the table and index so we can read from them.  We should\n\t\t\t * already have at least AccessShareLock on the table, but not\n\t\t\t * necessarily on the index.\n\t\t\t */\n\t\t\theapRel = heap_open(rte->relid, NoLock);\n\t\t\tindexRel = index_open(index->indexoid, AccessShareLock);\n\n\t\t\t/* extract index key information from the index's pg_index info */\n\t\t\tindexInfo = BuildIndexInfo(indexRel);\n\n\t\t\t/* some other stuff */\n\t\t\tslot = MakeSingleTupleTableSlot(RelationGetDescr(heapRel));\n\t\t\tecontext->ecxt_scantuple = slot;\n\t\t\tget_typlenbyval(vardata->atttype, &typLen, &typByVal);\n\t\t\tInitNonVacuumableSnapshot(SnapshotNonVacuumable, RecentGlobalXmin);\n\n\t\t\t/* set up an IS NOT NULL scan key so that we ignore nulls */\n\t\t\tScanKeyEntryInitialize(&scankeys[0],\n\t\t\t\t\t\t\t\t   SK_ISNULL | SK_SEARCHNOTNULL,\n\t\t\t\t\t\t\t\t   1,\t/* index col to scan */\n\t\t\t\t\t\t\t\t   InvalidStrategy, /* no strategy */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no strategy subtype */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no collation */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no reg proc for this */\n\t\t\t\t\t\t\t\t   (Datum) 0);\t/* constant */\n\n\t\t\thave_data = true;\n\n\t\t\t/* If min is requested ... */\n\t\t\tif (min)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * In principle, we should scan the index with our current\n\t\t\t\t * active snapshot, which is the best approximation we've got\n\t\t\t\t * to what the query will see when executed.  But that won't\n\t\t\t\t * be exact if a new snap is taken before running the query,\n\t\t\t\t * and it can be very expensive if a lot of recently-dead or\n\t\t\t\t * uncommitted rows exist at the beginning or end of the index\n\t\t\t\t * (because we'll laboriously fetch each one and reject it).\n\t\t\t\t * Instead, we use SnapshotNonVacuumable.  That will accept\n\t\t\t\t * recently-dead and uncommitted rows as well as normal\n\t\t\t\t * visible rows.  On the other hand, it will reject known-dead\n\t\t\t\t * rows, and thus not give a bogus answer when the extreme\n\t\t\t\t * value has been deleted (unless the deletion was quite\n\t\t\t\t * recent); that case motivates not using SnapshotAny here.\n\t\t\t\t *\n\t\t\t\t * A crucial point here is that SnapshotNonVacuumable, with\n\t\t\t\t * RecentGlobalXmin as horizon, yields the inverse of the\n\t\t\t\t * condition that the indexscan will use to decide that index\n\t\t\t\t * entries are killable (see heap_hot_search_buffer()).\n\t\t\t\t * Therefore, if the snapshot rejects a tuple and we have to\n\t\t\t\t * continue scanning past it, we know that the indexscan will\n\t\t\t\t * mark that index entry killed.  That means that the next\n\t\t\t\t * get_actual_variable_range() call will not have to visit\n\t\t\t\t * that heap entry.  In this way we avoid repetitive work when\n\t\t\t\t * this function is used a lot during planning.\n\t\t\t\t */\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in sortop's direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*min = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* If max is requested, and we didn't find the index is empty */\n\t\t\tif (max && have_data)\n\t\t\t{\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in reverse direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t -indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*max = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* Clean everything up */\n\t\t\tExecDropSingleTupleTableSlot(slot);\n\n\t\t\tindex_close(indexRel, AccessShareLock);\n\t\t\theap_close(heapRel, NoLock);\n\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\tFreeExecutorState(estate);\n\n\t\t\t/* And we're done */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn have_data;\n}"
  },
  {
    "function_name": "get_variable_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "5329-5449",
    "snippet": "static bool\nget_variable_range(PlannerInfo *root, VariableStatData *vardata, Oid sortop,\n\t\t\t\t   Datum *min, Datum *max)\n{\n\tDatum\t\ttmin = 0;\n\tDatum\t\ttmax = 0;\n\tbool\t\thave_data = false;\n\tint16\t\ttypLen;\n\tbool\t\ttypByVal;\n\tOid\t\t\topfuncoid;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\t/*\n\t * XXX It's very tempting to try to use the actual column min and max, if\n\t * we can get them relatively-cheaply with an index probe.  However, since\n\t * this function is called many times during join planning, that could\n\t * have unpleasant effects on planning speed.  Need more investigation\n\t * before enabling this.\n\t */\n#ifdef NOT_USED\n\tif (get_actual_variable_range(root, vardata, sortop, min, max))\n\t\treturn true;\n#endif\n\n\tif (!HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* no stats available, so default result */\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we can't apply the sortop to the stats data, just fail.  In\n\t * principle, if there's a histogram and no MCVs, we could return the\n\t * histogram endpoints without ever applying the sortop ... but it's\n\t * probably not worth trying, because whatever the caller wants to do with\n\t * the endpoints would likely fail the security check too.\n\t */\n\tif (!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(sortop))))\n\t\treturn false;\n\n\tget_typlenbyval(vardata->atttype, &typLen, &typByVal);\n\n\t/*\n\t * If there is a histogram, grab the first and last values.\n\t *\n\t * If there is a histogram that is sorted with some other operator than\n\t * the one we want, fail --- this suggests that there is data we can't\n\t * use.\n\t */\n\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, sortop,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 0)\n\t\t{\n\t\t\ttmin = datumCopy(sslot.values[0], typByVal, typLen);\n\t\t\ttmax = datumCopy(sslot.values[sslot.nvalues - 1], typByVal, typLen);\n\t\t\thave_data = true;\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse if (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t  STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t  0))\n\t{\n\t\tfree_attstatsslot(&sslot);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we have most-common-values info, look for extreme MCVs.  This is\n\t * needed even if we also have a histogram, since the histogram excludes\n\t * the MCVs.  However, usually the MCVs will not be the extreme values, so\n\t * avoid unnecessary data copying.\n\t */\n\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tbool\t\ttmin_is_mcv = false;\n\t\tbool\t\ttmax_is_mcv = false;\n\t\tFmgrInfo\topproc;\n\n\t\tfmgr_info(opfuncoid, &opproc);\n\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (!have_data)\n\t\t\t{\n\t\t\t\ttmin = tmax = sslot.values[i];\n\t\t\t\ttmin_is_mcv = tmax_is_mcv = have_data = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (DatumGetBool(FunctionCall2Coll(&opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i], tmin)))\n\t\t\t{\n\t\t\t\ttmin = sslot.values[i];\n\t\t\t\ttmin_is_mcv = true;\n\t\t\t}\n\t\t\tif (DatumGetBool(FunctionCall2Coll(&opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   tmax, sslot.values[i])))\n\t\t\t{\n\t\t\t\ttmax = sslot.values[i];\n\t\t\t\ttmax_is_mcv = true;\n\t\t\t}\n\t\t}\n\t\tif (tmin_is_mcv)\n\t\t\ttmin = datumCopy(tmin, typByVal, typLen);\n\t\tif (tmax_is_mcv)\n\t\t\ttmax = datumCopy(tmax, typByVal, typLen);\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*min = tmin;\n\t*max = tmax;\n\treturn have_data;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
      "static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);",
      "static bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 5443
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "tmax",
            "typByVal",
            "typLen"
          ],
          "line": 5442
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(&opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   tmax, sslot.values[i])"
          ],
          "line": 5431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&opproc",
            "DEFAULT_COLLATION_OID",
            "tmax",
            "sslot.values[i]"
          ],
          "line": 5431
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(&opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i], tmin)"
          ],
          "line": 5424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "opfuncoid",
            "&opproc"
          ],
          "line": 5414
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot",
            "vardata->statsTuple",
            "STATISTIC_KIND_MCV",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES"
          ],
          "line": 5406
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyval",
          "args": [
            "vardata->atttype",
            "&typLen",
            "&typByVal"
          ],
          "line": 5371
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2028-2041",
          "snippet": "void\nget_typlenbyval(Oid typid, int16 *typlen, bool *typbyval)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyval(Oid typid, int16 *typlen, bool *typbyval)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "statistic_proc_security_check",
          "args": [
            "vardata",
            "(opfuncoid = get_opcode(sortop))"
          ],
          "line": 5367
        },
        "resolved": true,
        "details": {
          "function_name": "statistic_proc_security_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5167-5183",
          "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "sortop"
          ],
          "line": 5368
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 5354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_actual_variable_range",
          "args": [
            "root",
            "vardata",
            "sortop",
            "min",
            "max"
          ],
          "line": 5350
        },
        "resolved": true,
        "details": {
          "function_name": "get_actual_variable_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5463-5693",
          "snippet": "static bool\nget_actual_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max)\n{\n\tbool\t\thave_data = false;\n\tRelOptInfo *rel = vardata->rel;\n\tRangeTblEntry *rte;\n\tListCell   *lc;\n\n\t/* No hope if no relation or it doesn't have indexes */\n\tif (rel == NULL || rel->indexlist == NIL)\n\t\treturn false;\n\t/* If it has indexes it must be a plain relation */\n\trte = root->simple_rte_array[rel->relid];\n\tAssert(rte->rtekind == RTE_RELATION);\n\n\t/* Search through the indexes to see if any match our problem */\n\tforeach(lc, rel->indexlist)\n\t{\n\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(lc);\n\t\tScanDirection indexscandir;\n\n\t\t/* Ignore non-btree indexes */\n\t\tif (index->relam != BTREE_AM_OID)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore partial indexes --- we only want stats that cover the entire\n\t\t * relation.\n\t\t */\n\t\tif (index->indpred != NIL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The index list might include hypothetical indexes inserted by a\n\t\t * get_relation_info hook --- don't try to access them.\n\t\t */\n\t\tif (index->hypothetical)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The first index column must match the desired variable and sort\n\t\t * operator --- but we can use a descending-order index.\n\t\t */\n\t\tif (!match_index_to_operand(vardata->var, 0, index))\n\t\t\tcontinue;\n\t\tswitch (get_op_opfamily_strategy(sortop, index->sortopfamily[0]))\n\t\t{\n\t\t\tcase BTLessStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tcase BTGreaterStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* index doesn't match the sortop */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Found a suitable index to extract data from.  We'll need an EState\n\t\t * and a bunch of other infrastructure.\n\t\t */\n\t\t{\n\t\t\tEState\t   *estate;\n\t\t\tExprContext *econtext;\n\t\t\tMemoryContext tmpcontext;\n\t\t\tMemoryContext oldcontext;\n\t\t\tRelation\theapRel;\n\t\t\tRelation\tindexRel;\n\t\t\tIndexInfo  *indexInfo;\n\t\t\tTupleTableSlot *slot;\n\t\t\tint16\t\ttypLen;\n\t\t\tbool\t\ttypByVal;\n\t\t\tScanKeyData scankeys[1];\n\t\t\tIndexScanDesc index_scan;\n\t\t\tHeapTuple\ttup;\n\t\t\tDatum\t\tvalues[INDEX_MAX_KEYS];\n\t\t\tbool\t\tisnull[INDEX_MAX_KEYS];\n\t\t\tSnapshotData SnapshotNonVacuumable;\n\n\t\t\testate = CreateExecutorState();\n\t\t\tecontext = GetPerTupleExprContext(estate);\n\t\t\t/* Make sure any cruft is generated in the econtext's memory */\n\t\t\ttmpcontext = econtext->ecxt_per_tuple_memory;\n\t\t\toldcontext = MemoryContextSwitchTo(tmpcontext);\n\n\t\t\t/*\n\t\t\t * Open the table and index so we can read from them.  We should\n\t\t\t * already have at least AccessShareLock on the table, but not\n\t\t\t * necessarily on the index.\n\t\t\t */\n\t\t\theapRel = heap_open(rte->relid, NoLock);\n\t\t\tindexRel = index_open(index->indexoid, AccessShareLock);\n\n\t\t\t/* extract index key information from the index's pg_index info */\n\t\t\tindexInfo = BuildIndexInfo(indexRel);\n\n\t\t\t/* some other stuff */\n\t\t\tslot = MakeSingleTupleTableSlot(RelationGetDescr(heapRel));\n\t\t\tecontext->ecxt_scantuple = slot;\n\t\t\tget_typlenbyval(vardata->atttype, &typLen, &typByVal);\n\t\t\tInitNonVacuumableSnapshot(SnapshotNonVacuumable, RecentGlobalXmin);\n\n\t\t\t/* set up an IS NOT NULL scan key so that we ignore nulls */\n\t\t\tScanKeyEntryInitialize(&scankeys[0],\n\t\t\t\t\t\t\t\t   SK_ISNULL | SK_SEARCHNOTNULL,\n\t\t\t\t\t\t\t\t   1,\t/* index col to scan */\n\t\t\t\t\t\t\t\t   InvalidStrategy, /* no strategy */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no strategy subtype */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no collation */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no reg proc for this */\n\t\t\t\t\t\t\t\t   (Datum) 0);\t/* constant */\n\n\t\t\thave_data = true;\n\n\t\t\t/* If min is requested ... */\n\t\t\tif (min)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * In principle, we should scan the index with our current\n\t\t\t\t * active snapshot, which is the best approximation we've got\n\t\t\t\t * to what the query will see when executed.  But that won't\n\t\t\t\t * be exact if a new snap is taken before running the query,\n\t\t\t\t * and it can be very expensive if a lot of recently-dead or\n\t\t\t\t * uncommitted rows exist at the beginning or end of the index\n\t\t\t\t * (because we'll laboriously fetch each one and reject it).\n\t\t\t\t * Instead, we use SnapshotNonVacuumable.  That will accept\n\t\t\t\t * recently-dead and uncommitted rows as well as normal\n\t\t\t\t * visible rows.  On the other hand, it will reject known-dead\n\t\t\t\t * rows, and thus not give a bogus answer when the extreme\n\t\t\t\t * value has been deleted (unless the deletion was quite\n\t\t\t\t * recent); that case motivates not using SnapshotAny here.\n\t\t\t\t *\n\t\t\t\t * A crucial point here is that SnapshotNonVacuumable, with\n\t\t\t\t * RecentGlobalXmin as horizon, yields the inverse of the\n\t\t\t\t * condition that the indexscan will use to decide that index\n\t\t\t\t * entries are killable (see heap_hot_search_buffer()).\n\t\t\t\t * Therefore, if the snapshot rejects a tuple and we have to\n\t\t\t\t * continue scanning past it, we know that the indexscan will\n\t\t\t\t * mark that index entry killed.  That means that the next\n\t\t\t\t * get_actual_variable_range() call will not have to visit\n\t\t\t\t * that heap entry.  In this way we avoid repetitive work when\n\t\t\t\t * this function is used a lot during planning.\n\t\t\t\t */\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in sortop's direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*min = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* If max is requested, and we didn't find the index is empty */\n\t\t\tif (max && have_data)\n\t\t\t{\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in reverse direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t -indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*max = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* Clean everything up */\n\t\t\tExecDropSingleTupleTableSlot(slot);\n\n\t\t\tindex_close(indexRel, AccessShareLock);\n\t\t\theap_close(heapRel, NoLock);\n\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\tFreeExecutorState(estate);\n\n\t\t\t/* And we're done */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn have_data;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
            "static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);",
            "static bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);\nstatic bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);\n\nstatic bool\nget_actual_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max)\n{\n\tbool\t\thave_data = false;\n\tRelOptInfo *rel = vardata->rel;\n\tRangeTblEntry *rte;\n\tListCell   *lc;\n\n\t/* No hope if no relation or it doesn't have indexes */\n\tif (rel == NULL || rel->indexlist == NIL)\n\t\treturn false;\n\t/* If it has indexes it must be a plain relation */\n\trte = root->simple_rte_array[rel->relid];\n\tAssert(rte->rtekind == RTE_RELATION);\n\n\t/* Search through the indexes to see if any match our problem */\n\tforeach(lc, rel->indexlist)\n\t{\n\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(lc);\n\t\tScanDirection indexscandir;\n\n\t\t/* Ignore non-btree indexes */\n\t\tif (index->relam != BTREE_AM_OID)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore partial indexes --- we only want stats that cover the entire\n\t\t * relation.\n\t\t */\n\t\tif (index->indpred != NIL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The index list might include hypothetical indexes inserted by a\n\t\t * get_relation_info hook --- don't try to access them.\n\t\t */\n\t\tif (index->hypothetical)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The first index column must match the desired variable and sort\n\t\t * operator --- but we can use a descending-order index.\n\t\t */\n\t\tif (!match_index_to_operand(vardata->var, 0, index))\n\t\t\tcontinue;\n\t\tswitch (get_op_opfamily_strategy(sortop, index->sortopfamily[0]))\n\t\t{\n\t\t\tcase BTLessStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tcase BTGreaterStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* index doesn't match the sortop */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Found a suitable index to extract data from.  We'll need an EState\n\t\t * and a bunch of other infrastructure.\n\t\t */\n\t\t{\n\t\t\tEState\t   *estate;\n\t\t\tExprContext *econtext;\n\t\t\tMemoryContext tmpcontext;\n\t\t\tMemoryContext oldcontext;\n\t\t\tRelation\theapRel;\n\t\t\tRelation\tindexRel;\n\t\t\tIndexInfo  *indexInfo;\n\t\t\tTupleTableSlot *slot;\n\t\t\tint16\t\ttypLen;\n\t\t\tbool\t\ttypByVal;\n\t\t\tScanKeyData scankeys[1];\n\t\t\tIndexScanDesc index_scan;\n\t\t\tHeapTuple\ttup;\n\t\t\tDatum\t\tvalues[INDEX_MAX_KEYS];\n\t\t\tbool\t\tisnull[INDEX_MAX_KEYS];\n\t\t\tSnapshotData SnapshotNonVacuumable;\n\n\t\t\testate = CreateExecutorState();\n\t\t\tecontext = GetPerTupleExprContext(estate);\n\t\t\t/* Make sure any cruft is generated in the econtext's memory */\n\t\t\ttmpcontext = econtext->ecxt_per_tuple_memory;\n\t\t\toldcontext = MemoryContextSwitchTo(tmpcontext);\n\n\t\t\t/*\n\t\t\t * Open the table and index so we can read from them.  We should\n\t\t\t * already have at least AccessShareLock on the table, but not\n\t\t\t * necessarily on the index.\n\t\t\t */\n\t\t\theapRel = heap_open(rte->relid, NoLock);\n\t\t\tindexRel = index_open(index->indexoid, AccessShareLock);\n\n\t\t\t/* extract index key information from the index's pg_index info */\n\t\t\tindexInfo = BuildIndexInfo(indexRel);\n\n\t\t\t/* some other stuff */\n\t\t\tslot = MakeSingleTupleTableSlot(RelationGetDescr(heapRel));\n\t\t\tecontext->ecxt_scantuple = slot;\n\t\t\tget_typlenbyval(vardata->atttype, &typLen, &typByVal);\n\t\t\tInitNonVacuumableSnapshot(SnapshotNonVacuumable, RecentGlobalXmin);\n\n\t\t\t/* set up an IS NOT NULL scan key so that we ignore nulls */\n\t\t\tScanKeyEntryInitialize(&scankeys[0],\n\t\t\t\t\t\t\t\t   SK_ISNULL | SK_SEARCHNOTNULL,\n\t\t\t\t\t\t\t\t   1,\t/* index col to scan */\n\t\t\t\t\t\t\t\t   InvalidStrategy, /* no strategy */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no strategy subtype */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no collation */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no reg proc for this */\n\t\t\t\t\t\t\t\t   (Datum) 0);\t/* constant */\n\n\t\t\thave_data = true;\n\n\t\t\t/* If min is requested ... */\n\t\t\tif (min)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * In principle, we should scan the index with our current\n\t\t\t\t * active snapshot, which is the best approximation we've got\n\t\t\t\t * to what the query will see when executed.  But that won't\n\t\t\t\t * be exact if a new snap is taken before running the query,\n\t\t\t\t * and it can be very expensive if a lot of recently-dead or\n\t\t\t\t * uncommitted rows exist at the beginning or end of the index\n\t\t\t\t * (because we'll laboriously fetch each one and reject it).\n\t\t\t\t * Instead, we use SnapshotNonVacuumable.  That will accept\n\t\t\t\t * recently-dead and uncommitted rows as well as normal\n\t\t\t\t * visible rows.  On the other hand, it will reject known-dead\n\t\t\t\t * rows, and thus not give a bogus answer when the extreme\n\t\t\t\t * value has been deleted (unless the deletion was quite\n\t\t\t\t * recent); that case motivates not using SnapshotAny here.\n\t\t\t\t *\n\t\t\t\t * A crucial point here is that SnapshotNonVacuumable, with\n\t\t\t\t * RecentGlobalXmin as horizon, yields the inverse of the\n\t\t\t\t * condition that the indexscan will use to decide that index\n\t\t\t\t * entries are killable (see heap_hot_search_buffer()).\n\t\t\t\t * Therefore, if the snapshot rejects a tuple and we have to\n\t\t\t\t * continue scanning past it, we know that the indexscan will\n\t\t\t\t * mark that index entry killed.  That means that the next\n\t\t\t\t * get_actual_variable_range() call will not have to visit\n\t\t\t\t * that heap entry.  In this way we avoid repetitive work when\n\t\t\t\t * this function is used a lot during planning.\n\t\t\t\t */\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in sortop's direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*min = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* If max is requested, and we didn't find the index is empty */\n\t\t\tif (max && have_data)\n\t\t\t{\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in reverse direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t -indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*max = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* Clean everything up */\n\t\t\tExecDropSingleTupleTableSlot(slot);\n\n\t\t\tindex_close(indexRel, AccessShareLock);\n\t\t\theap_close(heapRel, NoLock);\n\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\tFreeExecutorState(estate);\n\n\t\t\t/* And we're done */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn have_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);\nstatic bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);\n\nstatic bool\nget_variable_range(PlannerInfo *root, VariableStatData *vardata, Oid sortop,\n\t\t\t\t   Datum *min, Datum *max)\n{\n\tDatum\t\ttmin = 0;\n\tDatum\t\ttmax = 0;\n\tbool\t\thave_data = false;\n\tint16\t\ttypLen;\n\tbool\t\ttypByVal;\n\tOid\t\t\topfuncoid;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\t/*\n\t * XXX It's very tempting to try to use the actual column min and max, if\n\t * we can get them relatively-cheaply with an index probe.  However, since\n\t * this function is called many times during join planning, that could\n\t * have unpleasant effects on planning speed.  Need more investigation\n\t * before enabling this.\n\t */\n#ifdef NOT_USED\n\tif (get_actual_variable_range(root, vardata, sortop, min, max))\n\t\treturn true;\n#endif\n\n\tif (!HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* no stats available, so default result */\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we can't apply the sortop to the stats data, just fail.  In\n\t * principle, if there's a histogram and no MCVs, we could return the\n\t * histogram endpoints without ever applying the sortop ... but it's\n\t * probably not worth trying, because whatever the caller wants to do with\n\t * the endpoints would likely fail the security check too.\n\t */\n\tif (!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(sortop))))\n\t\treturn false;\n\n\tget_typlenbyval(vardata->atttype, &typLen, &typByVal);\n\n\t/*\n\t * If there is a histogram, grab the first and last values.\n\t *\n\t * If there is a histogram that is sorted with some other operator than\n\t * the one we want, fail --- this suggests that there is data we can't\n\t * use.\n\t */\n\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, sortop,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 0)\n\t\t{\n\t\t\ttmin = datumCopy(sslot.values[0], typByVal, typLen);\n\t\t\ttmax = datumCopy(sslot.values[sslot.nvalues - 1], typByVal, typLen);\n\t\t\thave_data = true;\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse if (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t  STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t  0))\n\t{\n\t\tfree_attstatsslot(&sslot);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we have most-common-values info, look for extreme MCVs.  This is\n\t * needed even if we also have a histogram, since the histogram excludes\n\t * the MCVs.  However, usually the MCVs will not be the extreme values, so\n\t * avoid unnecessary data copying.\n\t */\n\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tbool\t\ttmin_is_mcv = false;\n\t\tbool\t\ttmax_is_mcv = false;\n\t\tFmgrInfo\topproc;\n\n\t\tfmgr_info(opfuncoid, &opproc);\n\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (!have_data)\n\t\t\t{\n\t\t\t\ttmin = tmax = sslot.values[i];\n\t\t\t\ttmin_is_mcv = tmax_is_mcv = have_data = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (DatumGetBool(FunctionCall2Coll(&opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i], tmin)))\n\t\t\t{\n\t\t\t\ttmin = sslot.values[i];\n\t\t\t\ttmin_is_mcv = true;\n\t\t\t}\n\t\t\tif (DatumGetBool(FunctionCall2Coll(&opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   tmax, sslot.values[i])))\n\t\t\t{\n\t\t\t\ttmax = sslot.values[i];\n\t\t\t\ttmax_is_mcv = true;\n\t\t\t}\n\t\t}\n\t\tif (tmin_is_mcv)\n\t\t\ttmin = datumCopy(tmin, typByVal, typLen);\n\t\tif (tmax_is_mcv)\n\t\t\ttmax = datumCopy(tmax, typByVal, typLen);\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*min = tmin;\n\t*max = tmax;\n\treturn have_data;\n}"
  },
  {
    "function_name": "get_variable_numdistinct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "5196-5318",
    "snippet": "double\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clamp_row_est",
          "args": [
            "ntuples"
          ],
          "line": 5314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_row_est",
          "args": [
            "-stadistinct * ntuples"
          ],
          "line": 5306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_row_est",
          "args": [
            "stadistinct"
          ],
          "line": 5285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "vardata->var",
            "Var"
          ],
          "line": 5247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 5216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 5211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}"
  },
  {
    "function_name": "statistic_proc_security_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "5167-5183",
    "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "DEBUG2",
            "(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid)))"
          ],
          "line": 5179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg_internal",
          "args": [
            "\"not using statistics because function \\\"%s\\\" is not leak-proof\"",
            "get_func_name(func_oid)"
          ],
          "line": 5180
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_func_name",
          "args": [
            "func_oid"
          ],
          "line": 5181
        },
        "resolved": true,
        "details": {
          "function_name": "get_func_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1420-1437",
          "snippet": "Oid\nget_func_namespace(Oid funcid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_proc functup = (Form_pg_proc) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = functup->pronamespace;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_func_namespace(Oid funcid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_proc functup = (Form_pg_proc) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = functup->pronamespace;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_func_leakproof",
          "args": [
            "func_oid"
          ],
          "line": 5176
        },
        "resolved": true,
        "details": {
          "function_name": "get_func_leakproof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1625-1638",
          "snippet": "bool\nget_func_leakproof(Oid funcid)\n{\n\tHeapTuple\ttp;\n\tbool\t\tresult;\n\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\n\tresult = ((Form_pg_proc) GETSTRUCT(tp))->proleakproof;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_func_leakproof(Oid funcid)\n{\n\tHeapTuple\ttp;\n\tbool\t\tresult;\n\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\n\tresult = ((Form_pg_proc) GETSTRUCT(tp))->proleakproof;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "func_oid"
          ],
          "line": 5173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
  },
  {
    "function_name": "examine_simple_variable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4995-5159",
    "snippet": "static void\nexamine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata)\n{\n\tRangeTblEntry *rte = root->simple_rte_array[var->varno];\n\n\tAssert(IsA(rte, RangeTblEntry));\n\n\tif (get_relation_stats_hook &&\n\t\t(*get_relation_stats_hook) (root, rte, var->varattno, vardata))\n\t{\n\t\t/*\n\t\t * The hook took control of acquiring a stats tuple.  If it did supply\n\t\t * a tuple, it'd better have supplied a freefunc.\n\t\t */\n\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t!vardata->freefunc)\n\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t}\n\telse if (rte->rtekind == RTE_RELATION)\n\t{\n\t\t/*\n\t\t * Plain table or parent of an inheritance appendrel, so look up the\n\t\t * column in pg_statistic\n\t\t */\n\t\tvardata->statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(var->varattno),\n\t\t\t\t\t\t\t\t\t\t\t  BoolGetDatum(rte->inh));\n\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t{\n\t\t\t/*\n\t\t\t * Check if user has permission to read this column.  We require\n\t\t\t * all rows to be accessible, so there must be no securityQuals\n\t\t\t * from security barrier views or RLS policies.\n\t\t\t */\n\t\t\tvardata->acl_ok =\n\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t((pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK) ||\n\t\t\t\t (pg_attribute_aclcheck(rte->relid, var->varattno, GetUserId(),\n\t\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* suppress any possible leakproofness checks later */\n\t\t\tvardata->acl_ok = true;\n\t\t}\n\t}\n\telse if (rte->rtekind == RTE_SUBQUERY && !rte->inh)\n\t{\n\t\t/*\n\t\t * Plain subquery (not one that was converted to an appendrel).\n\t\t */\n\t\tQuery\t   *subquery = rte->subquery;\n\t\tRelOptInfo *rel;\n\t\tTargetEntry *ste;\n\n\t\t/*\n\t\t * Punt if it's a whole-row var rather than a plain column reference.\n\t\t */\n\t\tif (var->varattno == InvalidAttrNumber)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Punt if subquery uses set operations or GROUP BY, as these will\n\t\t * mash underlying columns' stats beyond recognition.  (Set ops are\n\t\t * particularly nasty; if we forged ahead, we would return stats\n\t\t * relevant to only the leftmost subselect...)\tDISTINCT is also\n\t\t * problematic, but we check that later because there is a possibility\n\t\t * of learning something even with it.\n\t\t */\n\t\tif (subquery->setOperations ||\n\t\t\tsubquery->groupClause)\n\t\t\treturn;\n\n\t\t/*\n\t\t * OK, fetch RelOptInfo for subquery.  Note that we don't change the\n\t\t * rel returned in vardata, since caller expects it to be a rel of the\n\t\t * caller's query level.  Because we might already be recursing, we\n\t\t * can't use that rel pointer either, but have to look up the Var's\n\t\t * rel afresh.\n\t\t */\n\t\trel = find_base_rel(root, var->varno);\n\n\t\t/* If the subquery hasn't been planned yet, we have to punt */\n\t\tif (rel->subroot == NULL)\n\t\t\treturn;\n\t\tAssert(IsA(rel->subroot, PlannerInfo));\n\n\t\t/*\n\t\t * Switch our attention to the subquery as mangled by the planner. It\n\t\t * was okay to look at the pre-planning version for the tests above,\n\t\t * but now we need a Var that will refer to the subroot's live\n\t\t * RelOptInfos.  For instance, if any subquery pullup happened during\n\t\t * planning, Vars in the targetlist might have gotten replaced, and we\n\t\t * need to see the replacement expressions.\n\t\t */\n\t\tsubquery = rel->subroot->parse;\n\t\tAssert(IsA(subquery, Query));\n\n\t\t/* Get the subquery output expression referenced by the upper Var */\n\t\tste = get_tle_by_resno(subquery->targetList, var->varattno);\n\t\tif (ste == NULL || ste->resjunk)\n\t\t\telog(ERROR, \"subquery %s does not have attribute %d\",\n\t\t\t\t rte->eref->aliasname, var->varattno);\n\t\tvar = (Var *) ste->expr;\n\n\t\t/*\n\t\t * If subquery uses DISTINCT, we can't make use of any stats for the\n\t\t * variable ... but, if it's the only DISTINCT column, we are entitled\n\t\t * to consider it unique.  We do the test this way so that it works\n\t\t * for cases involving DISTINCT ON.\n\t\t */\n\t\tif (subquery->distinctClause)\n\t\t{\n\t\t\tif (list_length(subquery->distinctClause) == 1 &&\n\t\t\t\ttargetIsInSortList(ste, InvalidOid, subquery->distinctClause))\n\t\t\t\tvardata->isunique = true;\n\t\t\t/* cannot go further */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the sub-query originated from a view with the security_barrier\n\t\t * attribute, we must not look at the variable's statistics, though it\n\t\t * seems all right to notice the existence of a DISTINCT clause. So\n\t\t * stop here.\n\t\t *\n\t\t * This is probably a harsher restriction than necessary; it's\n\t\t * certainly OK for the selectivity estimator (which is a C function,\n\t\t * and therefore omnipotent anyway) to look at the statistics.  But\n\t\t * many selectivity estimators will happily *invoke the operator\n\t\t * function* to try to work out a good estimate - and that's not OK.\n\t\t * So for now, don't dig down for stats.\n\t\t */\n\t\tif (rte->security_barrier)\n\t\t\treturn;\n\n\t\t/* Can only handle a simple Var of subquery's query level */\n\t\tif (var && IsA(var, Var) &&\n\t\t\tvar->varlevelsup == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * OK, recurse into the subquery.  Note that the original setting\n\t\t\t * of vardata->isunique (which will surely be false) is left\n\t\t\t * unchanged in this situation.  That's what we want, since even\n\t\t\t * if the underlying column is unique, the subquery may have\n\t\t\t * joined to other tables in a way that creates duplicates.\n\t\t\t */\n\t\t\texamine_simple_variable(rel->subroot, var, vardata);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We\n\t\t * won't see RTE_JOIN here because join alias Vars have already been\n\t\t * flattened.)\tThere's not much we can do with function outputs, but\n\t\t * maybe someday try to be smarter about VALUES and/or CTEs.\n\t\t */\n\t}\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "get_relation_stats_hook_type get_relation_stats_hook = NULL;",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "examine_simple_variable",
          "args": [
            "rel->subroot",
            "var",
            "vardata"
          ],
          "line": 5147
        },
        "resolved": true,
        "details": {
          "function_name": "examine_simple_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4995-5159",
          "snippet": "static void\nexamine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata)\n{\n\tRangeTblEntry *rte = root->simple_rte_array[var->varno];\n\n\tAssert(IsA(rte, RangeTblEntry));\n\n\tif (get_relation_stats_hook &&\n\t\t(*get_relation_stats_hook) (root, rte, var->varattno, vardata))\n\t{\n\t\t/*\n\t\t * The hook took control of acquiring a stats tuple.  If it did supply\n\t\t * a tuple, it'd better have supplied a freefunc.\n\t\t */\n\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t!vardata->freefunc)\n\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t}\n\telse if (rte->rtekind == RTE_RELATION)\n\t{\n\t\t/*\n\t\t * Plain table or parent of an inheritance appendrel, so look up the\n\t\t * column in pg_statistic\n\t\t */\n\t\tvardata->statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(var->varattno),\n\t\t\t\t\t\t\t\t\t\t\t  BoolGetDatum(rte->inh));\n\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t{\n\t\t\t/*\n\t\t\t * Check if user has permission to read this column.  We require\n\t\t\t * all rows to be accessible, so there must be no securityQuals\n\t\t\t * from security barrier views or RLS policies.\n\t\t\t */\n\t\t\tvardata->acl_ok =\n\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t((pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK) ||\n\t\t\t\t (pg_attribute_aclcheck(rte->relid, var->varattno, GetUserId(),\n\t\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* suppress any possible leakproofness checks later */\n\t\t\tvardata->acl_ok = true;\n\t\t}\n\t}\n\telse if (rte->rtekind == RTE_SUBQUERY && !rte->inh)\n\t{\n\t\t/*\n\t\t * Plain subquery (not one that was converted to an appendrel).\n\t\t */\n\t\tQuery\t   *subquery = rte->subquery;\n\t\tRelOptInfo *rel;\n\t\tTargetEntry *ste;\n\n\t\t/*\n\t\t * Punt if it's a whole-row var rather than a plain column reference.\n\t\t */\n\t\tif (var->varattno == InvalidAttrNumber)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Punt if subquery uses set operations or GROUP BY, as these will\n\t\t * mash underlying columns' stats beyond recognition.  (Set ops are\n\t\t * particularly nasty; if we forged ahead, we would return stats\n\t\t * relevant to only the leftmost subselect...)\tDISTINCT is also\n\t\t * problematic, but we check that later because there is a possibility\n\t\t * of learning something even with it.\n\t\t */\n\t\tif (subquery->setOperations ||\n\t\t\tsubquery->groupClause)\n\t\t\treturn;\n\n\t\t/*\n\t\t * OK, fetch RelOptInfo for subquery.  Note that we don't change the\n\t\t * rel returned in vardata, since caller expects it to be a rel of the\n\t\t * caller's query level.  Because we might already be recursing, we\n\t\t * can't use that rel pointer either, but have to look up the Var's\n\t\t * rel afresh.\n\t\t */\n\t\trel = find_base_rel(root, var->varno);\n\n\t\t/* If the subquery hasn't been planned yet, we have to punt */\n\t\tif (rel->subroot == NULL)\n\t\t\treturn;\n\t\tAssert(IsA(rel->subroot, PlannerInfo));\n\n\t\t/*\n\t\t * Switch our attention to the subquery as mangled by the planner. It\n\t\t * was okay to look at the pre-planning version for the tests above,\n\t\t * but now we need a Var that will refer to the subroot's live\n\t\t * RelOptInfos.  For instance, if any subquery pullup happened during\n\t\t * planning, Vars in the targetlist might have gotten replaced, and we\n\t\t * need to see the replacement expressions.\n\t\t */\n\t\tsubquery = rel->subroot->parse;\n\t\tAssert(IsA(subquery, Query));\n\n\t\t/* Get the subquery output expression referenced by the upper Var */\n\t\tste = get_tle_by_resno(subquery->targetList, var->varattno);\n\t\tif (ste == NULL || ste->resjunk)\n\t\t\telog(ERROR, \"subquery %s does not have attribute %d\",\n\t\t\t\t rte->eref->aliasname, var->varattno);\n\t\tvar = (Var *) ste->expr;\n\n\t\t/*\n\t\t * If subquery uses DISTINCT, we can't make use of any stats for the\n\t\t * variable ... but, if it's the only DISTINCT column, we are entitled\n\t\t * to consider it unique.  We do the test this way so that it works\n\t\t * for cases involving DISTINCT ON.\n\t\t */\n\t\tif (subquery->distinctClause)\n\t\t{\n\t\t\tif (list_length(subquery->distinctClause) == 1 &&\n\t\t\t\ttargetIsInSortList(ste, InvalidOid, subquery->distinctClause))\n\t\t\t\tvardata->isunique = true;\n\t\t\t/* cannot go further */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the sub-query originated from a view with the security_barrier\n\t\t * attribute, we must not look at the variable's statistics, though it\n\t\t * seems all right to notice the existence of a DISTINCT clause. So\n\t\t * stop here.\n\t\t *\n\t\t * This is probably a harsher restriction than necessary; it's\n\t\t * certainly OK for the selectivity estimator (which is a C function,\n\t\t * and therefore omnipotent anyway) to look at the statistics.  But\n\t\t * many selectivity estimators will happily *invoke the operator\n\t\t * function* to try to work out a good estimate - and that's not OK.\n\t\t * So for now, don't dig down for stats.\n\t\t */\n\t\tif (rte->security_barrier)\n\t\t\treturn;\n\n\t\t/* Can only handle a simple Var of subquery's query level */\n\t\tif (var && IsA(var, Var) &&\n\t\t\tvar->varlevelsup == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * OK, recurse into the subquery.  Note that the original setting\n\t\t\t * of vardata->isunique (which will surely be false) is left\n\t\t\t * unchanged in this situation.  That's what we want, since even\n\t\t\t * if the underlying column is unique, the subquery may have\n\t\t\t * joined to other tables in a way that creates duplicates.\n\t\t\t */\n\t\t\texamine_simple_variable(rel->subroot, var, vardata);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We\n\t\t * won't see RTE_JOIN here because join alias Vars have already been\n\t\t * flattened.)\tThere's not much we can do with function outputs, but\n\t\t * maybe someday try to be smarter about VALUES and/or CTEs.\n\t\t */\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "var",
            "Var"
          ],
          "line": 5137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "targetIsInSortList",
          "args": [
            "ste",
            "InvalidOid",
            "subquery->distinctClause"
          ],
          "line": 5114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "subquery->distinctClause"
          ],
          "line": 5113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"subquery %s does not have attribute %d\"",
            "rte->eref->aliasname",
            "var->varattno"
          ],
          "line": 5101
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tle_by_resno",
          "args": [
            "subquery->targetList",
            "var->varattno"
          ],
          "line": 5099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IsA(subquery, Query)"
          ],
          "line": 5096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "subquery",
            "Query"
          ],
          "line": 5096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IsA(rel->subroot, PlannerInfo)"
          ],
          "line": 5085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rel->subroot",
            "PlannerInfo"
          ],
          "line": 5085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_base_rel",
          "args": [
            "root",
            "var->varno"
          ],
          "line": 5080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_attribute_aclcheck",
          "args": [
            "rte->relid",
            "var->varattno",
            "GetUserId()",
            "ACL_SELECT"
          ],
          "line": 5037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 5037
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_class_aclcheck",
          "args": [
            "rte->relid",
            "GetUserId()",
            "ACL_SELECT"
          ],
          "line": 5035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache3",
          "args": [
            "STATRELATTINH",
            "ObjectIdGetDatum(rte->relid)",
            "Int16GetDatum(var->varattno)",
            "BoolGetDatum(rte->inh)"
          ],
          "line": 5020
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1133-1142",
          "snippet": "HeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "rte->inh"
          ],
          "line": 5023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "var->varattno"
          ],
          "line": 5022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "rte->relid"
          ],
          "line": 5021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 5010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "root",
            "rte",
            "var->varattno",
            "vardata"
          ],
          "line": 5004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IsA(rte, RangeTblEntry)"
          ],
          "line": 5001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rte",
            "RangeTblEntry"
          ],
          "line": 5001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_relation_stats_hook_type get_relation_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic void\nexamine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata)\n{\n\tRangeTblEntry *rte = root->simple_rte_array[var->varno];\n\n\tAssert(IsA(rte, RangeTblEntry));\n\n\tif (get_relation_stats_hook &&\n\t\t(*get_relation_stats_hook) (root, rte, var->varattno, vardata))\n\t{\n\t\t/*\n\t\t * The hook took control of acquiring a stats tuple.  If it did supply\n\t\t * a tuple, it'd better have supplied a freefunc.\n\t\t */\n\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t!vardata->freefunc)\n\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t}\n\telse if (rte->rtekind == RTE_RELATION)\n\t{\n\t\t/*\n\t\t * Plain table or parent of an inheritance appendrel, so look up the\n\t\t * column in pg_statistic\n\t\t */\n\t\tvardata->statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(var->varattno),\n\t\t\t\t\t\t\t\t\t\t\t  BoolGetDatum(rte->inh));\n\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t{\n\t\t\t/*\n\t\t\t * Check if user has permission to read this column.  We require\n\t\t\t * all rows to be accessible, so there must be no securityQuals\n\t\t\t * from security barrier views or RLS policies.\n\t\t\t */\n\t\t\tvardata->acl_ok =\n\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t((pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK) ||\n\t\t\t\t (pg_attribute_aclcheck(rte->relid, var->varattno, GetUserId(),\n\t\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* suppress any possible leakproofness checks later */\n\t\t\tvardata->acl_ok = true;\n\t\t}\n\t}\n\telse if (rte->rtekind == RTE_SUBQUERY && !rte->inh)\n\t{\n\t\t/*\n\t\t * Plain subquery (not one that was converted to an appendrel).\n\t\t */\n\t\tQuery\t   *subquery = rte->subquery;\n\t\tRelOptInfo *rel;\n\t\tTargetEntry *ste;\n\n\t\t/*\n\t\t * Punt if it's a whole-row var rather than a plain column reference.\n\t\t */\n\t\tif (var->varattno == InvalidAttrNumber)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Punt if subquery uses set operations or GROUP BY, as these will\n\t\t * mash underlying columns' stats beyond recognition.  (Set ops are\n\t\t * particularly nasty; if we forged ahead, we would return stats\n\t\t * relevant to only the leftmost subselect...)\tDISTINCT is also\n\t\t * problematic, but we check that later because there is a possibility\n\t\t * of learning something even with it.\n\t\t */\n\t\tif (subquery->setOperations ||\n\t\t\tsubquery->groupClause)\n\t\t\treturn;\n\n\t\t/*\n\t\t * OK, fetch RelOptInfo for subquery.  Note that we don't change the\n\t\t * rel returned in vardata, since caller expects it to be a rel of the\n\t\t * caller's query level.  Because we might already be recursing, we\n\t\t * can't use that rel pointer either, but have to look up the Var's\n\t\t * rel afresh.\n\t\t */\n\t\trel = find_base_rel(root, var->varno);\n\n\t\t/* If the subquery hasn't been planned yet, we have to punt */\n\t\tif (rel->subroot == NULL)\n\t\t\treturn;\n\t\tAssert(IsA(rel->subroot, PlannerInfo));\n\n\t\t/*\n\t\t * Switch our attention to the subquery as mangled by the planner. It\n\t\t * was okay to look at the pre-planning version for the tests above,\n\t\t * but now we need a Var that will refer to the subroot's live\n\t\t * RelOptInfos.  For instance, if any subquery pullup happened during\n\t\t * planning, Vars in the targetlist might have gotten replaced, and we\n\t\t * need to see the replacement expressions.\n\t\t */\n\t\tsubquery = rel->subroot->parse;\n\t\tAssert(IsA(subquery, Query));\n\n\t\t/* Get the subquery output expression referenced by the upper Var */\n\t\tste = get_tle_by_resno(subquery->targetList, var->varattno);\n\t\tif (ste == NULL || ste->resjunk)\n\t\t\telog(ERROR, \"subquery %s does not have attribute %d\",\n\t\t\t\t rte->eref->aliasname, var->varattno);\n\t\tvar = (Var *) ste->expr;\n\n\t\t/*\n\t\t * If subquery uses DISTINCT, we can't make use of any stats for the\n\t\t * variable ... but, if it's the only DISTINCT column, we are entitled\n\t\t * to consider it unique.  We do the test this way so that it works\n\t\t * for cases involving DISTINCT ON.\n\t\t */\n\t\tif (subquery->distinctClause)\n\t\t{\n\t\t\tif (list_length(subquery->distinctClause) == 1 &&\n\t\t\t\ttargetIsInSortList(ste, InvalidOid, subquery->distinctClause))\n\t\t\t\tvardata->isunique = true;\n\t\t\t/* cannot go further */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the sub-query originated from a view with the security_barrier\n\t\t * attribute, we must not look at the variable's statistics, though it\n\t\t * seems all right to notice the existence of a DISTINCT clause. So\n\t\t * stop here.\n\t\t *\n\t\t * This is probably a harsher restriction than necessary; it's\n\t\t * certainly OK for the selectivity estimator (which is a C function,\n\t\t * and therefore omnipotent anyway) to look at the statistics.  But\n\t\t * many selectivity estimators will happily *invoke the operator\n\t\t * function* to try to work out a good estimate - and that's not OK.\n\t\t * So for now, don't dig down for stats.\n\t\t */\n\t\tif (rte->security_barrier)\n\t\t\treturn;\n\n\t\t/* Can only handle a simple Var of subquery's query level */\n\t\tif (var && IsA(var, Var) &&\n\t\t\tvar->varlevelsup == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * OK, recurse into the subquery.  Note that the original setting\n\t\t\t * of vardata->isunique (which will surely be false) is left\n\t\t\t * unchanged in this situation.  That's what we want, since even\n\t\t\t * if the underlying column is unique, the subquery may have\n\t\t\t * joined to other tables in a way that creates duplicates.\n\t\t\t */\n\t\t\texamine_simple_variable(rel->subroot, var, vardata);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We\n\t\t * won't see RTE_JOIN here because join alias Vars have already been\n\t\t * flattened.)\tThere's not much we can do with function outputs, but\n\t\t * maybe someday try to be smarter about VALUES and/or CTEs.\n\t\t */\n\t}\n}"
  },
  {
    "function_name": "examine_variable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4775-4984",
    "snippet": "void\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "get_index_stats_hook_type get_index_stats_hook = NULL;",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lnext",
          "args": [
            "indexpr_item"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_class_aclcheck",
          "args": [
            "rte->relid",
            "GetUserId()",
            "ACL_SELECT"
          ],
          "line": 4965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 4965
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rte->rtekind == RTE_RELATION"
          ],
          "line": 4952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "planner_rt_fetch",
          "args": [
            "index->rel->relid",
            "root"
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 4946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache3",
          "args": [
            "STATRELATTINH",
            "ObjectIdGetDatum(index->indexoid)",
            "Int16GetDatum(pos + 1)",
            "BoolGetDatum(false)"
          ],
          "line": 4940
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1133-1142",
          "snippet": "HeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "false"
          ],
          "line": 4943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "pos + 1"
          ],
          "line": 4942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "index->indexoid"
          ],
          "line": 4941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"no function provided to release variable stats with\""
          ],
          "line": 4935
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 4933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "root",
            "index->indexoid",
            "pos + 1",
            "vardata"
          ],
          "line": 4925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equal",
          "args": [
            "node",
            "indexkey"
          ],
          "line": 4902
        },
        "resolved": true,
        "details": {
          "function_name": "equalsJsonbScalarValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1298-1322",
          "snippet": "static bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\n\nstatic bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "indexkey",
            "RelabelType"
          ],
          "line": 4900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "indexpr_item"
          ],
          "line": 4899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_head",
          "args": [
            "index->indexprs"
          ],
          "line": 4887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "ilist"
          ],
          "line": 4883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "ilist",
            "onerel->indexlist"
          ],
          "line": 4881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprTypmod",
          "args": [
            "node"
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "node"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "varnos"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_base_rel",
          "args": [
            "root",
            "varRelid"
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_is_member",
          "args": [
            "varRelid",
            "varnos"
          ],
          "line": 4847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_join_rel",
          "args": [
            "root",
            "varnos"
          ],
          "line": 4844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_base_rel",
          "args": [
            "root",
            "(varRelid ? varRelid : bms_singleton_member(varnos))"
          ],
          "line": 4833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_singleton_member",
          "args": [
            "varnos"
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_is_member",
          "args": [
            "varRelid",
            "varnos"
          ],
          "line": 4831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_membership",
          "args": [
            "varnos"
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pull_varnos",
          "args": [
            "basenode"
          ],
          "line": 4821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "examine_simple_variable",
          "args": [
            "root",
            "var",
            "vardata"
          ],
          "line": 4811
        },
        "resolved": true,
        "details": {
          "function_name": "examine_simple_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4995-5159",
          "snippet": "static void\nexamine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata)\n{\n\tRangeTblEntry *rte = root->simple_rte_array[var->varno];\n\n\tAssert(IsA(rte, RangeTblEntry));\n\n\tif (get_relation_stats_hook &&\n\t\t(*get_relation_stats_hook) (root, rte, var->varattno, vardata))\n\t{\n\t\t/*\n\t\t * The hook took control of acquiring a stats tuple.  If it did supply\n\t\t * a tuple, it'd better have supplied a freefunc.\n\t\t */\n\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t!vardata->freefunc)\n\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t}\n\telse if (rte->rtekind == RTE_RELATION)\n\t{\n\t\t/*\n\t\t * Plain table or parent of an inheritance appendrel, so look up the\n\t\t * column in pg_statistic\n\t\t */\n\t\tvardata->statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(var->varattno),\n\t\t\t\t\t\t\t\t\t\t\t  BoolGetDatum(rte->inh));\n\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t{\n\t\t\t/*\n\t\t\t * Check if user has permission to read this column.  We require\n\t\t\t * all rows to be accessible, so there must be no securityQuals\n\t\t\t * from security barrier views or RLS policies.\n\t\t\t */\n\t\t\tvardata->acl_ok =\n\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t((pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK) ||\n\t\t\t\t (pg_attribute_aclcheck(rte->relid, var->varattno, GetUserId(),\n\t\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* suppress any possible leakproofness checks later */\n\t\t\tvardata->acl_ok = true;\n\t\t}\n\t}\n\telse if (rte->rtekind == RTE_SUBQUERY && !rte->inh)\n\t{\n\t\t/*\n\t\t * Plain subquery (not one that was converted to an appendrel).\n\t\t */\n\t\tQuery\t   *subquery = rte->subquery;\n\t\tRelOptInfo *rel;\n\t\tTargetEntry *ste;\n\n\t\t/*\n\t\t * Punt if it's a whole-row var rather than a plain column reference.\n\t\t */\n\t\tif (var->varattno == InvalidAttrNumber)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Punt if subquery uses set operations or GROUP BY, as these will\n\t\t * mash underlying columns' stats beyond recognition.  (Set ops are\n\t\t * particularly nasty; if we forged ahead, we would return stats\n\t\t * relevant to only the leftmost subselect...)\tDISTINCT is also\n\t\t * problematic, but we check that later because there is a possibility\n\t\t * of learning something even with it.\n\t\t */\n\t\tif (subquery->setOperations ||\n\t\t\tsubquery->groupClause)\n\t\t\treturn;\n\n\t\t/*\n\t\t * OK, fetch RelOptInfo for subquery.  Note that we don't change the\n\t\t * rel returned in vardata, since caller expects it to be a rel of the\n\t\t * caller's query level.  Because we might already be recursing, we\n\t\t * can't use that rel pointer either, but have to look up the Var's\n\t\t * rel afresh.\n\t\t */\n\t\trel = find_base_rel(root, var->varno);\n\n\t\t/* If the subquery hasn't been planned yet, we have to punt */\n\t\tif (rel->subroot == NULL)\n\t\t\treturn;\n\t\tAssert(IsA(rel->subroot, PlannerInfo));\n\n\t\t/*\n\t\t * Switch our attention to the subquery as mangled by the planner. It\n\t\t * was okay to look at the pre-planning version for the tests above,\n\t\t * but now we need a Var that will refer to the subroot's live\n\t\t * RelOptInfos.  For instance, if any subquery pullup happened during\n\t\t * planning, Vars in the targetlist might have gotten replaced, and we\n\t\t * need to see the replacement expressions.\n\t\t */\n\t\tsubquery = rel->subroot->parse;\n\t\tAssert(IsA(subquery, Query));\n\n\t\t/* Get the subquery output expression referenced by the upper Var */\n\t\tste = get_tle_by_resno(subquery->targetList, var->varattno);\n\t\tif (ste == NULL || ste->resjunk)\n\t\t\telog(ERROR, \"subquery %s does not have attribute %d\",\n\t\t\t\t rte->eref->aliasname, var->varattno);\n\t\tvar = (Var *) ste->expr;\n\n\t\t/*\n\t\t * If subquery uses DISTINCT, we can't make use of any stats for the\n\t\t * variable ... but, if it's the only DISTINCT column, we are entitled\n\t\t * to consider it unique.  We do the test this way so that it works\n\t\t * for cases involving DISTINCT ON.\n\t\t */\n\t\tif (subquery->distinctClause)\n\t\t{\n\t\t\tif (list_length(subquery->distinctClause) == 1 &&\n\t\t\t\ttargetIsInSortList(ste, InvalidOid, subquery->distinctClause))\n\t\t\t\tvardata->isunique = true;\n\t\t\t/* cannot go further */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the sub-query originated from a view with the security_barrier\n\t\t * attribute, we must not look at the variable's statistics, though it\n\t\t * seems all right to notice the existence of a DISTINCT clause. So\n\t\t * stop here.\n\t\t *\n\t\t * This is probably a harsher restriction than necessary; it's\n\t\t * certainly OK for the selectivity estimator (which is a C function,\n\t\t * and therefore omnipotent anyway) to look at the statistics.  But\n\t\t * many selectivity estimators will happily *invoke the operator\n\t\t * function* to try to work out a good estimate - and that's not OK.\n\t\t * So for now, don't dig down for stats.\n\t\t */\n\t\tif (rte->security_barrier)\n\t\t\treturn;\n\n\t\t/* Can only handle a simple Var of subquery's query level */\n\t\tif (var && IsA(var, Var) &&\n\t\t\tvar->varlevelsup == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * OK, recurse into the subquery.  Note that the original setting\n\t\t\t * of vardata->isunique (which will surely be false) is left\n\t\t\t * unchanged in this situation.  That's what we want, since even\n\t\t\t * if the underlying column is unique, the subquery may have\n\t\t\t * joined to other tables in a way that creates duplicates.\n\t\t\t */\n\t\t\texamine_simple_variable(rel->subroot, var, vardata);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We\n\t\t * won't see RTE_JOIN here because join alias Vars have already been\n\t\t * flattened.)\tThere's not much we can do with function outputs, but\n\t\t * maybe someday try to be smarter about VALUES and/or CTEs.\n\t\t */\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "get_relation_stats_hook_type get_relation_stats_hook = NULL;",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_relation_stats_hook_type get_relation_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic void\nexamine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata)\n{\n\tRangeTblEntry *rte = root->simple_rte_array[var->varno];\n\n\tAssert(IsA(rte, RangeTblEntry));\n\n\tif (get_relation_stats_hook &&\n\t\t(*get_relation_stats_hook) (root, rte, var->varattno, vardata))\n\t{\n\t\t/*\n\t\t * The hook took control of acquiring a stats tuple.  If it did supply\n\t\t * a tuple, it'd better have supplied a freefunc.\n\t\t */\n\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t!vardata->freefunc)\n\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t}\n\telse if (rte->rtekind == RTE_RELATION)\n\t{\n\t\t/*\n\t\t * Plain table or parent of an inheritance appendrel, so look up the\n\t\t * column in pg_statistic\n\t\t */\n\t\tvardata->statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(var->varattno),\n\t\t\t\t\t\t\t\t\t\t\t  BoolGetDatum(rte->inh));\n\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t{\n\t\t\t/*\n\t\t\t * Check if user has permission to read this column.  We require\n\t\t\t * all rows to be accessible, so there must be no securityQuals\n\t\t\t * from security barrier views or RLS policies.\n\t\t\t */\n\t\t\tvardata->acl_ok =\n\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t((pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK) ||\n\t\t\t\t (pg_attribute_aclcheck(rte->relid, var->varattno, GetUserId(),\n\t\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* suppress any possible leakproofness checks later */\n\t\t\tvardata->acl_ok = true;\n\t\t}\n\t}\n\telse if (rte->rtekind == RTE_SUBQUERY && !rte->inh)\n\t{\n\t\t/*\n\t\t * Plain subquery (not one that was converted to an appendrel).\n\t\t */\n\t\tQuery\t   *subquery = rte->subquery;\n\t\tRelOptInfo *rel;\n\t\tTargetEntry *ste;\n\n\t\t/*\n\t\t * Punt if it's a whole-row var rather than a plain column reference.\n\t\t */\n\t\tif (var->varattno == InvalidAttrNumber)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Punt if subquery uses set operations or GROUP BY, as these will\n\t\t * mash underlying columns' stats beyond recognition.  (Set ops are\n\t\t * particularly nasty; if we forged ahead, we would return stats\n\t\t * relevant to only the leftmost subselect...)\tDISTINCT is also\n\t\t * problematic, but we check that later because there is a possibility\n\t\t * of learning something even with it.\n\t\t */\n\t\tif (subquery->setOperations ||\n\t\t\tsubquery->groupClause)\n\t\t\treturn;\n\n\t\t/*\n\t\t * OK, fetch RelOptInfo for subquery.  Note that we don't change the\n\t\t * rel returned in vardata, since caller expects it to be a rel of the\n\t\t * caller's query level.  Because we might already be recursing, we\n\t\t * can't use that rel pointer either, but have to look up the Var's\n\t\t * rel afresh.\n\t\t */\n\t\trel = find_base_rel(root, var->varno);\n\n\t\t/* If the subquery hasn't been planned yet, we have to punt */\n\t\tif (rel->subroot == NULL)\n\t\t\treturn;\n\t\tAssert(IsA(rel->subroot, PlannerInfo));\n\n\t\t/*\n\t\t * Switch our attention to the subquery as mangled by the planner. It\n\t\t * was okay to look at the pre-planning version for the tests above,\n\t\t * but now we need a Var that will refer to the subroot's live\n\t\t * RelOptInfos.  For instance, if any subquery pullup happened during\n\t\t * planning, Vars in the targetlist might have gotten replaced, and we\n\t\t * need to see the replacement expressions.\n\t\t */\n\t\tsubquery = rel->subroot->parse;\n\t\tAssert(IsA(subquery, Query));\n\n\t\t/* Get the subquery output expression referenced by the upper Var */\n\t\tste = get_tle_by_resno(subquery->targetList, var->varattno);\n\t\tif (ste == NULL || ste->resjunk)\n\t\t\telog(ERROR, \"subquery %s does not have attribute %d\",\n\t\t\t\t rte->eref->aliasname, var->varattno);\n\t\tvar = (Var *) ste->expr;\n\n\t\t/*\n\t\t * If subquery uses DISTINCT, we can't make use of any stats for the\n\t\t * variable ... but, if it's the only DISTINCT column, we are entitled\n\t\t * to consider it unique.  We do the test this way so that it works\n\t\t * for cases involving DISTINCT ON.\n\t\t */\n\t\tif (subquery->distinctClause)\n\t\t{\n\t\t\tif (list_length(subquery->distinctClause) == 1 &&\n\t\t\t\ttargetIsInSortList(ste, InvalidOid, subquery->distinctClause))\n\t\t\t\tvardata->isunique = true;\n\t\t\t/* cannot go further */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the sub-query originated from a view with the security_barrier\n\t\t * attribute, we must not look at the variable's statistics, though it\n\t\t * seems all right to notice the existence of a DISTINCT clause. So\n\t\t * stop here.\n\t\t *\n\t\t * This is probably a harsher restriction than necessary; it's\n\t\t * certainly OK for the selectivity estimator (which is a C function,\n\t\t * and therefore omnipotent anyway) to look at the statistics.  But\n\t\t * many selectivity estimators will happily *invoke the operator\n\t\t * function* to try to work out a good estimate - and that's not OK.\n\t\t * So for now, don't dig down for stats.\n\t\t */\n\t\tif (rte->security_barrier)\n\t\t\treturn;\n\n\t\t/* Can only handle a simple Var of subquery's query level */\n\t\tif (var && IsA(var, Var) &&\n\t\t\tvar->varlevelsup == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * OK, recurse into the subquery.  Note that the original setting\n\t\t\t * of vardata->isunique (which will surely be false) is left\n\t\t\t * unchanged in this situation.  That's what we want, since even\n\t\t\t * if the underlying column is unique, the subquery may have\n\t\t\t * joined to other tables in a way that creates duplicates.\n\t\t\t */\n\t\t\texamine_simple_variable(rel->subroot, var, vardata);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We\n\t\t * won't see RTE_JOIN here because join alias Vars have already been\n\t\t * flattened.)\tThere's not much we can do with function outputs, but\n\t\t * maybe someday try to be smarter about VALUES and/or CTEs.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_unique_index",
          "args": [
            "vardata->rel",
            "var->varattno"
          ],
          "line": 4808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_base_rel",
          "args": [
            "root",
            "var->varno"
          ],
          "line": 4805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "basenode",
            "Var"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "node",
            "RelabelType"
          ],
          "line": 4791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "node"
          ],
          "line": 4787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "vardata",
            "0",
            "sizeof(VariableStatData)"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_join_variables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4713-4738",
    "snippet": "void\nget_join_variables(PlannerInfo *root, List *args, SpecialJoinInfo *sjinfo,\n\t\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t\t   bool *join_is_reversed)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\n\tif (list_length(args) != 2)\n\t\telog(ERROR, \"join operator should take two arguments\");\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\texamine_variable(root, left, 0, vardata1);\n\texamine_variable(root, right, 0, vardata2);\n\n\tif (vardata1->rel &&\n\t\tbms_is_subset(vardata1->rel->relids, sjinfo->syn_righthand))\n\t\t*join_is_reversed = true;\t/* var1 is on RHS */\n\telse if (vardata2->rel &&\n\t\t\t bms_is_subset(vardata2->rel->relids, sjinfo->syn_lefthand))\n\t\t*join_is_reversed = true;\t/* var2 is on LHS */\n\telse\n\t\t*join_is_reversed = false;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
      "static RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bms_is_subset",
          "args": [
            "vardata2->rel->relids",
            "sjinfo->syn_lefthand"
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_is_subset",
          "args": [
            "vardata1->rel->relids",
            "sjinfo->syn_righthand"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "examine_variable",
          "args": [
            "root",
            "right",
            "0",
            "vardata2"
          ],
          "line": 4728
        },
        "resolved": true,
        "details": {
          "function_name": "examine_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4775-4984",
          "snippet": "void\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "get_index_stats_hook_type get_index_stats_hook = NULL;",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lsecond",
          "args": [
            "args"
          ],
          "line": 4725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "args"
          ],
          "line": 4724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"join operator should take two arguments\""
          ],
          "line": 4722
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "args"
          ],
          "line": 4721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);\n\nvoid\nget_join_variables(PlannerInfo *root, List *args, SpecialJoinInfo *sjinfo,\n\t\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t\t   bool *join_is_reversed)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\n\tif (list_length(args) != 2)\n\t\telog(ERROR, \"join operator should take two arguments\");\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\texamine_variable(root, left, 0, vardata1);\n\texamine_variable(root, right, 0, vardata2);\n\n\tif (vardata1->rel &&\n\t\tbms_is_subset(vardata1->rel->relids, sjinfo->syn_righthand))\n\t\t*join_is_reversed = true;\t/* var1 is on RHS */\n\telse if (vardata2->rel &&\n\t\t\t bms_is_subset(vardata2->rel->relids, sjinfo->syn_lefthand))\n\t\t*join_is_reversed = true;\t/* var2 is on LHS */\n\telse\n\t\t*join_is_reversed = false;\n}"
  },
  {
    "function_name": "get_restriction_variable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4653-4701",
    "snippet": "bool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "rdata"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "*vardata"
          ],
          "line": 4697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimate_expression_value",
          "args": [
            "root",
            "vardata->var"
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimate_expression_value",
          "args": [
            "root",
            "rdata.var"
          ],
          "line": 4682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "examine_variable",
          "args": [
            "root",
            "right",
            "varRelid",
            "&rdata"
          ],
          "line": 4674
        },
        "resolved": true,
        "details": {
          "function_name": "examine_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4775-4984",
          "snippet": "void\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "get_index_stats_hook_type get_index_stats_hook = NULL;",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lsecond",
          "args": [
            "args"
          ],
          "line": 4667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "args"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "args"
          ],
          "line": 4663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}"
  },
  {
    "function_name": "convert_timevalue_to_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4578-4627",
    "snippet": "static double\nconvert_timevalue_to_scalar(Datum value, Oid typid, bool *failure)\n{\n\tswitch (typid)\n\t{\n\t\tcase TIMESTAMPOID:\n\t\t\treturn DatumGetTimestamp(value);\n\t\tcase TIMESTAMPTZOID:\n\t\t\treturn DatumGetTimestampTz(value);\n\t\tcase ABSTIMEOID:\n\t\t\treturn DatumGetTimestamp(DirectFunctionCall1(abstime_timestamp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t value));\n\t\tcase DATEOID:\n\t\t\treturn date2timestamp_no_overflow(DatumGetDateADT(value));\n\t\tcase INTERVALOID:\n\t\t\t{\n\t\t\t\tInterval   *interval = DatumGetIntervalP(value);\n\n\t\t\t\t/*\n\t\t\t\t * Convert the month part of Interval to days using assumed\n\t\t\t\t * average month length of 365.25/12.0 days.  Not too\n\t\t\t\t * accurate, but plenty good enough for our purposes.\n\t\t\t\t */\n\t\t\t\treturn interval->time + interval->day * (double) USECS_PER_DAY +\n\t\t\t\t\tinterval->month * ((DAYS_PER_YEAR / (double) MONTHS_PER_YEAR) * USECS_PER_DAY);\n\t\t\t}\n\t\tcase RELTIMEOID:\n\t\t\treturn (DatumGetRelativeTime(value) * 1000000.0);\n\t\tcase TINTERVALOID:\n\t\t\t{\n\t\t\t\tTimeInterval tinterval = DatumGetTimeInterval(value);\n\n\t\t\t\tif (tinterval->status != 0)\n\t\t\t\t\treturn ((tinterval->data[1] - tinterval->data[0]) * 1000000.0);\n\t\t\t\treturn 0;\t\t/* for lack of a better idea */\n\t\t\t}\n\t\tcase TIMEOID:\n\t\t\treturn DatumGetTimeADT(value);\n\t\tcase TIMETZOID:\n\t\t\t{\n\t\t\t\tTimeTzADT  *timetz = DatumGetTimeTzADTP(value);\n\n\t\t\t\t/* use GMT-equivalent time */\n\t\t\t\treturn (double) (timetz->time + (timetz->zone * 1000000.0));\n\t\t\t}\n\t}\n\n\t*failure = true;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);",
      "static char *convert_string_datum(Datum value, Oid typid, bool *failure);",
      "static double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetTimeTzADTP",
          "args": [
            "value"
          ],
          "line": 4618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimeADT",
          "args": [
            "value"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimeInterval",
          "args": [
            "value"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRelativeTime",
          "args": [
            "value"
          ],
          "line": 4605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetIntervalP",
          "args": [
            "value"
          ],
          "line": 4594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamp_no_overflow",
          "args": [
            "DatumGetDateADT(value)"
          ],
          "line": 4591
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetDateADT",
          "args": [
            "value"
          ],
          "line": 4591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestamp",
          "args": [
            "DirectFunctionCall1(abstime_timestamp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t value)"
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "abstime_timestamp",
            "value"
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestampTz",
          "args": [
            "value"
          ],
          "line": 4586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTimestamp",
          "args": [
            "value"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);\nstatic char *convert_string_datum(Datum value, Oid typid, bool *failure);\nstatic double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);\n\nstatic double\nconvert_timevalue_to_scalar(Datum value, Oid typid, bool *failure)\n{\n\tswitch (typid)\n\t{\n\t\tcase TIMESTAMPOID:\n\t\t\treturn DatumGetTimestamp(value);\n\t\tcase TIMESTAMPTZOID:\n\t\t\treturn DatumGetTimestampTz(value);\n\t\tcase ABSTIMEOID:\n\t\t\treturn DatumGetTimestamp(DirectFunctionCall1(abstime_timestamp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t value));\n\t\tcase DATEOID:\n\t\t\treturn date2timestamp_no_overflow(DatumGetDateADT(value));\n\t\tcase INTERVALOID:\n\t\t\t{\n\t\t\t\tInterval   *interval = DatumGetIntervalP(value);\n\n\t\t\t\t/*\n\t\t\t\t * Convert the month part of Interval to days using assumed\n\t\t\t\t * average month length of 365.25/12.0 days.  Not too\n\t\t\t\t * accurate, but plenty good enough for our purposes.\n\t\t\t\t */\n\t\t\t\treturn interval->time + interval->day * (double) USECS_PER_DAY +\n\t\t\t\t\tinterval->month * ((DAYS_PER_YEAR / (double) MONTHS_PER_YEAR) * USECS_PER_DAY);\n\t\t\t}\n\t\tcase RELTIMEOID:\n\t\t\treturn (DatumGetRelativeTime(value) * 1000000.0);\n\t\tcase TINTERVALOID:\n\t\t\t{\n\t\t\t\tTimeInterval tinterval = DatumGetTimeInterval(value);\n\n\t\t\t\tif (tinterval->status != 0)\n\t\t\t\t\treturn ((tinterval->data[1] - tinterval->data[0]) * 1000000.0);\n\t\t\t\treturn 0;\t\t/* for lack of a better idea */\n\t\t\t}\n\t\tcase TIMEOID:\n\t\t\treturn DatumGetTimeADT(value);\n\t\tcase TIMETZOID:\n\t\t\t{\n\t\t\t\tTimeTzADT  *timetz = DatumGetTimeTzADTP(value);\n\n\t\t\t\t/* use GMT-equivalent time */\n\t\t\t\treturn (double) (timetz->time + (timetz->zone * 1000000.0));\n\t\t\t}\n\t}\n\n\t*failure = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "convert_one_bytea_to_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4535-4570",
    "snippet": "static double\nconvert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi)\n{\n\tdouble\t\tnum,\n\t\t\t\tdenom,\n\t\t\t\tbase;\n\n\tif (valuelen <= 0)\n\t\treturn 0.0;\t\t\t\t/* empty string has scalar value 0 */\n\n\t/*\n\t * Since base is 256, need not consider more than about 10 chars (even\n\t * this many seems like overkill)\n\t */\n\tif (valuelen > 10)\n\t\tvaluelen = 10;\n\n\t/* Convert initial characters to fraction */\n\tbase = rangehi - rangelo + 1;\n\tnum = 0.0;\n\tdenom = base;\n\twhile (valuelen-- > 0)\n\t{\n\t\tint\t\t\tch = *value++;\n\n\t\tif (ch < rangelo)\n\t\t\tch = rangelo - 1;\n\t\telse if (ch > rangehi)\n\t\t\tch = rangehi + 1;\n\t\tnum += ((double) (ch - rangelo)) / denom;\n\t\tdenom *= base;\n\t}\n\n\treturn num;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);",
      "static double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);\nstatic double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);\n\nstatic double\nconvert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi)\n{\n\tdouble\t\tnum,\n\t\t\t\tdenom,\n\t\t\t\tbase;\n\n\tif (valuelen <= 0)\n\t\treturn 0.0;\t\t\t\t/* empty string has scalar value 0 */\n\n\t/*\n\t * Since base is 256, need not consider more than about 10 chars (even\n\t * this many seems like overkill)\n\t */\n\tif (valuelen > 10)\n\t\tvaluelen = 10;\n\n\t/* Convert initial characters to fraction */\n\tbase = rangehi - rangelo + 1;\n\tnum = 0.0;\n\tdenom = base;\n\twhile (valuelen-- > 0)\n\t{\n\t\tint\t\t\tch = *value++;\n\n\t\tif (ch < rangelo)\n\t\t\tch = rangelo - 1;\n\t\telse if (ch > rangehi)\n\t\t\tch = rangehi + 1;\n\t\tnum += ((double) (ch - rangelo)) / denom;\n\t\tdenom *= base;\n\t}\n\n\treturn num;\n}"
  },
  {
    "function_name": "convert_bytea_to_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4487-4533",
    "snippet": "static void\nconvert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound)\n{\n\tbytea\t   *valuep = DatumGetByteaPP(value);\n\tbytea\t   *loboundp = DatumGetByteaPP(lobound);\n\tbytea\t   *hiboundp = DatumGetByteaPP(hibound);\n\tint\t\t\trangelo,\n\t\t\t\trangehi,\n\t\t\t\tvaluelen = VARSIZE_ANY_EXHDR(valuep),\n\t\t\t\tloboundlen = VARSIZE_ANY_EXHDR(loboundp),\n\t\t\t\thiboundlen = VARSIZE_ANY_EXHDR(hiboundp),\n\t\t\t\ti,\n\t\t\t\tminlen;\n\tunsigned char *valstr = (unsigned char *) VARDATA_ANY(valuep);\n\tunsigned char *lostr = (unsigned char *) VARDATA_ANY(loboundp);\n\tunsigned char *histr = (unsigned char *) VARDATA_ANY(hiboundp);\n\n\t/*\n\t * Assume bytea data is uniformly distributed across all byte values.\n\t */\n\trangelo = 0;\n\trangehi = 255;\n\n\t/*\n\t * Now strip any common prefix of the three strings.\n\t */\n\tminlen = Min(Min(valuelen, loboundlen), hiboundlen);\n\tfor (i = 0; i < minlen; i++)\n\t{\n\t\tif (*lostr != *histr || *lostr != *valstr)\n\t\t\tbreak;\n\t\tlostr++, histr++, valstr++;\n\t\tloboundlen--, hiboundlen--, valuelen--;\n\t}\n\n\t/*\n\t * Now we can do the conversions.\n\t */\n\t*scaledvalue = convert_one_bytea_to_scalar(valstr, valuelen, rangelo, rangehi);\n\t*scaledlobound = convert_one_bytea_to_scalar(lostr, loboundlen, rangelo, rangehi);\n\t*scaledhibound = convert_one_bytea_to_scalar(histr, hiboundlen, rangelo, rangehi);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);",
      "static void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);",
      "static void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);",
      "static double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);",
      "static double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "convert_one_bytea_to_scalar",
          "args": [
            "histr",
            "hiboundlen",
            "rangelo",
            "rangehi"
          ],
          "line": 4532
        },
        "resolved": true,
        "details": {
          "function_name": "convert_one_bytea_to_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4535-4570",
          "snippet": "static double\nconvert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi)\n{\n\tdouble\t\tnum,\n\t\t\t\tdenom,\n\t\t\t\tbase;\n\n\tif (valuelen <= 0)\n\t\treturn 0.0;\t\t\t\t/* empty string has scalar value 0 */\n\n\t/*\n\t * Since base is 256, need not consider more than about 10 chars (even\n\t * this many seems like overkill)\n\t */\n\tif (valuelen > 10)\n\t\tvaluelen = 10;\n\n\t/* Convert initial characters to fraction */\n\tbase = rangehi - rangelo + 1;\n\tnum = 0.0;\n\tdenom = base;\n\twhile (valuelen-- > 0)\n\t{\n\t\tint\t\t\tch = *value++;\n\n\t\tif (ch < rangelo)\n\t\t\tch = rangelo - 1;\n\t\telse if (ch > rangehi)\n\t\t\tch = rangehi + 1;\n\t\tnum += ((double) (ch - rangelo)) / denom;\n\t\tdenom *= base;\n\t}\n\n\treturn num;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);",
            "static double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);\nstatic double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);\n\nstatic double\nconvert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi)\n{\n\tdouble\t\tnum,\n\t\t\t\tdenom,\n\t\t\t\tbase;\n\n\tif (valuelen <= 0)\n\t\treturn 0.0;\t\t\t\t/* empty string has scalar value 0 */\n\n\t/*\n\t * Since base is 256, need not consider more than about 10 chars (even\n\t * this many seems like overkill)\n\t */\n\tif (valuelen > 10)\n\t\tvaluelen = 10;\n\n\t/* Convert initial characters to fraction */\n\tbase = rangehi - rangelo + 1;\n\tnum = 0.0;\n\tdenom = base;\n\twhile (valuelen-- > 0)\n\t{\n\t\tint\t\t\tch = *value++;\n\n\t\tif (ch < rangelo)\n\t\t\tch = rangelo - 1;\n\t\telse if (ch > rangehi)\n\t\t\tch = rangehi + 1;\n\t\tnum += ((double) (ch - rangelo)) / denom;\n\t\tdenom *= base;\n\t}\n\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "Min(valuelen, loboundlen)",
            "hiboundlen"
          ],
          "line": 4518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "valuelen",
            "loboundlen"
          ],
          "line": 4518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "hiboundp"
          ],
          "line": 4507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "loboundp"
          ],
          "line": 4506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "valuep"
          ],
          "line": 4505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "hiboundp"
          ],
          "line": 4502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "loboundp"
          ],
          "line": 4501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "valuep"
          ],
          "line": 4500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetByteaPP",
          "args": [
            "hibound"
          ],
          "line": 4497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetByteaPP",
          "args": [
            "lobound"
          ],
          "line": 4496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetByteaPP",
          "args": [
            "value"
          ],
          "line": 4495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);\nstatic void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);\nstatic void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);\nstatic double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);\nstatic double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);\n\nstatic void\nconvert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound)\n{\n\tbytea\t   *valuep = DatumGetByteaPP(value);\n\tbytea\t   *loboundp = DatumGetByteaPP(lobound);\n\tbytea\t   *hiboundp = DatumGetByteaPP(hibound);\n\tint\t\t\trangelo,\n\t\t\t\trangehi,\n\t\t\t\tvaluelen = VARSIZE_ANY_EXHDR(valuep),\n\t\t\t\tloboundlen = VARSIZE_ANY_EXHDR(loboundp),\n\t\t\t\thiboundlen = VARSIZE_ANY_EXHDR(hiboundp),\n\t\t\t\ti,\n\t\t\t\tminlen;\n\tunsigned char *valstr = (unsigned char *) VARDATA_ANY(valuep);\n\tunsigned char *lostr = (unsigned char *) VARDATA_ANY(loboundp);\n\tunsigned char *histr = (unsigned char *) VARDATA_ANY(hiboundp);\n\n\t/*\n\t * Assume bytea data is uniformly distributed across all byte values.\n\t */\n\trangelo = 0;\n\trangehi = 255;\n\n\t/*\n\t * Now strip any common prefix of the three strings.\n\t */\n\tminlen = Min(Min(valuelen, loboundlen), hiboundlen);\n\tfor (i = 0; i < minlen; i++)\n\t{\n\t\tif (*lostr != *histr || *lostr != *valstr)\n\t\t\tbreak;\n\t\tlostr++, histr++, valstr++;\n\t\tloboundlen--, hiboundlen--, valuelen--;\n\t}\n\n\t/*\n\t * Now we can do the conversions.\n\t */\n\t*scaledvalue = convert_one_bytea_to_scalar(valstr, valuelen, rangelo, rangehi);\n\t*scaledlobound = convert_one_bytea_to_scalar(lostr, loboundlen, rangelo, rangehi);\n\t*scaledhibound = convert_one_bytea_to_scalar(histr, hiboundlen, rangelo, rangehi);\n}"
  },
  {
    "function_name": "convert_string_datum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4393-4474",
    "snippet": "static char *\nconvert_string_datum(Datum value, Oid typid, bool *failure)\n{\n\tchar\t   *val;\n\n\tswitch (typid)\n\t{\n\t\tcase CHAROID:\n\t\t\tval = (char *) palloc(2);\n\t\t\tval[0] = DatumGetChar(value);\n\t\t\tval[1] = '\\0';\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\tcase VARCHAROID:\n\t\tcase TEXTOID:\n\t\t\tval = TextDatumGetCString(value);\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\t{\n\t\t\t\tNameData   *nm = (NameData *) DatumGetPointer(value);\n\n\t\t\t\tval = pstrdup(NameStr(*nm));\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\t*failure = true;\n\t\t\treturn NULL;\n\t}\n\n\tif (!lc_collate_is_c(DEFAULT_COLLATION_OID))\n\t{\n\t\tchar\t   *xfrmstr;\n\t\tsize_t\t\txfrmlen;\n\t\tsize_t\t\txfrmlen2 PG_USED_FOR_ASSERTS_ONLY;\n\n\t\t/*\n\t\t * XXX: We could guess at a suitable output buffer size and only call\n\t\t * strxfrm twice if our guess is too small.\n\t\t *\n\t\t * XXX: strxfrm doesn't support UTF-8 encoding on Win32, it can return\n\t\t * bogus data or set an error. This is not really a problem unless it\n\t\t * crashes since it will only give an estimation error and nothing\n\t\t * fatal.\n\t\t */\n#if _MSC_VER == 1400\t\t\t/* VS.Net 2005 */\n\n\t\t/*\n\t\t *\n\t\t * http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=99694\n\t\t */\n\t\t{\n\t\t\tchar\t\tx[1];\n\n\t\t\txfrmlen = strxfrm(x, val, 0);\n\t\t}\n#else\n\t\txfrmlen = strxfrm(NULL, val, 0);\n#endif\n#ifdef WIN32\n\n\t\t/*\n\t\t * On Windows, strxfrm returns INT_MAX when an error occurs. Instead\n\t\t * of trying to allocate this much memory (and fail), just return the\n\t\t * original string unmodified as if we were in the C locale.\n\t\t */\n\t\tif (xfrmlen == INT_MAX)\n\t\t\treturn val;\n#endif\n\t\txfrmstr = (char *) palloc(xfrmlen + 1);\n\t\txfrmlen2 = strxfrm(xfrmstr, val, xfrmlen + 1);\n\n\t\t/*\n\t\t * Some systems (e.g., glibc) can return a smaller value from the\n\t\t * second call than the first; thus the Assert must be <= not ==.\n\t\t */\n\t\tAssert(xfrmlen2 <= xfrmlen);\n\t\tpfree(val);\n\t\tval = xfrmstr;\n\t}\n\n\treturn val;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);",
      "static char *convert_string_datum(Datum value, Oid typid, bool *failure);",
      "static double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "val"
          ],
          "line": 4469
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "xfrmlen2 <= xfrmlen"
          ],
          "line": 4468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strxfrm",
          "args": [
            "xfrmstr",
            "val",
            "xfrmlen + 1"
          ],
          "line": 4462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "xfrmlen + 1"
          ],
          "line": 4461
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strxfrm",
          "args": [
            "NULL",
            "val",
            "0"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strxfrm",
          "args": [
            "x",
            "val",
            "0"
          ],
          "line": 4446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lc_collate_is_c",
          "args": [
            "DEFAULT_COLLATION_OID"
          ],
          "line": 4422
        },
        "resolved": true,
        "details": {
          "function_name": "lc_collate_is_c",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "1186-1231",
          "snippet": "bool\nlc_collate_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_COLLATE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_COLLATE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->collate_is_c;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\nbool\nlc_collate_is_c(Oid collation)\n{\n\t/*\n\t * If we're asked about \"collation 0\", return false, so that the code will\n\t * go into the non-C path and report that the collation is bogus.\n\t */\n\tif (!OidIsValid(collation))\n\t\treturn false;\n\n\t/*\n\t * If we're asked about the default collation, we have to inquire of the C\n\t * library.  Cache the result so we only have to compute it once.\n\t */\n\tif (collation == DEFAULT_COLLATION_OID)\n\t{\n\t\tstatic int\tresult = -1;\n\t\tchar\t   *localeptr;\n\n\t\tif (result >= 0)\n\t\t\treturn (bool) result;\n\t\tlocaleptr = setlocale(LC_COLLATE, NULL);\n\t\tif (!localeptr)\n\t\t\telog(ERROR, \"invalid LC_COLLATE setting\");\n\n\t\tif (strcmp(localeptr, \"C\") == 0)\n\t\t\tresult = true;\n\t\telse if (strcmp(localeptr, \"POSIX\") == 0)\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\treturn (bool) result;\n\t}\n\n\t/*\n\t * If we're asked about the built-in C/POSIX collations, we know that.\n\t */\n\tif (collation == C_COLLATION_OID ||\n\t\tcollation == POSIX_COLLATION_OID)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, we have to consult pg_collation, but we cache that.\n\t */\n\treturn (lookup_collation_cache(collation, true))->collate_is_c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "NameStr(*nm)"
          ],
          "line": 4414
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*nm"
          ],
          "line": 4414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value"
          ],
          "line": 4412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "value"
          ],
          "line": 4408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetChar",
          "args": [
            "value"
          ],
          "line": 4402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);\nstatic char *convert_string_datum(Datum value, Oid typid, bool *failure);\nstatic double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);\n\nstatic char *\nconvert_string_datum(Datum value, Oid typid, bool *failure)\n{\n\tchar\t   *val;\n\n\tswitch (typid)\n\t{\n\t\tcase CHAROID:\n\t\t\tval = (char *) palloc(2);\n\t\t\tval[0] = DatumGetChar(value);\n\t\t\tval[1] = '\\0';\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\tcase VARCHAROID:\n\t\tcase TEXTOID:\n\t\t\tval = TextDatumGetCString(value);\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\t{\n\t\t\t\tNameData   *nm = (NameData *) DatumGetPointer(value);\n\n\t\t\t\tval = pstrdup(NameStr(*nm));\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\t*failure = true;\n\t\t\treturn NULL;\n\t}\n\n\tif (!lc_collate_is_c(DEFAULT_COLLATION_OID))\n\t{\n\t\tchar\t   *xfrmstr;\n\t\tsize_t\t\txfrmlen;\n\t\tsize_t\t\txfrmlen2 PG_USED_FOR_ASSERTS_ONLY;\n\n\t\t/*\n\t\t * XXX: We could guess at a suitable output buffer size and only call\n\t\t * strxfrm twice if our guess is too small.\n\t\t *\n\t\t * XXX: strxfrm doesn't support UTF-8 encoding on Win32, it can return\n\t\t * bogus data or set an error. This is not really a problem unless it\n\t\t * crashes since it will only give an estimation error and nothing\n\t\t * fatal.\n\t\t */\n#if _MSC_VER == 1400\t\t\t/* VS.Net 2005 */\n\n\t\t/*\n\t\t *\n\t\t * http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=99694\n\t\t */\n\t\t{\n\t\t\tchar\t\tx[1];\n\n\t\t\txfrmlen = strxfrm(x, val, 0);\n\t\t}\n#else\n\t\txfrmlen = strxfrm(NULL, val, 0);\n#endif\n#ifdef WIN32\n\n\t\t/*\n\t\t * On Windows, strxfrm returns INT_MAX when an error occurs. Instead\n\t\t * of trying to allocate this much memory (and fail), just return the\n\t\t * original string unmodified as if we were in the C locale.\n\t\t */\n\t\tif (xfrmlen == INT_MAX)\n\t\t\treturn val;\n#endif\n\t\txfrmstr = (char *) palloc(xfrmlen + 1);\n\t\txfrmlen2 = strxfrm(xfrmstr, val, xfrmlen + 1);\n\n\t\t/*\n\t\t * Some systems (e.g., glibc) can return a smaller value from the\n\t\t * second call than the first; thus the Assert must be <= not ==.\n\t\t */\n\t\tAssert(xfrmlen2 <= xfrmlen);\n\t\tpfree(val);\n\t\tval = xfrmstr;\n\t}\n\n\treturn val;\n}"
  },
  {
    "function_name": "convert_one_string_to_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4342-4382",
    "snippet": "static double\nconvert_one_string_to_scalar(char *value, int rangelo, int rangehi)\n{\n\tint\t\t\tslen = strlen(value);\n\tdouble\t\tnum,\n\t\t\t\tdenom,\n\t\t\t\tbase;\n\n\tif (slen <= 0)\n\t\treturn 0.0;\t\t\t\t/* empty string has scalar value 0 */\n\n\t/*\n\t * There seems little point in considering more than a dozen bytes from\n\t * the string.  Since base is at least 10, that will give us nominal\n\t * resolution of at least 12 decimal digits, which is surely far more\n\t * precision than this estimation technique has got anyway (especially in\n\t * non-C locales).  Also, even with the maximum possible base of 256, this\n\t * ensures denom cannot grow larger than 256^13 = 2.03e31, which will not\n\t * overflow on any known machine.\n\t */\n\tif (slen > 12)\n\t\tslen = 12;\n\n\t/* Convert initial characters to fraction */\n\tbase = rangehi - rangelo + 1;\n\tnum = 0.0;\n\tdenom = base;\n\twhile (slen-- > 0)\n\t{\n\t\tint\t\t\tch = (unsigned char) *value++;\n\n\t\tif (ch < rangelo)\n\t\t\tch = rangelo - 1;\n\t\telse if (ch > rangehi)\n\t\t\tch = rangehi + 1;\n\t\tnum += ((double) (ch - rangelo)) / denom;\n\t\tdenom *= base;\n\t}\n\n\treturn num;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);",
      "static double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 4345
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);\nstatic double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);\n\nstatic double\nconvert_one_string_to_scalar(char *value, int rangelo, int rangehi)\n{\n\tint\t\t\tslen = strlen(value);\n\tdouble\t\tnum,\n\t\t\t\tdenom,\n\t\t\t\tbase;\n\n\tif (slen <= 0)\n\t\treturn 0.0;\t\t\t\t/* empty string has scalar value 0 */\n\n\t/*\n\t * There seems little point in considering more than a dozen bytes from\n\t * the string.  Since base is at least 10, that will give us nominal\n\t * resolution of at least 12 decimal digits, which is surely far more\n\t * precision than this estimation technique has got anyway (especially in\n\t * non-C locales).  Also, even with the maximum possible base of 256, this\n\t * ensures denom cannot grow larger than 256^13 = 2.03e31, which will not\n\t * overflow on any known machine.\n\t */\n\tif (slen > 12)\n\t\tslen = 12;\n\n\t/* Convert initial characters to fraction */\n\tbase = rangehi - rangelo + 1;\n\tnum = 0.0;\n\tdenom = base;\n\twhile (slen-- > 0)\n\t{\n\t\tint\t\t\tch = (unsigned char) *value++;\n\n\t\tif (ch < rangelo)\n\t\t\tch = rangelo - 1;\n\t\telse if (ch > rangehi)\n\t\t\tch = rangehi + 1;\n\t\tnum += ((double) (ch - rangelo)) / denom;\n\t\tdenom *= base;\n\t}\n\n\treturn num;\n}"
  },
  {
    "function_name": "convert_string_to_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4262-4340",
    "snippet": "static void\nconvert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound)\n{\n\tint\t\t\trangelo,\n\t\t\t\trangehi;\n\tchar\t   *sptr;\n\n\trangelo = rangehi = (unsigned char) hibound[0];\n\tfor (sptr = lobound; *sptr; sptr++)\n\t{\n\t\tif (rangelo > (unsigned char) *sptr)\n\t\t\trangelo = (unsigned char) *sptr;\n\t\tif (rangehi < (unsigned char) *sptr)\n\t\t\trangehi = (unsigned char) *sptr;\n\t}\n\tfor (sptr = hibound; *sptr; sptr++)\n\t{\n\t\tif (rangelo > (unsigned char) *sptr)\n\t\t\trangelo = (unsigned char) *sptr;\n\t\tif (rangehi < (unsigned char) *sptr)\n\t\t\trangehi = (unsigned char) *sptr;\n\t}\n\t/* If range includes any upper-case ASCII chars, make it include all */\n\tif (rangelo <= 'Z' && rangehi >= 'A')\n\t{\n\t\tif (rangelo > 'A')\n\t\t\trangelo = 'A';\n\t\tif (rangehi < 'Z')\n\t\t\trangehi = 'Z';\n\t}\n\t/* Ditto lower-case */\n\tif (rangelo <= 'z' && rangehi >= 'a')\n\t{\n\t\tif (rangelo > 'a')\n\t\t\trangelo = 'a';\n\t\tif (rangehi < 'z')\n\t\t\trangehi = 'z';\n\t}\n\t/* Ditto digits */\n\tif (rangelo <= '9' && rangehi >= '0')\n\t{\n\t\tif (rangelo > '0')\n\t\t\trangelo = '0';\n\t\tif (rangehi < '9')\n\t\t\trangehi = '9';\n\t}\n\n\t/*\n\t * If range includes less than 10 chars, assume we have not got enough\n\t * data, and make it include regular ASCII set.\n\t */\n\tif (rangehi - rangelo < 9)\n\t{\n\t\trangelo = ' ';\n\t\trangehi = 127;\n\t}\n\n\t/*\n\t * Now strip any common prefix of the three strings.\n\t */\n\twhile (*lobound)\n\t{\n\t\tif (*lobound != *hibound || *lobound != *value)\n\t\t\tbreak;\n\t\tlobound++, hibound++, value++;\n\t}\n\n\t/*\n\t * Now we can do the conversions.\n\t */\n\t*scaledvalue = convert_one_string_to_scalar(value, rangelo, rangehi);\n\t*scaledlobound = convert_one_string_to_scalar(lobound, rangelo, rangehi);\n\t*scaledhibound = convert_one_string_to_scalar(hibound, rangelo, rangehi);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);",
      "static void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);",
      "static void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);",
      "static double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);",
      "static double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "convert_one_string_to_scalar",
          "args": [
            "hibound",
            "rangelo",
            "rangehi"
          ],
          "line": 4339
        },
        "resolved": true,
        "details": {
          "function_name": "convert_one_string_to_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4342-4382",
          "snippet": "static double\nconvert_one_string_to_scalar(char *value, int rangelo, int rangehi)\n{\n\tint\t\t\tslen = strlen(value);\n\tdouble\t\tnum,\n\t\t\t\tdenom,\n\t\t\t\tbase;\n\n\tif (slen <= 0)\n\t\treturn 0.0;\t\t\t\t/* empty string has scalar value 0 */\n\n\t/*\n\t * There seems little point in considering more than a dozen bytes from\n\t * the string.  Since base is at least 10, that will give us nominal\n\t * resolution of at least 12 decimal digits, which is surely far more\n\t * precision than this estimation technique has got anyway (especially in\n\t * non-C locales).  Also, even with the maximum possible base of 256, this\n\t * ensures denom cannot grow larger than 256^13 = 2.03e31, which will not\n\t * overflow on any known machine.\n\t */\n\tif (slen > 12)\n\t\tslen = 12;\n\n\t/* Convert initial characters to fraction */\n\tbase = rangehi - rangelo + 1;\n\tnum = 0.0;\n\tdenom = base;\n\twhile (slen-- > 0)\n\t{\n\t\tint\t\t\tch = (unsigned char) *value++;\n\n\t\tif (ch < rangelo)\n\t\t\tch = rangelo - 1;\n\t\telse if (ch > rangehi)\n\t\t\tch = rangehi + 1;\n\t\tnum += ((double) (ch - rangelo)) / denom;\n\t\tdenom *= base;\n\t}\n\n\treturn num;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);",
            "static double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);\nstatic double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);\n\nstatic double\nconvert_one_string_to_scalar(char *value, int rangelo, int rangehi)\n{\n\tint\t\t\tslen = strlen(value);\n\tdouble\t\tnum,\n\t\t\t\tdenom,\n\t\t\t\tbase;\n\n\tif (slen <= 0)\n\t\treturn 0.0;\t\t\t\t/* empty string has scalar value 0 */\n\n\t/*\n\t * There seems little point in considering more than a dozen bytes from\n\t * the string.  Since base is at least 10, that will give us nominal\n\t * resolution of at least 12 decimal digits, which is surely far more\n\t * precision than this estimation technique has got anyway (especially in\n\t * non-C locales).  Also, even with the maximum possible base of 256, this\n\t * ensures denom cannot grow larger than 256^13 = 2.03e31, which will not\n\t * overflow on any known machine.\n\t */\n\tif (slen > 12)\n\t\tslen = 12;\n\n\t/* Convert initial characters to fraction */\n\tbase = rangehi - rangelo + 1;\n\tnum = 0.0;\n\tdenom = base;\n\twhile (slen-- > 0)\n\t{\n\t\tint\t\t\tch = (unsigned char) *value++;\n\n\t\tif (ch < rangelo)\n\t\t\tch = rangelo - 1;\n\t\telse if (ch > rangehi)\n\t\t\tch = rangehi + 1;\n\t\tnum += ((double) (ch - rangelo)) / denom;\n\t\tdenom *= base;\n\t}\n\n\treturn num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);\nstatic void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);\nstatic void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);\nstatic double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);\nstatic double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);\n\nstatic void\nconvert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound)\n{\n\tint\t\t\trangelo,\n\t\t\t\trangehi;\n\tchar\t   *sptr;\n\n\trangelo = rangehi = (unsigned char) hibound[0];\n\tfor (sptr = lobound; *sptr; sptr++)\n\t{\n\t\tif (rangelo > (unsigned char) *sptr)\n\t\t\trangelo = (unsigned char) *sptr;\n\t\tif (rangehi < (unsigned char) *sptr)\n\t\t\trangehi = (unsigned char) *sptr;\n\t}\n\tfor (sptr = hibound; *sptr; sptr++)\n\t{\n\t\tif (rangelo > (unsigned char) *sptr)\n\t\t\trangelo = (unsigned char) *sptr;\n\t\tif (rangehi < (unsigned char) *sptr)\n\t\t\trangehi = (unsigned char) *sptr;\n\t}\n\t/* If range includes any upper-case ASCII chars, make it include all */\n\tif (rangelo <= 'Z' && rangehi >= 'A')\n\t{\n\t\tif (rangelo > 'A')\n\t\t\trangelo = 'A';\n\t\tif (rangehi < 'Z')\n\t\t\trangehi = 'Z';\n\t}\n\t/* Ditto lower-case */\n\tif (rangelo <= 'z' && rangehi >= 'a')\n\t{\n\t\tif (rangelo > 'a')\n\t\t\trangelo = 'a';\n\t\tif (rangehi < 'z')\n\t\t\trangehi = 'z';\n\t}\n\t/* Ditto digits */\n\tif (rangelo <= '9' && rangehi >= '0')\n\t{\n\t\tif (rangelo > '0')\n\t\t\trangelo = '0';\n\t\tif (rangehi < '9')\n\t\t\trangehi = '9';\n\t}\n\n\t/*\n\t * If range includes less than 10 chars, assume we have not got enough\n\t * data, and make it include regular ASCII set.\n\t */\n\tif (rangehi - rangelo < 9)\n\t{\n\t\trangelo = ' ';\n\t\trangehi = 127;\n\t}\n\n\t/*\n\t * Now strip any common prefix of the three strings.\n\t */\n\twhile (*lobound)\n\t{\n\t\tif (*lobound != *hibound || *lobound != *value)\n\t\t\tbreak;\n\t\tlobound++, hibound++, value++;\n\t}\n\n\t/*\n\t * Now we can do the conversions.\n\t */\n\t*scaledvalue = convert_one_string_to_scalar(value, rangelo, rangehi);\n\t*scaledlobound = convert_one_string_to_scalar(lobound, rangelo, rangehi);\n\t*scaledhibound = convert_one_string_to_scalar(hibound, rangelo, rangehi);\n}"
  },
  {
    "function_name": "convert_numeric_to_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4201-4240",
    "snippet": "static double\nconvert_numeric_to_scalar(Datum value, Oid typid, bool *failure)\n{\n\tswitch (typid)\n\t{\n\t\tcase BOOLOID:\n\t\t\treturn (double) DatumGetBool(value);\n\t\tcase INT2OID:\n\t\t\treturn (double) DatumGetInt16(value);\n\t\tcase INT4OID:\n\t\t\treturn (double) DatumGetInt32(value);\n\t\tcase INT8OID:\n\t\t\treturn (double) DatumGetInt64(value);\n\t\tcase FLOAT4OID:\n\t\t\treturn (double) DatumGetFloat4(value);\n\t\tcase FLOAT8OID:\n\t\t\treturn (double) DatumGetFloat8(value);\n\t\tcase NUMERICOID:\n\t\t\t/* Note: out-of-range values will be clamped to +-HUGE_VAL */\n\t\t\treturn (double)\n\t\t\t\tDatumGetFloat8(DirectFunctionCall1(numeric_float8_no_overflow,\n\t\t\t\t\t\t\t\t\t\t\t\t   value));\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t/* we can treat OIDs as integers... */\n\t\t\treturn (double) DatumGetObjectId(value);\n\t}\n\n\t*failure = true;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);",
      "static char *convert_string_datum(Datum value, Oid typid, bool *failure);",
      "static double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "value"
          ],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "DirectFunctionCall1(numeric_float8_no_overflow,\n\t\t\t\t\t\t\t\t\t\t\t\t   value)"
          ],
          "line": 4221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "numeric_float8_no_overflow",
            "value"
          ],
          "line": 4221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "value"
          ],
          "line": 4217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat4",
          "args": [
            "value"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt64",
          "args": [
            "value"
          ],
          "line": 4213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "value"
          ],
          "line": 4211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt16",
          "args": [
            "value"
          ],
          "line": 4209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "value"
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);\nstatic char *convert_string_datum(Datum value, Oid typid, bool *failure);\nstatic double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);\n\nstatic double\nconvert_numeric_to_scalar(Datum value, Oid typid, bool *failure)\n{\n\tswitch (typid)\n\t{\n\t\tcase BOOLOID:\n\t\t\treturn (double) DatumGetBool(value);\n\t\tcase INT2OID:\n\t\t\treturn (double) DatumGetInt16(value);\n\t\tcase INT4OID:\n\t\t\treturn (double) DatumGetInt32(value);\n\t\tcase INT8OID:\n\t\t\treturn (double) DatumGetInt64(value);\n\t\tcase FLOAT4OID:\n\t\t\treturn (double) DatumGetFloat4(value);\n\t\tcase FLOAT8OID:\n\t\t\treturn (double) DatumGetFloat8(value);\n\t\tcase NUMERICOID:\n\t\t\t/* Note: out-of-range values will be clamped to +-HUGE_VAL */\n\t\t\treturn (double)\n\t\t\t\tDatumGetFloat8(DirectFunctionCall1(numeric_float8_no_overflow,\n\t\t\t\t\t\t\t\t\t\t\t\t   value));\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t/* we can treat OIDs as integers... */\n\t\t\treturn (double) DatumGetObjectId(value);\n\t}\n\n\t*failure = true;\n\treturn 0;\n}"
  },
  {
    "function_name": "convert_to_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "4052-4193",
    "snippet": "static bool\nconvert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound)\n{\n\tbool\t\tfailure = false;\n\n\t/*\n\t * Both the valuetypid and the boundstypid should exactly match the\n\t * declared input type(s) of the operator we are invoked for.  However,\n\t * extensions might try to use scalarineqsel as estimator for operators\n\t * with input type(s) we don't handle here; in such cases, we want to\n\t * return false, not fail.  In any case, we mustn't assume that valuetypid\n\t * and boundstypid are identical.\n\t *\n\t * XXX The histogram we are interpolating between points of could belong\n\t * to a column that's only binary-compatible with the declared type. In\n\t * essence we are assuming that the semantics of binary-compatible types\n\t * are enough alike that we can use a histogram generated with one type's\n\t * operators to estimate selectivity for the other's.  This is outright\n\t * wrong in some cases --- in particular signed versus unsigned\n\t * interpretation could trip us up.  But it's useful enough in the\n\t * majority of cases that we do it anyway.  Should think about more\n\t * rigorous ways to do it.\n\t */\n\tswitch (valuetypid)\n\t{\n\t\t\t/*\n\t\t\t * Built-in numeric types\n\t\t\t */\n\t\tcase BOOLOID:\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t*scaledvalue = convert_numeric_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledlobound = convert_numeric_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledhibound = convert_numeric_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\treturn !failure;\n\n\t\t\t/*\n\t\t\t * Built-in string types\n\t\t\t */\n\t\tcase CHAROID:\n\t\tcase BPCHAROID:\n\t\tcase VARCHAROID:\n\t\tcase TEXTOID:\n\t\tcase NAMEOID:\n\t\t\t{\n\t\t\t\tchar\t   *valstr = convert_string_datum(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &failure);\n\t\t\t\tchar\t   *lostr = convert_string_datum(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t\tchar\t   *histr = convert_string_datum(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\n\t\t\t\t/*\n\t\t\t\t * Bail out if any of the values is not of string type.  We\n\t\t\t\t * might leak converted strings for the other value(s), but\n\t\t\t\t * that's not worth troubling over.\n\t\t\t\t */\n\t\t\t\tif (failure)\n\t\t\t\t\treturn false;\n\n\t\t\t\tconvert_string_to_scalar(valstr, scaledvalue,\n\t\t\t\t\t\t\t\t\t\t lostr, scaledlobound,\n\t\t\t\t\t\t\t\t\t\t histr, scaledhibound);\n\t\t\t\tpfree(valstr);\n\t\t\t\tpfree(lostr);\n\t\t\t\tpfree(histr);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Built-in bytea type\n\t\t\t */\n\t\tcase BYTEAOID:\n\t\t\t{\n\t\t\t\t/* We only support bytea vs bytea comparison */\n\t\t\t\tif (boundstypid != BYTEAOID)\n\t\t\t\t\treturn false;\n\t\t\t\tconvert_bytea_to_scalar(value, scaledvalue,\n\t\t\t\t\t\t\t\t\t\tlobound, scaledlobound,\n\t\t\t\t\t\t\t\t\t\thibound, scaledhibound);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Built-in time types\n\t\t\t */\n\t\tcase TIMESTAMPOID:\n\t\tcase TIMESTAMPTZOID:\n\t\tcase ABSTIMEOID:\n\t\tcase DATEOID:\n\t\tcase INTERVALOID:\n\t\tcase RELTIMEOID:\n\t\tcase TINTERVALOID:\n\t\tcase TIMEOID:\n\t\tcase TIMETZOID:\n\t\t\t*scaledvalue = convert_timevalue_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledlobound = convert_timevalue_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledhibound = convert_timevalue_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\treturn !failure;\n\n\t\t\t/*\n\t\t\t * Built-in network types\n\t\t\t */\n\t\tcase INETOID:\n\t\tcase CIDROID:\n\t\tcase MACADDROID:\n\t\tcase MACADDR8OID:\n\t\t\t*scaledvalue = convert_network_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledlobound = convert_network_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledhibound = convert_network_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\treturn !failure;\n\t}\n\t/* Don't know how to convert */\n\t*scaledvalue = *scaledlobound = *scaledhibound = 0;\n\treturn false;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);",
      "static double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);",
      "static void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);",
      "static void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);",
      "static char *convert_string_datum(Datum value, Oid typid, bool *failure);",
      "static double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "convert_network_to_scalar",
          "args": [
            "hibound",
            "boundstypid",
            "&failure"
          ],
          "line": 4186
        },
        "resolved": true,
        "details": {
          "function_name": "convert_network_to_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/network.c",
          "lines": "909-962",
          "snippet": "double\nconvert_network_to_scalar(Datum value, Oid typid, bool *failure)\n{\n\tswitch (typid)\n\t{\n\t\tcase INETOID:\n\t\tcase CIDROID:\n\t\t\t{\n\t\t\t\tinet\t   *ip = DatumGetInetPP(value);\n\t\t\t\tint\t\t\tlen;\n\t\t\t\tdouble\t\tres;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/*\n\t\t\t\t * Note that we don't use the full address for IPv6.\n\t\t\t\t */\n\t\t\t\tif (ip_family(ip) == PGSQL_AF_INET)\n\t\t\t\t\tlen = 4;\n\t\t\t\telse\n\t\t\t\t\tlen = 5;\n\n\t\t\t\tres = ip_family(ip);\n\t\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tres *= 256;\n\t\t\t\t\tres += ip_addr(ip)[i];\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\tcase MACADDROID:\n\t\t\t{\n\t\t\t\tmacaddr    *mac = DatumGetMacaddrP(value);\n\t\t\t\tdouble\t\tres;\n\n\t\t\t\tres = (mac->a << 16) | (mac->b << 8) | (mac->c);\n\t\t\t\tres *= 256 * 256 * 256;\n\t\t\t\tres += (mac->d << 16) | (mac->e << 8) | (mac->f);\n\t\t\t\treturn res;\n\t\t\t}\n\t\tcase MACADDR8OID:\n\t\t\t{\n\t\t\t\tmacaddr8   *mac = DatumGetMacaddr8P(value);\n\t\t\t\tdouble\t\tres;\n\n\t\t\t\tres = (mac->a << 24) | (mac->b << 16) | (mac->c << 8) | (mac->d);\n\t\t\t\tres *= ((double) 256) * 256 * 256 * 256;\n\t\t\t\tres += (mac->e << 24) | (mac->f << 16) | (mac->g << 8) | (mac->h);\n\t\t\t\treturn res;\n\t\t\t}\n\t}\n\n\t*failure = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq-be.h\"",
            "#include \"common/ip.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq-be.h\"\n#include \"common/ip.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\ndouble\nconvert_network_to_scalar(Datum value, Oid typid, bool *failure)\n{\n\tswitch (typid)\n\t{\n\t\tcase INETOID:\n\t\tcase CIDROID:\n\t\t\t{\n\t\t\t\tinet\t   *ip = DatumGetInetPP(value);\n\t\t\t\tint\t\t\tlen;\n\t\t\t\tdouble\t\tres;\n\t\t\t\tint\t\t\ti;\n\n\t\t\t\t/*\n\t\t\t\t * Note that we don't use the full address for IPv6.\n\t\t\t\t */\n\t\t\t\tif (ip_family(ip) == PGSQL_AF_INET)\n\t\t\t\t\tlen = 4;\n\t\t\t\telse\n\t\t\t\t\tlen = 5;\n\n\t\t\t\tres = ip_family(ip);\n\t\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tres *= 256;\n\t\t\t\t\tres += ip_addr(ip)[i];\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\tcase MACADDROID:\n\t\t\t{\n\t\t\t\tmacaddr    *mac = DatumGetMacaddrP(value);\n\t\t\t\tdouble\t\tres;\n\n\t\t\t\tres = (mac->a << 16) | (mac->b << 8) | (mac->c);\n\t\t\t\tres *= 256 * 256 * 256;\n\t\t\t\tres += (mac->d << 16) | (mac->e << 8) | (mac->f);\n\t\t\t\treturn res;\n\t\t\t}\n\t\tcase MACADDR8OID:\n\t\t\t{\n\t\t\t\tmacaddr8   *mac = DatumGetMacaddr8P(value);\n\t\t\t\tdouble\t\tres;\n\n\t\t\t\tres = (mac->a << 24) | (mac->b << 16) | (mac->c << 8) | (mac->d);\n\t\t\t\tres *= ((double) 256) * 256 * 256 * 256;\n\t\t\t\tres += (mac->e << 24) | (mac->f << 16) | (mac->g << 8) | (mac->h);\n\t\t\t\treturn res;\n\t\t\t}\n\t}\n\n\t*failure = true;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_timevalue_to_scalar",
          "args": [
            "hibound",
            "boundstypid",
            "&failure"
          ],
          "line": 4171
        },
        "resolved": true,
        "details": {
          "function_name": "convert_timevalue_to_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4578-4627",
          "snippet": "static double\nconvert_timevalue_to_scalar(Datum value, Oid typid, bool *failure)\n{\n\tswitch (typid)\n\t{\n\t\tcase TIMESTAMPOID:\n\t\t\treturn DatumGetTimestamp(value);\n\t\tcase TIMESTAMPTZOID:\n\t\t\treturn DatumGetTimestampTz(value);\n\t\tcase ABSTIMEOID:\n\t\t\treturn DatumGetTimestamp(DirectFunctionCall1(abstime_timestamp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t value));\n\t\tcase DATEOID:\n\t\t\treturn date2timestamp_no_overflow(DatumGetDateADT(value));\n\t\tcase INTERVALOID:\n\t\t\t{\n\t\t\t\tInterval   *interval = DatumGetIntervalP(value);\n\n\t\t\t\t/*\n\t\t\t\t * Convert the month part of Interval to days using assumed\n\t\t\t\t * average month length of 365.25/12.0 days.  Not too\n\t\t\t\t * accurate, but plenty good enough for our purposes.\n\t\t\t\t */\n\t\t\t\treturn interval->time + interval->day * (double) USECS_PER_DAY +\n\t\t\t\t\tinterval->month * ((DAYS_PER_YEAR / (double) MONTHS_PER_YEAR) * USECS_PER_DAY);\n\t\t\t}\n\t\tcase RELTIMEOID:\n\t\t\treturn (DatumGetRelativeTime(value) * 1000000.0);\n\t\tcase TINTERVALOID:\n\t\t\t{\n\t\t\t\tTimeInterval tinterval = DatumGetTimeInterval(value);\n\n\t\t\t\tif (tinterval->status != 0)\n\t\t\t\t\treturn ((tinterval->data[1] - tinterval->data[0]) * 1000000.0);\n\t\t\t\treturn 0;\t\t/* for lack of a better idea */\n\t\t\t}\n\t\tcase TIMEOID:\n\t\t\treturn DatumGetTimeADT(value);\n\t\tcase TIMETZOID:\n\t\t\t{\n\t\t\t\tTimeTzADT  *timetz = DatumGetTimeTzADTP(value);\n\n\t\t\t\t/* use GMT-equivalent time */\n\t\t\t\treturn (double) (timetz->time + (timetz->zone * 1000000.0));\n\t\t\t}\n\t}\n\n\t*failure = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);",
            "static char *convert_string_datum(Datum value, Oid typid, bool *failure);",
            "static double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);\nstatic char *convert_string_datum(Datum value, Oid typid, bool *failure);\nstatic double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);\n\nstatic double\nconvert_timevalue_to_scalar(Datum value, Oid typid, bool *failure)\n{\n\tswitch (typid)\n\t{\n\t\tcase TIMESTAMPOID:\n\t\t\treturn DatumGetTimestamp(value);\n\t\tcase TIMESTAMPTZOID:\n\t\t\treturn DatumGetTimestampTz(value);\n\t\tcase ABSTIMEOID:\n\t\t\treturn DatumGetTimestamp(DirectFunctionCall1(abstime_timestamp,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t value));\n\t\tcase DATEOID:\n\t\t\treturn date2timestamp_no_overflow(DatumGetDateADT(value));\n\t\tcase INTERVALOID:\n\t\t\t{\n\t\t\t\tInterval   *interval = DatumGetIntervalP(value);\n\n\t\t\t\t/*\n\t\t\t\t * Convert the month part of Interval to days using assumed\n\t\t\t\t * average month length of 365.25/12.0 days.  Not too\n\t\t\t\t * accurate, but plenty good enough for our purposes.\n\t\t\t\t */\n\t\t\t\treturn interval->time + interval->day * (double) USECS_PER_DAY +\n\t\t\t\t\tinterval->month * ((DAYS_PER_YEAR / (double) MONTHS_PER_YEAR) * USECS_PER_DAY);\n\t\t\t}\n\t\tcase RELTIMEOID:\n\t\t\treturn (DatumGetRelativeTime(value) * 1000000.0);\n\t\tcase TINTERVALOID:\n\t\t\t{\n\t\t\t\tTimeInterval tinterval = DatumGetTimeInterval(value);\n\n\t\t\t\tif (tinterval->status != 0)\n\t\t\t\t\treturn ((tinterval->data[1] - tinterval->data[0]) * 1000000.0);\n\t\t\t\treturn 0;\t\t/* for lack of a better idea */\n\t\t\t}\n\t\tcase TIMEOID:\n\t\t\treturn DatumGetTimeADT(value);\n\t\tcase TIMETZOID:\n\t\t\t{\n\t\t\t\tTimeTzADT  *timetz = DatumGetTimeTzADTP(value);\n\n\t\t\t\t/* use GMT-equivalent time */\n\t\t\t\treturn (double) (timetz->time + (timetz->zone * 1000000.0));\n\t\t\t}\n\t}\n\n\t*failure = true;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_bytea_to_scalar",
          "args": [
            "value",
            "scaledvalue",
            "lobound",
            "scaledlobound",
            "hibound",
            "scaledhibound"
          ],
          "line": 4149
        },
        "resolved": true,
        "details": {
          "function_name": "convert_bytea_to_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4487-4533",
          "snippet": "static void\nconvert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound)\n{\n\tbytea\t   *valuep = DatumGetByteaPP(value);\n\tbytea\t   *loboundp = DatumGetByteaPP(lobound);\n\tbytea\t   *hiboundp = DatumGetByteaPP(hibound);\n\tint\t\t\trangelo,\n\t\t\t\trangehi,\n\t\t\t\tvaluelen = VARSIZE_ANY_EXHDR(valuep),\n\t\t\t\tloboundlen = VARSIZE_ANY_EXHDR(loboundp),\n\t\t\t\thiboundlen = VARSIZE_ANY_EXHDR(hiboundp),\n\t\t\t\ti,\n\t\t\t\tminlen;\n\tunsigned char *valstr = (unsigned char *) VARDATA_ANY(valuep);\n\tunsigned char *lostr = (unsigned char *) VARDATA_ANY(loboundp);\n\tunsigned char *histr = (unsigned char *) VARDATA_ANY(hiboundp);\n\n\t/*\n\t * Assume bytea data is uniformly distributed across all byte values.\n\t */\n\trangelo = 0;\n\trangehi = 255;\n\n\t/*\n\t * Now strip any common prefix of the three strings.\n\t */\n\tminlen = Min(Min(valuelen, loboundlen), hiboundlen);\n\tfor (i = 0; i < minlen; i++)\n\t{\n\t\tif (*lostr != *histr || *lostr != *valstr)\n\t\t\tbreak;\n\t\tlostr++, histr++, valstr++;\n\t\tloboundlen--, hiboundlen--, valuelen--;\n\t}\n\n\t/*\n\t * Now we can do the conversions.\n\t */\n\t*scaledvalue = convert_one_bytea_to_scalar(valstr, valuelen, rangelo, rangehi);\n\t*scaledlobound = convert_one_bytea_to_scalar(lostr, loboundlen, rangelo, rangehi);\n\t*scaledhibound = convert_one_bytea_to_scalar(histr, hiboundlen, rangelo, rangehi);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);",
            "static void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);",
            "static void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);",
            "static double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);",
            "static double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);\nstatic void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);\nstatic void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);\nstatic double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);\nstatic double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);\n\nstatic void\nconvert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound)\n{\n\tbytea\t   *valuep = DatumGetByteaPP(value);\n\tbytea\t   *loboundp = DatumGetByteaPP(lobound);\n\tbytea\t   *hiboundp = DatumGetByteaPP(hibound);\n\tint\t\t\trangelo,\n\t\t\t\trangehi,\n\t\t\t\tvaluelen = VARSIZE_ANY_EXHDR(valuep),\n\t\t\t\tloboundlen = VARSIZE_ANY_EXHDR(loboundp),\n\t\t\t\thiboundlen = VARSIZE_ANY_EXHDR(hiboundp),\n\t\t\t\ti,\n\t\t\t\tminlen;\n\tunsigned char *valstr = (unsigned char *) VARDATA_ANY(valuep);\n\tunsigned char *lostr = (unsigned char *) VARDATA_ANY(loboundp);\n\tunsigned char *histr = (unsigned char *) VARDATA_ANY(hiboundp);\n\n\t/*\n\t * Assume bytea data is uniformly distributed across all byte values.\n\t */\n\trangelo = 0;\n\trangehi = 255;\n\n\t/*\n\t * Now strip any common prefix of the three strings.\n\t */\n\tminlen = Min(Min(valuelen, loboundlen), hiboundlen);\n\tfor (i = 0; i < minlen; i++)\n\t{\n\t\tif (*lostr != *histr || *lostr != *valstr)\n\t\t\tbreak;\n\t\tlostr++, histr++, valstr++;\n\t\tloboundlen--, hiboundlen--, valuelen--;\n\t}\n\n\t/*\n\t * Now we can do the conversions.\n\t */\n\t*scaledvalue = convert_one_bytea_to_scalar(valstr, valuelen, rangelo, rangehi);\n\t*scaledlobound = convert_one_bytea_to_scalar(lostr, loboundlen, rangelo, rangehi);\n\t*scaledhibound = convert_one_bytea_to_scalar(histr, hiboundlen, rangelo, rangehi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "histr"
          ],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_string_to_scalar",
          "args": [
            "valstr",
            "scaledvalue",
            "lostr",
            "scaledlobound",
            "histr",
            "scaledhibound"
          ],
          "line": 4132
        },
        "resolved": true,
        "details": {
          "function_name": "convert_string_to_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4262-4340",
          "snippet": "static void\nconvert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound)\n{\n\tint\t\t\trangelo,\n\t\t\t\trangehi;\n\tchar\t   *sptr;\n\n\trangelo = rangehi = (unsigned char) hibound[0];\n\tfor (sptr = lobound; *sptr; sptr++)\n\t{\n\t\tif (rangelo > (unsigned char) *sptr)\n\t\t\trangelo = (unsigned char) *sptr;\n\t\tif (rangehi < (unsigned char) *sptr)\n\t\t\trangehi = (unsigned char) *sptr;\n\t}\n\tfor (sptr = hibound; *sptr; sptr++)\n\t{\n\t\tif (rangelo > (unsigned char) *sptr)\n\t\t\trangelo = (unsigned char) *sptr;\n\t\tif (rangehi < (unsigned char) *sptr)\n\t\t\trangehi = (unsigned char) *sptr;\n\t}\n\t/* If range includes any upper-case ASCII chars, make it include all */\n\tif (rangelo <= 'Z' && rangehi >= 'A')\n\t{\n\t\tif (rangelo > 'A')\n\t\t\trangelo = 'A';\n\t\tif (rangehi < 'Z')\n\t\t\trangehi = 'Z';\n\t}\n\t/* Ditto lower-case */\n\tif (rangelo <= 'z' && rangehi >= 'a')\n\t{\n\t\tif (rangelo > 'a')\n\t\t\trangelo = 'a';\n\t\tif (rangehi < 'z')\n\t\t\trangehi = 'z';\n\t}\n\t/* Ditto digits */\n\tif (rangelo <= '9' && rangehi >= '0')\n\t{\n\t\tif (rangelo > '0')\n\t\t\trangelo = '0';\n\t\tif (rangehi < '9')\n\t\t\trangehi = '9';\n\t}\n\n\t/*\n\t * If range includes less than 10 chars, assume we have not got enough\n\t * data, and make it include regular ASCII set.\n\t */\n\tif (rangehi - rangelo < 9)\n\t{\n\t\trangelo = ' ';\n\t\trangehi = 127;\n\t}\n\n\t/*\n\t * Now strip any common prefix of the three strings.\n\t */\n\twhile (*lobound)\n\t{\n\t\tif (*lobound != *hibound || *lobound != *value)\n\t\t\tbreak;\n\t\tlobound++, hibound++, value++;\n\t}\n\n\t/*\n\t * Now we can do the conversions.\n\t */\n\t*scaledvalue = convert_one_string_to_scalar(value, rangelo, rangehi);\n\t*scaledlobound = convert_one_string_to_scalar(lobound, rangelo, rangehi);\n\t*scaledhibound = convert_one_string_to_scalar(hibound, rangelo, rangehi);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);",
            "static void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);",
            "static void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);",
            "static double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);",
            "static double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);\nstatic void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);\nstatic void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);\nstatic double convert_one_string_to_scalar(char *value,\n\t\t\t\t\t\t\t int rangelo, int rangehi);\nstatic double convert_one_bytea_to_scalar(unsigned char *value, int valuelen,\n\t\t\t\t\t\t\tint rangelo, int rangehi);\n\nstatic void\nconvert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound)\n{\n\tint\t\t\trangelo,\n\t\t\t\trangehi;\n\tchar\t   *sptr;\n\n\trangelo = rangehi = (unsigned char) hibound[0];\n\tfor (sptr = lobound; *sptr; sptr++)\n\t{\n\t\tif (rangelo > (unsigned char) *sptr)\n\t\t\trangelo = (unsigned char) *sptr;\n\t\tif (rangehi < (unsigned char) *sptr)\n\t\t\trangehi = (unsigned char) *sptr;\n\t}\n\tfor (sptr = hibound; *sptr; sptr++)\n\t{\n\t\tif (rangelo > (unsigned char) *sptr)\n\t\t\trangelo = (unsigned char) *sptr;\n\t\tif (rangehi < (unsigned char) *sptr)\n\t\t\trangehi = (unsigned char) *sptr;\n\t}\n\t/* If range includes any upper-case ASCII chars, make it include all */\n\tif (rangelo <= 'Z' && rangehi >= 'A')\n\t{\n\t\tif (rangelo > 'A')\n\t\t\trangelo = 'A';\n\t\tif (rangehi < 'Z')\n\t\t\trangehi = 'Z';\n\t}\n\t/* Ditto lower-case */\n\tif (rangelo <= 'z' && rangehi >= 'a')\n\t{\n\t\tif (rangelo > 'a')\n\t\t\trangelo = 'a';\n\t\tif (rangehi < 'z')\n\t\t\trangehi = 'z';\n\t}\n\t/* Ditto digits */\n\tif (rangelo <= '9' && rangehi >= '0')\n\t{\n\t\tif (rangelo > '0')\n\t\t\trangelo = '0';\n\t\tif (rangehi < '9')\n\t\t\trangehi = '9';\n\t}\n\n\t/*\n\t * If range includes less than 10 chars, assume we have not got enough\n\t * data, and make it include regular ASCII set.\n\t */\n\tif (rangehi - rangelo < 9)\n\t{\n\t\trangelo = ' ';\n\t\trangehi = 127;\n\t}\n\n\t/*\n\t * Now strip any common prefix of the three strings.\n\t */\n\twhile (*lobound)\n\t{\n\t\tif (*lobound != *hibound || *lobound != *value)\n\t\t\tbreak;\n\t\tlobound++, hibound++, value++;\n\t}\n\n\t/*\n\t * Now we can do the conversions.\n\t */\n\t*scaledvalue = convert_one_string_to_scalar(value, rangelo, rangehi);\n\t*scaledlobound = convert_one_string_to_scalar(lobound, rangelo, rangehi);\n\t*scaledhibound = convert_one_string_to_scalar(hibound, rangelo, rangehi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_string_datum",
          "args": [
            "hibound",
            "boundstypid",
            "&failure"
          ],
          "line": 4121
        },
        "resolved": true,
        "details": {
          "function_name": "convert_string_datum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4393-4474",
          "snippet": "static char *\nconvert_string_datum(Datum value, Oid typid, bool *failure)\n{\n\tchar\t   *val;\n\n\tswitch (typid)\n\t{\n\t\tcase CHAROID:\n\t\t\tval = (char *) palloc(2);\n\t\t\tval[0] = DatumGetChar(value);\n\t\t\tval[1] = '\\0';\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\tcase VARCHAROID:\n\t\tcase TEXTOID:\n\t\t\tval = TextDatumGetCString(value);\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\t{\n\t\t\t\tNameData   *nm = (NameData *) DatumGetPointer(value);\n\n\t\t\t\tval = pstrdup(NameStr(*nm));\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\t*failure = true;\n\t\t\treturn NULL;\n\t}\n\n\tif (!lc_collate_is_c(DEFAULT_COLLATION_OID))\n\t{\n\t\tchar\t   *xfrmstr;\n\t\tsize_t\t\txfrmlen;\n\t\tsize_t\t\txfrmlen2 PG_USED_FOR_ASSERTS_ONLY;\n\n\t\t/*\n\t\t * XXX: We could guess at a suitable output buffer size and only call\n\t\t * strxfrm twice if our guess is too small.\n\t\t *\n\t\t * XXX: strxfrm doesn't support UTF-8 encoding on Win32, it can return\n\t\t * bogus data or set an error. This is not really a problem unless it\n\t\t * crashes since it will only give an estimation error and nothing\n\t\t * fatal.\n\t\t */\n#if _MSC_VER == 1400\t\t\t/* VS.Net 2005 */\n\n\t\t/*\n\t\t *\n\t\t * http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=99694\n\t\t */\n\t\t{\n\t\t\tchar\t\tx[1];\n\n\t\t\txfrmlen = strxfrm(x, val, 0);\n\t\t}\n#else\n\t\txfrmlen = strxfrm(NULL, val, 0);\n#endif\n#ifdef WIN32\n\n\t\t/*\n\t\t * On Windows, strxfrm returns INT_MAX when an error occurs. Instead\n\t\t * of trying to allocate this much memory (and fail), just return the\n\t\t * original string unmodified as if we were in the C locale.\n\t\t */\n\t\tif (xfrmlen == INT_MAX)\n\t\t\treturn val;\n#endif\n\t\txfrmstr = (char *) palloc(xfrmlen + 1);\n\t\txfrmlen2 = strxfrm(xfrmstr, val, xfrmlen + 1);\n\n\t\t/*\n\t\t * Some systems (e.g., glibc) can return a smaller value from the\n\t\t * second call than the first; thus the Assert must be <= not ==.\n\t\t */\n\t\tAssert(xfrmlen2 <= xfrmlen);\n\t\tpfree(val);\n\t\tval = xfrmstr;\n\t}\n\n\treturn val;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);",
            "static char *convert_string_datum(Datum value, Oid typid, bool *failure);",
            "static double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);\nstatic char *convert_string_datum(Datum value, Oid typid, bool *failure);\nstatic double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);\n\nstatic char *\nconvert_string_datum(Datum value, Oid typid, bool *failure)\n{\n\tchar\t   *val;\n\n\tswitch (typid)\n\t{\n\t\tcase CHAROID:\n\t\t\tval = (char *) palloc(2);\n\t\t\tval[0] = DatumGetChar(value);\n\t\t\tval[1] = '\\0';\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\tcase VARCHAROID:\n\t\tcase TEXTOID:\n\t\t\tval = TextDatumGetCString(value);\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\t{\n\t\t\t\tNameData   *nm = (NameData *) DatumGetPointer(value);\n\n\t\t\t\tval = pstrdup(NameStr(*nm));\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\t*failure = true;\n\t\t\treturn NULL;\n\t}\n\n\tif (!lc_collate_is_c(DEFAULT_COLLATION_OID))\n\t{\n\t\tchar\t   *xfrmstr;\n\t\tsize_t\t\txfrmlen;\n\t\tsize_t\t\txfrmlen2 PG_USED_FOR_ASSERTS_ONLY;\n\n\t\t/*\n\t\t * XXX: We could guess at a suitable output buffer size and only call\n\t\t * strxfrm twice if our guess is too small.\n\t\t *\n\t\t * XXX: strxfrm doesn't support UTF-8 encoding on Win32, it can return\n\t\t * bogus data or set an error. This is not really a problem unless it\n\t\t * crashes since it will only give an estimation error and nothing\n\t\t * fatal.\n\t\t */\n#if _MSC_VER == 1400\t\t\t/* VS.Net 2005 */\n\n\t\t/*\n\t\t *\n\t\t * http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=99694\n\t\t */\n\t\t{\n\t\t\tchar\t\tx[1];\n\n\t\t\txfrmlen = strxfrm(x, val, 0);\n\t\t}\n#else\n\t\txfrmlen = strxfrm(NULL, val, 0);\n#endif\n#ifdef WIN32\n\n\t\t/*\n\t\t * On Windows, strxfrm returns INT_MAX when an error occurs. Instead\n\t\t * of trying to allocate this much memory (and fail), just return the\n\t\t * original string unmodified as if we were in the C locale.\n\t\t */\n\t\tif (xfrmlen == INT_MAX)\n\t\t\treturn val;\n#endif\n\t\txfrmstr = (char *) palloc(xfrmlen + 1);\n\t\txfrmlen2 = strxfrm(xfrmstr, val, xfrmlen + 1);\n\n\t\t/*\n\t\t * Some systems (e.g., glibc) can return a smaller value from the\n\t\t * second call than the first; thus the Assert must be <= not ==.\n\t\t */\n\t\tAssert(xfrmlen2 <= xfrmlen);\n\t\tpfree(val);\n\t\tval = xfrmstr;\n\t}\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "convert_numeric_to_scalar",
          "args": [
            "hibound",
            "boundstypid",
            "&failure"
          ],
          "line": 4104
        },
        "resolved": true,
        "details": {
          "function_name": "convert_numeric_to_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4201-4240",
          "snippet": "static double\nconvert_numeric_to_scalar(Datum value, Oid typid, bool *failure)\n{\n\tswitch (typid)\n\t{\n\t\tcase BOOLOID:\n\t\t\treturn (double) DatumGetBool(value);\n\t\tcase INT2OID:\n\t\t\treturn (double) DatumGetInt16(value);\n\t\tcase INT4OID:\n\t\t\treturn (double) DatumGetInt32(value);\n\t\tcase INT8OID:\n\t\t\treturn (double) DatumGetInt64(value);\n\t\tcase FLOAT4OID:\n\t\t\treturn (double) DatumGetFloat4(value);\n\t\tcase FLOAT8OID:\n\t\t\treturn (double) DatumGetFloat8(value);\n\t\tcase NUMERICOID:\n\t\t\t/* Note: out-of-range values will be clamped to +-HUGE_VAL */\n\t\t\treturn (double)\n\t\t\t\tDatumGetFloat8(DirectFunctionCall1(numeric_float8_no_overflow,\n\t\t\t\t\t\t\t\t\t\t\t\t   value));\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t/* we can treat OIDs as integers... */\n\t\t\treturn (double) DatumGetObjectId(value);\n\t}\n\n\t*failure = true;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);",
            "static char *convert_string_datum(Datum value, Oid typid, bool *failure);",
            "static double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);\nstatic char *convert_string_datum(Datum value, Oid typid, bool *failure);\nstatic double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);\n\nstatic double\nconvert_numeric_to_scalar(Datum value, Oid typid, bool *failure)\n{\n\tswitch (typid)\n\t{\n\t\tcase BOOLOID:\n\t\t\treturn (double) DatumGetBool(value);\n\t\tcase INT2OID:\n\t\t\treturn (double) DatumGetInt16(value);\n\t\tcase INT4OID:\n\t\t\treturn (double) DatumGetInt32(value);\n\t\tcase INT8OID:\n\t\t\treturn (double) DatumGetInt64(value);\n\t\tcase FLOAT4OID:\n\t\t\treturn (double) DatumGetFloat4(value);\n\t\tcase FLOAT8OID:\n\t\t\treturn (double) DatumGetFloat8(value);\n\t\tcase NUMERICOID:\n\t\t\t/* Note: out-of-range values will be clamped to +-HUGE_VAL */\n\t\t\treturn (double)\n\t\t\t\tDatumGetFloat8(DirectFunctionCall1(numeric_float8_no_overflow,\n\t\t\t\t\t\t\t\t\t\t\t\t   value));\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t/* we can treat OIDs as integers... */\n\t\t\treturn (double) DatumGetObjectId(value);\n\t}\n\n\t*failure = true;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);\nstatic double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);\nstatic void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);\nstatic void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);\nstatic char *convert_string_datum(Datum value, Oid typid, bool *failure);\nstatic double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);\n\nstatic bool\nconvert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound)\n{\n\tbool\t\tfailure = false;\n\n\t/*\n\t * Both the valuetypid and the boundstypid should exactly match the\n\t * declared input type(s) of the operator we are invoked for.  However,\n\t * extensions might try to use scalarineqsel as estimator for operators\n\t * with input type(s) we don't handle here; in such cases, we want to\n\t * return false, not fail.  In any case, we mustn't assume that valuetypid\n\t * and boundstypid are identical.\n\t *\n\t * XXX The histogram we are interpolating between points of could belong\n\t * to a column that's only binary-compatible with the declared type. In\n\t * essence we are assuming that the semantics of binary-compatible types\n\t * are enough alike that we can use a histogram generated with one type's\n\t * operators to estimate selectivity for the other's.  This is outright\n\t * wrong in some cases --- in particular signed versus unsigned\n\t * interpretation could trip us up.  But it's useful enough in the\n\t * majority of cases that we do it anyway.  Should think about more\n\t * rigorous ways to do it.\n\t */\n\tswitch (valuetypid)\n\t{\n\t\t\t/*\n\t\t\t * Built-in numeric types\n\t\t\t */\n\t\tcase BOOLOID:\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t*scaledvalue = convert_numeric_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledlobound = convert_numeric_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledhibound = convert_numeric_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\treturn !failure;\n\n\t\t\t/*\n\t\t\t * Built-in string types\n\t\t\t */\n\t\tcase CHAROID:\n\t\tcase BPCHAROID:\n\t\tcase VARCHAROID:\n\t\tcase TEXTOID:\n\t\tcase NAMEOID:\n\t\t\t{\n\t\t\t\tchar\t   *valstr = convert_string_datum(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &failure);\n\t\t\t\tchar\t   *lostr = convert_string_datum(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t\tchar\t   *histr = convert_string_datum(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\n\t\t\t\t/*\n\t\t\t\t * Bail out if any of the values is not of string type.  We\n\t\t\t\t * might leak converted strings for the other value(s), but\n\t\t\t\t * that's not worth troubling over.\n\t\t\t\t */\n\t\t\t\tif (failure)\n\t\t\t\t\treturn false;\n\n\t\t\t\tconvert_string_to_scalar(valstr, scaledvalue,\n\t\t\t\t\t\t\t\t\t\t lostr, scaledlobound,\n\t\t\t\t\t\t\t\t\t\t histr, scaledhibound);\n\t\t\t\tpfree(valstr);\n\t\t\t\tpfree(lostr);\n\t\t\t\tpfree(histr);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Built-in bytea type\n\t\t\t */\n\t\tcase BYTEAOID:\n\t\t\t{\n\t\t\t\t/* We only support bytea vs bytea comparison */\n\t\t\t\tif (boundstypid != BYTEAOID)\n\t\t\t\t\treturn false;\n\t\t\t\tconvert_bytea_to_scalar(value, scaledvalue,\n\t\t\t\t\t\t\t\t\t\tlobound, scaledlobound,\n\t\t\t\t\t\t\t\t\t\thibound, scaledhibound);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Built-in time types\n\t\t\t */\n\t\tcase TIMESTAMPOID:\n\t\tcase TIMESTAMPTZOID:\n\t\tcase ABSTIMEOID:\n\t\tcase DATEOID:\n\t\tcase INTERVALOID:\n\t\tcase RELTIMEOID:\n\t\tcase TINTERVALOID:\n\t\tcase TIMEOID:\n\t\tcase TIMETZOID:\n\t\t\t*scaledvalue = convert_timevalue_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledlobound = convert_timevalue_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledhibound = convert_timevalue_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\treturn !failure;\n\n\t\t\t/*\n\t\t\t * Built-in network types\n\t\t\t */\n\t\tcase INETOID:\n\t\tcase CIDROID:\n\t\tcase MACADDROID:\n\t\tcase MACADDR8OID:\n\t\t\t*scaledvalue = convert_network_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledlobound = convert_network_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledhibound = convert_network_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\treturn !failure;\n\t}\n\t/* Don't know how to convert */\n\t*scaledvalue = *scaledlobound = *scaledhibound = 0;\n\treturn false;\n}"
  },
  {
    "function_name": "estimate_multivariate_ndistinct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "3905-4021",
    "snippet": "static bool\nestimate_multivariate_ndistinct(PlannerInfo *root, RelOptInfo *rel,\n\t\t\t\t\t\t\t\tList **varinfos, double *ndistinct)\n{\n\tListCell   *lc;\n\tBitmapset  *attnums = NULL;\n\tint\t\t\tnmatches;\n\tOid\t\t\tstatOid = InvalidOid;\n\tMVNDistinct *stats;\n\tBitmapset  *matched = NULL;\n\n\t/* bail out immediately if the table has no extended statistics */\n\tif (!rel->statlist)\n\t\treturn false;\n\n\t/* Determine the attnums we're looking for */\n\tforeach(lc, *varinfos)\n\t{\n\t\tGroupVarInfo *varinfo = (GroupVarInfo *) lfirst(lc);\n\n\t\tAssert(varinfo->rel == rel);\n\n\t\tif (IsA(varinfo->var, Var))\n\t\t{\n\t\t\tattnums = bms_add_member(attnums,\n\t\t\t\t\t\t\t\t\t ((Var *) varinfo->var)->varattno);\n\t\t}\n\t}\n\n\t/* look for the ndistinct statistics matching the most vars */\n\tnmatches = 1;\t\t\t\t/* we require at least two matches */\n\tforeach(lc, rel->statlist)\n\t{\n\t\tStatisticExtInfo *info = (StatisticExtInfo *) lfirst(lc);\n\t\tBitmapset  *shared;\n\t\tint\t\t\tnshared;\n\n\t\t/* skip statistics of other kinds */\n\t\tif (info->kind != STATS_EXT_NDISTINCT)\n\t\t\tcontinue;\n\n\t\t/* compute attnums shared by the vars and the statistics object */\n\t\tshared = bms_intersect(info->keys, attnums);\n\t\tnshared = bms_num_members(shared);\n\n\t\t/*\n\t\t * Does this statistics object match more columns than the currently\n\t\t * best object?  If so, use this one instead.\n\t\t *\n\t\t * XXX This should break ties using name of the object, or something\n\t\t * like that, to make the outcome stable.\n\t\t */\n\t\tif (nshared > nmatches)\n\t\t{\n\t\t\tstatOid = info->statOid;\n\t\t\tnmatches = nshared;\n\t\t\tmatched = shared;\n\t\t}\n\t}\n\n\t/* No match? */\n\tif (statOid == InvalidOid)\n\t\treturn false;\n\tAssert(nmatches > 1 && matched != NULL);\n\n\tstats = statext_ndistinct_load(statOid);\n\n\t/*\n\t * If we have a match, search it for the specific item that matches (there\n\t * must be one), and construct the output values.\n\t */\n\tif (stats)\n\t{\n\t\tint\t\t\ti;\n\t\tList\t   *newlist = NIL;\n\t\tMVNDistinctItem *item = NULL;\n\n\t\t/* Find the specific item that exactly matches the combination */\n\t\tfor (i = 0; i < stats->nitems; i++)\n\t\t{\n\t\t\tMVNDistinctItem *tmpitem = &stats->items[i];\n\n\t\t\tif (bms_subset_compare(tmpitem->attrs, matched) == BMS_EQUAL)\n\t\t\t{\n\t\t\t\titem = tmpitem;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* make sure we found an item */\n\t\tif (!item)\n\t\t\telog(ERROR, \"corrupt MVNDistinct entry\");\n\n\t\t/* Form the output varinfo list, keeping only unmatched ones */\n\t\tforeach(lc, *varinfos)\n\t\t{\n\t\t\tGroupVarInfo *varinfo = (GroupVarInfo *) lfirst(lc);\n\t\t\tAttrNumber\tattnum;\n\n\t\t\tif (!IsA(varinfo->var, Var))\n\t\t\t{\n\t\t\t\tnewlist = lappend(newlist, varinfo);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tattnum = ((Var *) varinfo->var)->varattno;\n\t\t\tif (!bms_is_member(attnum, matched))\n\t\t\t\tnewlist = lappend(newlist, varinfo);\n\t\t}\n\n\t\t*varinfos = newlist;\n\t\t*ndistinct = item->ndistinct;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "newlist",
            "varinfo"
          ],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_is_member",
          "args": [
            "attnum",
            "matched"
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "newlist",
            "varinfo"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "varinfo->var",
            "Var"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "*varinfos"
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"corrupt MVNDistinct entry\""
          ],
          "line": 3996
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bms_subset_compare",
          "args": [
            "tmpitem->attrs",
            "matched"
          ],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statext_ndistinct_load",
          "args": [
            "statOid"
          ],
          "line": 3970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nmatches > 1 && matched != NULL"
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_num_members",
          "args": [
            "shared"
          ],
          "line": 3948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_intersect",
          "args": [
            "info->keys",
            "attnums"
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "rel->statlist"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_add_member",
          "args": [
            "attnums",
            "((Var *) varinfo->var)->varattno"
          ],
          "line": 3929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "varinfo->var",
            "Var"
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "varinfo->rel == rel"
          ],
          "line": 3925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "*varinfos"
          ],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\n\nstatic bool\nestimate_multivariate_ndistinct(PlannerInfo *root, RelOptInfo *rel,\n\t\t\t\t\t\t\t\tList **varinfos, double *ndistinct)\n{\n\tListCell   *lc;\n\tBitmapset  *attnums = NULL;\n\tint\t\t\tnmatches;\n\tOid\t\t\tstatOid = InvalidOid;\n\tMVNDistinct *stats;\n\tBitmapset  *matched = NULL;\n\n\t/* bail out immediately if the table has no extended statistics */\n\tif (!rel->statlist)\n\t\treturn false;\n\n\t/* Determine the attnums we're looking for */\n\tforeach(lc, *varinfos)\n\t{\n\t\tGroupVarInfo *varinfo = (GroupVarInfo *) lfirst(lc);\n\n\t\tAssert(varinfo->rel == rel);\n\n\t\tif (IsA(varinfo->var, Var))\n\t\t{\n\t\t\tattnums = bms_add_member(attnums,\n\t\t\t\t\t\t\t\t\t ((Var *) varinfo->var)->varattno);\n\t\t}\n\t}\n\n\t/* look for the ndistinct statistics matching the most vars */\n\tnmatches = 1;\t\t\t\t/* we require at least two matches */\n\tforeach(lc, rel->statlist)\n\t{\n\t\tStatisticExtInfo *info = (StatisticExtInfo *) lfirst(lc);\n\t\tBitmapset  *shared;\n\t\tint\t\t\tnshared;\n\n\t\t/* skip statistics of other kinds */\n\t\tif (info->kind != STATS_EXT_NDISTINCT)\n\t\t\tcontinue;\n\n\t\t/* compute attnums shared by the vars and the statistics object */\n\t\tshared = bms_intersect(info->keys, attnums);\n\t\tnshared = bms_num_members(shared);\n\n\t\t/*\n\t\t * Does this statistics object match more columns than the currently\n\t\t * best object?  If so, use this one instead.\n\t\t *\n\t\t * XXX This should break ties using name of the object, or something\n\t\t * like that, to make the outcome stable.\n\t\t */\n\t\tif (nshared > nmatches)\n\t\t{\n\t\t\tstatOid = info->statOid;\n\t\t\tnmatches = nshared;\n\t\t\tmatched = shared;\n\t\t}\n\t}\n\n\t/* No match? */\n\tif (statOid == InvalidOid)\n\t\treturn false;\n\tAssert(nmatches > 1 && matched != NULL);\n\n\tstats = statext_ndistinct_load(statOid);\n\n\t/*\n\t * If we have a match, search it for the specific item that matches (there\n\t * must be one), and construct the output values.\n\t */\n\tif (stats)\n\t{\n\t\tint\t\t\ti;\n\t\tList\t   *newlist = NIL;\n\t\tMVNDistinctItem *item = NULL;\n\n\t\t/* Find the specific item that exactly matches the combination */\n\t\tfor (i = 0; i < stats->nitems; i++)\n\t\t{\n\t\t\tMVNDistinctItem *tmpitem = &stats->items[i];\n\n\t\t\tif (bms_subset_compare(tmpitem->attrs, matched) == BMS_EQUAL)\n\t\t\t{\n\t\t\t\titem = tmpitem;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* make sure we found an item */\n\t\tif (!item)\n\t\t\telog(ERROR, \"corrupt MVNDistinct entry\");\n\n\t\t/* Form the output varinfo list, keeping only unmatched ones */\n\t\tforeach(lc, *varinfos)\n\t\t{\n\t\t\tGroupVarInfo *varinfo = (GroupVarInfo *) lfirst(lc);\n\t\t\tAttrNumber\tattnum;\n\n\t\t\tif (!IsA(varinfo->var, Var))\n\t\t\t{\n\t\t\t\tnewlist = lappend(newlist, varinfo);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tattnum = ((Var *) varinfo->var)->varattno;\n\t\t\tif (!bms_is_member(attnum, matched))\n\t\t\t\tnewlist = lappend(newlist, varinfo);\n\t\t}\n\n\t\t*varinfos = newlist;\n\t\t*ndistinct = item->ndistinct;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "estimate_hash_bucket_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "3781-3885",
    "snippet": "void\nestimate_hash_bucket_stats(PlannerInfo *root, Node *hashkey, double nbuckets,\n\t\t\t\t\t\t   Selectivity *mcv_freq,\n\t\t\t\t\t\t   Selectivity *bucketsize_frac)\n{\n\tVariableStatData vardata;\n\tdouble\t\testfract,\n\t\t\t\tndistinct,\n\t\t\t\tstanullfrac,\n\t\t\t\tavgfreq;\n\tbool\t\tisdefault;\n\tAttStatsSlot sslot;\n\n\texamine_variable(root, hashkey, 0, &vardata);\n\n\t/* Look up the frequency of the most common value, if available */\n\t*mcv_freq = 0.0;\n\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tif (get_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\t/*\n\t\t\t * The first MCV stat is for the most common value.\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0)\n\t\t\t\t*mcv_freq = sslot.numbers[0];\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t}\n\n\t/* Get number of distinct values */\n\tndistinct = get_variable_numdistinct(&vardata, &isdefault);\n\n\t/*\n\t * If ndistinct isn't real, punt.  We normally return 0.1, but if the\n\t * mcv_freq is known to be even higher than that, use it instead.\n\t */\n\tif (isdefault)\n\t{\n\t\t*bucketsize_frac = (Selectivity) Max(0.1, *mcv_freq);\n\t\tReleaseVariableStats(vardata);\n\t\treturn;\n\t}\n\n\t/* Get fraction that are null */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse\n\t\tstanullfrac = 0.0;\n\n\t/* Compute avg freq of all distinct data values in raw relation */\n\tavgfreq = (1.0 - stanullfrac) / ndistinct;\n\n\t/*\n\t * Adjust ndistinct to account for restriction clauses.  Observe we are\n\t * assuming that the data distribution is affected uniformly by the\n\t * restriction clauses!\n\t *\n\t * XXX Possibly better way, but much more expensive: multiply by\n\t * selectivity of rel's restriction clauses that mention the target Var.\n\t */\n\tif (vardata.rel && vardata.rel->tuples > 0)\n\t{\n\t\tndistinct *= vardata.rel->rows / vardata.rel->tuples;\n\t\tndistinct = clamp_row_est(ndistinct);\n\t}\n\n\t/*\n\t * Initial estimate of bucketsize fraction is 1/nbuckets as long as the\n\t * number of buckets is less than the expected number of distinct values;\n\t * otherwise it is 1/ndistinct.\n\t */\n\tif (ndistinct > nbuckets)\n\t\testfract = 1.0 / nbuckets;\n\telse\n\t\testfract = 1.0 / ndistinct;\n\n\t/*\n\t * Adjust estimated bucketsize upward to account for skewed distribution.\n\t */\n\tif (avgfreq > 0.0 && *mcv_freq > avgfreq)\n\t\testfract *= *mcv_freq / avgfreq;\n\n\t/*\n\t * Clamp bucketsize to sane range (the above adjustment could easily\n\t * produce an out-of-range result).  We set the lower bound a little above\n\t * zero, since zero isn't a very sane result.\n\t */\n\tif (estfract < 1.0e-6)\n\t\testfract = 1.0e-6;\n\telse if (estfract > 1.0)\n\t\testfract = 1.0;\n\n\t*bucketsize_frac = (Selectivity) estfract;\n\n\tReleaseVariableStats(vardata);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_row_est",
          "args": [
            "ndistinct"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 3824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "0.1",
            "*mcv_freq"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_variable_numdistinct",
          "args": [
            "&vardata",
            "&isdefault"
          ],
          "line": 3815
        },
        "resolved": true,
        "details": {
          "function_name": "get_variable_numdistinct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5196-5318",
          "snippet": "double\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot",
            "vardata.statsTuple",
            "STATISTIC_KIND_MCV",
            "InvalidOid",
            "ATTSTATSSLOT_NUMBERS"
          ],
          "line": 3801
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "examine_variable",
          "args": [
            "root",
            "hashkey",
            "0",
            "&vardata"
          ],
          "line": 3794
        },
        "resolved": true,
        "details": {
          "function_name": "examine_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4775-4984",
          "snippet": "void\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "get_index_stats_hook_type get_index_stats_hook = NULL;",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nestimate_hash_bucket_stats(PlannerInfo *root, Node *hashkey, double nbuckets,\n\t\t\t\t\t\t   Selectivity *mcv_freq,\n\t\t\t\t\t\t   Selectivity *bucketsize_frac)\n{\n\tVariableStatData vardata;\n\tdouble\t\testfract,\n\t\t\t\tndistinct,\n\t\t\t\tstanullfrac,\n\t\t\t\tavgfreq;\n\tbool\t\tisdefault;\n\tAttStatsSlot sslot;\n\n\texamine_variable(root, hashkey, 0, &vardata);\n\n\t/* Look up the frequency of the most common value, if available */\n\t*mcv_freq = 0.0;\n\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tif (get_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\t/*\n\t\t\t * The first MCV stat is for the most common value.\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0)\n\t\t\t\t*mcv_freq = sslot.numbers[0];\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t}\n\n\t/* Get number of distinct values */\n\tndistinct = get_variable_numdistinct(&vardata, &isdefault);\n\n\t/*\n\t * If ndistinct isn't real, punt.  We normally return 0.1, but if the\n\t * mcv_freq is known to be even higher than that, use it instead.\n\t */\n\tif (isdefault)\n\t{\n\t\t*bucketsize_frac = (Selectivity) Max(0.1, *mcv_freq);\n\t\tReleaseVariableStats(vardata);\n\t\treturn;\n\t}\n\n\t/* Get fraction that are null */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse\n\t\tstanullfrac = 0.0;\n\n\t/* Compute avg freq of all distinct data values in raw relation */\n\tavgfreq = (1.0 - stanullfrac) / ndistinct;\n\n\t/*\n\t * Adjust ndistinct to account for restriction clauses.  Observe we are\n\t * assuming that the data distribution is affected uniformly by the\n\t * restriction clauses!\n\t *\n\t * XXX Possibly better way, but much more expensive: multiply by\n\t * selectivity of rel's restriction clauses that mention the target Var.\n\t */\n\tif (vardata.rel && vardata.rel->tuples > 0)\n\t{\n\t\tndistinct *= vardata.rel->rows / vardata.rel->tuples;\n\t\tndistinct = clamp_row_est(ndistinct);\n\t}\n\n\t/*\n\t * Initial estimate of bucketsize fraction is 1/nbuckets as long as the\n\t * number of buckets is less than the expected number of distinct values;\n\t * otherwise it is 1/ndistinct.\n\t */\n\tif (ndistinct > nbuckets)\n\t\testfract = 1.0 / nbuckets;\n\telse\n\t\testfract = 1.0 / ndistinct;\n\n\t/*\n\t * Adjust estimated bucketsize upward to account for skewed distribution.\n\t */\n\tif (avgfreq > 0.0 && *mcv_freq > avgfreq)\n\t\testfract *= *mcv_freq / avgfreq;\n\n\t/*\n\t * Clamp bucketsize to sane range (the above adjustment could easily\n\t * produce an out-of-range result).  We set the lower bound a little above\n\t * zero, since zero isn't a very sane result.\n\t */\n\tif (estfract < 1.0e-6)\n\t\testfract = 1.0e-6;\n\telse if (estfract > 1.0)\n\t\testfract = 1.0;\n\n\t*bucketsize_frac = (Selectivity) estfract;\n\n\tReleaseVariableStats(vardata);\n}"
  },
  {
    "function_name": "estimate_num_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "3418-3736",
    "snippet": "double\nestimate_num_groups(PlannerInfo *root, List *groupExprs, double input_rows,\n\t\t\t\t\tList **pgset)\n{\n\tList\t   *varinfos = NIL;\n\tdouble\t\tsrf_multiplier = 1.0;\n\tdouble\t\tnumdistinct;\n\tListCell   *l;\n\tint\t\t\ti;\n\n\t/*\n\t * We don't ever want to return an estimate of zero groups, as that tends\n\t * to lead to division-by-zero and other unpleasantness.  The input_rows\n\t * estimate is usually already at least 1, but clamp it just in case it\n\t * isn't.\n\t */\n\tinput_rows = clamp_row_est(input_rows);\n\n\t/*\n\t * If no grouping columns, there's exactly one group.  (This can't happen\n\t * for normal cases with GROUP BY or DISTINCT, but it is possible for\n\t * corner cases with set operations.)\n\t */\n\tif (groupExprs == NIL || (pgset && list_length(*pgset) < 1))\n\t\treturn 1.0;\n\n\t/*\n\t * Count groups derived from boolean grouping expressions.  For other\n\t * expressions, find the unique Vars used, treating an expression as a Var\n\t * if we can find stats for it.  For each one, record the statistical\n\t * estimate of number of distinct values (total in its table, without\n\t * regard for filtering).\n\t */\n\tnumdistinct = 1.0;\n\n\ti = 0;\n\tforeach(l, groupExprs)\n\t{\n\t\tNode\t   *groupexpr = (Node *) lfirst(l);\n\t\tdouble\t\tthis_srf_multiplier;\n\t\tVariableStatData vardata;\n\t\tList\t   *varshere;\n\t\tListCell   *l2;\n\n\t\t/* is expression in this grouping set? */\n\t\tif (pgset && !list_member_int(*pgset, i++))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Set-returning functions in grouping columns are a bit problematic.\n\t\t * The code below will effectively ignore their SRF nature and come up\n\t\t * with a numdistinct estimate as though they were scalar functions.\n\t\t * We compensate by scaling up the end result by the largest SRF\n\t\t * rowcount estimate.  (This will be an overestimate if the SRF\n\t\t * produces multiple copies of any output value, but it seems best to\n\t\t * assume the SRF's outputs are distinct.  In any case, it's probably\n\t\t * pointless to worry too much about this without much better\n\t\t * estimates for SRF output rowcounts than we have today.)\n\t\t */\n\t\tthis_srf_multiplier = expression_returns_set_rows(groupexpr);\n\t\tif (srf_multiplier < this_srf_multiplier)\n\t\t\tsrf_multiplier = this_srf_multiplier;\n\n\t\t/* Short-circuit for expressions returning boolean */\n\t\tif (exprType(groupexpr) == BOOLOID)\n\t\t{\n\t\t\tnumdistinct *= 2.0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If examine_variable is able to deduce anything about the GROUP BY\n\t\t * expression, treat it as a single variable even if it's really more\n\t\t * complicated.\n\t\t */\n\t\texamine_variable(root, groupexpr, 0, &vardata);\n\t\tif (HeapTupleIsValid(vardata.statsTuple) || vardata.isunique)\n\t\t{\n\t\t\tvarinfos = add_unique_group_var(root, varinfos,\n\t\t\t\t\t\t\t\t\t\t\tgroupexpr, &vardata);\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tcontinue;\n\t\t}\n\t\tReleaseVariableStats(vardata);\n\n\t\t/*\n\t\t * Else pull out the component Vars.  Handle PlaceHolderVars by\n\t\t * recursing into their arguments (effectively assuming that the\n\t\t * PlaceHolderVar doesn't change the number of groups, which boils\n\t\t * down to ignoring the possible addition of nulls to the result set).\n\t\t */\n\t\tvarshere = pull_var_clause(groupexpr,\n\t\t\t\t\t\t\t\t   PVC_RECURSE_AGGREGATES |\n\t\t\t\t\t\t\t\t   PVC_RECURSE_WINDOWFUNCS |\n\t\t\t\t\t\t\t\t   PVC_RECURSE_PLACEHOLDERS);\n\n\t\t/*\n\t\t * If we find any variable-free GROUP BY item, then either it is a\n\t\t * constant (and we can ignore it) or it contains a volatile function;\n\t\t * in the latter case we punt and assume that each input row will\n\t\t * yield a distinct group.\n\t\t */\n\t\tif (varshere == NIL)\n\t\t{\n\t\t\tif (contain_volatile_functions(groupexpr))\n\t\t\t\treturn input_rows;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Else add variables to varinfos list\n\t\t */\n\t\tforeach(l2, varshere)\n\t\t{\n\t\t\tNode\t   *var = (Node *) lfirst(l2);\n\n\t\t\texamine_variable(root, var, 0, &vardata);\n\t\t\tvarinfos = add_unique_group_var(root, varinfos, var, &vardata);\n\t\t\tReleaseVariableStats(vardata);\n\t\t}\n\t}\n\n\t/*\n\t * If now no Vars, we must have an all-constant or all-boolean GROUP BY\n\t * list.\n\t */\n\tif (varinfos == NIL)\n\t{\n\t\t/* Apply SRF multiplier as we would do in the long path */\n\t\tnumdistinct *= srf_multiplier;\n\t\t/* Round off */\n\t\tnumdistinct = ceil(numdistinct);\n\t\t/* Guard against out-of-range answers */\n\t\tif (numdistinct > input_rows)\n\t\t\tnumdistinct = input_rows;\n\t\tif (numdistinct < 1.0)\n\t\t\tnumdistinct = 1.0;\n\t\treturn numdistinct;\n\t}\n\n\t/*\n\t * Group Vars by relation and estimate total numdistinct.\n\t *\n\t * For each iteration of the outer loop, we process the frontmost Var in\n\t * varinfos, plus all other Vars in the same relation.  We remove these\n\t * Vars from the newvarinfos list for the next iteration. This is the\n\t * easiest way to group Vars of same rel together.\n\t */\n\tdo\n\t{\n\t\tGroupVarInfo *varinfo1 = (GroupVarInfo *) linitial(varinfos);\n\t\tRelOptInfo *rel = varinfo1->rel;\n\t\tdouble\t\treldistinct = 1;\n\t\tdouble\t\trelmaxndistinct = reldistinct;\n\t\tint\t\t\trelvarcount = 0;\n\t\tList\t   *newvarinfos = NIL;\n\t\tList\t   *relvarinfos = NIL;\n\n\t\t/*\n\t\t * Split the list of varinfos in two - one for the current rel, one\n\t\t * for remaining Vars on other rels.\n\t\t */\n\t\trelvarinfos = lcons(varinfo1, relvarinfos);\n\t\tfor_each_cell(l, lnext(list_head(varinfos)))\n\t\t{\n\t\t\tGroupVarInfo *varinfo2 = (GroupVarInfo *) lfirst(l);\n\n\t\t\tif (varinfo2->rel == varinfo1->rel)\n\t\t\t{\n\t\t\t\t/* varinfos on current rel */\n\t\t\t\trelvarinfos = lcons(varinfo2, relvarinfos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not time to process varinfo2 yet */\n\t\t\t\tnewvarinfos = lcons(varinfo2, newvarinfos);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Get the numdistinct estimate for the Vars of this rel.  We\n\t\t * iteratively search for multivariate n-distinct with maximum number\n\t\t * of vars; assuming that each var group is independent of the others,\n\t\t * we multiply them together.  Any remaining relvarinfos after no more\n\t\t * multivariate matches are found are assumed independent too, so\n\t\t * their individual ndistinct estimates are multiplied also.\n\t\t *\n\t\t * While iterating, count how many separate numdistinct values we\n\t\t * apply.  We apply a fudge factor below, but only if we multiplied\n\t\t * more than one such values.\n\t\t */\n\t\twhile (relvarinfos)\n\t\t{\n\t\t\tdouble\t\tmvndistinct;\n\n\t\t\tif (estimate_multivariate_ndistinct(root, rel, &relvarinfos,\n\t\t\t\t\t\t\t\t\t\t\t\t&mvndistinct))\n\t\t\t{\n\t\t\t\treldistinct *= mvndistinct;\n\t\t\t\tif (relmaxndistinct < mvndistinct)\n\t\t\t\t\trelmaxndistinct = mvndistinct;\n\t\t\t\trelvarcount++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tforeach(l, relvarinfos)\n\t\t\t\t{\n\t\t\t\t\tGroupVarInfo *varinfo2 = (GroupVarInfo *) lfirst(l);\n\n\t\t\t\t\treldistinct *= varinfo2->ndistinct;\n\t\t\t\t\tif (relmaxndistinct < varinfo2->ndistinct)\n\t\t\t\t\t\trelmaxndistinct = varinfo2->ndistinct;\n\t\t\t\t\trelvarcount++;\n\t\t\t\t}\n\n\t\t\t\t/* we're done with this relation */\n\t\t\t\trelvarinfos = NIL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Sanity check --- don't divide by zero if empty relation.\n\t\t */\n\t\tAssert(IS_SIMPLE_REL(rel));\n\t\tif (rel->tuples > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Clamp to size of rel, or size of rel / 10 if multiple Vars. The\n\t\t\t * fudge factor is because the Vars are probably correlated but we\n\t\t\t * don't know by how much.  We should never clamp to less than the\n\t\t\t * largest ndistinct value for any of the Vars, though, since\n\t\t\t * there will surely be at least that many groups.\n\t\t\t */\n\t\t\tdouble\t\tclamp = rel->tuples;\n\n\t\t\tif (relvarcount > 1)\n\t\t\t{\n\t\t\t\tclamp *= 0.1;\n\t\t\t\tif (clamp < relmaxndistinct)\n\t\t\t\t{\n\t\t\t\t\tclamp = relmaxndistinct;\n\t\t\t\t\t/* for sanity in case some ndistinct is too large: */\n\t\t\t\t\tif (clamp > rel->tuples)\n\t\t\t\t\t\tclamp = rel->tuples;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reldistinct > clamp)\n\t\t\t\treldistinct = clamp;\n\n\t\t\t/*\n\t\t\t * Update the estimate based on the restriction selectivity,\n\t\t\t * guarding against division by zero when reldistinct is zero.\n\t\t\t * Also skip this if we know that we are returning all rows.\n\t\t\t */\n\t\t\tif (reldistinct > 0 && rel->rows < rel->tuples)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Given a table containing N rows with n distinct values in a\n\t\t\t\t * uniform distribution, if we select p rows at random then\n\t\t\t\t * the expected number of distinct values selected is\n\t\t\t\t *\n\t\t\t\t * n * (1 - product((N-N/n-i)/(N-i), i=0..p-1))\n\t\t\t\t *\n\t\t\t\t * = n * (1 - (N-N/n)! / (N-N/n-p)! * (N-p)! / N!)\n\t\t\t\t *\n\t\t\t\t * See \"Approximating block accesses in database\n\t\t\t\t * organizations\", S. B. Yao, Communications of the ACM,\n\t\t\t\t * Volume 20 Issue 4, April 1977 Pages 260-261.\n\t\t\t\t *\n\t\t\t\t * Alternatively, re-arranging the terms from the factorials,\n\t\t\t\t * this may be written as\n\t\t\t\t *\n\t\t\t\t * n * (1 - product((N-p-i)/(N-i), i=0..N/n-1))\n\t\t\t\t *\n\t\t\t\t * This form of the formula is more efficient to compute in\n\t\t\t\t * the common case where p is larger than N/n.  Additionally,\n\t\t\t\t * as pointed out by Dell'Era, if i << N for all terms in the\n\t\t\t\t * product, it can be approximated by\n\t\t\t\t *\n\t\t\t\t * n * (1 - ((N-p)/N)^(N/n))\n\t\t\t\t *\n\t\t\t\t * See \"Expected distinct values when selecting from a bag\n\t\t\t\t * without replacement\", Alberto Dell'Era,\n\t\t\t\t * http://www.adellera.it/investigations/distinct_balls/.\n\t\t\t\t *\n\t\t\t\t * The condition i << N is equivalent to n >> 1, so this is a\n\t\t\t\t * good approximation when the number of distinct values in\n\t\t\t\t * the table is large.  It turns out that this formula also\n\t\t\t\t * works well even when n is small.\n\t\t\t\t */\n\t\t\t\treldistinct *=\n\t\t\t\t\t(1 - pow((rel->tuples - rel->rows) / rel->tuples,\n\t\t\t\t\t\t\t rel->tuples / reldistinct));\n\t\t\t}\n\t\t\treldistinct = clamp_row_est(reldistinct);\n\n\t\t\t/*\n\t\t\t * Update estimate of total distinct groups.\n\t\t\t */\n\t\t\tnumdistinct *= reldistinct;\n\t\t}\n\n\t\tvarinfos = newvarinfos;\n\t} while (varinfos != NIL);\n\n\t/* Now we can account for the effects of any SRFs */\n\tnumdistinct *= srf_multiplier;\n\n\t/* Round off */\n\tnumdistinct = ceil(numdistinct);\n\n\t/* Guard against out-of-range answers */\n\tif (numdistinct > input_rows)\n\t\tnumdistinct = input_rows;\n\tif (numdistinct < 1.0)\n\t\tnumdistinct = 1.0;\n\n\treturn numdistinct;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceil",
          "args": [
            "numdistinct"
          ],
          "line": 3727
        },
        "resolved": true,
        "details": {
          "function_name": "dceil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "1547-1553",
          "snippet": "Datum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndceil(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\targ1 = PG_GETARG_FLOAT8(0);\n\n\tPG_RETURN_FLOAT8(ceil(arg1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clamp_row_est",
          "args": [
            "reldistinct"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "(rel->tuples - rel->rows) / rel->tuples",
            "rel->tuples / reldistinct"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IS_SIMPLE_REL(rel)"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SIMPLE_REL",
          "args": [
            "rel"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 3625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "relvarinfos"
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimate_multivariate_ndistinct",
          "args": [
            "root",
            "rel",
            "&relvarinfos",
            "&mvndistinct"
          ],
          "line": 3613
        },
        "resolved": true,
        "details": {
          "function_name": "estimate_multivariate_ndistinct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "3905-4021",
          "snippet": "static bool\nestimate_multivariate_ndistinct(PlannerInfo *root, RelOptInfo *rel,\n\t\t\t\t\t\t\t\tList **varinfos, double *ndistinct)\n{\n\tListCell   *lc;\n\tBitmapset  *attnums = NULL;\n\tint\t\t\tnmatches;\n\tOid\t\t\tstatOid = InvalidOid;\n\tMVNDistinct *stats;\n\tBitmapset  *matched = NULL;\n\n\t/* bail out immediately if the table has no extended statistics */\n\tif (!rel->statlist)\n\t\treturn false;\n\n\t/* Determine the attnums we're looking for */\n\tforeach(lc, *varinfos)\n\t{\n\t\tGroupVarInfo *varinfo = (GroupVarInfo *) lfirst(lc);\n\n\t\tAssert(varinfo->rel == rel);\n\n\t\tif (IsA(varinfo->var, Var))\n\t\t{\n\t\t\tattnums = bms_add_member(attnums,\n\t\t\t\t\t\t\t\t\t ((Var *) varinfo->var)->varattno);\n\t\t}\n\t}\n\n\t/* look for the ndistinct statistics matching the most vars */\n\tnmatches = 1;\t\t\t\t/* we require at least two matches */\n\tforeach(lc, rel->statlist)\n\t{\n\t\tStatisticExtInfo *info = (StatisticExtInfo *) lfirst(lc);\n\t\tBitmapset  *shared;\n\t\tint\t\t\tnshared;\n\n\t\t/* skip statistics of other kinds */\n\t\tif (info->kind != STATS_EXT_NDISTINCT)\n\t\t\tcontinue;\n\n\t\t/* compute attnums shared by the vars and the statistics object */\n\t\tshared = bms_intersect(info->keys, attnums);\n\t\tnshared = bms_num_members(shared);\n\n\t\t/*\n\t\t * Does this statistics object match more columns than the currently\n\t\t * best object?  If so, use this one instead.\n\t\t *\n\t\t * XXX This should break ties using name of the object, or something\n\t\t * like that, to make the outcome stable.\n\t\t */\n\t\tif (nshared > nmatches)\n\t\t{\n\t\t\tstatOid = info->statOid;\n\t\t\tnmatches = nshared;\n\t\t\tmatched = shared;\n\t\t}\n\t}\n\n\t/* No match? */\n\tif (statOid == InvalidOid)\n\t\treturn false;\n\tAssert(nmatches > 1 && matched != NULL);\n\n\tstats = statext_ndistinct_load(statOid);\n\n\t/*\n\t * If we have a match, search it for the specific item that matches (there\n\t * must be one), and construct the output values.\n\t */\n\tif (stats)\n\t{\n\t\tint\t\t\ti;\n\t\tList\t   *newlist = NIL;\n\t\tMVNDistinctItem *item = NULL;\n\n\t\t/* Find the specific item that exactly matches the combination */\n\t\tfor (i = 0; i < stats->nitems; i++)\n\t\t{\n\t\t\tMVNDistinctItem *tmpitem = &stats->items[i];\n\n\t\t\tif (bms_subset_compare(tmpitem->attrs, matched) == BMS_EQUAL)\n\t\t\t{\n\t\t\t\titem = tmpitem;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* make sure we found an item */\n\t\tif (!item)\n\t\t\telog(ERROR, \"corrupt MVNDistinct entry\");\n\n\t\t/* Form the output varinfo list, keeping only unmatched ones */\n\t\tforeach(lc, *varinfos)\n\t\t{\n\t\t\tGroupVarInfo *varinfo = (GroupVarInfo *) lfirst(lc);\n\t\t\tAttrNumber\tattnum;\n\n\t\t\tif (!IsA(varinfo->var, Var))\n\t\t\t{\n\t\t\t\tnewlist = lappend(newlist, varinfo);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tattnum = ((Var *) varinfo->var)->varattno;\n\t\t\tif (!bms_is_member(attnum, matched))\n\t\t\t\tnewlist = lappend(newlist, varinfo);\n\t\t}\n\n\t\t*varinfos = newlist;\n\t\t*ndistinct = item->ndistinct;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\n\nstatic bool\nestimate_multivariate_ndistinct(PlannerInfo *root, RelOptInfo *rel,\n\t\t\t\t\t\t\t\tList **varinfos, double *ndistinct)\n{\n\tListCell   *lc;\n\tBitmapset  *attnums = NULL;\n\tint\t\t\tnmatches;\n\tOid\t\t\tstatOid = InvalidOid;\n\tMVNDistinct *stats;\n\tBitmapset  *matched = NULL;\n\n\t/* bail out immediately if the table has no extended statistics */\n\tif (!rel->statlist)\n\t\treturn false;\n\n\t/* Determine the attnums we're looking for */\n\tforeach(lc, *varinfos)\n\t{\n\t\tGroupVarInfo *varinfo = (GroupVarInfo *) lfirst(lc);\n\n\t\tAssert(varinfo->rel == rel);\n\n\t\tif (IsA(varinfo->var, Var))\n\t\t{\n\t\t\tattnums = bms_add_member(attnums,\n\t\t\t\t\t\t\t\t\t ((Var *) varinfo->var)->varattno);\n\t\t}\n\t}\n\n\t/* look for the ndistinct statistics matching the most vars */\n\tnmatches = 1;\t\t\t\t/* we require at least two matches */\n\tforeach(lc, rel->statlist)\n\t{\n\t\tStatisticExtInfo *info = (StatisticExtInfo *) lfirst(lc);\n\t\tBitmapset  *shared;\n\t\tint\t\t\tnshared;\n\n\t\t/* skip statistics of other kinds */\n\t\tif (info->kind != STATS_EXT_NDISTINCT)\n\t\t\tcontinue;\n\n\t\t/* compute attnums shared by the vars and the statistics object */\n\t\tshared = bms_intersect(info->keys, attnums);\n\t\tnshared = bms_num_members(shared);\n\n\t\t/*\n\t\t * Does this statistics object match more columns than the currently\n\t\t * best object?  If so, use this one instead.\n\t\t *\n\t\t * XXX This should break ties using name of the object, or something\n\t\t * like that, to make the outcome stable.\n\t\t */\n\t\tif (nshared > nmatches)\n\t\t{\n\t\t\tstatOid = info->statOid;\n\t\t\tnmatches = nshared;\n\t\t\tmatched = shared;\n\t\t}\n\t}\n\n\t/* No match? */\n\tif (statOid == InvalidOid)\n\t\treturn false;\n\tAssert(nmatches > 1 && matched != NULL);\n\n\tstats = statext_ndistinct_load(statOid);\n\n\t/*\n\t * If we have a match, search it for the specific item that matches (there\n\t * must be one), and construct the output values.\n\t */\n\tif (stats)\n\t{\n\t\tint\t\t\ti;\n\t\tList\t   *newlist = NIL;\n\t\tMVNDistinctItem *item = NULL;\n\n\t\t/* Find the specific item that exactly matches the combination */\n\t\tfor (i = 0; i < stats->nitems; i++)\n\t\t{\n\t\t\tMVNDistinctItem *tmpitem = &stats->items[i];\n\n\t\t\tif (bms_subset_compare(tmpitem->attrs, matched) == BMS_EQUAL)\n\t\t\t{\n\t\t\t\titem = tmpitem;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* make sure we found an item */\n\t\tif (!item)\n\t\t\telog(ERROR, \"corrupt MVNDistinct entry\");\n\n\t\t/* Form the output varinfo list, keeping only unmatched ones */\n\t\tforeach(lc, *varinfos)\n\t\t{\n\t\t\tGroupVarInfo *varinfo = (GroupVarInfo *) lfirst(lc);\n\t\t\tAttrNumber\tattnum;\n\n\t\t\tif (!IsA(varinfo->var, Var))\n\t\t\t{\n\t\t\t\tnewlist = lappend(newlist, varinfo);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tattnum = ((Var *) varinfo->var)->varattno;\n\t\t\tif (!bms_is_member(attnum, matched))\n\t\t\t\tnewlist = lappend(newlist, varinfo);\n\t\t}\n\n\t\t*varinfos = newlist;\n\t\t*ndistinct = item->ndistinct;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "varinfo2",
            "newvarinfos"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "varinfo2",
            "relvarinfos"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cell",
          "args": [
            "l",
            "lnext(list_head(varinfos))"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnext",
          "args": [
            "list_head(varinfos)"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_head",
          "args": [
            "varinfos"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "varinfo1",
            "relvarinfos"
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "varinfos"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_unique_group_var",
          "args": [
            "root",
            "varinfos",
            "var",
            "&vardata"
          ],
          "line": 3535
        },
        "resolved": true,
        "details": {
          "function_name": "add_unique_group_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "3300-3351",
          "snippet": "static List *\nadd_unique_group_var(PlannerInfo *root, List *varinfos,\n\t\t\t\t\t Node *var, VariableStatData *vardata)\n{\n\tGroupVarInfo *varinfo;\n\tdouble\t\tndistinct;\n\tbool\t\tisdefault;\n\tListCell   *lc;\n\n\tndistinct = get_variable_numdistinct(vardata, &isdefault);\n\n\t/* cannot use foreach here because of possible list_delete */\n\tlc = list_head(varinfos);\n\twhile (lc)\n\t{\n\t\tvarinfo = (GroupVarInfo *) lfirst(lc);\n\n\t\t/* must advance lc before list_delete possibly pfree's it */\n\t\tlc = lnext(lc);\n\n\t\t/* Drop exact duplicates */\n\t\tif (equal(var, varinfo->var))\n\t\t\treturn varinfos;\n\n\t\t/*\n\t\t * Drop known-equal vars, but only if they belong to different\n\t\t * relations (see comments for estimate_num_groups)\n\t\t */\n\t\tif (vardata->rel != varinfo->rel &&\n\t\t\texprs_known_equal(root, var, varinfo->var))\n\t\t{\n\t\t\tif (varinfo->ndistinct <= ndistinct)\n\t\t\t{\n\t\t\t\t/* Keep older item, forget new one */\n\t\t\t\treturn varinfos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Delete the older item */\n\t\t\t\tvarinfos = list_delete_ptr(varinfos, varinfo);\n\t\t\t}\n\t\t}\n\t}\n\n\tvarinfo = (GroupVarInfo *) palloc(sizeof(GroupVarInfo));\n\n\tvarinfo->var = var;\n\tvarinfo->rel = vardata->rel;\n\tvarinfo->ndistinct = ndistinct;\n\tvarinfos = lappend(varinfos, varinfo);\n\treturn varinfos;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic List *\nadd_unique_group_var(PlannerInfo *root, List *varinfos,\n\t\t\t\t\t Node *var, VariableStatData *vardata)\n{\n\tGroupVarInfo *varinfo;\n\tdouble\t\tndistinct;\n\tbool\t\tisdefault;\n\tListCell   *lc;\n\n\tndistinct = get_variable_numdistinct(vardata, &isdefault);\n\n\t/* cannot use foreach here because of possible list_delete */\n\tlc = list_head(varinfos);\n\twhile (lc)\n\t{\n\t\tvarinfo = (GroupVarInfo *) lfirst(lc);\n\n\t\t/* must advance lc before list_delete possibly pfree's it */\n\t\tlc = lnext(lc);\n\n\t\t/* Drop exact duplicates */\n\t\tif (equal(var, varinfo->var))\n\t\t\treturn varinfos;\n\n\t\t/*\n\t\t * Drop known-equal vars, but only if they belong to different\n\t\t * relations (see comments for estimate_num_groups)\n\t\t */\n\t\tif (vardata->rel != varinfo->rel &&\n\t\t\texprs_known_equal(root, var, varinfo->var))\n\t\t{\n\t\t\tif (varinfo->ndistinct <= ndistinct)\n\t\t\t{\n\t\t\t\t/* Keep older item, forget new one */\n\t\t\t\treturn varinfos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Delete the older item */\n\t\t\t\tvarinfos = list_delete_ptr(varinfos, varinfo);\n\t\t\t}\n\t\t}\n\t}\n\n\tvarinfo = (GroupVarInfo *) palloc(sizeof(GroupVarInfo));\n\n\tvarinfo->var = var;\n\tvarinfo->rel = vardata->rel;\n\tvarinfo->ndistinct = ndistinct;\n\tvarinfos = lappend(varinfos, varinfo);\n\treturn varinfos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "examine_variable",
          "args": [
            "root",
            "var",
            "0",
            "&vardata"
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "examine_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4775-4984",
          "snippet": "void\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "get_index_stats_hook_type get_index_stats_hook = NULL;",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l2"
          ],
          "line": 3532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l2",
            "varshere"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contain_volatile_functions",
          "args": [
            "groupexpr"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pull_var_clause",
          "args": [
            "groupexpr",
            "PVC_RECURSE_AGGREGATES |\n\t\t\t\t\t\t\t\t   PVC_RECURSE_WINDOWFUNCS |\n\t\t\t\t\t\t\t\t   PVC_RECURSE_PLACEHOLDERS"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "groupexpr"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expression_returns_set_rows",
          "args": [
            "groupexpr"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_member_int",
          "args": [
            "*pgset",
            "i++"
          ],
          "line": 3463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "groupExprs"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "*pgset"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp_row_est",
          "args": [
            "input_rows"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nestimate_num_groups(PlannerInfo *root, List *groupExprs, double input_rows,\n\t\t\t\t\tList **pgset)\n{\n\tList\t   *varinfos = NIL;\n\tdouble\t\tsrf_multiplier = 1.0;\n\tdouble\t\tnumdistinct;\n\tListCell   *l;\n\tint\t\t\ti;\n\n\t/*\n\t * We don't ever want to return an estimate of zero groups, as that tends\n\t * to lead to division-by-zero and other unpleasantness.  The input_rows\n\t * estimate is usually already at least 1, but clamp it just in case it\n\t * isn't.\n\t */\n\tinput_rows = clamp_row_est(input_rows);\n\n\t/*\n\t * If no grouping columns, there's exactly one group.  (This can't happen\n\t * for normal cases with GROUP BY or DISTINCT, but it is possible for\n\t * corner cases with set operations.)\n\t */\n\tif (groupExprs == NIL || (pgset && list_length(*pgset) < 1))\n\t\treturn 1.0;\n\n\t/*\n\t * Count groups derived from boolean grouping expressions.  For other\n\t * expressions, find the unique Vars used, treating an expression as a Var\n\t * if we can find stats for it.  For each one, record the statistical\n\t * estimate of number of distinct values (total in its table, without\n\t * regard for filtering).\n\t */\n\tnumdistinct = 1.0;\n\n\ti = 0;\n\tforeach(l, groupExprs)\n\t{\n\t\tNode\t   *groupexpr = (Node *) lfirst(l);\n\t\tdouble\t\tthis_srf_multiplier;\n\t\tVariableStatData vardata;\n\t\tList\t   *varshere;\n\t\tListCell   *l2;\n\n\t\t/* is expression in this grouping set? */\n\t\tif (pgset && !list_member_int(*pgset, i++))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Set-returning functions in grouping columns are a bit problematic.\n\t\t * The code below will effectively ignore their SRF nature and come up\n\t\t * with a numdistinct estimate as though they were scalar functions.\n\t\t * We compensate by scaling up the end result by the largest SRF\n\t\t * rowcount estimate.  (This will be an overestimate if the SRF\n\t\t * produces multiple copies of any output value, but it seems best to\n\t\t * assume the SRF's outputs are distinct.  In any case, it's probably\n\t\t * pointless to worry too much about this without much better\n\t\t * estimates for SRF output rowcounts than we have today.)\n\t\t */\n\t\tthis_srf_multiplier = expression_returns_set_rows(groupexpr);\n\t\tif (srf_multiplier < this_srf_multiplier)\n\t\t\tsrf_multiplier = this_srf_multiplier;\n\n\t\t/* Short-circuit for expressions returning boolean */\n\t\tif (exprType(groupexpr) == BOOLOID)\n\t\t{\n\t\t\tnumdistinct *= 2.0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If examine_variable is able to deduce anything about the GROUP BY\n\t\t * expression, treat it as a single variable even if it's really more\n\t\t * complicated.\n\t\t */\n\t\texamine_variable(root, groupexpr, 0, &vardata);\n\t\tif (HeapTupleIsValid(vardata.statsTuple) || vardata.isunique)\n\t\t{\n\t\t\tvarinfos = add_unique_group_var(root, varinfos,\n\t\t\t\t\t\t\t\t\t\t\tgroupexpr, &vardata);\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tcontinue;\n\t\t}\n\t\tReleaseVariableStats(vardata);\n\n\t\t/*\n\t\t * Else pull out the component Vars.  Handle PlaceHolderVars by\n\t\t * recursing into their arguments (effectively assuming that the\n\t\t * PlaceHolderVar doesn't change the number of groups, which boils\n\t\t * down to ignoring the possible addition of nulls to the result set).\n\t\t */\n\t\tvarshere = pull_var_clause(groupexpr,\n\t\t\t\t\t\t\t\t   PVC_RECURSE_AGGREGATES |\n\t\t\t\t\t\t\t\t   PVC_RECURSE_WINDOWFUNCS |\n\t\t\t\t\t\t\t\t   PVC_RECURSE_PLACEHOLDERS);\n\n\t\t/*\n\t\t * If we find any variable-free GROUP BY item, then either it is a\n\t\t * constant (and we can ignore it) or it contains a volatile function;\n\t\t * in the latter case we punt and assume that each input row will\n\t\t * yield a distinct group.\n\t\t */\n\t\tif (varshere == NIL)\n\t\t{\n\t\t\tif (contain_volatile_functions(groupexpr))\n\t\t\t\treturn input_rows;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Else add variables to varinfos list\n\t\t */\n\t\tforeach(l2, varshere)\n\t\t{\n\t\t\tNode\t   *var = (Node *) lfirst(l2);\n\n\t\t\texamine_variable(root, var, 0, &vardata);\n\t\t\tvarinfos = add_unique_group_var(root, varinfos, var, &vardata);\n\t\t\tReleaseVariableStats(vardata);\n\t\t}\n\t}\n\n\t/*\n\t * If now no Vars, we must have an all-constant or all-boolean GROUP BY\n\t * list.\n\t */\n\tif (varinfos == NIL)\n\t{\n\t\t/* Apply SRF multiplier as we would do in the long path */\n\t\tnumdistinct *= srf_multiplier;\n\t\t/* Round off */\n\t\tnumdistinct = ceil(numdistinct);\n\t\t/* Guard against out-of-range answers */\n\t\tif (numdistinct > input_rows)\n\t\t\tnumdistinct = input_rows;\n\t\tif (numdistinct < 1.0)\n\t\t\tnumdistinct = 1.0;\n\t\treturn numdistinct;\n\t}\n\n\t/*\n\t * Group Vars by relation and estimate total numdistinct.\n\t *\n\t * For each iteration of the outer loop, we process the frontmost Var in\n\t * varinfos, plus all other Vars in the same relation.  We remove these\n\t * Vars from the newvarinfos list for the next iteration. This is the\n\t * easiest way to group Vars of same rel together.\n\t */\n\tdo\n\t{\n\t\tGroupVarInfo *varinfo1 = (GroupVarInfo *) linitial(varinfos);\n\t\tRelOptInfo *rel = varinfo1->rel;\n\t\tdouble\t\treldistinct = 1;\n\t\tdouble\t\trelmaxndistinct = reldistinct;\n\t\tint\t\t\trelvarcount = 0;\n\t\tList\t   *newvarinfos = NIL;\n\t\tList\t   *relvarinfos = NIL;\n\n\t\t/*\n\t\t * Split the list of varinfos in two - one for the current rel, one\n\t\t * for remaining Vars on other rels.\n\t\t */\n\t\trelvarinfos = lcons(varinfo1, relvarinfos);\n\t\tfor_each_cell(l, lnext(list_head(varinfos)))\n\t\t{\n\t\t\tGroupVarInfo *varinfo2 = (GroupVarInfo *) lfirst(l);\n\n\t\t\tif (varinfo2->rel == varinfo1->rel)\n\t\t\t{\n\t\t\t\t/* varinfos on current rel */\n\t\t\t\trelvarinfos = lcons(varinfo2, relvarinfos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not time to process varinfo2 yet */\n\t\t\t\tnewvarinfos = lcons(varinfo2, newvarinfos);\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Get the numdistinct estimate for the Vars of this rel.  We\n\t\t * iteratively search for multivariate n-distinct with maximum number\n\t\t * of vars; assuming that each var group is independent of the others,\n\t\t * we multiply them together.  Any remaining relvarinfos after no more\n\t\t * multivariate matches are found are assumed independent too, so\n\t\t * their individual ndistinct estimates are multiplied also.\n\t\t *\n\t\t * While iterating, count how many separate numdistinct values we\n\t\t * apply.  We apply a fudge factor below, but only if we multiplied\n\t\t * more than one such values.\n\t\t */\n\t\twhile (relvarinfos)\n\t\t{\n\t\t\tdouble\t\tmvndistinct;\n\n\t\t\tif (estimate_multivariate_ndistinct(root, rel, &relvarinfos,\n\t\t\t\t\t\t\t\t\t\t\t\t&mvndistinct))\n\t\t\t{\n\t\t\t\treldistinct *= mvndistinct;\n\t\t\t\tif (relmaxndistinct < mvndistinct)\n\t\t\t\t\trelmaxndistinct = mvndistinct;\n\t\t\t\trelvarcount++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tforeach(l, relvarinfos)\n\t\t\t\t{\n\t\t\t\t\tGroupVarInfo *varinfo2 = (GroupVarInfo *) lfirst(l);\n\n\t\t\t\t\treldistinct *= varinfo2->ndistinct;\n\t\t\t\t\tif (relmaxndistinct < varinfo2->ndistinct)\n\t\t\t\t\t\trelmaxndistinct = varinfo2->ndistinct;\n\t\t\t\t\trelvarcount++;\n\t\t\t\t}\n\n\t\t\t\t/* we're done with this relation */\n\t\t\t\trelvarinfos = NIL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Sanity check --- don't divide by zero if empty relation.\n\t\t */\n\t\tAssert(IS_SIMPLE_REL(rel));\n\t\tif (rel->tuples > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Clamp to size of rel, or size of rel / 10 if multiple Vars. The\n\t\t\t * fudge factor is because the Vars are probably correlated but we\n\t\t\t * don't know by how much.  We should never clamp to less than the\n\t\t\t * largest ndistinct value for any of the Vars, though, since\n\t\t\t * there will surely be at least that many groups.\n\t\t\t */\n\t\t\tdouble\t\tclamp = rel->tuples;\n\n\t\t\tif (relvarcount > 1)\n\t\t\t{\n\t\t\t\tclamp *= 0.1;\n\t\t\t\tif (clamp < relmaxndistinct)\n\t\t\t\t{\n\t\t\t\t\tclamp = relmaxndistinct;\n\t\t\t\t\t/* for sanity in case some ndistinct is too large: */\n\t\t\t\t\tif (clamp > rel->tuples)\n\t\t\t\t\t\tclamp = rel->tuples;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reldistinct > clamp)\n\t\t\t\treldistinct = clamp;\n\n\t\t\t/*\n\t\t\t * Update the estimate based on the restriction selectivity,\n\t\t\t * guarding against division by zero when reldistinct is zero.\n\t\t\t * Also skip this if we know that we are returning all rows.\n\t\t\t */\n\t\t\tif (reldistinct > 0 && rel->rows < rel->tuples)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Given a table containing N rows with n distinct values in a\n\t\t\t\t * uniform distribution, if we select p rows at random then\n\t\t\t\t * the expected number of distinct values selected is\n\t\t\t\t *\n\t\t\t\t * n * (1 - product((N-N/n-i)/(N-i), i=0..p-1))\n\t\t\t\t *\n\t\t\t\t * = n * (1 - (N-N/n)! / (N-N/n-p)! * (N-p)! / N!)\n\t\t\t\t *\n\t\t\t\t * See \"Approximating block accesses in database\n\t\t\t\t * organizations\", S. B. Yao, Communications of the ACM,\n\t\t\t\t * Volume 20 Issue 4, April 1977 Pages 260-261.\n\t\t\t\t *\n\t\t\t\t * Alternatively, re-arranging the terms from the factorials,\n\t\t\t\t * this may be written as\n\t\t\t\t *\n\t\t\t\t * n * (1 - product((N-p-i)/(N-i), i=0..N/n-1))\n\t\t\t\t *\n\t\t\t\t * This form of the formula is more efficient to compute in\n\t\t\t\t * the common case where p is larger than N/n.  Additionally,\n\t\t\t\t * as pointed out by Dell'Era, if i << N for all terms in the\n\t\t\t\t * product, it can be approximated by\n\t\t\t\t *\n\t\t\t\t * n * (1 - ((N-p)/N)^(N/n))\n\t\t\t\t *\n\t\t\t\t * See \"Expected distinct values when selecting from a bag\n\t\t\t\t * without replacement\", Alberto Dell'Era,\n\t\t\t\t * http://www.adellera.it/investigations/distinct_balls/.\n\t\t\t\t *\n\t\t\t\t * The condition i << N is equivalent to n >> 1, so this is a\n\t\t\t\t * good approximation when the number of distinct values in\n\t\t\t\t * the table is large.  It turns out that this formula also\n\t\t\t\t * works well even when n is small.\n\t\t\t\t */\n\t\t\t\treldistinct *=\n\t\t\t\t\t(1 - pow((rel->tuples - rel->rows) / rel->tuples,\n\t\t\t\t\t\t\t rel->tuples / reldistinct));\n\t\t\t}\n\t\t\treldistinct = clamp_row_est(reldistinct);\n\n\t\t\t/*\n\t\t\t * Update estimate of total distinct groups.\n\t\t\t */\n\t\t\tnumdistinct *= reldistinct;\n\t\t}\n\n\t\tvarinfos = newvarinfos;\n\t} while (varinfos != NIL);\n\n\t/* Now we can account for the effects of any SRFs */\n\tnumdistinct *= srf_multiplier;\n\n\t/* Round off */\n\tnumdistinct = ceil(numdistinct);\n\n\t/* Guard against out-of-range answers */\n\tif (numdistinct > input_rows)\n\t\tnumdistinct = input_rows;\n\tif (numdistinct < 1.0)\n\t\tnumdistinct = 1.0;\n\n\treturn numdistinct;\n}"
  },
  {
    "function_name": "add_unique_group_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "3300-3351",
    "snippet": "static List *\nadd_unique_group_var(PlannerInfo *root, List *varinfos,\n\t\t\t\t\t Node *var, VariableStatData *vardata)\n{\n\tGroupVarInfo *varinfo;\n\tdouble\t\tndistinct;\n\tbool\t\tisdefault;\n\tListCell   *lc;\n\n\tndistinct = get_variable_numdistinct(vardata, &isdefault);\n\n\t/* cannot use foreach here because of possible list_delete */\n\tlc = list_head(varinfos);\n\twhile (lc)\n\t{\n\t\tvarinfo = (GroupVarInfo *) lfirst(lc);\n\n\t\t/* must advance lc before list_delete possibly pfree's it */\n\t\tlc = lnext(lc);\n\n\t\t/* Drop exact duplicates */\n\t\tif (equal(var, varinfo->var))\n\t\t\treturn varinfos;\n\n\t\t/*\n\t\t * Drop known-equal vars, but only if they belong to different\n\t\t * relations (see comments for estimate_num_groups)\n\t\t */\n\t\tif (vardata->rel != varinfo->rel &&\n\t\t\texprs_known_equal(root, var, varinfo->var))\n\t\t{\n\t\t\tif (varinfo->ndistinct <= ndistinct)\n\t\t\t{\n\t\t\t\t/* Keep older item, forget new one */\n\t\t\t\treturn varinfos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Delete the older item */\n\t\t\t\tvarinfos = list_delete_ptr(varinfos, varinfo);\n\t\t\t}\n\t\t}\n\t}\n\n\tvarinfo = (GroupVarInfo *) palloc(sizeof(GroupVarInfo));\n\n\tvarinfo->var = var;\n\tvarinfo->rel = vardata->rel;\n\tvarinfo->ndistinct = ndistinct;\n\tvarinfos = lappend(varinfos, varinfo);\n\treturn varinfos;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "varinfos",
            "varinfo"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(GroupVarInfo)"
          ],
          "line": 3344
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_delete_ptr",
          "args": [
            "varinfos",
            "varinfo"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprs_known_equal",
          "args": [
            "root",
            "var",
            "varinfo->var"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equal",
          "args": [
            "var",
            "varinfo->var"
          ],
          "line": 3321
        },
        "resolved": true,
        "details": {
          "function_name": "equalsJsonbScalarValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1298-1322",
          "snippet": "static bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\n\nstatic bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lnext",
          "args": [
            "lc"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_head",
          "args": [
            "varinfos"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_variable_numdistinct",
          "args": [
            "vardata",
            "&isdefault"
          ],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "get_variable_numdistinct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5196-5318",
          "snippet": "double\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic List *\nadd_unique_group_var(PlannerInfo *root, List *varinfos,\n\t\t\t\t\t Node *var, VariableStatData *vardata)\n{\n\tGroupVarInfo *varinfo;\n\tdouble\t\tndistinct;\n\tbool\t\tisdefault;\n\tListCell   *lc;\n\n\tndistinct = get_variable_numdistinct(vardata, &isdefault);\n\n\t/* cannot use foreach here because of possible list_delete */\n\tlc = list_head(varinfos);\n\twhile (lc)\n\t{\n\t\tvarinfo = (GroupVarInfo *) lfirst(lc);\n\n\t\t/* must advance lc before list_delete possibly pfree's it */\n\t\tlc = lnext(lc);\n\n\t\t/* Drop exact duplicates */\n\t\tif (equal(var, varinfo->var))\n\t\t\treturn varinfos;\n\n\t\t/*\n\t\t * Drop known-equal vars, but only if they belong to different\n\t\t * relations (see comments for estimate_num_groups)\n\t\t */\n\t\tif (vardata->rel != varinfo->rel &&\n\t\t\texprs_known_equal(root, var, varinfo->var))\n\t\t{\n\t\t\tif (varinfo->ndistinct <= ndistinct)\n\t\t\t{\n\t\t\t\t/* Keep older item, forget new one */\n\t\t\t\treturn varinfos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Delete the older item */\n\t\t\t\tvarinfos = list_delete_ptr(varinfos, varinfo);\n\t\t\t}\n\t\t}\n\t}\n\n\tvarinfo = (GroupVarInfo *) palloc(sizeof(GroupVarInfo));\n\n\tvarinfo->var = var;\n\tvarinfo->rel = vardata->rel;\n\tvarinfo->ndistinct = ndistinct;\n\tvarinfos = lappend(varinfos, varinfo);\n\treturn varinfos;\n}"
  },
  {
    "function_name": "mergejoinscansel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2994-3285",
    "snippet": "void\nmergejoinscansel(PlannerInfo *root, Node *clause,\n\t\t\t\t Oid opfamily, int strategy, bool nulls_first,\n\t\t\t\t Selectivity *leftstart, Selectivity *leftend,\n\t\t\t\t Selectivity *rightstart, Selectivity *rightend)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData leftvar,\n\t\t\t\trightvar;\n\tint\t\t\top_strategy;\n\tOid\t\t\top_lefttype;\n\tOid\t\t\top_righttype;\n\tOid\t\t\topno,\n\t\t\t\tlsortop,\n\t\t\t\trsortop,\n\t\t\t\tlstatop,\n\t\t\t\trstatop,\n\t\t\t\tltop,\n\t\t\t\tleop,\n\t\t\t\trevltop,\n\t\t\t\trevleop;\n\tbool\t\tisgt;\n\tDatum\t\tleftmin,\n\t\t\t\tleftmax,\n\t\t\t\trightmin,\n\t\t\t\trightmax;\n\tdouble\t\tselec;\n\n\t/* Set default results if we can't figure anything out. */\n\t/* XXX should default \"start\" fraction be a bit more than 0? */\n\t*leftstart = *rightstart = 0.0;\n\t*leftend = *rightend = 1.0;\n\n\t/* Deconstruct the merge clause */\n\tif (!is_opclause(clause))\n\t\treturn;\t\t\t\t\t/* shouldn't happen */\n\topno = ((OpExpr *) clause)->opno;\n\tleft = get_leftop((Expr *) clause);\n\tright = get_rightop((Expr *) clause);\n\tif (!right)\n\t\treturn;\t\t\t\t\t/* shouldn't happen */\n\n\t/* Look for stats for the inputs */\n\texamine_variable(root, left, 0, &leftvar);\n\texamine_variable(root, right, 0, &rightvar);\n\n\t/* Extract the operator's declared left/right datatypes */\n\tget_op_opfamily_properties(opno, opfamily, false,\n\t\t\t\t\t\t\t   &op_strategy,\n\t\t\t\t\t\t\t   &op_lefttype,\n\t\t\t\t\t\t\t   &op_righttype);\n\tAssert(op_strategy == BTEqualStrategyNumber);\n\n\t/*\n\t * Look up the various operators we need.  If we don't find them all, it\n\t * probably means the opfamily is broken, but we just fail silently.\n\t *\n\t * Note: we expect that pg_statistic histograms will be sorted by the '<'\n\t * operator, regardless of which sort direction we are considering.\n\t */\n\tswitch (strategy)\n\t{\n\t\tcase BTLessStrategyNumber:\n\t\t\tisgt = false;\n\t\t\tif (op_lefttype == op_righttype)\n\t\t\t{\n\t\t\t\t/* easy case */\n\t\t\t\tltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTLessStrategyNumber);\n\t\t\t\tleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTLessEqualStrategyNumber);\n\t\t\t\tlsortop = ltop;\n\t\t\t\trsortop = ltop;\n\t\t\t\tlstatop = lsortop;\n\t\t\t\trstatop = rsortop;\n\t\t\t\trevltop = ltop;\n\t\t\t\trevleop = leop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTLessStrategyNumber);\n\t\t\t\tleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTLessEqualStrategyNumber);\n\t\t\t\tlsortop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_lefttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\trsortop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\tlstatop = lsortop;\n\t\t\t\trstatop = rsortop;\n\t\t\t\trevltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\trevleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessEqualStrategyNumber);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BTGreaterStrategyNumber:\n\t\t\t/* descending-order case */\n\t\t\tisgt = true;\n\t\t\tif (op_lefttype == op_righttype)\n\t\t\t{\n\t\t\t\t/* easy case */\n\t\t\t\tltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTGreaterStrategyNumber);\n\t\t\t\tleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTGreaterEqualStrategyNumber);\n\t\t\t\tlsortop = ltop;\n\t\t\t\trsortop = ltop;\n\t\t\t\tlstatop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_lefttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\trstatop = lstatop;\n\t\t\t\trevltop = ltop;\n\t\t\t\trevleop = leop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTGreaterStrategyNumber);\n\t\t\t\tleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTGreaterEqualStrategyNumber);\n\t\t\t\tlsortop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_lefttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTGreaterStrategyNumber);\n\t\t\t\trsortop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTGreaterStrategyNumber);\n\t\t\t\tlstatop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_lefttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\trstatop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\trevltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTGreaterStrategyNumber);\n\t\t\t\trevleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTGreaterEqualStrategyNumber);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\t\t\t/* shouldn't get here */\n\t}\n\n\tif (!OidIsValid(lsortop) ||\n\t\t!OidIsValid(rsortop) ||\n\t\t!OidIsValid(lstatop) ||\n\t\t!OidIsValid(rstatop) ||\n\t\t!OidIsValid(ltop) ||\n\t\t!OidIsValid(leop) ||\n\t\t!OidIsValid(revltop) ||\n\t\t!OidIsValid(revleop))\n\t\tgoto fail;\t\t\t\t/* insufficient info in catalogs */\n\n\t/* Try to get ranges of both inputs */\n\tif (!isgt)\n\t{\n\t\tif (!get_variable_range(root, &leftvar, lstatop,\n\t\t\t\t\t\t\t\t&leftmin, &leftmax))\n\t\t\tgoto fail;\t\t\t/* no range available from stats */\n\t\tif (!get_variable_range(root, &rightvar, rstatop,\n\t\t\t\t\t\t\t\t&rightmin, &rightmax))\n\t\t\tgoto fail;\t\t\t/* no range available from stats */\n\t}\n\telse\n\t{\n\t\t/* need to swap the max and min */\n\t\tif (!get_variable_range(root, &leftvar, lstatop,\n\t\t\t\t\t\t\t\t&leftmax, &leftmin))\n\t\t\tgoto fail;\t\t\t/* no range available from stats */\n\t\tif (!get_variable_range(root, &rightvar, rstatop,\n\t\t\t\t\t\t\t\t&rightmax, &rightmin))\n\t\t\tgoto fail;\t\t\t/* no range available from stats */\n\t}\n\n\t/*\n\t * Now, the fraction of the left variable that will be scanned is the\n\t * fraction that's <= the right-side maximum value.  But only believe\n\t * non-default estimates, else stick with our 1.0.\n\t */\n\tselec = scalarineqsel(root, leop, isgt, true, &leftvar,\n\t\t\t\t\t\t  rightmax, op_righttype);\n\tif (selec != DEFAULT_INEQ_SEL)\n\t\t*leftend = selec;\n\n\t/* And similarly for the right variable. */\n\tselec = scalarineqsel(root, revleop, isgt, true, &rightvar,\n\t\t\t\t\t\t  leftmax, op_lefttype);\n\tif (selec != DEFAULT_INEQ_SEL)\n\t\t*rightend = selec;\n\n\t/*\n\t * Only one of the two \"end\" fractions can really be less than 1.0;\n\t * believe the smaller estimate and reset the other one to exactly 1.0. If\n\t * we get exactly equal estimates (as can easily happen with self-joins),\n\t * believe neither.\n\t */\n\tif (*leftend > *rightend)\n\t\t*leftend = 1.0;\n\telse if (*leftend < *rightend)\n\t\t*rightend = 1.0;\n\telse\n\t\t*leftend = *rightend = 1.0;\n\n\t/*\n\t * Also, the fraction of the left variable that will be scanned before the\n\t * first join pair is found is the fraction that's < the right-side\n\t * minimum value.  But only believe non-default estimates, else stick with\n\t * our own default.\n\t */\n\tselec = scalarineqsel(root, ltop, isgt, false, &leftvar,\n\t\t\t\t\t\t  rightmin, op_righttype);\n\tif (selec != DEFAULT_INEQ_SEL)\n\t\t*leftstart = selec;\n\n\t/* And similarly for the right variable. */\n\tselec = scalarineqsel(root, revltop, isgt, false, &rightvar,\n\t\t\t\t\t\t  leftmin, op_lefttype);\n\tif (selec != DEFAULT_INEQ_SEL)\n\t\t*rightstart = selec;\n\n\t/*\n\t * Only one of the two \"start\" fractions can really be more than zero;\n\t * believe the larger estimate and reset the other one to exactly 0.0. If\n\t * we get exactly equal estimates (as can easily happen with self-joins),\n\t * believe neither.\n\t */\n\tif (*leftstart < *rightstart)\n\t\t*leftstart = 0.0;\n\telse if (*leftstart > *rightstart)\n\t\t*rightstart = 0.0;\n\telse\n\t\t*leftstart = *rightstart = 0.0;\n\n\t/*\n\t * If the sort order is nulls-first, we're going to have to skip over any\n\t * nulls too.  These would not have been counted by scalarineqsel, and we\n\t * can safely add in this fraction regardless of whether we believe\n\t * scalarineqsel's results or not.  But be sure to clamp the sum to 1.0!\n\t */\n\tif (nulls_first)\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tif (HeapTupleIsValid(leftvar.statsTuple))\n\t\t{\n\t\t\tstats = (Form_pg_statistic) GETSTRUCT(leftvar.statsTuple);\n\t\t\t*leftstart += stats->stanullfrac;\n\t\t\tCLAMP_PROBABILITY(*leftstart);\n\t\t\t*leftend += stats->stanullfrac;\n\t\t\tCLAMP_PROBABILITY(*leftend);\n\t\t}\n\t\tif (HeapTupleIsValid(rightvar.statsTuple))\n\t\t{\n\t\t\tstats = (Form_pg_statistic) GETSTRUCT(rightvar.statsTuple);\n\t\t\t*rightstart += stats->stanullfrac;\n\t\t\tCLAMP_PROBABILITY(*rightstart);\n\t\t\t*rightend += stats->stanullfrac;\n\t\t\tCLAMP_PROBABILITY(*rightend);\n\t\t}\n\t}\n\n\t/* Disbelieve start >= end, just in case that can happen */\n\tif (*leftstart >= *leftend)\n\t{\n\t\t*leftstart = 0.0;\n\t\t*leftend = 1.0;\n\t}\n\tif (*rightstart >= *rightend)\n\t{\n\t\t*rightstart = 0.0;\n\t\t*rightend = 1.0;\n\t}\n\nfail:\n\tReleaseVariableStats(leftvar);\n\tReleaseVariableStats(rightvar);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);",
      "static bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "rightvar"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "leftvar"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "*rightend"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "*rightstart"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "rightvar.statsTuple"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "rightvar.statsTuple"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "*leftend"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "*leftstart"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "leftvar.statsTuple"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "leftvar.statsTuple"
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scalarineqsel",
          "args": [
            "root",
            "revltop",
            "isgt",
            "false",
            "&rightvar",
            "leftmin",
            "op_lefttype"
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "scalarineqsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "563-624",
          "snippet": "static double\nscalarineqsel(PlannerInfo *root, Oid operator, bool isgt, bool iseq,\n\t\t\t  VariableStatData *vardata, Datum constval, Oid consttype)\n{\n\tForm_pg_statistic stats;\n\tFmgrInfo\topproc;\n\tdouble\t\tmcv_selec,\n\t\t\t\thist_selec,\n\t\t\t\tsumcommon;\n\tdouble\t\tselec;\n\n\tif (!HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* no stats available, so default result */\n\t\treturn DEFAULT_INEQ_SEL;\n\t}\n\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\n\tfmgr_info(get_opcode(operator), &opproc);\n\n\t/*\n\t * If we have most-common-values info, add up the fractions of the MCV\n\t * entries that satisfy MCV OP CONST.  These fractions contribute directly\n\t * to the result selectivity.  Also add up the total fraction represented\n\t * by MCV entries.\n\t */\n\tmcv_selec = mcv_selectivity(vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t&sumcommon);\n\n\t/*\n\t * If there is a histogram, determine which bin the constant falls in, and\n\t * compute the resulting contribution to selectivity.\n\t */\n\thist_selec = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t\t&opproc, isgt, iseq,\n\t\t\t\t\t\t\t\t\t\t\tconstval, consttype);\n\n\t/*\n\t * Now merge the results from the MCV and histogram calculations,\n\t * realizing that the histogram covers only the non-null values that are\n\t * not listed in MCV.\n\t */\n\tselec = 1.0 - stats->stanullfrac - sumcommon;\n\n\tif (hist_selec >= 0.0)\n\t\tselec *= hist_selec;\n\telse\n\t{\n\t\t/*\n\t\t * If no histogram but there are values not accounted for by MCV,\n\t\t * arbitrarily assume half of them will match.\n\t\t */\n\t\tselec *= 0.5;\n\t}\n\n\tselec += mcv_selec;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\nscalarineqsel(PlannerInfo *root, Oid operator, bool isgt, bool iseq,\n\t\t\t  VariableStatData *vardata, Datum constval, Oid consttype)\n{\n\tForm_pg_statistic stats;\n\tFmgrInfo\topproc;\n\tdouble\t\tmcv_selec,\n\t\t\t\thist_selec,\n\t\t\t\tsumcommon;\n\tdouble\t\tselec;\n\n\tif (!HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* no stats available, so default result */\n\t\treturn DEFAULT_INEQ_SEL;\n\t}\n\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\n\tfmgr_info(get_opcode(operator), &opproc);\n\n\t/*\n\t * If we have most-common-values info, add up the fractions of the MCV\n\t * entries that satisfy MCV OP CONST.  These fractions contribute directly\n\t * to the result selectivity.  Also add up the total fraction represented\n\t * by MCV entries.\n\t */\n\tmcv_selec = mcv_selectivity(vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t&sumcommon);\n\n\t/*\n\t * If there is a histogram, determine which bin the constant falls in, and\n\t * compute the resulting contribution to selectivity.\n\t */\n\thist_selec = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t\t&opproc, isgt, iseq,\n\t\t\t\t\t\t\t\t\t\t\tconstval, consttype);\n\n\t/*\n\t * Now merge the results from the MCV and histogram calculations,\n\t * realizing that the histogram covers only the non-null values that are\n\t * not listed in MCV.\n\t */\n\tselec = 1.0 - stats->stanullfrac - sumcommon;\n\n\tif (hist_selec >= 0.0)\n\t\tselec *= hist_selec;\n\telse\n\t{\n\t\t/*\n\t\t * If no histogram but there are values not accounted for by MCV,\n\t\t * arbitrarily assume half of them will match.\n\t\t */\n\t\tselec *= 0.5;\n\t}\n\n\tselec += mcv_selec;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_variable_range",
          "args": [
            "root",
            "&rightvar",
            "rstatop",
            "&rightmax",
            "&rightmin"
          ],
          "line": 3178
        },
        "resolved": true,
        "details": {
          "function_name": "get_variable_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5329-5449",
          "snippet": "static bool\nget_variable_range(PlannerInfo *root, VariableStatData *vardata, Oid sortop,\n\t\t\t\t   Datum *min, Datum *max)\n{\n\tDatum\t\ttmin = 0;\n\tDatum\t\ttmax = 0;\n\tbool\t\thave_data = false;\n\tint16\t\ttypLen;\n\tbool\t\ttypByVal;\n\tOid\t\t\topfuncoid;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\t/*\n\t * XXX It's very tempting to try to use the actual column min and max, if\n\t * we can get them relatively-cheaply with an index probe.  However, since\n\t * this function is called many times during join planning, that could\n\t * have unpleasant effects on planning speed.  Need more investigation\n\t * before enabling this.\n\t */\n#ifdef NOT_USED\n\tif (get_actual_variable_range(root, vardata, sortop, min, max))\n\t\treturn true;\n#endif\n\n\tif (!HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* no stats available, so default result */\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we can't apply the sortop to the stats data, just fail.  In\n\t * principle, if there's a histogram and no MCVs, we could return the\n\t * histogram endpoints without ever applying the sortop ... but it's\n\t * probably not worth trying, because whatever the caller wants to do with\n\t * the endpoints would likely fail the security check too.\n\t */\n\tif (!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(sortop))))\n\t\treturn false;\n\n\tget_typlenbyval(vardata->atttype, &typLen, &typByVal);\n\n\t/*\n\t * If there is a histogram, grab the first and last values.\n\t *\n\t * If there is a histogram that is sorted with some other operator than\n\t * the one we want, fail --- this suggests that there is data we can't\n\t * use.\n\t */\n\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, sortop,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 0)\n\t\t{\n\t\t\ttmin = datumCopy(sslot.values[0], typByVal, typLen);\n\t\t\ttmax = datumCopy(sslot.values[sslot.nvalues - 1], typByVal, typLen);\n\t\t\thave_data = true;\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse if (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t  STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t  0))\n\t{\n\t\tfree_attstatsslot(&sslot);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we have most-common-values info, look for extreme MCVs.  This is\n\t * needed even if we also have a histogram, since the histogram excludes\n\t * the MCVs.  However, usually the MCVs will not be the extreme values, so\n\t * avoid unnecessary data copying.\n\t */\n\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tbool\t\ttmin_is_mcv = false;\n\t\tbool\t\ttmax_is_mcv = false;\n\t\tFmgrInfo\topproc;\n\n\t\tfmgr_info(opfuncoid, &opproc);\n\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (!have_data)\n\t\t\t{\n\t\t\t\ttmin = tmax = sslot.values[i];\n\t\t\t\ttmin_is_mcv = tmax_is_mcv = have_data = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (DatumGetBool(FunctionCall2Coll(&opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i], tmin)))\n\t\t\t{\n\t\t\t\ttmin = sslot.values[i];\n\t\t\t\ttmin_is_mcv = true;\n\t\t\t}\n\t\t\tif (DatumGetBool(FunctionCall2Coll(&opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   tmax, sslot.values[i])))\n\t\t\t{\n\t\t\t\ttmax = sslot.values[i];\n\t\t\t\ttmax_is_mcv = true;\n\t\t\t}\n\t\t}\n\t\tif (tmin_is_mcv)\n\t\t\ttmin = datumCopy(tmin, typByVal, typLen);\n\t\tif (tmax_is_mcv)\n\t\t\ttmax = datumCopy(tmax, typByVal, typLen);\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*min = tmin;\n\t*max = tmax;\n\treturn have_data;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
            "static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);",
            "static bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);\nstatic bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);\n\nstatic bool\nget_variable_range(PlannerInfo *root, VariableStatData *vardata, Oid sortop,\n\t\t\t\t   Datum *min, Datum *max)\n{\n\tDatum\t\ttmin = 0;\n\tDatum\t\ttmax = 0;\n\tbool\t\thave_data = false;\n\tint16\t\ttypLen;\n\tbool\t\ttypByVal;\n\tOid\t\t\topfuncoid;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\t/*\n\t * XXX It's very tempting to try to use the actual column min and max, if\n\t * we can get them relatively-cheaply with an index probe.  However, since\n\t * this function is called many times during join planning, that could\n\t * have unpleasant effects on planning speed.  Need more investigation\n\t * before enabling this.\n\t */\n#ifdef NOT_USED\n\tif (get_actual_variable_range(root, vardata, sortop, min, max))\n\t\treturn true;\n#endif\n\n\tif (!HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* no stats available, so default result */\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we can't apply the sortop to the stats data, just fail.  In\n\t * principle, if there's a histogram and no MCVs, we could return the\n\t * histogram endpoints without ever applying the sortop ... but it's\n\t * probably not worth trying, because whatever the caller wants to do with\n\t * the endpoints would likely fail the security check too.\n\t */\n\tif (!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(sortop))))\n\t\treturn false;\n\n\tget_typlenbyval(vardata->atttype, &typLen, &typByVal);\n\n\t/*\n\t * If there is a histogram, grab the first and last values.\n\t *\n\t * If there is a histogram that is sorted with some other operator than\n\t * the one we want, fail --- this suggests that there is data we can't\n\t * use.\n\t */\n\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, sortop,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 0)\n\t\t{\n\t\t\ttmin = datumCopy(sslot.values[0], typByVal, typLen);\n\t\t\ttmax = datumCopy(sslot.values[sslot.nvalues - 1], typByVal, typLen);\n\t\t\thave_data = true;\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse if (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t  STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t\t  0))\n\t{\n\t\tfree_attstatsslot(&sslot);\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we have most-common-values info, look for extreme MCVs.  This is\n\t * needed even if we also have a histogram, since the histogram excludes\n\t * the MCVs.  However, usually the MCVs will not be the extreme values, so\n\t * avoid unnecessary data copying.\n\t */\n\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tbool\t\ttmin_is_mcv = false;\n\t\tbool\t\ttmax_is_mcv = false;\n\t\tFmgrInfo\topproc;\n\n\t\tfmgr_info(opfuncoid, &opproc);\n\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (!have_data)\n\t\t\t{\n\t\t\t\ttmin = tmax = sslot.values[i];\n\t\t\t\ttmin_is_mcv = tmax_is_mcv = have_data = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (DatumGetBool(FunctionCall2Coll(&opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i], tmin)))\n\t\t\t{\n\t\t\t\ttmin = sslot.values[i];\n\t\t\t\ttmin_is_mcv = true;\n\t\t\t}\n\t\t\tif (DatumGetBool(FunctionCall2Coll(&opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   tmax, sslot.values[i])))\n\t\t\t{\n\t\t\t\ttmax = sslot.values[i];\n\t\t\t\ttmax_is_mcv = true;\n\t\t\t}\n\t\t}\n\t\tif (tmin_is_mcv)\n\t\t\ttmin = datumCopy(tmin, typByVal, typLen);\n\t\tif (tmax_is_mcv)\n\t\t\ttmax = datumCopy(tmax, typByVal, typLen);\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*min = tmin;\n\t*max = tmax;\n\treturn have_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "revleop"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "revltop"
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "leop"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "ltop"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "rstatop"
          ],
          "line": 3155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "lstatop"
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "rsortop"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "lsortop"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_opfamily_member",
          "args": [
            "opfamily",
            "op_righttype",
            "op_lefttype",
            "BTGreaterEqualStrategyNumber"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "get_opfamily_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "162-181",
          "snippet": "Oid\nget_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,\n\t\t\t\t\tint16 strategy)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache4(AMOPSTRATEGY,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(strategy));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopopr;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,\n\t\t\t\t\tint16 strategy)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache4(AMOPSTRATEGY,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(strategy));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopopr;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "op_strategy == BTEqualStrategyNumber"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_op_opfamily_properties",
          "args": [
            "opno",
            "opfamily",
            "false",
            "&op_strategy",
            "&op_lefttype",
            "&op_righttype"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "get_op_opfamily_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "132-153",
          "snippet": "void\nget_op_opfamily_properties(Oid opno, Oid opfamily, bool ordering_op,\n\t\t\t\t\t\t   int *strategy,\n\t\t\t\t\t\t   Oid *lefttype,\n\t\t\t\t\t\t   Oid *righttype)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(ordering_op ? AMOP_ORDER : AMOP_SEARCH),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"operator %u is not a member of opfamily %u\",\n\t\t\t opno, opfamily);\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\t*strategy = amop_tup->amopstrategy;\n\t*lefttype = amop_tup->amoplefttype;\n\t*righttype = amop_tup->amoprighttype;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_op_opfamily_properties(Oid opno, Oid opfamily, bool ordering_op,\n\t\t\t\t\t\t   int *strategy,\n\t\t\t\t\t\t   Oid *lefttype,\n\t\t\t\t\t\t   Oid *righttype)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(ordering_op ? AMOP_ORDER : AMOP_SEARCH),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"operator %u is not a member of opfamily %u\",\n\t\t\t opno, opfamily);\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\t*strategy = amop_tup->amopstrategy;\n\t*lefttype = amop_tup->amoplefttype;\n\t*righttype = amop_tup->amoprighttype;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "examine_variable",
          "args": [
            "root",
            "right",
            "0",
            "&rightvar"
          ],
          "line": 3039
        },
        "resolved": true,
        "details": {
          "function_name": "examine_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4775-4984",
          "snippet": "void\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "get_index_stats_hook_type get_index_stats_hook = NULL;",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rightop",
          "args": [
            "(Expr *) clause"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_leftop",
          "args": [
            "(Expr *) clause"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_opclause",
          "args": [
            "clause"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);\nstatic bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);\n\nvoid\nmergejoinscansel(PlannerInfo *root, Node *clause,\n\t\t\t\t Oid opfamily, int strategy, bool nulls_first,\n\t\t\t\t Selectivity *leftstart, Selectivity *leftend,\n\t\t\t\t Selectivity *rightstart, Selectivity *rightend)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData leftvar,\n\t\t\t\trightvar;\n\tint\t\t\top_strategy;\n\tOid\t\t\top_lefttype;\n\tOid\t\t\top_righttype;\n\tOid\t\t\topno,\n\t\t\t\tlsortop,\n\t\t\t\trsortop,\n\t\t\t\tlstatop,\n\t\t\t\trstatop,\n\t\t\t\tltop,\n\t\t\t\tleop,\n\t\t\t\trevltop,\n\t\t\t\trevleop;\n\tbool\t\tisgt;\n\tDatum\t\tleftmin,\n\t\t\t\tleftmax,\n\t\t\t\trightmin,\n\t\t\t\trightmax;\n\tdouble\t\tselec;\n\n\t/* Set default results if we can't figure anything out. */\n\t/* XXX should default \"start\" fraction be a bit more than 0? */\n\t*leftstart = *rightstart = 0.0;\n\t*leftend = *rightend = 1.0;\n\n\t/* Deconstruct the merge clause */\n\tif (!is_opclause(clause))\n\t\treturn;\t\t\t\t\t/* shouldn't happen */\n\topno = ((OpExpr *) clause)->opno;\n\tleft = get_leftop((Expr *) clause);\n\tright = get_rightop((Expr *) clause);\n\tif (!right)\n\t\treturn;\t\t\t\t\t/* shouldn't happen */\n\n\t/* Look for stats for the inputs */\n\texamine_variable(root, left, 0, &leftvar);\n\texamine_variable(root, right, 0, &rightvar);\n\n\t/* Extract the operator's declared left/right datatypes */\n\tget_op_opfamily_properties(opno, opfamily, false,\n\t\t\t\t\t\t\t   &op_strategy,\n\t\t\t\t\t\t\t   &op_lefttype,\n\t\t\t\t\t\t\t   &op_righttype);\n\tAssert(op_strategy == BTEqualStrategyNumber);\n\n\t/*\n\t * Look up the various operators we need.  If we don't find them all, it\n\t * probably means the opfamily is broken, but we just fail silently.\n\t *\n\t * Note: we expect that pg_statistic histograms will be sorted by the '<'\n\t * operator, regardless of which sort direction we are considering.\n\t */\n\tswitch (strategy)\n\t{\n\t\tcase BTLessStrategyNumber:\n\t\t\tisgt = false;\n\t\t\tif (op_lefttype == op_righttype)\n\t\t\t{\n\t\t\t\t/* easy case */\n\t\t\t\tltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTLessStrategyNumber);\n\t\t\t\tleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTLessEqualStrategyNumber);\n\t\t\t\tlsortop = ltop;\n\t\t\t\trsortop = ltop;\n\t\t\t\tlstatop = lsortop;\n\t\t\t\trstatop = rsortop;\n\t\t\t\trevltop = ltop;\n\t\t\t\trevleop = leop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTLessStrategyNumber);\n\t\t\t\tleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTLessEqualStrategyNumber);\n\t\t\t\tlsortop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_lefttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\trsortop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\tlstatop = lsortop;\n\t\t\t\trstatop = rsortop;\n\t\t\t\trevltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\trevleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessEqualStrategyNumber);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BTGreaterStrategyNumber:\n\t\t\t/* descending-order case */\n\t\t\tisgt = true;\n\t\t\tif (op_lefttype == op_righttype)\n\t\t\t{\n\t\t\t\t/* easy case */\n\t\t\t\tltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTGreaterStrategyNumber);\n\t\t\t\tleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTGreaterEqualStrategyNumber);\n\t\t\t\tlsortop = ltop;\n\t\t\t\trsortop = ltop;\n\t\t\t\tlstatop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_lefttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\trstatop = lstatop;\n\t\t\t\trevltop = ltop;\n\t\t\t\trevleop = leop;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTGreaterStrategyNumber);\n\t\t\t\tleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t   op_lefttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t   BTGreaterEqualStrategyNumber);\n\t\t\t\tlsortop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_lefttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTGreaterStrategyNumber);\n\t\t\t\trsortop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTGreaterStrategyNumber);\n\t\t\t\tlstatop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_lefttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\trstatop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_righttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTLessStrategyNumber);\n\t\t\t\trevltop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTGreaterStrategyNumber);\n\t\t\t\trevleop = get_opfamily_member(opfamily,\n\t\t\t\t\t\t\t\t\t\t\t  op_righttype, op_lefttype,\n\t\t\t\t\t\t\t\t\t\t\t  BTGreaterEqualStrategyNumber);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\t\t\t/* shouldn't get here */\n\t}\n\n\tif (!OidIsValid(lsortop) ||\n\t\t!OidIsValid(rsortop) ||\n\t\t!OidIsValid(lstatop) ||\n\t\t!OidIsValid(rstatop) ||\n\t\t!OidIsValid(ltop) ||\n\t\t!OidIsValid(leop) ||\n\t\t!OidIsValid(revltop) ||\n\t\t!OidIsValid(revleop))\n\t\tgoto fail;\t\t\t\t/* insufficient info in catalogs */\n\n\t/* Try to get ranges of both inputs */\n\tif (!isgt)\n\t{\n\t\tif (!get_variable_range(root, &leftvar, lstatop,\n\t\t\t\t\t\t\t\t&leftmin, &leftmax))\n\t\t\tgoto fail;\t\t\t/* no range available from stats */\n\t\tif (!get_variable_range(root, &rightvar, rstatop,\n\t\t\t\t\t\t\t\t&rightmin, &rightmax))\n\t\t\tgoto fail;\t\t\t/* no range available from stats */\n\t}\n\telse\n\t{\n\t\t/* need to swap the max and min */\n\t\tif (!get_variable_range(root, &leftvar, lstatop,\n\t\t\t\t\t\t\t\t&leftmax, &leftmin))\n\t\t\tgoto fail;\t\t\t/* no range available from stats */\n\t\tif (!get_variable_range(root, &rightvar, rstatop,\n\t\t\t\t\t\t\t\t&rightmax, &rightmin))\n\t\t\tgoto fail;\t\t\t/* no range available from stats */\n\t}\n\n\t/*\n\t * Now, the fraction of the left variable that will be scanned is the\n\t * fraction that's <= the right-side maximum value.  But only believe\n\t * non-default estimates, else stick with our 1.0.\n\t */\n\tselec = scalarineqsel(root, leop, isgt, true, &leftvar,\n\t\t\t\t\t\t  rightmax, op_righttype);\n\tif (selec != DEFAULT_INEQ_SEL)\n\t\t*leftend = selec;\n\n\t/* And similarly for the right variable. */\n\tselec = scalarineqsel(root, revleop, isgt, true, &rightvar,\n\t\t\t\t\t\t  leftmax, op_lefttype);\n\tif (selec != DEFAULT_INEQ_SEL)\n\t\t*rightend = selec;\n\n\t/*\n\t * Only one of the two \"end\" fractions can really be less than 1.0;\n\t * believe the smaller estimate and reset the other one to exactly 1.0. If\n\t * we get exactly equal estimates (as can easily happen with self-joins),\n\t * believe neither.\n\t */\n\tif (*leftend > *rightend)\n\t\t*leftend = 1.0;\n\telse if (*leftend < *rightend)\n\t\t*rightend = 1.0;\n\telse\n\t\t*leftend = *rightend = 1.0;\n\n\t/*\n\t * Also, the fraction of the left variable that will be scanned before the\n\t * first join pair is found is the fraction that's < the right-side\n\t * minimum value.  But only believe non-default estimates, else stick with\n\t * our own default.\n\t */\n\tselec = scalarineqsel(root, ltop, isgt, false, &leftvar,\n\t\t\t\t\t\t  rightmin, op_righttype);\n\tif (selec != DEFAULT_INEQ_SEL)\n\t\t*leftstart = selec;\n\n\t/* And similarly for the right variable. */\n\tselec = scalarineqsel(root, revltop, isgt, false, &rightvar,\n\t\t\t\t\t\t  leftmin, op_lefttype);\n\tif (selec != DEFAULT_INEQ_SEL)\n\t\t*rightstart = selec;\n\n\t/*\n\t * Only one of the two \"start\" fractions can really be more than zero;\n\t * believe the larger estimate and reset the other one to exactly 0.0. If\n\t * we get exactly equal estimates (as can easily happen with self-joins),\n\t * believe neither.\n\t */\n\tif (*leftstart < *rightstart)\n\t\t*leftstart = 0.0;\n\telse if (*leftstart > *rightstart)\n\t\t*rightstart = 0.0;\n\telse\n\t\t*leftstart = *rightstart = 0.0;\n\n\t/*\n\t * If the sort order is nulls-first, we're going to have to skip over any\n\t * nulls too.  These would not have been counted by scalarineqsel, and we\n\t * can safely add in this fraction regardless of whether we believe\n\t * scalarineqsel's results or not.  But be sure to clamp the sum to 1.0!\n\t */\n\tif (nulls_first)\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tif (HeapTupleIsValid(leftvar.statsTuple))\n\t\t{\n\t\t\tstats = (Form_pg_statistic) GETSTRUCT(leftvar.statsTuple);\n\t\t\t*leftstart += stats->stanullfrac;\n\t\t\tCLAMP_PROBABILITY(*leftstart);\n\t\t\t*leftend += stats->stanullfrac;\n\t\t\tCLAMP_PROBABILITY(*leftend);\n\t\t}\n\t\tif (HeapTupleIsValid(rightvar.statsTuple))\n\t\t{\n\t\t\tstats = (Form_pg_statistic) GETSTRUCT(rightvar.statsTuple);\n\t\t\t*rightstart += stats->stanullfrac;\n\t\t\tCLAMP_PROBABILITY(*rightstart);\n\t\t\t*rightend += stats->stanullfrac;\n\t\t\tCLAMP_PROBABILITY(*rightend);\n\t\t}\n\t}\n\n\t/* Disbelieve start >= end, just in case that can happen */\n\tif (*leftstart >= *leftend)\n\t{\n\t\t*leftstart = 0.0;\n\t\t*leftend = 1.0;\n\t}\n\tif (*rightstart >= *rightend)\n\t{\n\t\t*rightstart = 0.0;\n\t\t*rightend = 1.0;\n\t}\n\nfail:\n\tReleaseVariableStats(leftvar);\n\tReleaseVariableStats(rightvar);\n}"
  },
  {
    "function_name": "icnlikejoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2967-2971",
    "snippet": "Datum\nicnlikejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Like_IC, true));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternjoinsel(fcinfo, Pattern_Type_Like_IC, true)"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternjoinsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Like_IC",
            "true"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "patternjoinsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2885-2890",
          "snippet": "static double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\n\nstatic double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nicnlikejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Like_IC, true));\n}"
  },
  {
    "function_name": "nlikejoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2958-2962",
    "snippet": "Datum\nnlikejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Like, true));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternjoinsel(fcinfo, Pattern_Type_Like, true)"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternjoinsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Like",
            "true"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "patternjoinsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2885-2890",
          "snippet": "static double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\n\nstatic double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nnlikejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Like, true));\n}"
  },
  {
    "function_name": "icregexnejoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2949-2953",
    "snippet": "Datum\nicregexnejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Regex_IC, true));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternjoinsel(fcinfo, Pattern_Type_Regex_IC, true)"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternjoinsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Regex_IC",
            "true"
          ],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "patternjoinsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2885-2890",
          "snippet": "static double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\n\nstatic double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nicregexnejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Regex_IC, true));\n}"
  },
  {
    "function_name": "regexnejoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2940-2944",
    "snippet": "Datum\nregexnejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Regex, true));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternjoinsel(fcinfo, Pattern_Type_Regex, true)"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternjoinsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Regex",
            "true"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "patternjoinsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2885-2890",
          "snippet": "static double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\n\nstatic double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregexnejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Regex, true));\n}"
  },
  {
    "function_name": "iclikejoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2931-2935",
    "snippet": "Datum\niclikejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Like_IC, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternjoinsel(fcinfo, Pattern_Type_Like_IC, false)"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternjoinsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Like_IC",
            "false"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "patternjoinsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2885-2890",
          "snippet": "static double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\n\nstatic double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\niclikejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Like_IC, false));\n}"
  },
  {
    "function_name": "prefixjoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2922-2926",
    "snippet": "Datum\nprefixjoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Prefix, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternjoinsel(fcinfo, Pattern_Type_Prefix, false)"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternjoinsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Prefix",
            "false"
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "patternjoinsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2885-2890",
          "snippet": "static double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\n\nstatic double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nprefixjoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Prefix, false));\n}"
  },
  {
    "function_name": "likejoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2913-2917",
    "snippet": "Datum\nlikejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Like, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternjoinsel(fcinfo, Pattern_Type_Like, false)"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternjoinsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Like",
            "false"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "patternjoinsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2885-2890",
          "snippet": "static double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\n\nstatic double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nlikejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Like, false));\n}"
  },
  {
    "function_name": "icregexeqjoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2904-2908",
    "snippet": "Datum\nicregexeqjoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Regex_IC, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternjoinsel(fcinfo, Pattern_Type_Regex_IC, false)"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternjoinsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Regex_IC",
            "false"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "patternjoinsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2885-2890",
          "snippet": "static double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\n\nstatic double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nicregexeqjoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Regex_IC, false));\n}"
  },
  {
    "function_name": "regexeqjoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2895-2899",
    "snippet": "Datum\nregexeqjoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Regex, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternjoinsel(fcinfo, Pattern_Type_Regex, false)"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternjoinsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Regex",
            "false"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "patternjoinsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2885-2890",
          "snippet": "static double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\n\nstatic double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregexeqjoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Regex, false));\n}"
  },
  {
    "function_name": "patternjoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2885-2890",
    "snippet": "static double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
      "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
      "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\n\nstatic double\npatternjoinsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\t/* For the moment we just punt. */\n\treturn negate ? (1.0 - DEFAULT_MATCH_SEL) : DEFAULT_MATCH_SEL;\n}"
  },
  {
    "function_name": "scalargejoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2876-2880",
    "snippet": "Datum\nscalargejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_INEQ_SEL"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nscalargejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n}"
  },
  {
    "function_name": "scalargtjoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2867-2871",
    "snippet": "Datum\nscalargtjoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_INEQ_SEL"
          ],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nscalargtjoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n}"
  },
  {
    "function_name": "scalarlejoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2858-2862",
    "snippet": "Datum\nscalarlejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_INEQ_SEL"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nscalarlejoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n}"
  },
  {
    "function_name": "scalarltjoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2849-2853",
    "snippet": "Datum\nscalarltjoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_INEQ_SEL"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nscalarltjoinsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n}"
  },
  {
    "function_name": "neqjoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2774-2844",
    "snippet": "Datum\nneqjoinsel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tJoinType\tjointype = (JoinType) PG_GETARG_INT16(3);\n\tSpecialJoinInfo *sjinfo = (SpecialJoinInfo *) PG_GETARG_POINTER(4);\n\tfloat8\t\tresult;\n\n\tif (jointype == JOIN_SEMI || jointype == JOIN_ANTI)\n\t{\n\t\t/*\n\t\t * For semi-joins, if there is more than one distinct value in the RHS\n\t\t * relation then every non-null LHS row must find a row to join since\n\t\t * it can only be equal to one of them.  We'll assume that there is\n\t\t * always more than one distinct RHS value for the sake of stability,\n\t\t * though in theory we could have special cases for empty RHS\n\t\t * (selectivity = 0) and single-distinct-value RHS (selectivity =\n\t\t * fraction of LHS that has the same value as the single RHS value).\n\t\t *\n\t\t * For anti-joins, if we use the same assumption that there is more\n\t\t * than one distinct key in the RHS relation, then every non-null LHS\n\t\t * row must be suppressed by the anti-join.\n\t\t *\n\t\t * So either way, the selectivity estimate should be 1 - nullfrac.\n\t\t */\n\t\tVariableStatData leftvar;\n\t\tVariableStatData rightvar;\n\t\tbool\t\treversed;\n\t\tHeapTuple\tstatsTuple;\n\t\tdouble\t\tnullfrac;\n\n\t\tget_join_variables(root, args, sjinfo, &leftvar, &rightvar, &reversed);\n\t\tstatsTuple = reversed ? rightvar.statsTuple : leftvar.statsTuple;\n\t\tif (HeapTupleIsValid(statsTuple))\n\t\t\tnullfrac = ((Form_pg_statistic) GETSTRUCT(statsTuple))->stanullfrac;\n\t\telse\n\t\t\tnullfrac = 0.0;\n\t\tReleaseVariableStats(leftvar);\n\t\tReleaseVariableStats(rightvar);\n\n\t\tresult = 1.0 - nullfrac;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We want 1 - eqjoinsel() where the equality operator is the one\n\t\t * associated with this != operator, that is, its negator.\n\t\t */\n\t\tOid\t\t\teqop = get_negator(operator);\n\n\t\tif (eqop)\n\t\t{\n\t\t\tresult = DatumGetFloat8(DirectFunctionCall5(eqjoinsel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(eqop),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(sjinfo)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tresult = DEFAULT_EQ_SEL;\n\t\t}\n\t\tresult = 1.0 - result;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "DirectFunctionCall5(eqjoinsel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(eqop),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(sjinfo))"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall5",
          "args": [
            "eqjoinsel",
            "PointerGetDatum(root)",
            "ObjectIdGetDatum(eqop)",
            "PointerGetDatum(args)",
            "Int16GetDatum(jointype)",
            "PointerGetDatum(sjinfo)"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "sjinfo"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "jointype"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "args"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "eqop"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "root"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_negator",
          "args": [
            "operator"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "get_negator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1321-1338",
          "snippet": "Oid\nget_negator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprnegate;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_negator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprnegate;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "rightvar"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "leftvar"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "statsTuple"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "statsTuple"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_join_variables",
          "args": [
            "root",
            "args",
            "sjinfo",
            "&leftvar",
            "&rightvar",
            "&reversed"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "get_join_variables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4713-4738",
          "snippet": "void\nget_join_variables(PlannerInfo *root, List *args, SpecialJoinInfo *sjinfo,\n\t\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t\t   bool *join_is_reversed)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\n\tif (list_length(args) != 2)\n\t\telog(ERROR, \"join operator should take two arguments\");\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\texamine_variable(root, left, 0, vardata1);\n\texamine_variable(root, right, 0, vardata2);\n\n\tif (vardata1->rel &&\n\t\tbms_is_subset(vardata1->rel->relids, sjinfo->syn_righthand))\n\t\t*join_is_reversed = true;\t/* var1 is on RHS */\n\telse if (vardata2->rel &&\n\t\t\t bms_is_subset(vardata2->rel->relids, sjinfo->syn_lefthand))\n\t\t*join_is_reversed = true;\t/* var2 is on LHS */\n\telse\n\t\t*join_is_reversed = false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
            "static RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);\n\nvoid\nget_join_variables(PlannerInfo *root, List *args, SpecialJoinInfo *sjinfo,\n\t\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t\t   bool *join_is_reversed)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\n\tif (list_length(args) != 2)\n\t\telog(ERROR, \"join operator should take two arguments\");\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\texamine_variable(root, left, 0, vardata1);\n\texamine_variable(root, right, 0, vardata2);\n\n\tif (vardata1->rel &&\n\t\tbms_is_subset(vardata1->rel->relids, sjinfo->syn_righthand))\n\t\t*join_is_reversed = true;\t/* var1 is on RHS */\n\telse if (vardata2->rel &&\n\t\t\t bms_is_subset(vardata2->rel->relids, sjinfo->syn_lefthand))\n\t\t*join_is_reversed = true;\t/* var2 is on LHS */\n\telse\n\t\t*join_is_reversed = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "4"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT16",
          "args": [
            "3"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nneqjoinsel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tJoinType\tjointype = (JoinType) PG_GETARG_INT16(3);\n\tSpecialJoinInfo *sjinfo = (SpecialJoinInfo *) PG_GETARG_POINTER(4);\n\tfloat8\t\tresult;\n\n\tif (jointype == JOIN_SEMI || jointype == JOIN_ANTI)\n\t{\n\t\t/*\n\t\t * For semi-joins, if there is more than one distinct value in the RHS\n\t\t * relation then every non-null LHS row must find a row to join since\n\t\t * it can only be equal to one of them.  We'll assume that there is\n\t\t * always more than one distinct RHS value for the sake of stability,\n\t\t * though in theory we could have special cases for empty RHS\n\t\t * (selectivity = 0) and single-distinct-value RHS (selectivity =\n\t\t * fraction of LHS that has the same value as the single RHS value).\n\t\t *\n\t\t * For anti-joins, if we use the same assumption that there is more\n\t\t * than one distinct key in the RHS relation, then every non-null LHS\n\t\t * row must be suppressed by the anti-join.\n\t\t *\n\t\t * So either way, the selectivity estimate should be 1 - nullfrac.\n\t\t */\n\t\tVariableStatData leftvar;\n\t\tVariableStatData rightvar;\n\t\tbool\t\treversed;\n\t\tHeapTuple\tstatsTuple;\n\t\tdouble\t\tnullfrac;\n\n\t\tget_join_variables(root, args, sjinfo, &leftvar, &rightvar, &reversed);\n\t\tstatsTuple = reversed ? rightvar.statsTuple : leftvar.statsTuple;\n\t\tif (HeapTupleIsValid(statsTuple))\n\t\t\tnullfrac = ((Form_pg_statistic) GETSTRUCT(statsTuple))->stanullfrac;\n\t\telse\n\t\t\tnullfrac = 0.0;\n\t\tReleaseVariableStats(leftvar);\n\t\tReleaseVariableStats(rightvar);\n\n\t\tresult = 1.0 - nullfrac;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We want 1 - eqjoinsel() where the equality operator is the one\n\t\t * associated with this != operator, that is, its negator.\n\t\t */\n\t\tOid\t\t\teqop = get_negator(operator);\n\n\t\tif (eqop)\n\t\t{\n\t\t\tresult = DatumGetFloat8(DirectFunctionCall5(eqjoinsel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(eqop),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(sjinfo)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tresult = DEFAULT_EQ_SEL;\n\t\t}\n\t\tresult = 1.0 - result;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "eqjoinsel_semi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2568-2769",
    "snippet": "static double\neqjoinsel_semi(Oid operator,\n\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t   RelOptInfo *inner_rel)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnd1;\n\tdouble\t\tnd2;\n\tbool\t\tisdefault1;\n\tbool\t\tisdefault2;\n\tOid\t\t\topfuncoid;\n\tForm_pg_statistic stats1 = NULL;\n\tbool\t\thave_mcvs1 = false;\n\tbool\t\thave_mcvs2 = false;\n\tAttStatsSlot sslot1;\n\tAttStatsSlot sslot2;\n\n\tnd1 = get_variable_numdistinct(vardata1, &isdefault1);\n\tnd2 = get_variable_numdistinct(vardata2, &isdefault2);\n\n\topfuncoid = OidIsValid(operator) ? get_opcode(operator) : InvalidOid;\n\n\tmemset(&sslot1, 0, sizeof(sslot1));\n\tmemset(&sslot2, 0, sizeof(sslot2));\n\n\t/*\n\t * We clamp nd2 to be not more than what we estimate the inner relation's\n\t * size to be.  This is intuitively somewhat reasonable since obviously\n\t * there can't be more than that many distinct values coming from the\n\t * inner rel.  The reason for the asymmetry (ie, that we don't clamp nd1\n\t * likewise) is that this is the only pathway by which restriction clauses\n\t * applied to the inner rel will affect the join result size estimate,\n\t * since set_joinrel_size_estimates will multiply SEMI/ANTI selectivity by\n\t * only the outer rel's size.  If we clamped nd1 we'd be double-counting\n\t * the selectivity of outer-rel restrictions.\n\t *\n\t * We can apply this clamping both with respect to the base relation from\n\t * which the join variable comes (if there is just one), and to the\n\t * immediate inner input relation of the current join.\n\t *\n\t * If we clamp, we can treat nd2 as being a non-default estimate; it's not\n\t * great, maybe, but it didn't come out of nowhere either.  This is most\n\t * helpful when the inner relation is empty and consequently has no stats.\n\t */\n\tif (vardata2->rel)\n\t{\n\t\tif (nd2 >= vardata2->rel->rows)\n\t\t{\n\t\t\tnd2 = vardata2->rel->rows;\n\t\t\tisdefault2 = false;\n\t\t}\n\t}\n\tif (nd2 >= inner_rel->rows)\n\t{\n\t\tnd2 = inner_rel->rows;\n\t\tisdefault2 = false;\n\t}\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats1 = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tif (statistic_proc_security_check(vardata1, opfuncoid))\n\t\t\thave_mcvs1 = get_attstatsslot(&sslot1, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata2, opfuncoid))\n\t{\n\t\thave_mcvs2 = get_attstatsslot(&sslot2, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES);\n\t\t/* note: currently don't need stanumbers from RHS */\n\t}\n\n\tif (have_mcvs1 && have_mcvs2 && OidIsValid(operator))\n\t{\n\t\t/*\n\t\t * We have most-common-value lists for both relations.  Run through\n\t\t * the lists to see which MCVs actually join to each other with the\n\t\t * given operator.  This allows us to determine the exact join\n\t\t * selectivity for the portion of the relations represented by the MCV\n\t\t * lists.  We still have to estimate for the remaining population, but\n\t\t * in a skewed distribution this gives us a big leg up in accuracy.\n\t\t */\n\t\tFmgrInfo\teqproc;\n\t\tbool\t   *hasmatch1;\n\t\tbool\t   *hasmatch2;\n\t\tdouble\t\tnullfrac1 = stats1->stanullfrac;\n\t\tdouble\t\tmatchfreq1,\n\t\t\t\t\tuncertainfrac,\n\t\t\t\t\tuncertain;\n\t\tint\t\t\ti,\n\t\t\t\t\tnmatches,\n\t\t\t\t\tclamped_nvalues2;\n\n\t\t/*\n\t\t * The clamping above could have resulted in nd2 being less than\n\t\t * sslot2.nvalues; in which case, we assume that precisely the nd2\n\t\t * most common values in the relation will appear in the join input,\n\t\t * and so compare to only the first nd2 members of the MCV list.  Of\n\t\t * course this is frequently wrong, but it's the best bet we can make.\n\t\t */\n\t\tclamped_nvalues2 = Min(sslot2.nvalues, nd2);\n\n\t\tfmgr_info(opfuncoid, &eqproc);\n\t\thasmatch1 = (bool *) palloc0(sslot1.nvalues * sizeof(bool));\n\t\thasmatch2 = (bool *) palloc0(clamped_nvalues2 * sizeof(bool));\n\n\t\t/*\n\t\t * Note we assume that each MCV will match at most one member of the\n\t\t * other MCV list.  If the operator isn't really equality, there could\n\t\t * be multiple matches --- but we don't look for them, both for speed\n\t\t * and because the math wouldn't add up...\n\t\t */\n\t\tnmatches = 0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tint\t\t\tj;\n\n\t\t\tfor (j = 0; j < clamped_nvalues2; j++)\n\t\t\t{\n\t\t\t\tif (hasmatch2[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot1.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot2.values[j])))\n\t\t\t\t{\n\t\t\t\t\thasmatch1[i] = hasmatch2[j] = true;\n\t\t\t\t\tnmatches++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Sum up frequencies of matched MCVs */\n\t\tmatchfreq1 = 0.0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch1[i])\n\t\t\t\tmatchfreq1 += sslot1.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq1);\n\t\tpfree(hasmatch1);\n\t\tpfree(hasmatch2);\n\n\t\t/*\n\t\t * Now we need to estimate the fraction of relation 1 that has at\n\t\t * least one join partner.  We know for certain that the matched MCVs\n\t\t * do, so that gives us a lower bound, but we're really in the dark\n\t\t * about everything else.  Our crude approach is: if nd1 <= nd2 then\n\t\t * assume all non-null rel1 rows have join partners, else assume for\n\t\t * the uncertain rows that a fraction nd2/nd1 have join partners. We\n\t\t * can discount the known-matched MCVs from the distinct-values counts\n\t\t * before doing the division.\n\t\t *\n\t\t * Crude as the above is, it's completely useless if we don't have\n\t\t * reliable ndistinct values for both sides.  Hence, if either nd1 or\n\t\t * nd2 is default, punt and assume half of the uncertain rows have\n\t\t * join partners.\n\t\t */\n\t\tif (!isdefault1 && !isdefault2)\n\t\t{\n\t\t\tnd1 -= nmatches;\n\t\t\tnd2 -= nmatches;\n\t\t\tif (nd1 <= nd2 || nd2 < 0)\n\t\t\t\tuncertainfrac = 1.0;\n\t\t\telse\n\t\t\t\tuncertainfrac = nd2 / nd1;\n\t\t}\n\t\telse\n\t\t\tuncertainfrac = 0.5;\n\t\tuncertain = 1.0 - matchfreq1 - nullfrac1;\n\t\tCLAMP_PROBABILITY(uncertain);\n\t\tselec = matchfreq1 + uncertainfrac * uncertain;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Without MCV lists for both sides, we can only use the heuristic\n\t\t * about nd1 vs nd2.\n\t\t */\n\t\tdouble\t\tnullfrac1 = stats1 ? stats1->stanullfrac : 0.0;\n\n\t\tif (!isdefault1 && !isdefault2)\n\t\t{\n\t\t\tif (nd1 <= nd2 || nd2 < 0)\n\t\t\t\tselec = 1.0 - nullfrac1;\n\t\t\telse\n\t\t\t\tselec = (nd2 / nd1) * (1.0 - nullfrac1);\n\t\t}\n\t\telse\n\t\t\tselec = 0.5 * (1.0 - nullfrac1);\n\t}\n\n\tfree_attstatsslot(&sslot1);\n\tfree_attstatsslot(&sslot2);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
      "static double eqjoinsel_semi(Oid operator,\n\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t   RelOptInfo *inner_rel);",
      "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot2"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "uncertain"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "hasmatch2"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "matchfreq1"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot1.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot2.values[j])"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&eqproc",
            "DEFAULT_COLLATION_OID",
            "sslot1.values[i]",
            "sslot2.values[j]"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "clamped_nvalues2 * sizeof(bool)"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "opfuncoid",
            "&eqproc"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "sslot2.nvalues",
            "nd2"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "operator"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot2",
            "vardata2->statsTuple",
            "STATISTIC_KIND_MCV",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statistic_proc_security_check",
          "args": [
            "vardata2",
            "opfuncoid"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "statistic_proc_security_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5167-5183",
          "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata2->statsTuple"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata1->statsTuple"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata1->statsTuple"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sslot2",
            "0",
            "sizeof(sslot2)"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sslot1",
            "0",
            "sizeof(sslot1)"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "operator"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "operator"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_variable_numdistinct",
          "args": [
            "vardata2",
            "&isdefault2"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "get_variable_numdistinct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5196-5318",
          "snippet": "double\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic double eqjoinsel_semi(Oid operator,\n\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t   RelOptInfo *inner_rel);\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\n\nstatic double\neqjoinsel_semi(Oid operator,\n\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t   RelOptInfo *inner_rel)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnd1;\n\tdouble\t\tnd2;\n\tbool\t\tisdefault1;\n\tbool\t\tisdefault2;\n\tOid\t\t\topfuncoid;\n\tForm_pg_statistic stats1 = NULL;\n\tbool\t\thave_mcvs1 = false;\n\tbool\t\thave_mcvs2 = false;\n\tAttStatsSlot sslot1;\n\tAttStatsSlot sslot2;\n\n\tnd1 = get_variable_numdistinct(vardata1, &isdefault1);\n\tnd2 = get_variable_numdistinct(vardata2, &isdefault2);\n\n\topfuncoid = OidIsValid(operator) ? get_opcode(operator) : InvalidOid;\n\n\tmemset(&sslot1, 0, sizeof(sslot1));\n\tmemset(&sslot2, 0, sizeof(sslot2));\n\n\t/*\n\t * We clamp nd2 to be not more than what we estimate the inner relation's\n\t * size to be.  This is intuitively somewhat reasonable since obviously\n\t * there can't be more than that many distinct values coming from the\n\t * inner rel.  The reason for the asymmetry (ie, that we don't clamp nd1\n\t * likewise) is that this is the only pathway by which restriction clauses\n\t * applied to the inner rel will affect the join result size estimate,\n\t * since set_joinrel_size_estimates will multiply SEMI/ANTI selectivity by\n\t * only the outer rel's size.  If we clamped nd1 we'd be double-counting\n\t * the selectivity of outer-rel restrictions.\n\t *\n\t * We can apply this clamping both with respect to the base relation from\n\t * which the join variable comes (if there is just one), and to the\n\t * immediate inner input relation of the current join.\n\t *\n\t * If we clamp, we can treat nd2 as being a non-default estimate; it's not\n\t * great, maybe, but it didn't come out of nowhere either.  This is most\n\t * helpful when the inner relation is empty and consequently has no stats.\n\t */\n\tif (vardata2->rel)\n\t{\n\t\tif (nd2 >= vardata2->rel->rows)\n\t\t{\n\t\t\tnd2 = vardata2->rel->rows;\n\t\t\tisdefault2 = false;\n\t\t}\n\t}\n\tif (nd2 >= inner_rel->rows)\n\t{\n\t\tnd2 = inner_rel->rows;\n\t\tisdefault2 = false;\n\t}\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats1 = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tif (statistic_proc_security_check(vardata1, opfuncoid))\n\t\t\thave_mcvs1 = get_attstatsslot(&sslot1, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata2, opfuncoid))\n\t{\n\t\thave_mcvs2 = get_attstatsslot(&sslot2, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES);\n\t\t/* note: currently don't need stanumbers from RHS */\n\t}\n\n\tif (have_mcvs1 && have_mcvs2 && OidIsValid(operator))\n\t{\n\t\t/*\n\t\t * We have most-common-value lists for both relations.  Run through\n\t\t * the lists to see which MCVs actually join to each other with the\n\t\t * given operator.  This allows us to determine the exact join\n\t\t * selectivity for the portion of the relations represented by the MCV\n\t\t * lists.  We still have to estimate for the remaining population, but\n\t\t * in a skewed distribution this gives us a big leg up in accuracy.\n\t\t */\n\t\tFmgrInfo\teqproc;\n\t\tbool\t   *hasmatch1;\n\t\tbool\t   *hasmatch2;\n\t\tdouble\t\tnullfrac1 = stats1->stanullfrac;\n\t\tdouble\t\tmatchfreq1,\n\t\t\t\t\tuncertainfrac,\n\t\t\t\t\tuncertain;\n\t\tint\t\t\ti,\n\t\t\t\t\tnmatches,\n\t\t\t\t\tclamped_nvalues2;\n\n\t\t/*\n\t\t * The clamping above could have resulted in nd2 being less than\n\t\t * sslot2.nvalues; in which case, we assume that precisely the nd2\n\t\t * most common values in the relation will appear in the join input,\n\t\t * and so compare to only the first nd2 members of the MCV list.  Of\n\t\t * course this is frequently wrong, but it's the best bet we can make.\n\t\t */\n\t\tclamped_nvalues2 = Min(sslot2.nvalues, nd2);\n\n\t\tfmgr_info(opfuncoid, &eqproc);\n\t\thasmatch1 = (bool *) palloc0(sslot1.nvalues * sizeof(bool));\n\t\thasmatch2 = (bool *) palloc0(clamped_nvalues2 * sizeof(bool));\n\n\t\t/*\n\t\t * Note we assume that each MCV will match at most one member of the\n\t\t * other MCV list.  If the operator isn't really equality, there could\n\t\t * be multiple matches --- but we don't look for them, both for speed\n\t\t * and because the math wouldn't add up...\n\t\t */\n\t\tnmatches = 0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tint\t\t\tj;\n\n\t\t\tfor (j = 0; j < clamped_nvalues2; j++)\n\t\t\t{\n\t\t\t\tif (hasmatch2[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot1.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot2.values[j])))\n\t\t\t\t{\n\t\t\t\t\thasmatch1[i] = hasmatch2[j] = true;\n\t\t\t\t\tnmatches++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Sum up frequencies of matched MCVs */\n\t\tmatchfreq1 = 0.0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch1[i])\n\t\t\t\tmatchfreq1 += sslot1.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq1);\n\t\tpfree(hasmatch1);\n\t\tpfree(hasmatch2);\n\n\t\t/*\n\t\t * Now we need to estimate the fraction of relation 1 that has at\n\t\t * least one join partner.  We know for certain that the matched MCVs\n\t\t * do, so that gives us a lower bound, but we're really in the dark\n\t\t * about everything else.  Our crude approach is: if nd1 <= nd2 then\n\t\t * assume all non-null rel1 rows have join partners, else assume for\n\t\t * the uncertain rows that a fraction nd2/nd1 have join partners. We\n\t\t * can discount the known-matched MCVs from the distinct-values counts\n\t\t * before doing the division.\n\t\t *\n\t\t * Crude as the above is, it's completely useless if we don't have\n\t\t * reliable ndistinct values for both sides.  Hence, if either nd1 or\n\t\t * nd2 is default, punt and assume half of the uncertain rows have\n\t\t * join partners.\n\t\t */\n\t\tif (!isdefault1 && !isdefault2)\n\t\t{\n\t\t\tnd1 -= nmatches;\n\t\t\tnd2 -= nmatches;\n\t\t\tif (nd1 <= nd2 || nd2 < 0)\n\t\t\t\tuncertainfrac = 1.0;\n\t\t\telse\n\t\t\t\tuncertainfrac = nd2 / nd1;\n\t\t}\n\t\telse\n\t\t\tuncertainfrac = 0.5;\n\t\tuncertain = 1.0 - matchfreq1 - nullfrac1;\n\t\tCLAMP_PROBABILITY(uncertain);\n\t\tselec = matchfreq1 + uncertainfrac * uncertain;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Without MCV lists for both sides, we can only use the heuristic\n\t\t * about nd1 vs nd2.\n\t\t */\n\t\tdouble\t\tnullfrac1 = stats1 ? stats1->stanullfrac : 0.0;\n\n\t\tif (!isdefault1 && !isdefault2)\n\t\t{\n\t\t\tif (nd1 <= nd2 || nd2 < 0)\n\t\t\t\tselec = 1.0 - nullfrac1;\n\t\t\telse\n\t\t\t\tselec = (nd2 / nd1) * (1.0 - nullfrac1);\n\t\t}\n\t\telse\n\t\t\tselec = 0.5 * (1.0 - nullfrac1);\n\t}\n\n\tfree_attstatsslot(&sslot1);\n\tfree_attstatsslot(&sslot2);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "eqjoinsel_inner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2351-2559",
    "snippet": "static double\neqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnd1;\n\tdouble\t\tnd2;\n\tbool\t\tisdefault1;\n\tbool\t\tisdefault2;\n\tOid\t\t\topfuncoid;\n\tForm_pg_statistic stats1 = NULL;\n\tForm_pg_statistic stats2 = NULL;\n\tbool\t\thave_mcvs1 = false;\n\tbool\t\thave_mcvs2 = false;\n\tAttStatsSlot sslot1;\n\tAttStatsSlot sslot2;\n\n\tnd1 = get_variable_numdistinct(vardata1, &isdefault1);\n\tnd2 = get_variable_numdistinct(vardata2, &isdefault2);\n\n\topfuncoid = get_opcode(operator);\n\n\tmemset(&sslot1, 0, sizeof(sslot1));\n\tmemset(&sslot2, 0, sizeof(sslot2));\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats1 = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tif (statistic_proc_security_check(vardata1, opfuncoid))\n\t\t\thave_mcvs1 = get_attstatsslot(&sslot1, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats2 = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tif (statistic_proc_security_check(vardata2, opfuncoid))\n\t\t\thave_mcvs2 = get_attstatsslot(&sslot2, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (have_mcvs1 && have_mcvs2)\n\t{\n\t\t/*\n\t\t * We have most-common-value lists for both relations.  Run through\n\t\t * the lists to see which MCVs actually join to each other with the\n\t\t * given operator.  This allows us to determine the exact join\n\t\t * selectivity for the portion of the relations represented by the MCV\n\t\t * lists.  We still have to estimate for the remaining population, but\n\t\t * in a skewed distribution this gives us a big leg up in accuracy.\n\t\t * For motivation see the analysis in Y. Ioannidis and S.\n\t\t * Christodoulakis, \"On the propagation of errors in the size of join\n\t\t * results\", Technical Report 1018, Computer Science Dept., University\n\t\t * of Wisconsin, Madison, March 1991 (available from ftp.cs.wisc.edu).\n\t\t */\n\t\tFmgrInfo\teqproc;\n\t\tbool\t   *hasmatch1;\n\t\tbool\t   *hasmatch2;\n\t\tdouble\t\tnullfrac1 = stats1->stanullfrac;\n\t\tdouble\t\tnullfrac2 = stats2->stanullfrac;\n\t\tdouble\t\tmatchprodfreq,\n\t\t\t\t\tmatchfreq1,\n\t\t\t\t\tmatchfreq2,\n\t\t\t\t\tunmatchfreq1,\n\t\t\t\t\tunmatchfreq2,\n\t\t\t\t\totherfreq1,\n\t\t\t\t\totherfreq2,\n\t\t\t\t\ttotalsel1,\n\t\t\t\t\ttotalsel2;\n\t\tint\t\t\ti,\n\t\t\t\t\tnmatches;\n\n\t\tfmgr_info(opfuncoid, &eqproc);\n\t\thasmatch1 = (bool *) palloc0(sslot1.nvalues * sizeof(bool));\n\t\thasmatch2 = (bool *) palloc0(sslot2.nvalues * sizeof(bool));\n\n\t\t/*\n\t\t * Note we assume that each MCV will match at most one member of the\n\t\t * other MCV list.  If the operator isn't really equality, there could\n\t\t * be multiple matches --- but we don't look for them, both for speed\n\t\t * and because the math wouldn't add up...\n\t\t */\n\t\tmatchprodfreq = 0.0;\n\t\tnmatches = 0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tint\t\t\tj;\n\n\t\t\tfor (j = 0; j < sslot2.nvalues; j++)\n\t\t\t{\n\t\t\t\tif (hasmatch2[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot1.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot2.values[j])))\n\t\t\t\t{\n\t\t\t\t\thasmatch1[i] = hasmatch2[j] = true;\n\t\t\t\t\tmatchprodfreq += sslot1.numbers[i] * sslot2.numbers[j];\n\t\t\t\t\tnmatches++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCLAMP_PROBABILITY(matchprodfreq);\n\t\t/* Sum up frequencies of matched and unmatched MCVs */\n\t\tmatchfreq1 = unmatchfreq1 = 0.0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch1[i])\n\t\t\t\tmatchfreq1 += sslot1.numbers[i];\n\t\t\telse\n\t\t\t\tunmatchfreq1 += sslot1.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq1);\n\t\tCLAMP_PROBABILITY(unmatchfreq1);\n\t\tmatchfreq2 = unmatchfreq2 = 0.0;\n\t\tfor (i = 0; i < sslot2.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch2[i])\n\t\t\t\tmatchfreq2 += sslot2.numbers[i];\n\t\t\telse\n\t\t\t\tunmatchfreq2 += sslot2.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq2);\n\t\tCLAMP_PROBABILITY(unmatchfreq2);\n\t\tpfree(hasmatch1);\n\t\tpfree(hasmatch2);\n\n\t\t/*\n\t\t * Compute total frequency of non-null values that are not in the MCV\n\t\t * lists.\n\t\t */\n\t\totherfreq1 = 1.0 - nullfrac1 - matchfreq1 - unmatchfreq1;\n\t\totherfreq2 = 1.0 - nullfrac2 - matchfreq2 - unmatchfreq2;\n\t\tCLAMP_PROBABILITY(otherfreq1);\n\t\tCLAMP_PROBABILITY(otherfreq2);\n\n\t\t/*\n\t\t * We can estimate the total selectivity from the point of view of\n\t\t * relation 1 as: the known selectivity for matched MCVs, plus\n\t\t * unmatched MCVs that are assumed to match against random members of\n\t\t * relation 2's non-MCV population, plus non-MCV values that are\n\t\t * assumed to match against random members of relation 2's unmatched\n\t\t * MCVs plus non-MCV values.\n\t\t */\n\t\ttotalsel1 = matchprodfreq;\n\t\tif (nd2 > sslot2.nvalues)\n\t\t\ttotalsel1 += unmatchfreq1 * otherfreq2 / (nd2 - sslot2.nvalues);\n\t\tif (nd2 > nmatches)\n\t\t\ttotalsel1 += otherfreq1 * (otherfreq2 + unmatchfreq2) /\n\t\t\t\t(nd2 - nmatches);\n\t\t/* Same estimate from the point of view of relation 2. */\n\t\ttotalsel2 = matchprodfreq;\n\t\tif (nd1 > sslot1.nvalues)\n\t\t\ttotalsel2 += unmatchfreq2 * otherfreq1 / (nd1 - sslot1.nvalues);\n\t\tif (nd1 > nmatches)\n\t\t\ttotalsel2 += otherfreq2 * (otherfreq1 + unmatchfreq1) /\n\t\t\t\t(nd1 - nmatches);\n\n\t\t/*\n\t\t * Use the smaller of the two estimates.  This can be justified in\n\t\t * essentially the same terms as given below for the no-stats case: to\n\t\t * a first approximation, we are estimating from the point of view of\n\t\t * the relation with smaller nd.\n\t\t */\n\t\tselec = (totalsel1 < totalsel2) ? totalsel1 : totalsel2;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We do not have MCV lists for both sides.  Estimate the join\n\t\t * selectivity as MIN(1/nd1,1/nd2)*(1-nullfrac1)*(1-nullfrac2). This\n\t\t * is plausible if we assume that the join operator is strict and the\n\t\t * non-null values are about equally distributed: a given non-null\n\t\t * tuple of rel1 will join to either zero or N2*(1-nullfrac2)/nd2 rows\n\t\t * of rel2, so total join rows are at most\n\t\t * N1*(1-nullfrac1)*N2*(1-nullfrac2)/nd2 giving a join selectivity of\n\t\t * not more than (1-nullfrac1)*(1-nullfrac2)/nd2. By the same logic it\n\t\t * is not more than (1-nullfrac1)*(1-nullfrac2)/nd1, so the expression\n\t\t * with MIN() is an upper bound.  Using the MIN() means we estimate\n\t\t * from the point of view of the relation with smaller nd (since the\n\t\t * larger nd is determining the MIN).  It is reasonable to assume that\n\t\t * most tuples in this rel will have join partners, so the bound is\n\t\t * probably reasonably tight and should be taken as-is.\n\t\t *\n\t\t * XXX Can we be smarter if we have an MCV list for just one side? It\n\t\t * seems that if we assume equal distribution for the other side, we\n\t\t * end up with the same answer anyway.\n\t\t */\n\t\tdouble\t\tnullfrac1 = stats1 ? stats1->stanullfrac : 0.0;\n\t\tdouble\t\tnullfrac2 = stats2 ? stats2->stanullfrac : 0.0;\n\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2);\n\t\tif (nd1 > nd2)\n\t\t\tselec /= nd1;\n\t\telse\n\t\t\tselec /= nd2;\n\t}\n\n\tfree_attstatsslot(&sslot1);\n\tfree_attstatsslot(&sslot2);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot2"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "otherfreq2"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "otherfreq1"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "hasmatch2"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "unmatchfreq2"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "matchfreq2"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "unmatchfreq1"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "matchfreq1"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "matchprodfreq"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot1.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot2.values[j])"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&eqproc",
            "DEFAULT_COLLATION_OID",
            "sslot1.values[i]",
            "sslot2.values[j]"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sslot2.nvalues * sizeof(bool)"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "opfuncoid",
            "&eqproc"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot2",
            "vardata2->statsTuple",
            "STATISTIC_KIND_MCV",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statistic_proc_security_check",
          "args": [
            "vardata2",
            "opfuncoid"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "statistic_proc_security_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5167-5183",
          "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata2->statsTuple"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata2->statsTuple"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata1->statsTuple"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata1->statsTuple"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sslot2",
            "0",
            "sizeof(sslot2)"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sslot1",
            "0",
            "sizeof(sslot1)"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "operator"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_variable_numdistinct",
          "args": [
            "vardata2",
            "&isdefault2"
          ],
          "line": 2369
        },
        "resolved": true,
        "details": {
          "function_name": "get_variable_numdistinct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5196-5318",
          "snippet": "double\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\n\nstatic double\neqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnd1;\n\tdouble\t\tnd2;\n\tbool\t\tisdefault1;\n\tbool\t\tisdefault2;\n\tOid\t\t\topfuncoid;\n\tForm_pg_statistic stats1 = NULL;\n\tForm_pg_statistic stats2 = NULL;\n\tbool\t\thave_mcvs1 = false;\n\tbool\t\thave_mcvs2 = false;\n\tAttStatsSlot sslot1;\n\tAttStatsSlot sslot2;\n\n\tnd1 = get_variable_numdistinct(vardata1, &isdefault1);\n\tnd2 = get_variable_numdistinct(vardata2, &isdefault2);\n\n\topfuncoid = get_opcode(operator);\n\n\tmemset(&sslot1, 0, sizeof(sslot1));\n\tmemset(&sslot2, 0, sizeof(sslot2));\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats1 = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tif (statistic_proc_security_check(vardata1, opfuncoid))\n\t\t\thave_mcvs1 = get_attstatsslot(&sslot1, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats2 = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tif (statistic_proc_security_check(vardata2, opfuncoid))\n\t\t\thave_mcvs2 = get_attstatsslot(&sslot2, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (have_mcvs1 && have_mcvs2)\n\t{\n\t\t/*\n\t\t * We have most-common-value lists for both relations.  Run through\n\t\t * the lists to see which MCVs actually join to each other with the\n\t\t * given operator.  This allows us to determine the exact join\n\t\t * selectivity for the portion of the relations represented by the MCV\n\t\t * lists.  We still have to estimate for the remaining population, but\n\t\t * in a skewed distribution this gives us a big leg up in accuracy.\n\t\t * For motivation see the analysis in Y. Ioannidis and S.\n\t\t * Christodoulakis, \"On the propagation of errors in the size of join\n\t\t * results\", Technical Report 1018, Computer Science Dept., University\n\t\t * of Wisconsin, Madison, March 1991 (available from ftp.cs.wisc.edu).\n\t\t */\n\t\tFmgrInfo\teqproc;\n\t\tbool\t   *hasmatch1;\n\t\tbool\t   *hasmatch2;\n\t\tdouble\t\tnullfrac1 = stats1->stanullfrac;\n\t\tdouble\t\tnullfrac2 = stats2->stanullfrac;\n\t\tdouble\t\tmatchprodfreq,\n\t\t\t\t\tmatchfreq1,\n\t\t\t\t\tmatchfreq2,\n\t\t\t\t\tunmatchfreq1,\n\t\t\t\t\tunmatchfreq2,\n\t\t\t\t\totherfreq1,\n\t\t\t\t\totherfreq2,\n\t\t\t\t\ttotalsel1,\n\t\t\t\t\ttotalsel2;\n\t\tint\t\t\ti,\n\t\t\t\t\tnmatches;\n\n\t\tfmgr_info(opfuncoid, &eqproc);\n\t\thasmatch1 = (bool *) palloc0(sslot1.nvalues * sizeof(bool));\n\t\thasmatch2 = (bool *) palloc0(sslot2.nvalues * sizeof(bool));\n\n\t\t/*\n\t\t * Note we assume that each MCV will match at most one member of the\n\t\t * other MCV list.  If the operator isn't really equality, there could\n\t\t * be multiple matches --- but we don't look for them, both for speed\n\t\t * and because the math wouldn't add up...\n\t\t */\n\t\tmatchprodfreq = 0.0;\n\t\tnmatches = 0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tint\t\t\tj;\n\n\t\t\tfor (j = 0; j < sslot2.nvalues; j++)\n\t\t\t{\n\t\t\t\tif (hasmatch2[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot1.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot2.values[j])))\n\t\t\t\t{\n\t\t\t\t\thasmatch1[i] = hasmatch2[j] = true;\n\t\t\t\t\tmatchprodfreq += sslot1.numbers[i] * sslot2.numbers[j];\n\t\t\t\t\tnmatches++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCLAMP_PROBABILITY(matchprodfreq);\n\t\t/* Sum up frequencies of matched and unmatched MCVs */\n\t\tmatchfreq1 = unmatchfreq1 = 0.0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch1[i])\n\t\t\t\tmatchfreq1 += sslot1.numbers[i];\n\t\t\telse\n\t\t\t\tunmatchfreq1 += sslot1.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq1);\n\t\tCLAMP_PROBABILITY(unmatchfreq1);\n\t\tmatchfreq2 = unmatchfreq2 = 0.0;\n\t\tfor (i = 0; i < sslot2.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch2[i])\n\t\t\t\tmatchfreq2 += sslot2.numbers[i];\n\t\t\telse\n\t\t\t\tunmatchfreq2 += sslot2.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq2);\n\t\tCLAMP_PROBABILITY(unmatchfreq2);\n\t\tpfree(hasmatch1);\n\t\tpfree(hasmatch2);\n\n\t\t/*\n\t\t * Compute total frequency of non-null values that are not in the MCV\n\t\t * lists.\n\t\t */\n\t\totherfreq1 = 1.0 - nullfrac1 - matchfreq1 - unmatchfreq1;\n\t\totherfreq2 = 1.0 - nullfrac2 - matchfreq2 - unmatchfreq2;\n\t\tCLAMP_PROBABILITY(otherfreq1);\n\t\tCLAMP_PROBABILITY(otherfreq2);\n\n\t\t/*\n\t\t * We can estimate the total selectivity from the point of view of\n\t\t * relation 1 as: the known selectivity for matched MCVs, plus\n\t\t * unmatched MCVs that are assumed to match against random members of\n\t\t * relation 2's non-MCV population, plus non-MCV values that are\n\t\t * assumed to match against random members of relation 2's unmatched\n\t\t * MCVs plus non-MCV values.\n\t\t */\n\t\ttotalsel1 = matchprodfreq;\n\t\tif (nd2 > sslot2.nvalues)\n\t\t\ttotalsel1 += unmatchfreq1 * otherfreq2 / (nd2 - sslot2.nvalues);\n\t\tif (nd2 > nmatches)\n\t\t\ttotalsel1 += otherfreq1 * (otherfreq2 + unmatchfreq2) /\n\t\t\t\t(nd2 - nmatches);\n\t\t/* Same estimate from the point of view of relation 2. */\n\t\ttotalsel2 = matchprodfreq;\n\t\tif (nd1 > sslot1.nvalues)\n\t\t\ttotalsel2 += unmatchfreq2 * otherfreq1 / (nd1 - sslot1.nvalues);\n\t\tif (nd1 > nmatches)\n\t\t\ttotalsel2 += otherfreq2 * (otherfreq1 + unmatchfreq1) /\n\t\t\t\t(nd1 - nmatches);\n\n\t\t/*\n\t\t * Use the smaller of the two estimates.  This can be justified in\n\t\t * essentially the same terms as given below for the no-stats case: to\n\t\t * a first approximation, we are estimating from the point of view of\n\t\t * the relation with smaller nd.\n\t\t */\n\t\tselec = (totalsel1 < totalsel2) ? totalsel1 : totalsel2;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We do not have MCV lists for both sides.  Estimate the join\n\t\t * selectivity as MIN(1/nd1,1/nd2)*(1-nullfrac1)*(1-nullfrac2). This\n\t\t * is plausible if we assume that the join operator is strict and the\n\t\t * non-null values are about equally distributed: a given non-null\n\t\t * tuple of rel1 will join to either zero or N2*(1-nullfrac2)/nd2 rows\n\t\t * of rel2, so total join rows are at most\n\t\t * N1*(1-nullfrac1)*N2*(1-nullfrac2)/nd2 giving a join selectivity of\n\t\t * not more than (1-nullfrac1)*(1-nullfrac2)/nd2. By the same logic it\n\t\t * is not more than (1-nullfrac1)*(1-nullfrac2)/nd1, so the expression\n\t\t * with MIN() is an upper bound.  Using the MIN() means we estimate\n\t\t * from the point of view of the relation with smaller nd (since the\n\t\t * larger nd is determining the MIN).  It is reasonable to assume that\n\t\t * most tuples in this rel will have join partners, so the bound is\n\t\t * probably reasonably tight and should be taken as-is.\n\t\t *\n\t\t * XXX Can we be smarter if we have an MCV list for just one side? It\n\t\t * seems that if we assume equal distribution for the other side, we\n\t\t * end up with the same answer anyway.\n\t\t */\n\t\tdouble\t\tnullfrac1 = stats1 ? stats1->stanullfrac : 0.0;\n\t\tdouble\t\tnullfrac2 = stats2 ? stats2->stanullfrac : 0.0;\n\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2);\n\t\tif (nd1 > nd2)\n\t\t\tselec /= nd1;\n\t\telse\n\t\t\tselec /= nd2;\n\t}\n\n\tfree_attstatsslot(&sslot1);\n\tfree_attstatsslot(&sslot2);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "eqjoinsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2283-2343",
    "snippet": "Datum\neqjoinsel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\n#ifdef NOT_USED\n\tJoinType\tjointype = (JoinType) PG_GETARG_INT16(3);\n#endif\n\tSpecialJoinInfo *sjinfo = (SpecialJoinInfo *) PG_GETARG_POINTER(4);\n\tdouble\t\tselec;\n\tVariableStatData vardata1;\n\tVariableStatData vardata2;\n\tbool\t\tjoin_is_reversed;\n\tRelOptInfo *inner_rel;\n\n\tget_join_variables(root, args, sjinfo,\n\t\t\t\t\t   &vardata1, &vardata2, &join_is_reversed);\n\n\tswitch (sjinfo->jointype)\n\t{\n\t\tcase JOIN_INNER:\n\t\tcase JOIN_LEFT:\n\t\tcase JOIN_FULL:\n\t\t\tselec = eqjoinsel_inner(operator, &vardata1, &vardata2);\n\t\t\tbreak;\n\t\tcase JOIN_SEMI:\n\t\tcase JOIN_ANTI:\n\n\t\t\t/*\n\t\t\t * Look up the join's inner relation.  min_righthand is sufficient\n\t\t\t * information because neither SEMI nor ANTI joins permit any\n\t\t\t * reassociation into or out of their RHS, so the righthand will\n\t\t\t * always be exactly that set of rels.\n\t\t\t */\n\t\t\tinner_rel = find_join_input_rel(root, sjinfo->min_righthand);\n\n\t\t\tif (!join_is_reversed)\n\t\t\t\tselec = eqjoinsel_semi(operator, &vardata1, &vardata2,\n\t\t\t\t\t\t\t\t\t   inner_rel);\n\t\t\telse\n\t\t\t\tselec = eqjoinsel_semi(get_commutator(operator),\n\t\t\t\t\t\t\t\t\t   &vardata2, &vardata1,\n\t\t\t\t\t\t\t\t\t   inner_rel);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* other values not expected here */\n\t\t\telog(ERROR, \"unrecognized join type: %d\",\n\t\t\t\t (int) sjinfo->jointype);\n\t\t\tselec = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\tReleaseVariableStats(vardata1);\n\tReleaseVariableStats(vardata2);\n\n\tCLAMP_PROBABILITY(selec);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
      "static double eqjoinsel_semi(Oid operator,\n\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t   RelOptInfo *inner_rel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) selec"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata2"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata1"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized join type: %d\"",
            "(int) sjinfo->jointype"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eqjoinsel_semi",
          "args": [
            "get_commutator(operator)",
            "&vardata2",
            "&vardata1",
            "inner_rel"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "eqjoinsel_semi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2568-2769",
          "snippet": "static double\neqjoinsel_semi(Oid operator,\n\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t   RelOptInfo *inner_rel)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnd1;\n\tdouble\t\tnd2;\n\tbool\t\tisdefault1;\n\tbool\t\tisdefault2;\n\tOid\t\t\topfuncoid;\n\tForm_pg_statistic stats1 = NULL;\n\tbool\t\thave_mcvs1 = false;\n\tbool\t\thave_mcvs2 = false;\n\tAttStatsSlot sslot1;\n\tAttStatsSlot sslot2;\n\n\tnd1 = get_variable_numdistinct(vardata1, &isdefault1);\n\tnd2 = get_variable_numdistinct(vardata2, &isdefault2);\n\n\topfuncoid = OidIsValid(operator) ? get_opcode(operator) : InvalidOid;\n\n\tmemset(&sslot1, 0, sizeof(sslot1));\n\tmemset(&sslot2, 0, sizeof(sslot2));\n\n\t/*\n\t * We clamp nd2 to be not more than what we estimate the inner relation's\n\t * size to be.  This is intuitively somewhat reasonable since obviously\n\t * there can't be more than that many distinct values coming from the\n\t * inner rel.  The reason for the asymmetry (ie, that we don't clamp nd1\n\t * likewise) is that this is the only pathway by which restriction clauses\n\t * applied to the inner rel will affect the join result size estimate,\n\t * since set_joinrel_size_estimates will multiply SEMI/ANTI selectivity by\n\t * only the outer rel's size.  If we clamped nd1 we'd be double-counting\n\t * the selectivity of outer-rel restrictions.\n\t *\n\t * We can apply this clamping both with respect to the base relation from\n\t * which the join variable comes (if there is just one), and to the\n\t * immediate inner input relation of the current join.\n\t *\n\t * If we clamp, we can treat nd2 as being a non-default estimate; it's not\n\t * great, maybe, but it didn't come out of nowhere either.  This is most\n\t * helpful when the inner relation is empty and consequently has no stats.\n\t */\n\tif (vardata2->rel)\n\t{\n\t\tif (nd2 >= vardata2->rel->rows)\n\t\t{\n\t\t\tnd2 = vardata2->rel->rows;\n\t\t\tisdefault2 = false;\n\t\t}\n\t}\n\tif (nd2 >= inner_rel->rows)\n\t{\n\t\tnd2 = inner_rel->rows;\n\t\tisdefault2 = false;\n\t}\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats1 = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tif (statistic_proc_security_check(vardata1, opfuncoid))\n\t\t\thave_mcvs1 = get_attstatsslot(&sslot1, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata2, opfuncoid))\n\t{\n\t\thave_mcvs2 = get_attstatsslot(&sslot2, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES);\n\t\t/* note: currently don't need stanumbers from RHS */\n\t}\n\n\tif (have_mcvs1 && have_mcvs2 && OidIsValid(operator))\n\t{\n\t\t/*\n\t\t * We have most-common-value lists for both relations.  Run through\n\t\t * the lists to see which MCVs actually join to each other with the\n\t\t * given operator.  This allows us to determine the exact join\n\t\t * selectivity for the portion of the relations represented by the MCV\n\t\t * lists.  We still have to estimate for the remaining population, but\n\t\t * in a skewed distribution this gives us a big leg up in accuracy.\n\t\t */\n\t\tFmgrInfo\teqproc;\n\t\tbool\t   *hasmatch1;\n\t\tbool\t   *hasmatch2;\n\t\tdouble\t\tnullfrac1 = stats1->stanullfrac;\n\t\tdouble\t\tmatchfreq1,\n\t\t\t\t\tuncertainfrac,\n\t\t\t\t\tuncertain;\n\t\tint\t\t\ti,\n\t\t\t\t\tnmatches,\n\t\t\t\t\tclamped_nvalues2;\n\n\t\t/*\n\t\t * The clamping above could have resulted in nd2 being less than\n\t\t * sslot2.nvalues; in which case, we assume that precisely the nd2\n\t\t * most common values in the relation will appear in the join input,\n\t\t * and so compare to only the first nd2 members of the MCV list.  Of\n\t\t * course this is frequently wrong, but it's the best bet we can make.\n\t\t */\n\t\tclamped_nvalues2 = Min(sslot2.nvalues, nd2);\n\n\t\tfmgr_info(opfuncoid, &eqproc);\n\t\thasmatch1 = (bool *) palloc0(sslot1.nvalues * sizeof(bool));\n\t\thasmatch2 = (bool *) palloc0(clamped_nvalues2 * sizeof(bool));\n\n\t\t/*\n\t\t * Note we assume that each MCV will match at most one member of the\n\t\t * other MCV list.  If the operator isn't really equality, there could\n\t\t * be multiple matches --- but we don't look for them, both for speed\n\t\t * and because the math wouldn't add up...\n\t\t */\n\t\tnmatches = 0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tint\t\t\tj;\n\n\t\t\tfor (j = 0; j < clamped_nvalues2; j++)\n\t\t\t{\n\t\t\t\tif (hasmatch2[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot1.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot2.values[j])))\n\t\t\t\t{\n\t\t\t\t\thasmatch1[i] = hasmatch2[j] = true;\n\t\t\t\t\tnmatches++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Sum up frequencies of matched MCVs */\n\t\tmatchfreq1 = 0.0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch1[i])\n\t\t\t\tmatchfreq1 += sslot1.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq1);\n\t\tpfree(hasmatch1);\n\t\tpfree(hasmatch2);\n\n\t\t/*\n\t\t * Now we need to estimate the fraction of relation 1 that has at\n\t\t * least one join partner.  We know for certain that the matched MCVs\n\t\t * do, so that gives us a lower bound, but we're really in the dark\n\t\t * about everything else.  Our crude approach is: if nd1 <= nd2 then\n\t\t * assume all non-null rel1 rows have join partners, else assume for\n\t\t * the uncertain rows that a fraction nd2/nd1 have join partners. We\n\t\t * can discount the known-matched MCVs from the distinct-values counts\n\t\t * before doing the division.\n\t\t *\n\t\t * Crude as the above is, it's completely useless if we don't have\n\t\t * reliable ndistinct values for both sides.  Hence, if either nd1 or\n\t\t * nd2 is default, punt and assume half of the uncertain rows have\n\t\t * join partners.\n\t\t */\n\t\tif (!isdefault1 && !isdefault2)\n\t\t{\n\t\t\tnd1 -= nmatches;\n\t\t\tnd2 -= nmatches;\n\t\t\tif (nd1 <= nd2 || nd2 < 0)\n\t\t\t\tuncertainfrac = 1.0;\n\t\t\telse\n\t\t\t\tuncertainfrac = nd2 / nd1;\n\t\t}\n\t\telse\n\t\t\tuncertainfrac = 0.5;\n\t\tuncertain = 1.0 - matchfreq1 - nullfrac1;\n\t\tCLAMP_PROBABILITY(uncertain);\n\t\tselec = matchfreq1 + uncertainfrac * uncertain;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Without MCV lists for both sides, we can only use the heuristic\n\t\t * about nd1 vs nd2.\n\t\t */\n\t\tdouble\t\tnullfrac1 = stats1 ? stats1->stanullfrac : 0.0;\n\n\t\tif (!isdefault1 && !isdefault2)\n\t\t{\n\t\t\tif (nd1 <= nd2 || nd2 < 0)\n\t\t\t\tselec = 1.0 - nullfrac1;\n\t\t\telse\n\t\t\t\tselec = (nd2 / nd1) * (1.0 - nullfrac1);\n\t\t}\n\t\telse\n\t\t\tselec = 0.5 * (1.0 - nullfrac1);\n\t}\n\n\tfree_attstatsslot(&sslot1);\n\tfree_attstatsslot(&sslot2);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
            "static double eqjoinsel_semi(Oid operator,\n\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t   RelOptInfo *inner_rel);",
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic double eqjoinsel_semi(Oid operator,\n\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t   RelOptInfo *inner_rel);\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\n\nstatic double\neqjoinsel_semi(Oid operator,\n\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t   RelOptInfo *inner_rel)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnd1;\n\tdouble\t\tnd2;\n\tbool\t\tisdefault1;\n\tbool\t\tisdefault2;\n\tOid\t\t\topfuncoid;\n\tForm_pg_statistic stats1 = NULL;\n\tbool\t\thave_mcvs1 = false;\n\tbool\t\thave_mcvs2 = false;\n\tAttStatsSlot sslot1;\n\tAttStatsSlot sslot2;\n\n\tnd1 = get_variable_numdistinct(vardata1, &isdefault1);\n\tnd2 = get_variable_numdistinct(vardata2, &isdefault2);\n\n\topfuncoid = OidIsValid(operator) ? get_opcode(operator) : InvalidOid;\n\n\tmemset(&sslot1, 0, sizeof(sslot1));\n\tmemset(&sslot2, 0, sizeof(sslot2));\n\n\t/*\n\t * We clamp nd2 to be not more than what we estimate the inner relation's\n\t * size to be.  This is intuitively somewhat reasonable since obviously\n\t * there can't be more than that many distinct values coming from the\n\t * inner rel.  The reason for the asymmetry (ie, that we don't clamp nd1\n\t * likewise) is that this is the only pathway by which restriction clauses\n\t * applied to the inner rel will affect the join result size estimate,\n\t * since set_joinrel_size_estimates will multiply SEMI/ANTI selectivity by\n\t * only the outer rel's size.  If we clamped nd1 we'd be double-counting\n\t * the selectivity of outer-rel restrictions.\n\t *\n\t * We can apply this clamping both with respect to the base relation from\n\t * which the join variable comes (if there is just one), and to the\n\t * immediate inner input relation of the current join.\n\t *\n\t * If we clamp, we can treat nd2 as being a non-default estimate; it's not\n\t * great, maybe, but it didn't come out of nowhere either.  This is most\n\t * helpful when the inner relation is empty and consequently has no stats.\n\t */\n\tif (vardata2->rel)\n\t{\n\t\tif (nd2 >= vardata2->rel->rows)\n\t\t{\n\t\t\tnd2 = vardata2->rel->rows;\n\t\t\tisdefault2 = false;\n\t\t}\n\t}\n\tif (nd2 >= inner_rel->rows)\n\t{\n\t\tnd2 = inner_rel->rows;\n\t\tisdefault2 = false;\n\t}\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats1 = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tif (statistic_proc_security_check(vardata1, opfuncoid))\n\t\t\thave_mcvs1 = get_attstatsslot(&sslot1, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata2, opfuncoid))\n\t{\n\t\thave_mcvs2 = get_attstatsslot(&sslot2, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES);\n\t\t/* note: currently don't need stanumbers from RHS */\n\t}\n\n\tif (have_mcvs1 && have_mcvs2 && OidIsValid(operator))\n\t{\n\t\t/*\n\t\t * We have most-common-value lists for both relations.  Run through\n\t\t * the lists to see which MCVs actually join to each other with the\n\t\t * given operator.  This allows us to determine the exact join\n\t\t * selectivity for the portion of the relations represented by the MCV\n\t\t * lists.  We still have to estimate for the remaining population, but\n\t\t * in a skewed distribution this gives us a big leg up in accuracy.\n\t\t */\n\t\tFmgrInfo\teqproc;\n\t\tbool\t   *hasmatch1;\n\t\tbool\t   *hasmatch2;\n\t\tdouble\t\tnullfrac1 = stats1->stanullfrac;\n\t\tdouble\t\tmatchfreq1,\n\t\t\t\t\tuncertainfrac,\n\t\t\t\t\tuncertain;\n\t\tint\t\t\ti,\n\t\t\t\t\tnmatches,\n\t\t\t\t\tclamped_nvalues2;\n\n\t\t/*\n\t\t * The clamping above could have resulted in nd2 being less than\n\t\t * sslot2.nvalues; in which case, we assume that precisely the nd2\n\t\t * most common values in the relation will appear in the join input,\n\t\t * and so compare to only the first nd2 members of the MCV list.  Of\n\t\t * course this is frequently wrong, but it's the best bet we can make.\n\t\t */\n\t\tclamped_nvalues2 = Min(sslot2.nvalues, nd2);\n\n\t\tfmgr_info(opfuncoid, &eqproc);\n\t\thasmatch1 = (bool *) palloc0(sslot1.nvalues * sizeof(bool));\n\t\thasmatch2 = (bool *) palloc0(clamped_nvalues2 * sizeof(bool));\n\n\t\t/*\n\t\t * Note we assume that each MCV will match at most one member of the\n\t\t * other MCV list.  If the operator isn't really equality, there could\n\t\t * be multiple matches --- but we don't look for them, both for speed\n\t\t * and because the math wouldn't add up...\n\t\t */\n\t\tnmatches = 0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tint\t\t\tj;\n\n\t\t\tfor (j = 0; j < clamped_nvalues2; j++)\n\t\t\t{\n\t\t\t\tif (hasmatch2[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot1.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot2.values[j])))\n\t\t\t\t{\n\t\t\t\t\thasmatch1[i] = hasmatch2[j] = true;\n\t\t\t\t\tnmatches++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Sum up frequencies of matched MCVs */\n\t\tmatchfreq1 = 0.0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch1[i])\n\t\t\t\tmatchfreq1 += sslot1.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq1);\n\t\tpfree(hasmatch1);\n\t\tpfree(hasmatch2);\n\n\t\t/*\n\t\t * Now we need to estimate the fraction of relation 1 that has at\n\t\t * least one join partner.  We know for certain that the matched MCVs\n\t\t * do, so that gives us a lower bound, but we're really in the dark\n\t\t * about everything else.  Our crude approach is: if nd1 <= nd2 then\n\t\t * assume all non-null rel1 rows have join partners, else assume for\n\t\t * the uncertain rows that a fraction nd2/nd1 have join partners. We\n\t\t * can discount the known-matched MCVs from the distinct-values counts\n\t\t * before doing the division.\n\t\t *\n\t\t * Crude as the above is, it's completely useless if we don't have\n\t\t * reliable ndistinct values for both sides.  Hence, if either nd1 or\n\t\t * nd2 is default, punt and assume half of the uncertain rows have\n\t\t * join partners.\n\t\t */\n\t\tif (!isdefault1 && !isdefault2)\n\t\t{\n\t\t\tnd1 -= nmatches;\n\t\t\tnd2 -= nmatches;\n\t\t\tif (nd1 <= nd2 || nd2 < 0)\n\t\t\t\tuncertainfrac = 1.0;\n\t\t\telse\n\t\t\t\tuncertainfrac = nd2 / nd1;\n\t\t}\n\t\telse\n\t\t\tuncertainfrac = 0.5;\n\t\tuncertain = 1.0 - matchfreq1 - nullfrac1;\n\t\tCLAMP_PROBABILITY(uncertain);\n\t\tselec = matchfreq1 + uncertainfrac * uncertain;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Without MCV lists for both sides, we can only use the heuristic\n\t\t * about nd1 vs nd2.\n\t\t */\n\t\tdouble\t\tnullfrac1 = stats1 ? stats1->stanullfrac : 0.0;\n\n\t\tif (!isdefault1 && !isdefault2)\n\t\t{\n\t\t\tif (nd1 <= nd2 || nd2 < 0)\n\t\t\t\tselec = 1.0 - nullfrac1;\n\t\t\telse\n\t\t\t\tselec = (nd2 / nd1) * (1.0 - nullfrac1);\n\t\t}\n\t\telse\n\t\t\tselec = 0.5 * (1.0 - nullfrac1);\n\t}\n\n\tfree_attstatsslot(&sslot1);\n\tfree_attstatsslot(&sslot2);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_commutator",
          "args": [
            "operator"
          ],
          "line": 2325
        },
        "resolved": true,
        "details": {
          "function_name": "get_commutator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1297-1314",
          "snippet": "Oid\nget_commutator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprcom;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_commutator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprcom;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_join_input_rel",
          "args": [
            "root",
            "sjinfo->min_righthand"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "find_join_input_rel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5702-5724",
          "snippet": "static RelOptInfo *\nfind_join_input_rel(PlannerInfo *root, Relids relids)\n{\n\tRelOptInfo *rel = NULL;\n\n\tswitch (bms_membership(relids))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* should not happen */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\trel = find_base_rel(root, bms_singleton_member(relids));\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\trel = find_join_rel(root, relids);\n\t\t\tbreak;\n\t}\n\n\tif (rel == NULL)\n\t\telog(ERROR, \"could not find RelOptInfo for given relids\");\n\n\treturn rel;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);\n\nstatic RelOptInfo *\nfind_join_input_rel(PlannerInfo *root, Relids relids)\n{\n\tRelOptInfo *rel = NULL;\n\n\tswitch (bms_membership(relids))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* should not happen */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\trel = find_base_rel(root, bms_singleton_member(relids));\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\trel = find_join_rel(root, relids);\n\t\t\tbreak;\n\t}\n\n\tif (rel == NULL)\n\t\telog(ERROR, \"could not find RelOptInfo for given relids\");\n\n\treturn rel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eqjoinsel_inner",
          "args": [
            "operator",
            "&vardata1",
            "&vardata2"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "eqjoinsel_inner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "2351-2559",
          "snippet": "static double\neqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnd1;\n\tdouble\t\tnd2;\n\tbool\t\tisdefault1;\n\tbool\t\tisdefault2;\n\tOid\t\t\topfuncoid;\n\tForm_pg_statistic stats1 = NULL;\n\tForm_pg_statistic stats2 = NULL;\n\tbool\t\thave_mcvs1 = false;\n\tbool\t\thave_mcvs2 = false;\n\tAttStatsSlot sslot1;\n\tAttStatsSlot sslot2;\n\n\tnd1 = get_variable_numdistinct(vardata1, &isdefault1);\n\tnd2 = get_variable_numdistinct(vardata2, &isdefault2);\n\n\topfuncoid = get_opcode(operator);\n\n\tmemset(&sslot1, 0, sizeof(sslot1));\n\tmemset(&sslot2, 0, sizeof(sslot2));\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats1 = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tif (statistic_proc_security_check(vardata1, opfuncoid))\n\t\t\thave_mcvs1 = get_attstatsslot(&sslot1, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats2 = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tif (statistic_proc_security_check(vardata2, opfuncoid))\n\t\t\thave_mcvs2 = get_attstatsslot(&sslot2, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (have_mcvs1 && have_mcvs2)\n\t{\n\t\t/*\n\t\t * We have most-common-value lists for both relations.  Run through\n\t\t * the lists to see which MCVs actually join to each other with the\n\t\t * given operator.  This allows us to determine the exact join\n\t\t * selectivity for the portion of the relations represented by the MCV\n\t\t * lists.  We still have to estimate for the remaining population, but\n\t\t * in a skewed distribution this gives us a big leg up in accuracy.\n\t\t * For motivation see the analysis in Y. Ioannidis and S.\n\t\t * Christodoulakis, \"On the propagation of errors in the size of join\n\t\t * results\", Technical Report 1018, Computer Science Dept., University\n\t\t * of Wisconsin, Madison, March 1991 (available from ftp.cs.wisc.edu).\n\t\t */\n\t\tFmgrInfo\teqproc;\n\t\tbool\t   *hasmatch1;\n\t\tbool\t   *hasmatch2;\n\t\tdouble\t\tnullfrac1 = stats1->stanullfrac;\n\t\tdouble\t\tnullfrac2 = stats2->stanullfrac;\n\t\tdouble\t\tmatchprodfreq,\n\t\t\t\t\tmatchfreq1,\n\t\t\t\t\tmatchfreq2,\n\t\t\t\t\tunmatchfreq1,\n\t\t\t\t\tunmatchfreq2,\n\t\t\t\t\totherfreq1,\n\t\t\t\t\totherfreq2,\n\t\t\t\t\ttotalsel1,\n\t\t\t\t\ttotalsel2;\n\t\tint\t\t\ti,\n\t\t\t\t\tnmatches;\n\n\t\tfmgr_info(opfuncoid, &eqproc);\n\t\thasmatch1 = (bool *) palloc0(sslot1.nvalues * sizeof(bool));\n\t\thasmatch2 = (bool *) palloc0(sslot2.nvalues * sizeof(bool));\n\n\t\t/*\n\t\t * Note we assume that each MCV will match at most one member of the\n\t\t * other MCV list.  If the operator isn't really equality, there could\n\t\t * be multiple matches --- but we don't look for them, both for speed\n\t\t * and because the math wouldn't add up...\n\t\t */\n\t\tmatchprodfreq = 0.0;\n\t\tnmatches = 0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tint\t\t\tj;\n\n\t\t\tfor (j = 0; j < sslot2.nvalues; j++)\n\t\t\t{\n\t\t\t\tif (hasmatch2[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot1.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot2.values[j])))\n\t\t\t\t{\n\t\t\t\t\thasmatch1[i] = hasmatch2[j] = true;\n\t\t\t\t\tmatchprodfreq += sslot1.numbers[i] * sslot2.numbers[j];\n\t\t\t\t\tnmatches++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCLAMP_PROBABILITY(matchprodfreq);\n\t\t/* Sum up frequencies of matched and unmatched MCVs */\n\t\tmatchfreq1 = unmatchfreq1 = 0.0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch1[i])\n\t\t\t\tmatchfreq1 += sslot1.numbers[i];\n\t\t\telse\n\t\t\t\tunmatchfreq1 += sslot1.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq1);\n\t\tCLAMP_PROBABILITY(unmatchfreq1);\n\t\tmatchfreq2 = unmatchfreq2 = 0.0;\n\t\tfor (i = 0; i < sslot2.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch2[i])\n\t\t\t\tmatchfreq2 += sslot2.numbers[i];\n\t\t\telse\n\t\t\t\tunmatchfreq2 += sslot2.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq2);\n\t\tCLAMP_PROBABILITY(unmatchfreq2);\n\t\tpfree(hasmatch1);\n\t\tpfree(hasmatch2);\n\n\t\t/*\n\t\t * Compute total frequency of non-null values that are not in the MCV\n\t\t * lists.\n\t\t */\n\t\totherfreq1 = 1.0 - nullfrac1 - matchfreq1 - unmatchfreq1;\n\t\totherfreq2 = 1.0 - nullfrac2 - matchfreq2 - unmatchfreq2;\n\t\tCLAMP_PROBABILITY(otherfreq1);\n\t\tCLAMP_PROBABILITY(otherfreq2);\n\n\t\t/*\n\t\t * We can estimate the total selectivity from the point of view of\n\t\t * relation 1 as: the known selectivity for matched MCVs, plus\n\t\t * unmatched MCVs that are assumed to match against random members of\n\t\t * relation 2's non-MCV population, plus non-MCV values that are\n\t\t * assumed to match against random members of relation 2's unmatched\n\t\t * MCVs plus non-MCV values.\n\t\t */\n\t\ttotalsel1 = matchprodfreq;\n\t\tif (nd2 > sslot2.nvalues)\n\t\t\ttotalsel1 += unmatchfreq1 * otherfreq2 / (nd2 - sslot2.nvalues);\n\t\tif (nd2 > nmatches)\n\t\t\ttotalsel1 += otherfreq1 * (otherfreq2 + unmatchfreq2) /\n\t\t\t\t(nd2 - nmatches);\n\t\t/* Same estimate from the point of view of relation 2. */\n\t\ttotalsel2 = matchprodfreq;\n\t\tif (nd1 > sslot1.nvalues)\n\t\t\ttotalsel2 += unmatchfreq2 * otherfreq1 / (nd1 - sslot1.nvalues);\n\t\tif (nd1 > nmatches)\n\t\t\ttotalsel2 += otherfreq2 * (otherfreq1 + unmatchfreq1) /\n\t\t\t\t(nd1 - nmatches);\n\n\t\t/*\n\t\t * Use the smaller of the two estimates.  This can be justified in\n\t\t * essentially the same terms as given below for the no-stats case: to\n\t\t * a first approximation, we are estimating from the point of view of\n\t\t * the relation with smaller nd.\n\t\t */\n\t\tselec = (totalsel1 < totalsel2) ? totalsel1 : totalsel2;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We do not have MCV lists for both sides.  Estimate the join\n\t\t * selectivity as MIN(1/nd1,1/nd2)*(1-nullfrac1)*(1-nullfrac2). This\n\t\t * is plausible if we assume that the join operator is strict and the\n\t\t * non-null values are about equally distributed: a given non-null\n\t\t * tuple of rel1 will join to either zero or N2*(1-nullfrac2)/nd2 rows\n\t\t * of rel2, so total join rows are at most\n\t\t * N1*(1-nullfrac1)*N2*(1-nullfrac2)/nd2 giving a join selectivity of\n\t\t * not more than (1-nullfrac1)*(1-nullfrac2)/nd2. By the same logic it\n\t\t * is not more than (1-nullfrac1)*(1-nullfrac2)/nd1, so the expression\n\t\t * with MIN() is an upper bound.  Using the MIN() means we estimate\n\t\t * from the point of view of the relation with smaller nd (since the\n\t\t * larger nd is determining the MIN).  It is reasonable to assume that\n\t\t * most tuples in this rel will have join partners, so the bound is\n\t\t * probably reasonably tight and should be taken as-is.\n\t\t *\n\t\t * XXX Can we be smarter if we have an MCV list for just one side? It\n\t\t * seems that if we assume equal distribution for the other side, we\n\t\t * end up with the same answer anyway.\n\t\t */\n\t\tdouble\t\tnullfrac1 = stats1 ? stats1->stanullfrac : 0.0;\n\t\tdouble\t\tnullfrac2 = stats2 ? stats2->stanullfrac : 0.0;\n\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2);\n\t\tif (nd1 > nd2)\n\t\t\tselec /= nd1;\n\t\telse\n\t\t\tselec /= nd2;\n\t}\n\n\tfree_attstatsslot(&sslot1);\n\tfree_attstatsslot(&sslot2);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\n\nstatic double\neqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnd1;\n\tdouble\t\tnd2;\n\tbool\t\tisdefault1;\n\tbool\t\tisdefault2;\n\tOid\t\t\topfuncoid;\n\tForm_pg_statistic stats1 = NULL;\n\tForm_pg_statistic stats2 = NULL;\n\tbool\t\thave_mcvs1 = false;\n\tbool\t\thave_mcvs2 = false;\n\tAttStatsSlot sslot1;\n\tAttStatsSlot sslot2;\n\n\tnd1 = get_variable_numdistinct(vardata1, &isdefault1);\n\tnd2 = get_variable_numdistinct(vardata2, &isdefault2);\n\n\topfuncoid = get_opcode(operator);\n\n\tmemset(&sslot1, 0, sizeof(sslot1));\n\tmemset(&sslot2, 0, sizeof(sslot2));\n\n\tif (HeapTupleIsValid(vardata1->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats1 = (Form_pg_statistic) GETSTRUCT(vardata1->statsTuple);\n\t\tif (statistic_proc_security_check(vardata1, opfuncoid))\n\t\t\thave_mcvs1 = get_attstatsslot(&sslot1, vardata1->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (HeapTupleIsValid(vardata2->statsTuple))\n\t{\n\t\t/* note we allow use of nullfrac regardless of security check */\n\t\tstats2 = (Form_pg_statistic) GETSTRUCT(vardata2->statsTuple);\n\t\tif (statistic_proc_security_check(vardata2, opfuncoid))\n\t\t\thave_mcvs2 = get_attstatsslot(&sslot2, vardata2->statsTuple,\n\t\t\t\t\t\t\t\t\t\t  STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t  ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS);\n\t}\n\n\tif (have_mcvs1 && have_mcvs2)\n\t{\n\t\t/*\n\t\t * We have most-common-value lists for both relations.  Run through\n\t\t * the lists to see which MCVs actually join to each other with the\n\t\t * given operator.  This allows us to determine the exact join\n\t\t * selectivity for the portion of the relations represented by the MCV\n\t\t * lists.  We still have to estimate for the remaining population, but\n\t\t * in a skewed distribution this gives us a big leg up in accuracy.\n\t\t * For motivation see the analysis in Y. Ioannidis and S.\n\t\t * Christodoulakis, \"On the propagation of errors in the size of join\n\t\t * results\", Technical Report 1018, Computer Science Dept., University\n\t\t * of Wisconsin, Madison, March 1991 (available from ftp.cs.wisc.edu).\n\t\t */\n\t\tFmgrInfo\teqproc;\n\t\tbool\t   *hasmatch1;\n\t\tbool\t   *hasmatch2;\n\t\tdouble\t\tnullfrac1 = stats1->stanullfrac;\n\t\tdouble\t\tnullfrac2 = stats2->stanullfrac;\n\t\tdouble\t\tmatchprodfreq,\n\t\t\t\t\tmatchfreq1,\n\t\t\t\t\tmatchfreq2,\n\t\t\t\t\tunmatchfreq1,\n\t\t\t\t\tunmatchfreq2,\n\t\t\t\t\totherfreq1,\n\t\t\t\t\totherfreq2,\n\t\t\t\t\ttotalsel1,\n\t\t\t\t\ttotalsel2;\n\t\tint\t\t\ti,\n\t\t\t\t\tnmatches;\n\n\t\tfmgr_info(opfuncoid, &eqproc);\n\t\thasmatch1 = (bool *) palloc0(sslot1.nvalues * sizeof(bool));\n\t\thasmatch2 = (bool *) palloc0(sslot2.nvalues * sizeof(bool));\n\n\t\t/*\n\t\t * Note we assume that each MCV will match at most one member of the\n\t\t * other MCV list.  If the operator isn't really equality, there could\n\t\t * be multiple matches --- but we don't look for them, both for speed\n\t\t * and because the math wouldn't add up...\n\t\t */\n\t\tmatchprodfreq = 0.0;\n\t\tnmatches = 0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tint\t\t\tj;\n\n\t\t\tfor (j = 0; j < sslot2.nvalues; j++)\n\t\t\t{\n\t\t\t\tif (hasmatch2[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot1.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot2.values[j])))\n\t\t\t\t{\n\t\t\t\t\thasmatch1[i] = hasmatch2[j] = true;\n\t\t\t\t\tmatchprodfreq += sslot1.numbers[i] * sslot2.numbers[j];\n\t\t\t\t\tnmatches++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCLAMP_PROBABILITY(matchprodfreq);\n\t\t/* Sum up frequencies of matched and unmatched MCVs */\n\t\tmatchfreq1 = unmatchfreq1 = 0.0;\n\t\tfor (i = 0; i < sslot1.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch1[i])\n\t\t\t\tmatchfreq1 += sslot1.numbers[i];\n\t\t\telse\n\t\t\t\tunmatchfreq1 += sslot1.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq1);\n\t\tCLAMP_PROBABILITY(unmatchfreq1);\n\t\tmatchfreq2 = unmatchfreq2 = 0.0;\n\t\tfor (i = 0; i < sslot2.nvalues; i++)\n\t\t{\n\t\t\tif (hasmatch2[i])\n\t\t\t\tmatchfreq2 += sslot2.numbers[i];\n\t\t\telse\n\t\t\t\tunmatchfreq2 += sslot2.numbers[i];\n\t\t}\n\t\tCLAMP_PROBABILITY(matchfreq2);\n\t\tCLAMP_PROBABILITY(unmatchfreq2);\n\t\tpfree(hasmatch1);\n\t\tpfree(hasmatch2);\n\n\t\t/*\n\t\t * Compute total frequency of non-null values that are not in the MCV\n\t\t * lists.\n\t\t */\n\t\totherfreq1 = 1.0 - nullfrac1 - matchfreq1 - unmatchfreq1;\n\t\totherfreq2 = 1.0 - nullfrac2 - matchfreq2 - unmatchfreq2;\n\t\tCLAMP_PROBABILITY(otherfreq1);\n\t\tCLAMP_PROBABILITY(otherfreq2);\n\n\t\t/*\n\t\t * We can estimate the total selectivity from the point of view of\n\t\t * relation 1 as: the known selectivity for matched MCVs, plus\n\t\t * unmatched MCVs that are assumed to match against random members of\n\t\t * relation 2's non-MCV population, plus non-MCV values that are\n\t\t * assumed to match against random members of relation 2's unmatched\n\t\t * MCVs plus non-MCV values.\n\t\t */\n\t\ttotalsel1 = matchprodfreq;\n\t\tif (nd2 > sslot2.nvalues)\n\t\t\ttotalsel1 += unmatchfreq1 * otherfreq2 / (nd2 - sslot2.nvalues);\n\t\tif (nd2 > nmatches)\n\t\t\ttotalsel1 += otherfreq1 * (otherfreq2 + unmatchfreq2) /\n\t\t\t\t(nd2 - nmatches);\n\t\t/* Same estimate from the point of view of relation 2. */\n\t\ttotalsel2 = matchprodfreq;\n\t\tif (nd1 > sslot1.nvalues)\n\t\t\ttotalsel2 += unmatchfreq2 * otherfreq1 / (nd1 - sslot1.nvalues);\n\t\tif (nd1 > nmatches)\n\t\t\ttotalsel2 += otherfreq2 * (otherfreq1 + unmatchfreq1) /\n\t\t\t\t(nd1 - nmatches);\n\n\t\t/*\n\t\t * Use the smaller of the two estimates.  This can be justified in\n\t\t * essentially the same terms as given below for the no-stats case: to\n\t\t * a first approximation, we are estimating from the point of view of\n\t\t * the relation with smaller nd.\n\t\t */\n\t\tselec = (totalsel1 < totalsel2) ? totalsel1 : totalsel2;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We do not have MCV lists for both sides.  Estimate the join\n\t\t * selectivity as MIN(1/nd1,1/nd2)*(1-nullfrac1)*(1-nullfrac2). This\n\t\t * is plausible if we assume that the join operator is strict and the\n\t\t * non-null values are about equally distributed: a given non-null\n\t\t * tuple of rel1 will join to either zero or N2*(1-nullfrac2)/nd2 rows\n\t\t * of rel2, so total join rows are at most\n\t\t * N1*(1-nullfrac1)*N2*(1-nullfrac2)/nd2 giving a join selectivity of\n\t\t * not more than (1-nullfrac1)*(1-nullfrac2)/nd2. By the same logic it\n\t\t * is not more than (1-nullfrac1)*(1-nullfrac2)/nd1, so the expression\n\t\t * with MIN() is an upper bound.  Using the MIN() means we estimate\n\t\t * from the point of view of the relation with smaller nd (since the\n\t\t * larger nd is determining the MIN).  It is reasonable to assume that\n\t\t * most tuples in this rel will have join partners, so the bound is\n\t\t * probably reasonably tight and should be taken as-is.\n\t\t *\n\t\t * XXX Can we be smarter if we have an MCV list for just one side? It\n\t\t * seems that if we assume equal distribution for the other side, we\n\t\t * end up with the same answer anyway.\n\t\t */\n\t\tdouble\t\tnullfrac1 = stats1 ? stats1->stanullfrac : 0.0;\n\t\tdouble\t\tnullfrac2 = stats2 ? stats2->stanullfrac : 0.0;\n\n\t\tselec = (1.0 - nullfrac1) * (1.0 - nullfrac2);\n\t\tif (nd1 > nd2)\n\t\t\tselec /= nd1;\n\t\telse\n\t\t\tselec /= nd2;\n\t}\n\n\tfree_attstatsslot(&sslot1);\n\tfree_attstatsslot(&sslot2);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_join_variables",
          "args": [
            "root",
            "args",
            "sjinfo",
            "&vardata1",
            "&vardata2",
            "&join_is_reversed"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "get_join_variables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4713-4738",
          "snippet": "void\nget_join_variables(PlannerInfo *root, List *args, SpecialJoinInfo *sjinfo,\n\t\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t\t   bool *join_is_reversed)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\n\tif (list_length(args) != 2)\n\t\telog(ERROR, \"join operator should take two arguments\");\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\texamine_variable(root, left, 0, vardata1);\n\texamine_variable(root, right, 0, vardata2);\n\n\tif (vardata1->rel &&\n\t\tbms_is_subset(vardata1->rel->relids, sjinfo->syn_righthand))\n\t\t*join_is_reversed = true;\t/* var1 is on RHS */\n\telse if (vardata2->rel &&\n\t\t\t bms_is_subset(vardata2->rel->relids, sjinfo->syn_lefthand))\n\t\t*join_is_reversed = true;\t/* var2 is on LHS */\n\telse\n\t\t*join_is_reversed = false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);",
            "static RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic RelOptInfo *find_join_input_rel(PlannerInfo *root, Relids relids);\n\nvoid\nget_join_variables(PlannerInfo *root, List *args, SpecialJoinInfo *sjinfo,\n\t\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t\t   bool *join_is_reversed)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\n\tif (list_length(args) != 2)\n\t\telog(ERROR, \"join operator should take two arguments\");\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\texamine_variable(root, left, 0, vardata1);\n\texamine_variable(root, right, 0, vardata2);\n\n\tif (vardata1->rel &&\n\t\tbms_is_subset(vardata1->rel->relids, sjinfo->syn_righthand))\n\t\t*join_is_reversed = true;\t/* var1 is on RHS */\n\telse if (vardata2->rel &&\n\t\t\t bms_is_subset(vardata2->rel->relids, sjinfo->syn_lefthand))\n\t\t*join_is_reversed = true;\t/* var2 is on LHS */\n\telse\n\t\t*join_is_reversed = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "4"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT16",
          "args": [
            "3"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqjoinsel_inner(Oid operator,\n\t\t\t\tVariableStatData *vardata1, VariableStatData *vardata2);\nstatic double eqjoinsel_semi(Oid operator,\n\t\t\t   VariableStatData *vardata1, VariableStatData *vardata2,\n\t\t\t   RelOptInfo *inner_rel);\n\nDatum\neqjoinsel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\n#ifdef NOT_USED\n\tJoinType\tjointype = (JoinType) PG_GETARG_INT16(3);\n#endif\n\tSpecialJoinInfo *sjinfo = (SpecialJoinInfo *) PG_GETARG_POINTER(4);\n\tdouble\t\tselec;\n\tVariableStatData vardata1;\n\tVariableStatData vardata2;\n\tbool\t\tjoin_is_reversed;\n\tRelOptInfo *inner_rel;\n\n\tget_join_variables(root, args, sjinfo,\n\t\t\t\t\t   &vardata1, &vardata2, &join_is_reversed);\n\n\tswitch (sjinfo->jointype)\n\t{\n\t\tcase JOIN_INNER:\n\t\tcase JOIN_LEFT:\n\t\tcase JOIN_FULL:\n\t\t\tselec = eqjoinsel_inner(operator, &vardata1, &vardata2);\n\t\t\tbreak;\n\t\tcase JOIN_SEMI:\n\t\tcase JOIN_ANTI:\n\n\t\t\t/*\n\t\t\t * Look up the join's inner relation.  min_righthand is sufficient\n\t\t\t * information because neither SEMI nor ANTI joins permit any\n\t\t\t * reassociation into or out of their RHS, so the righthand will\n\t\t\t * always be exactly that set of rels.\n\t\t\t */\n\t\t\tinner_rel = find_join_input_rel(root, sjinfo->min_righthand);\n\n\t\t\tif (!join_is_reversed)\n\t\t\t\tselec = eqjoinsel_semi(operator, &vardata1, &vardata2,\n\t\t\t\t\t\t\t\t\t   inner_rel);\n\t\t\telse\n\t\t\t\tselec = eqjoinsel_semi(get_commutator(operator),\n\t\t\t\t\t\t\t\t\t   &vardata2, &vardata1,\n\t\t\t\t\t\t\t\t\t   inner_rel);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* other values not expected here */\n\t\t\telog(ERROR, \"unrecognized join type: %d\",\n\t\t\t\t (int) sjinfo->jointype);\n\t\t\tselec = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\tReleaseVariableStats(vardata1);\n\tReleaseVariableStats(vardata2);\n\n\tCLAMP_PROBABILITY(selec);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}"
  },
  {
    "function_name": "rowcomparesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2216-2278",
    "snippet": "Selectivity\nrowcomparesel(PlannerInfo *root,\n\t\t\t  RowCompareExpr *clause,\n\t\t\t  int varRelid, JoinType jointype, SpecialJoinInfo *sjinfo)\n{\n\tSelectivity s1;\n\tOid\t\t\topno = linitial_oid(clause->opnos);\n\tOid\t\t\tinputcollid = linitial_oid(clause->inputcollids);\n\tList\t   *opargs;\n\tbool\t\tis_join_clause;\n\n\t/* Build equivalent arg list for single operator */\n\topargs = list_make2(linitial(clause->largs), linitial(clause->rargs));\n\n\t/*\n\t * Decide if it's a join clause.  This should match clausesel.c's\n\t * treat_as_join_clause(), except that we intentionally consider only the\n\t * leading columns and not the rest of the clause.\n\t */\n\tif (varRelid != 0)\n\t{\n\t\t/*\n\t\t * Caller is forcing restriction mode (eg, because we are examining an\n\t\t * inner indexscan qual).\n\t\t */\n\t\tis_join_clause = false;\n\t}\n\telse if (sjinfo == NULL)\n\t{\n\t\t/*\n\t\t * It must be a restriction clause, since it's being evaluated at a\n\t\t * scan node.\n\t\t */\n\t\tis_join_clause = false;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, it's a join if there's more than one relation used.\n\t\t */\n\t\tis_join_clause = (NumRelids((Node *) opargs) > 1);\n\t}\n\n\tif (is_join_clause)\n\t{\n\t\t/* Estimate selectivity for a join clause. */\n\t\ts1 = join_selectivity(root, opno,\n\t\t\t\t\t\t\t  opargs,\n\t\t\t\t\t\t\t  inputcollid,\n\t\t\t\t\t\t\t  jointype,\n\t\t\t\t\t\t\t  sjinfo);\n\t}\n\telse\n\t{\n\t\t/* Estimate selectivity for a restriction clause. */\n\t\ts1 = restriction_selectivity(root, opno,\n\t\t\t\t\t\t\t\t\t opargs,\n\t\t\t\t\t\t\t\t\t inputcollid,\n\t\t\t\t\t\t\t\t\t varRelid);\n\t}\n\n\treturn s1;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "restriction_selectivity",
          "args": [
            "root",
            "opno",
            "opargs",
            "inputcollid",
            "varRelid"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_selectivity",
          "args": [
            "root",
            "opno",
            "opargs",
            "inputcollid",
            "jointype",
            "sjinfo"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumRelids",
          "args": [
            "(Node *) opargs"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make2",
          "args": [
            "linitial(clause->largs)",
            "linitial(clause->rargs)"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "clause->rargs"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "clause->largs"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial_oid",
          "args": [
            "clause->inputcollids"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial_oid",
          "args": [
            "clause->opnos"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nSelectivity\nrowcomparesel(PlannerInfo *root,\n\t\t\t  RowCompareExpr *clause,\n\t\t\t  int varRelid, JoinType jointype, SpecialJoinInfo *sjinfo)\n{\n\tSelectivity s1;\n\tOid\t\t\topno = linitial_oid(clause->opnos);\n\tOid\t\t\tinputcollid = linitial_oid(clause->inputcollids);\n\tList\t   *opargs;\n\tbool\t\tis_join_clause;\n\n\t/* Build equivalent arg list for single operator */\n\topargs = list_make2(linitial(clause->largs), linitial(clause->rargs));\n\n\t/*\n\t * Decide if it's a join clause.  This should match clausesel.c's\n\t * treat_as_join_clause(), except that we intentionally consider only the\n\t * leading columns and not the rest of the clause.\n\t */\n\tif (varRelid != 0)\n\t{\n\t\t/*\n\t\t * Caller is forcing restriction mode (eg, because we are examining an\n\t\t * inner indexscan qual).\n\t\t */\n\t\tis_join_clause = false;\n\t}\n\telse if (sjinfo == NULL)\n\t{\n\t\t/*\n\t\t * It must be a restriction clause, since it's being evaluated at a\n\t\t * scan node.\n\t\t */\n\t\tis_join_clause = false;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, it's a join if there's more than one relation used.\n\t\t */\n\t\tis_join_clause = (NumRelids((Node *) opargs) > 1);\n\t}\n\n\tif (is_join_clause)\n\t{\n\t\t/* Estimate selectivity for a join clause. */\n\t\ts1 = join_selectivity(root, opno,\n\t\t\t\t\t\t\t  opargs,\n\t\t\t\t\t\t\t  inputcollid,\n\t\t\t\t\t\t\t  jointype,\n\t\t\t\t\t\t\t  sjinfo);\n\t}\n\telse\n\t{\n\t\t/* Estimate selectivity for a restriction clause. */\n\t\ts1 = restriction_selectivity(root, opno,\n\t\t\t\t\t\t\t\t\t opargs,\n\t\t\t\t\t\t\t\t\t inputcollid,\n\t\t\t\t\t\t\t\t\t varRelid);\n\t}\n\n\treturn s1;\n}"
  },
  {
    "function_name": "estimate_array_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "2178-2205",
    "snippet": "int\nestimate_array_length(Node *arrayexpr)\n{\n\t/* look through any binary-compatible relabeling of arrayexpr */\n\tarrayexpr = strip_array_coercion(arrayexpr);\n\n\tif (arrayexpr && IsA(arrayexpr, Const))\n\t{\n\t\tDatum\t\tarraydatum = ((Const *) arrayexpr)->constvalue;\n\t\tbool\t\tarrayisnull = ((Const *) arrayexpr)->constisnull;\n\t\tArrayType  *arrayval;\n\n\t\tif (arrayisnull)\n\t\t\treturn 0;\n\t\tarrayval = DatumGetArrayTypeP(arraydatum);\n\t\treturn ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));\n\t}\n\telse if (arrayexpr && IsA(arrayexpr, ArrayExpr) &&\n\t\t\t !((ArrayExpr *) arrayexpr)->multidims)\n\t{\n\t\treturn list_length(((ArrayExpr *) arrayexpr)->elements);\n\t}\n\telse\n\t{\n\t\t/* default guess --- see also scalararraysel */\n\t\treturn 10;\n\t}\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "((ArrayExpr *) arrayexpr)->elements"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "arrayexpr",
            "ArrayExpr"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ARR_NDIM(arrayval)",
            "ARR_DIMS(arrayval)"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arrayval"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arrayval"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "arraydatum"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "arrayexpr",
            "Const"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strip_array_coercion",
          "args": [
            "arrayexpr"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "strip_array_coercion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1826-1854",
          "snippet": "static Node *\nstrip_array_coercion(Node *node)\n{\n\tfor (;;)\n\t{\n\t\tif (node && IsA(node, ArrayCoerceExpr))\n\t\t{\n\t\t\tArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) node;\n\n\t\t\t/*\n\t\t\t * If the per-element expression is just a RelabelType on top of\n\t\t\t * CaseTestExpr, then we know it's a binary-compatible relabeling.\n\t\t\t */\n\t\t\tif (IsA(acoerce->elemexpr, RelabelType) &&\n\t\t\t\tIsA(((RelabelType *) acoerce->elemexpr)->arg, CaseTestExpr))\n\t\t\t\tnode = (Node *) acoerce->arg;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (node && IsA(node, RelabelType))\n\t\t{\n\t\t\t/* We don't really expect this case, but may as well cope */\n\t\t\tnode = (Node *) ((RelabelType *) node)->arg;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn node;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Node *\nstrip_array_coercion(Node *node)\n{\n\tfor (;;)\n\t{\n\t\tif (node && IsA(node, ArrayCoerceExpr))\n\t\t{\n\t\t\tArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) node;\n\n\t\t\t/*\n\t\t\t * If the per-element expression is just a RelabelType on top of\n\t\t\t * CaseTestExpr, then we know it's a binary-compatible relabeling.\n\t\t\t */\n\t\t\tif (IsA(acoerce->elemexpr, RelabelType) &&\n\t\t\t\tIsA(((RelabelType *) acoerce->elemexpr)->arg, CaseTestExpr))\n\t\t\t\tnode = (Node *) acoerce->arg;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (node && IsA(node, RelabelType))\n\t\t{\n\t\t\t/* We don't really expect this case, but may as well cope */\n\t\t\tnode = (Node *) ((RelabelType *) node)->arg;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nestimate_array_length(Node *arrayexpr)\n{\n\t/* look through any binary-compatible relabeling of arrayexpr */\n\tarrayexpr = strip_array_coercion(arrayexpr);\n\n\tif (arrayexpr && IsA(arrayexpr, Const))\n\t{\n\t\tDatum\t\tarraydatum = ((Const *) arrayexpr)->constvalue;\n\t\tbool\t\tarrayisnull = ((Const *) arrayexpr)->constisnull;\n\t\tArrayType  *arrayval;\n\n\t\tif (arrayisnull)\n\t\t\treturn 0;\n\t\tarrayval = DatumGetArrayTypeP(arraydatum);\n\t\treturn ArrayGetNItems(ARR_NDIM(arrayval), ARR_DIMS(arrayval));\n\t}\n\telse if (arrayexpr && IsA(arrayexpr, ArrayExpr) &&\n\t\t\t !((ArrayExpr *) arrayexpr)->multidims)\n\t{\n\t\treturn list_length(((ArrayExpr *) arrayexpr)->elements);\n\t}\n\telse\n\t{\n\t\t/* default guess --- see also scalararraysel */\n\t\treturn 10;\n\t}\n}"
  },
  {
    "function_name": "scalararraysel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1859-2171",
    "snippet": "Selectivity\nscalararraysel(PlannerInfo *root,\n\t\t\t   ScalarArrayOpExpr *clause,\n\t\t\t   bool is_join_clause,\n\t\t\t   int varRelid,\n\t\t\t   JoinType jointype,\n\t\t\t   SpecialJoinInfo *sjinfo)\n{\n\tOid\t\t\toperator = clause->opno;\n\tbool\t\tuseOr = clause->useOr;\n\tbool\t\tisEquality = false;\n\tbool\t\tisInequality = false;\n\tNode\t   *leftop;\n\tNode\t   *rightop;\n\tOid\t\t\tnominal_element_type;\n\tOid\t\t\tnominal_element_collation;\n\tTypeCacheEntry *typentry;\n\tRegProcedure oprsel;\n\tFmgrInfo\toprselproc;\n\tSelectivity s1;\n\tSelectivity s1disjoint;\n\n\t/* First, deconstruct the expression */\n\tAssert(list_length(clause->args) == 2);\n\tleftop = (Node *) linitial(clause->args);\n\trightop = (Node *) lsecond(clause->args);\n\n\t/* aggressively reduce both sides to constants */\n\tleftop = estimate_expression_value(root, leftop);\n\trightop = estimate_expression_value(root, rightop);\n\n\t/* get nominal (after relabeling) element type of rightop */\n\tnominal_element_type = get_base_element_type(exprType(rightop));\n\tif (!OidIsValid(nominal_element_type))\n\t\treturn (Selectivity) 0.5;\t/* probably shouldn't happen */\n\t/* get nominal collation, too, for generating constants */\n\tnominal_element_collation = exprCollation(rightop);\n\n\t/* look through any binary-compatible relabeling of rightop */\n\trightop = strip_array_coercion(rightop);\n\n\t/*\n\t * Detect whether the operator is the default equality or inequality\n\t * operator of the array element type.\n\t */\n\ttypentry = lookup_type_cache(nominal_element_type, TYPECACHE_EQ_OPR);\n\tif (OidIsValid(typentry->eq_opr))\n\t{\n\t\tif (operator == typentry->eq_opr)\n\t\t\tisEquality = true;\n\t\telse if (get_negator(operator) == typentry->eq_opr)\n\t\t\tisInequality = true;\n\t}\n\n\t/*\n\t * If it is equality or inequality, we might be able to estimate this as a\n\t * form of array containment; for instance \"const = ANY(column)\" can be\n\t * treated as \"ARRAY[const] <@ column\".  scalararraysel_containment tries\n\t * that, and returns the selectivity estimate if successful, or -1 if not.\n\t */\n\tif ((isEquality || isInequality) && !is_join_clause)\n\t{\n\t\ts1 = scalararraysel_containment(root, leftop, rightop,\n\t\t\t\t\t\t\t\t\t\tnominal_element_type,\n\t\t\t\t\t\t\t\t\t\tisEquality, useOr, varRelid);\n\t\tif (s1 >= 0.0)\n\t\t\treturn s1;\n\t}\n\n\t/*\n\t * Look up the underlying operator's selectivity estimator. Punt if it\n\t * hasn't got one.\n\t */\n\tif (is_join_clause)\n\t\toprsel = get_oprjoin(operator);\n\telse\n\t\toprsel = get_oprrest(operator);\n\tif (!oprsel)\n\t\treturn (Selectivity) 0.5;\n\tfmgr_info(oprsel, &oprselproc);\n\n\t/*\n\t * In the array-containment check above, we must only believe that an\n\t * operator is equality or inequality if it is the default btree equality\n\t * operator (or its negator) for the element type, since those are the\n\t * operators that array containment will use.  But in what follows, we can\n\t * be a little laxer, and also believe that any operators using eqsel() or\n\t * neqsel() as selectivity estimator act like equality or inequality.\n\t */\n\tif (oprsel == F_EQSEL || oprsel == F_EQJOINSEL)\n\t\tisEquality = true;\n\telse if (oprsel == F_NEQSEL || oprsel == F_NEQJOINSEL)\n\t\tisInequality = true;\n\n\t/*\n\t * We consider three cases:\n\t *\n\t * 1. rightop is an Array constant: deconstruct the array, apply the\n\t * operator's selectivity function for each array element, and merge the\n\t * results in the same way that clausesel.c does for AND/OR combinations.\n\t *\n\t * 2. rightop is an ARRAY[] construct: apply the operator's selectivity\n\t * function for each element of the ARRAY[] construct, and merge.\n\t *\n\t * 3. otherwise, make a guess ...\n\t */\n\tif (rightop && IsA(rightop, Const))\n\t{\n\t\tDatum\t\tarraydatum = ((Const *) rightop)->constvalue;\n\t\tbool\t\tarrayisnull = ((Const *) rightop)->constisnull;\n\t\tArrayType  *arrayval;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tint\t\t\ti;\n\n\t\tif (arrayisnull)\t\t/* qual can't succeed if null array */\n\t\t\treturn (Selectivity) 0.0;\n\t\tarrayval = DatumGetArrayTypeP(arraydatum);\n\t\tget_typlenbyvalalign(ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t\t\t &elmlen, &elmbyval, &elmalign);\n\t\tdeconstruct_array(arrayval,\n\t\t\t\t\t\t  ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls, &num_elems);\n\n\t\t/*\n\t\t * For generic operators, we assume the probability of success is\n\t\t * independent for each array element.  But for \"= ANY\" or \"<> ALL\",\n\t\t * if the array elements are distinct (which'd typically be the case)\n\t\t * then the probabilities are disjoint, and we should just sum them.\n\t\t *\n\t\t * If we were being really tense we would try to confirm that the\n\t\t * elements are all distinct, but that would be expensive and it\n\t\t * doesn't seem to be worth the cycles; it would amount to penalizing\n\t\t * well-written queries in favor of poorly-written ones.  However, we\n\t\t * do protect ourselves a little bit by checking whether the\n\t\t * disjointness assumption leads to an impossible (out of range)\n\t\t * probability; if so, we fall back to the normal calculation.\n\t\t */\n\t\ts1 = s1disjoint = (useOr ? 0.0 : 1.0);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tList\t   *args;\n\t\t\tSelectivity s2;\n\n\t\t\targs = list_make2(leftop,\n\t\t\t\t\t\t\t  makeConst(nominal_element_type,\n\t\t\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t\t\tnominal_element_collation,\n\t\t\t\t\t\t\t\t\t\telmlen,\n\t\t\t\t\t\t\t\t\t\telem_values[i],\n\t\t\t\t\t\t\t\t\t\telem_nulls[i],\n\t\t\t\t\t\t\t\t\t\telmbyval));\n\t\t\tif (is_join_clause)\n\t\t\t\ts2 = DatumGetFloat8(FunctionCall5Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(sjinfo)));\n\t\t\telse\n\t\t\t\ts2 = DatumGetFloat8(FunctionCall4Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(varRelid)));\n\n\t\t\tif (useOr)\n\t\t\t{\n\t\t\t\ts1 = s1 + s2 - s1 * s2;\n\t\t\t\tif (isEquality)\n\t\t\t\t\ts1disjoint += s2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts1 = s1 * s2;\n\t\t\t\tif (isInequality)\n\t\t\t\t\ts1disjoint += s2 - 1.0;\n\t\t\t}\n\t\t}\n\n\t\t/* accept disjoint-probability estimate if in range */\n\t\tif ((useOr ? isEquality : isInequality) &&\n\t\t\ts1disjoint >= 0.0 && s1disjoint <= 1.0)\n\t\t\ts1 = s1disjoint;\n\t}\n\telse if (rightop && IsA(rightop, ArrayExpr) &&\n\t\t\t !((ArrayExpr *) rightop)->multidims)\n\t{\n\t\tArrayExpr  *arrayexpr = (ArrayExpr *) rightop;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tListCell   *l;\n\n\t\tget_typlenbyval(arrayexpr->element_typeid,\n\t\t\t\t\t\t&elmlen, &elmbyval);\n\n\t\t/*\n\t\t * We use the assumption of disjoint probabilities here too, although\n\t\t * the odds of equal array elements are rather higher if the elements\n\t\t * are not all constants (which they won't be, else constant folding\n\t\t * would have reduced the ArrayExpr to a Const).  In this path it's\n\t\t * critical to have the sanity check on the s1disjoint estimate.\n\t\t */\n\t\ts1 = s1disjoint = (useOr ? 0.0 : 1.0);\n\n\t\tforeach(l, arrayexpr->elements)\n\t\t{\n\t\t\tNode\t   *elem = (Node *) lfirst(l);\n\t\t\tList\t   *args;\n\t\t\tSelectivity s2;\n\n\t\t\t/*\n\t\t\t * Theoretically, if elem isn't of nominal_element_type we should\n\t\t\t * insert a RelabelType, but it seems unlikely that any operator\n\t\t\t * estimation function would really care ...\n\t\t\t */\n\t\t\targs = list_make2(leftop, elem);\n\t\t\tif (is_join_clause)\n\t\t\t\ts2 = DatumGetFloat8(FunctionCall5Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(sjinfo)));\n\t\t\telse\n\t\t\t\ts2 = DatumGetFloat8(FunctionCall4Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(varRelid)));\n\n\t\t\tif (useOr)\n\t\t\t{\n\t\t\t\ts1 = s1 + s2 - s1 * s2;\n\t\t\t\tif (isEquality)\n\t\t\t\t\ts1disjoint += s2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts1 = s1 * s2;\n\t\t\t\tif (isInequality)\n\t\t\t\t\ts1disjoint += s2 - 1.0;\n\t\t\t}\n\t\t}\n\n\t\t/* accept disjoint-probability estimate if in range */\n\t\tif ((useOr ? isEquality : isInequality) &&\n\t\t\ts1disjoint >= 0.0 && s1disjoint <= 1.0)\n\t\t\ts1 = s1disjoint;\n\t}\n\telse\n\t{\n\t\tCaseTestExpr *dummyexpr;\n\t\tList\t   *args;\n\t\tSelectivity s2;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * We need a dummy rightop to pass to the operator selectivity\n\t\t * routine.  It can be pretty much anything that doesn't look like a\n\t\t * constant; CaseTestExpr is a convenient choice.\n\t\t */\n\t\tdummyexpr = makeNode(CaseTestExpr);\n\t\tdummyexpr->typeId = nominal_element_type;\n\t\tdummyexpr->typeMod = -1;\n\t\tdummyexpr->collation = clause->inputcollid;\n\t\targs = list_make2(leftop, dummyexpr);\n\t\tif (is_join_clause)\n\t\t\ts2 = DatumGetFloat8(FunctionCall5Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(sjinfo)));\n\t\telse\n\t\t\ts2 = DatumGetFloat8(FunctionCall4Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(varRelid)));\n\t\ts1 = useOr ? 0.0 : 1.0;\n\n\t\t/*\n\t\t * Arbitrarily assume 10 elements in the eventual array value (see\n\t\t * also estimate_array_length).  We don't risk an assumption of\n\t\t * disjoint probabilities here.\n\t\t */\n\t\tfor (i = 0; i < 10; i++)\n\t\t{\n\t\t\tif (useOr)\n\t\t\t\ts1 = s1 + s2 - s1 * s2;\n\t\t\telse\n\t\t\t\ts1 = s1 * s2;\n\t\t}\n\t}\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(s1);\n\n\treturn s1;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "s1"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall4Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(varRelid))"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall4Coll",
          "args": [
            "&oprselproc",
            "clause->inputcollid",
            "PointerGetDatum(root)",
            "ObjectIdGetDatum(operator)",
            "PointerGetDatum(args)",
            "Int32GetDatum(varRelid)"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall4Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1480-1508",
          "snippet": "Datum\nOidFunctionCall4Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 4, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall4Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 4, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "varRelid"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "args"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "operator"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "root"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall5Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(sjinfo))"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall5Coll",
          "args": [
            "&oprselproc",
            "clause->inputcollid",
            "PointerGetDatum(root)",
            "ObjectIdGetDatum(operator)",
            "PointerGetDatum(args)",
            "Int16GetDatum(jointype)",
            "PointerGetDatum(sjinfo)"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall5Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1510-1540",
          "snippet": "Datum\nOidFunctionCall5Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 5, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall5Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 5, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "sjinfo"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "jointype"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "args"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "operator"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "root"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make2",
          "args": [
            "leftop",
            "dummyexpr"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeNode",
          "args": [
            "CaseTestExpr"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall4Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(varRelid))"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "varRelid"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "args"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "operator"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "root"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall5Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(sjinfo))"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "sjinfo"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "jointype"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "args"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "operator"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "root"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make2",
          "args": [
            "leftop",
            "elem"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "arrayexpr->elements"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typlenbyval",
          "args": [
            "arrayexpr->element_typeid",
            "&elmlen",
            "&elmbyval"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2028-2041",
          "snippet": "void\nget_typlenbyval(Oid typid, int16 *typlen, bool *typbyval)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyval(Oid typid, int16 *typlen, bool *typbyval)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rightop",
            "ArrayExpr"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall4Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(varRelid))"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "varRelid"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "args"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "operator"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "root"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall5Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(sjinfo))"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "sjinfo"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "jointype"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "args"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "operator"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "root"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make2",
          "args": [
            "leftop",
            "makeConst(nominal_element_type,\n\t\t\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t\t\tnominal_element_collation,\n\t\t\t\t\t\t\t\t\t\telmlen,\n\t\t\t\t\t\t\t\t\t\telem_values[i],\n\t\t\t\t\t\t\t\t\t\telem_nulls[i],\n\t\t\t\t\t\t\t\t\t\telmbyval)"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeConst",
          "args": [
            "nominal_element_type",
            "-1",
            "nominal_element_collation",
            "elmlen",
            "elem_values[i]",
            "elem_nulls[i]",
            "elmbyval"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "arrayval",
            "ARR_ELEMTYPE(arrayval)",
            "elmlen",
            "elmbyval",
            "elmalign",
            "&elem_values",
            "&elem_nulls",
            "&num_elems"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arrayval"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "ARR_ELEMTYPE(arrayval)",
            "&elmlen",
            "&elmbyval",
            "&elmalign"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arrayval"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "arraydatum"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rightop",
            "Const"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "oprsel",
            "&oprselproc"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_oprrest",
          "args": [
            "operator"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "get_oprrest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1345-1362",
          "snippet": "RegProcedure\nget_oprrest(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprrest;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_oprrest(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprrest;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_oprjoin",
          "args": [
            "operator"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "get_oprjoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1369-1386",
          "snippet": "RegProcedure\nget_oprjoin(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprjoin;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_oprjoin(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprjoin;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scalararraysel_containment",
          "args": [
            "root",
            "leftop",
            "rightop",
            "nominal_element_type",
            "isEquality",
            "useOr",
            "varRelid"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "scalararraysel_containment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "82-237",
          "snippet": "Selectivity\nscalararraysel_containment(PlannerInfo *root,\n\t\t\t\t\t\t   Node *leftop, Node *rightop,\n\t\t\t\t\t\t   Oid elemtype, bool isEquality, bool useOr,\n\t\t\t\t\t\t   int varRelid)\n{\n\tSelectivity selec;\n\tVariableStatData vardata;\n\tDatum\t\tconstval;\n\tTypeCacheEntry *typentry;\n\tFmgrInfo   *cmpfunc;\n\n\t/*\n\t * rightop must be a variable, else punt.\n\t */\n\texamine_variable(root, rightop, varRelid, &vardata);\n\tif (!vardata.rel)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\n\t/*\n\t * leftop must be a constant, else punt.\n\t */\n\tif (!IsA(leftop, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\tif (((Const *) leftop)->constisnull)\n\t{\n\t\t/* qual can't succeed if null on left */\n\t\tReleaseVariableStats(vardata);\n\t\treturn (Selectivity) 0.0;\n\t}\n\tconstval = ((Const *) leftop)->constvalue;\n\n\t/* Get element type's default comparison function */\n\ttypentry = lookup_type_cache(elemtype, TYPECACHE_CMP_PROC_FINFO);\n\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\tcmpfunc = &typentry->cmp_proc_finfo;\n\n\t/*\n\t * If the operator is <>, swap ANY/ALL, then invert the result later.\n\t */\n\tif (!isEquality)\n\t\tuseOr = !useOr;\n\n\t/* Get array element stats for var, if available */\n\tif (HeapTupleIsValid(vardata.statsTuple) &&\n\t\tstatistic_proc_security_check(&vardata, cmpfunc->fn_oid))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\t\tAttStatsSlot hslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\n\t\t/* MCELEM will be an array of same type as element */\n\t\tif (get_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCELEM, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\t/* For ALL case, also get histogram of distinct-element counts */\n\t\t\tif (useOr ||\n\t\t\t\t!get_attstatsslot(&hslot, vardata.statsTuple,\n\t\t\t\t\t\t\t\t  STATISTIC_KIND_DECHIST, InvalidOid,\n\t\t\t\t\t\t\t\t  ATTSTATSSLOT_NUMBERS))\n\t\t\t\tmemset(&hslot, 0, sizeof(hslot));\n\n\t\t\t/*\n\t\t\t * For = ANY, estimate as var @> ARRAY[const].\n\t\t\t *\n\t\t\t * For = ALL, estimate as var <@ ARRAY[const].\n\t\t\t */\n\t\t\tif (useOr)\n\t\t\t\tselec = mcelem_array_contain_overlap_selec(sslot.values,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\t\telse\n\t\t\t\tselec = mcelem_array_contained_selec(sslot.values,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No most-common-elements info, so do without */\n\t\t\tif (useOr)\n\t\t\t\tselec = mcelem_array_contain_overlap_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\t\telse\n\t\t\t\tselec = mcelem_array_contained_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\t\t}\n\n\t\t/*\n\t\t * MCE stats count only non-null rows, so adjust for null rows.\n\t\t */\n\t\tselec *= (1.0 - stats->stanullfrac);\n\t}\n\telse\n\t{\n\t\t/* No stats at all, so do without */\n\t\tif (useOr)\n\t\t\tselec = mcelem_array_contain_overlap_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\telse\n\t\t\tselec = mcelem_array_contained_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\t\t/* we assume no nulls here, so no stanullfrac correction */\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\t/*\n\t * If the operator is <>, invert the results.\n\t */\n\tif (!isEquality)\n\t\tselec = 1.0 - selec;\n\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);",
            "static Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);",
            "static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);",
            "static bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic Selectivity calc_arraycontsel(VariableStatData *vardata, Datum constval,\n\t\t\t\t  Oid elemtype, Oid operator);\nstatic Selectivity mcelem_array_selec(ArrayType *array,\n\t\t\t\t   TypeCacheEntry *typentry,\n\t\t\t\t   Datum *mcelem, int nmcelem,\n\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t   float4 *hist, int nhist,\n\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t\t   float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t\t   Datum *array_data, int nitems,\n\t\t\t\t\t\t\t\t   Oid operator, FmgrInfo *cmpfunc);\nstatic Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem,\n\t\t\t\t\t\t\t float4 *numbers, int nnumbers,\n\t\t\t\t\t\t\t Datum *array_data, int nitems,\n\t\t\t\t\t\t\t float4 *hist, int nhist,\n\t\t\t\t\t\t\t Oid operator, FmgrInfo *cmpfunc);\nstatic bool find_next_mcelem(Datum *mcelem, int nmcelem, Datum value,\n\t\t\t\t int *index, FmgrInfo *cmpfunc);\n\nSelectivity\nscalararraysel_containment(PlannerInfo *root,\n\t\t\t\t\t\t   Node *leftop, Node *rightop,\n\t\t\t\t\t\t   Oid elemtype, bool isEquality, bool useOr,\n\t\t\t\t\t\t   int varRelid)\n{\n\tSelectivity selec;\n\tVariableStatData vardata;\n\tDatum\t\tconstval;\n\tTypeCacheEntry *typentry;\n\tFmgrInfo   *cmpfunc;\n\n\t/*\n\t * rightop must be a variable, else punt.\n\t */\n\texamine_variable(root, rightop, varRelid, &vardata);\n\tif (!vardata.rel)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\n\t/*\n\t * leftop must be a constant, else punt.\n\t */\n\tif (!IsA(leftop, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\tif (((Const *) leftop)->constisnull)\n\t{\n\t\t/* qual can't succeed if null on left */\n\t\tReleaseVariableStats(vardata);\n\t\treturn (Selectivity) 0.0;\n\t}\n\tconstval = ((Const *) leftop)->constvalue;\n\n\t/* Get element type's default comparison function */\n\ttypentry = lookup_type_cache(elemtype, TYPECACHE_CMP_PROC_FINFO);\n\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn -1.0;\n\t}\n\tcmpfunc = &typentry->cmp_proc_finfo;\n\n\t/*\n\t * If the operator is <>, swap ANY/ALL, then invert the result later.\n\t */\n\tif (!isEquality)\n\t\tuseOr = !useOr;\n\n\t/* Get array element stats for var, if available */\n\tif (HeapTupleIsValid(vardata.statsTuple) &&\n\t\tstatistic_proc_security_check(&vardata, cmpfunc->fn_oid))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\t\tAttStatsSlot hslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\n\t\t/* MCELEM will be an array of same type as element */\n\t\tif (get_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCELEM, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\t/* For ALL case, also get histogram of distinct-element counts */\n\t\t\tif (useOr ||\n\t\t\t\t!get_attstatsslot(&hslot, vardata.statsTuple,\n\t\t\t\t\t\t\t\t  STATISTIC_KIND_DECHIST, InvalidOid,\n\t\t\t\t\t\t\t\t  ATTSTATSSLOT_NUMBERS))\n\t\t\t\tmemset(&hslot, 0, sizeof(hslot));\n\n\t\t\t/*\n\t\t\t * For = ANY, estimate as var @> ARRAY[const].\n\t\t\t *\n\t\t\t * For = ALL, estimate as var <@ ARRAY[const].\n\t\t\t */\n\t\t\tif (useOr)\n\t\t\t\tselec = mcelem_array_contain_overlap_selec(sslot.values,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\t\telse\n\t\t\t\tselec = mcelem_array_contained_selec(sslot.values,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hslot.numbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hslot.nnumbers,\n\t\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No most-common-elements info, so do without */\n\t\t\tif (useOr)\n\t\t\t\tselec = mcelem_array_contain_overlap_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\t\telse\n\t\t\t\tselec = mcelem_array_contained_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\t\t}\n\n\t\t/*\n\t\t * MCE stats count only non-null rows, so adjust for null rows.\n\t\t */\n\t\tselec *= (1.0 - stats->stanullfrac);\n\t}\n\telse\n\t{\n\t\t/* No stats at all, so do without */\n\t\tif (useOr)\n\t\t\tselec = mcelem_array_contain_overlap_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   OID_ARRAY_CONTAINS_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   cmpfunc);\n\t\telse\n\t\t\tselec = mcelem_array_contained_selec(NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t &constval, 1,\n\t\t\t\t\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t\t\t\t\t OID_ARRAY_CONTAINED_OP,\n\t\t\t\t\t\t\t\t\t\t\t\t cmpfunc);\n\t\t/* we assume no nulls here, so no stanullfrac correction */\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\t/*\n\t * If the operator is <>, invert the results.\n\t */\n\tif (!isEquality)\n\t\tselec = 1.0 - selec;\n\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_negator",
          "args": [
            "operator"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "get_negator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1321-1338",
          "snippet": "Oid\nget_negator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprnegate;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_negator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprnegate;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->eq_opr"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "nominal_element_type",
            "TYPECACHE_EQ_OPR"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strip_array_coercion",
          "args": [
            "rightop"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "strip_array_coercion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1826-1854",
          "snippet": "static Node *\nstrip_array_coercion(Node *node)\n{\n\tfor (;;)\n\t{\n\t\tif (node && IsA(node, ArrayCoerceExpr))\n\t\t{\n\t\t\tArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) node;\n\n\t\t\t/*\n\t\t\t * If the per-element expression is just a RelabelType on top of\n\t\t\t * CaseTestExpr, then we know it's a binary-compatible relabeling.\n\t\t\t */\n\t\t\tif (IsA(acoerce->elemexpr, RelabelType) &&\n\t\t\t\tIsA(((RelabelType *) acoerce->elemexpr)->arg, CaseTestExpr))\n\t\t\t\tnode = (Node *) acoerce->arg;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (node && IsA(node, RelabelType))\n\t\t{\n\t\t\t/* We don't really expect this case, but may as well cope */\n\t\t\tnode = (Node *) ((RelabelType *) node)->arg;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn node;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Node *\nstrip_array_coercion(Node *node)\n{\n\tfor (;;)\n\t{\n\t\tif (node && IsA(node, ArrayCoerceExpr))\n\t\t{\n\t\t\tArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) node;\n\n\t\t\t/*\n\t\t\t * If the per-element expression is just a RelabelType on top of\n\t\t\t * CaseTestExpr, then we know it's a binary-compatible relabeling.\n\t\t\t */\n\t\t\tif (IsA(acoerce->elemexpr, RelabelType) &&\n\t\t\t\tIsA(((RelabelType *) acoerce->elemexpr)->arg, CaseTestExpr))\n\t\t\t\tnode = (Node *) acoerce->arg;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (node && IsA(node, RelabelType))\n\t\t{\n\t\t\t/* We don't really expect this case, but may as well cope */\n\t\t\tnode = (Node *) ((RelabelType *) node)->arg;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exprCollation",
          "args": [
            "rightop"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "nominal_element_type"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_base_element_type",
          "args": [
            "exprType(rightop)"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "get_base_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2598-2633",
          "snippet": "Oid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "rightop"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimate_expression_value",
          "args": [
            "root",
            "rightop"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "estimate_expression_value",
          "args": [
            "root",
            "leftop"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lsecond",
          "args": [
            "clause->args"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "clause->args"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "list_length(clause->args) == 2"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "clause->args"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nSelectivity\nscalararraysel(PlannerInfo *root,\n\t\t\t   ScalarArrayOpExpr *clause,\n\t\t\t   bool is_join_clause,\n\t\t\t   int varRelid,\n\t\t\t   JoinType jointype,\n\t\t\t   SpecialJoinInfo *sjinfo)\n{\n\tOid\t\t\toperator = clause->opno;\n\tbool\t\tuseOr = clause->useOr;\n\tbool\t\tisEquality = false;\n\tbool\t\tisInequality = false;\n\tNode\t   *leftop;\n\tNode\t   *rightop;\n\tOid\t\t\tnominal_element_type;\n\tOid\t\t\tnominal_element_collation;\n\tTypeCacheEntry *typentry;\n\tRegProcedure oprsel;\n\tFmgrInfo\toprselproc;\n\tSelectivity s1;\n\tSelectivity s1disjoint;\n\n\t/* First, deconstruct the expression */\n\tAssert(list_length(clause->args) == 2);\n\tleftop = (Node *) linitial(clause->args);\n\trightop = (Node *) lsecond(clause->args);\n\n\t/* aggressively reduce both sides to constants */\n\tleftop = estimate_expression_value(root, leftop);\n\trightop = estimate_expression_value(root, rightop);\n\n\t/* get nominal (after relabeling) element type of rightop */\n\tnominal_element_type = get_base_element_type(exprType(rightop));\n\tif (!OidIsValid(nominal_element_type))\n\t\treturn (Selectivity) 0.5;\t/* probably shouldn't happen */\n\t/* get nominal collation, too, for generating constants */\n\tnominal_element_collation = exprCollation(rightop);\n\n\t/* look through any binary-compatible relabeling of rightop */\n\trightop = strip_array_coercion(rightop);\n\n\t/*\n\t * Detect whether the operator is the default equality or inequality\n\t * operator of the array element type.\n\t */\n\ttypentry = lookup_type_cache(nominal_element_type, TYPECACHE_EQ_OPR);\n\tif (OidIsValid(typentry->eq_opr))\n\t{\n\t\tif (operator == typentry->eq_opr)\n\t\t\tisEquality = true;\n\t\telse if (get_negator(operator) == typentry->eq_opr)\n\t\t\tisInequality = true;\n\t}\n\n\t/*\n\t * If it is equality or inequality, we might be able to estimate this as a\n\t * form of array containment; for instance \"const = ANY(column)\" can be\n\t * treated as \"ARRAY[const] <@ column\".  scalararraysel_containment tries\n\t * that, and returns the selectivity estimate if successful, or -1 if not.\n\t */\n\tif ((isEquality || isInequality) && !is_join_clause)\n\t{\n\t\ts1 = scalararraysel_containment(root, leftop, rightop,\n\t\t\t\t\t\t\t\t\t\tnominal_element_type,\n\t\t\t\t\t\t\t\t\t\tisEquality, useOr, varRelid);\n\t\tif (s1 >= 0.0)\n\t\t\treturn s1;\n\t}\n\n\t/*\n\t * Look up the underlying operator's selectivity estimator. Punt if it\n\t * hasn't got one.\n\t */\n\tif (is_join_clause)\n\t\toprsel = get_oprjoin(operator);\n\telse\n\t\toprsel = get_oprrest(operator);\n\tif (!oprsel)\n\t\treturn (Selectivity) 0.5;\n\tfmgr_info(oprsel, &oprselproc);\n\n\t/*\n\t * In the array-containment check above, we must only believe that an\n\t * operator is equality or inequality if it is the default btree equality\n\t * operator (or its negator) for the element type, since those are the\n\t * operators that array containment will use.  But in what follows, we can\n\t * be a little laxer, and also believe that any operators using eqsel() or\n\t * neqsel() as selectivity estimator act like equality or inequality.\n\t */\n\tif (oprsel == F_EQSEL || oprsel == F_EQJOINSEL)\n\t\tisEquality = true;\n\telse if (oprsel == F_NEQSEL || oprsel == F_NEQJOINSEL)\n\t\tisInequality = true;\n\n\t/*\n\t * We consider three cases:\n\t *\n\t * 1. rightop is an Array constant: deconstruct the array, apply the\n\t * operator's selectivity function for each array element, and merge the\n\t * results in the same way that clausesel.c does for AND/OR combinations.\n\t *\n\t * 2. rightop is an ARRAY[] construct: apply the operator's selectivity\n\t * function for each element of the ARRAY[] construct, and merge.\n\t *\n\t * 3. otherwise, make a guess ...\n\t */\n\tif (rightop && IsA(rightop, Const))\n\t{\n\t\tDatum\t\tarraydatum = ((Const *) rightop)->constvalue;\n\t\tbool\t\tarrayisnull = ((Const *) rightop)->constisnull;\n\t\tArrayType  *arrayval;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t\tint\t\t\tnum_elems;\n\t\tDatum\t   *elem_values;\n\t\tbool\t   *elem_nulls;\n\t\tint\t\t\ti;\n\n\t\tif (arrayisnull)\t\t/* qual can't succeed if null array */\n\t\t\treturn (Selectivity) 0.0;\n\t\tarrayval = DatumGetArrayTypeP(arraydatum);\n\t\tget_typlenbyvalalign(ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t\t\t &elmlen, &elmbyval, &elmalign);\n\t\tdeconstruct_array(arrayval,\n\t\t\t\t\t\t  ARR_ELEMTYPE(arrayval),\n\t\t\t\t\t\t  elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &elem_values, &elem_nulls, &num_elems);\n\n\t\t/*\n\t\t * For generic operators, we assume the probability of success is\n\t\t * independent for each array element.  But for \"= ANY\" or \"<> ALL\",\n\t\t * if the array elements are distinct (which'd typically be the case)\n\t\t * then the probabilities are disjoint, and we should just sum them.\n\t\t *\n\t\t * If we were being really tense we would try to confirm that the\n\t\t * elements are all distinct, but that would be expensive and it\n\t\t * doesn't seem to be worth the cycles; it would amount to penalizing\n\t\t * well-written queries in favor of poorly-written ones.  However, we\n\t\t * do protect ourselves a little bit by checking whether the\n\t\t * disjointness assumption leads to an impossible (out of range)\n\t\t * probability; if so, we fall back to the normal calculation.\n\t\t */\n\t\ts1 = s1disjoint = (useOr ? 0.0 : 1.0);\n\n\t\tfor (i = 0; i < num_elems; i++)\n\t\t{\n\t\t\tList\t   *args;\n\t\t\tSelectivity s2;\n\n\t\t\targs = list_make2(leftop,\n\t\t\t\t\t\t\t  makeConst(nominal_element_type,\n\t\t\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t\t\tnominal_element_collation,\n\t\t\t\t\t\t\t\t\t\telmlen,\n\t\t\t\t\t\t\t\t\t\telem_values[i],\n\t\t\t\t\t\t\t\t\t\telem_nulls[i],\n\t\t\t\t\t\t\t\t\t\telmbyval));\n\t\t\tif (is_join_clause)\n\t\t\t\ts2 = DatumGetFloat8(FunctionCall5Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(sjinfo)));\n\t\t\telse\n\t\t\t\ts2 = DatumGetFloat8(FunctionCall4Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(varRelid)));\n\n\t\t\tif (useOr)\n\t\t\t{\n\t\t\t\ts1 = s1 + s2 - s1 * s2;\n\t\t\t\tif (isEquality)\n\t\t\t\t\ts1disjoint += s2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts1 = s1 * s2;\n\t\t\t\tif (isInequality)\n\t\t\t\t\ts1disjoint += s2 - 1.0;\n\t\t\t}\n\t\t}\n\n\t\t/* accept disjoint-probability estimate if in range */\n\t\tif ((useOr ? isEquality : isInequality) &&\n\t\t\ts1disjoint >= 0.0 && s1disjoint <= 1.0)\n\t\t\ts1 = s1disjoint;\n\t}\n\telse if (rightop && IsA(rightop, ArrayExpr) &&\n\t\t\t !((ArrayExpr *) rightop)->multidims)\n\t{\n\t\tArrayExpr  *arrayexpr = (ArrayExpr *) rightop;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tListCell   *l;\n\n\t\tget_typlenbyval(arrayexpr->element_typeid,\n\t\t\t\t\t\t&elmlen, &elmbyval);\n\n\t\t/*\n\t\t * We use the assumption of disjoint probabilities here too, although\n\t\t * the odds of equal array elements are rather higher if the elements\n\t\t * are not all constants (which they won't be, else constant folding\n\t\t * would have reduced the ArrayExpr to a Const).  In this path it's\n\t\t * critical to have the sanity check on the s1disjoint estimate.\n\t\t */\n\t\ts1 = s1disjoint = (useOr ? 0.0 : 1.0);\n\n\t\tforeach(l, arrayexpr->elements)\n\t\t{\n\t\t\tNode\t   *elem = (Node *) lfirst(l);\n\t\t\tList\t   *args;\n\t\t\tSelectivity s2;\n\n\t\t\t/*\n\t\t\t * Theoretically, if elem isn't of nominal_element_type we should\n\t\t\t * insert a RelabelType, but it seems unlikely that any operator\n\t\t\t * estimation function would really care ...\n\t\t\t */\n\t\t\targs = list_make2(leftop, elem);\n\t\t\tif (is_join_clause)\n\t\t\t\ts2 = DatumGetFloat8(FunctionCall5Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(sjinfo)));\n\t\t\telse\n\t\t\t\ts2 = DatumGetFloat8(FunctionCall4Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(varRelid)));\n\n\t\t\tif (useOr)\n\t\t\t{\n\t\t\t\ts1 = s1 + s2 - s1 * s2;\n\t\t\t\tif (isEquality)\n\t\t\t\t\ts1disjoint += s2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts1 = s1 * s2;\n\t\t\t\tif (isInequality)\n\t\t\t\t\ts1disjoint += s2 - 1.0;\n\t\t\t}\n\t\t}\n\n\t\t/* accept disjoint-probability estimate if in range */\n\t\tif ((useOr ? isEquality : isInequality) &&\n\t\t\ts1disjoint >= 0.0 && s1disjoint <= 1.0)\n\t\t\ts1 = s1disjoint;\n\t}\n\telse\n\t{\n\t\tCaseTestExpr *dummyexpr;\n\t\tList\t   *args;\n\t\tSelectivity s2;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * We need a dummy rightop to pass to the operator selectivity\n\t\t * routine.  It can be pretty much anything that doesn't look like a\n\t\t * constant; CaseTestExpr is a convenient choice.\n\t\t */\n\t\tdummyexpr = makeNode(CaseTestExpr);\n\t\tdummyexpr->typeId = nominal_element_type;\n\t\tdummyexpr->typeMod = -1;\n\t\tdummyexpr->collation = clause->inputcollid;\n\t\targs = list_make2(leftop, dummyexpr);\n\t\tif (is_join_clause)\n\t\t\ts2 = DatumGetFloat8(FunctionCall5Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(jointype),\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(sjinfo)));\n\t\telse\n\t\t\ts2 = DatumGetFloat8(FunctionCall4Coll(&oprselproc,\n\t\t\t\t\t\t\t\t\t\t\t\t  clause->inputcollid,\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(root),\n\t\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(operator),\n\t\t\t\t\t\t\t\t\t\t\t\t  PointerGetDatum(args),\n\t\t\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(varRelid)));\n\t\ts1 = useOr ? 0.0 : 1.0;\n\n\t\t/*\n\t\t * Arbitrarily assume 10 elements in the eventual array value (see\n\t\t * also estimate_array_length).  We don't risk an assumption of\n\t\t * disjoint probabilities here.\n\t\t */\n\t\tfor (i = 0; i < 10; i++)\n\t\t{\n\t\t\tif (useOr)\n\t\t\t\ts1 = s1 + s2 - s1 * s2;\n\t\t\telse\n\t\t\t\ts1 = s1 * s2;\n\t\t}\n\t}\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(s1);\n\n\treturn s1;\n}"
  },
  {
    "function_name": "strip_array_coercion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1826-1854",
    "snippet": "static Node *\nstrip_array_coercion(Node *node)\n{\n\tfor (;;)\n\t{\n\t\tif (node && IsA(node, ArrayCoerceExpr))\n\t\t{\n\t\t\tArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) node;\n\n\t\t\t/*\n\t\t\t * If the per-element expression is just a RelabelType on top of\n\t\t\t * CaseTestExpr, then we know it's a binary-compatible relabeling.\n\t\t\t */\n\t\t\tif (IsA(acoerce->elemexpr, RelabelType) &&\n\t\t\t\tIsA(((RelabelType *) acoerce->elemexpr)->arg, CaseTestExpr))\n\t\t\t\tnode = (Node *) acoerce->arg;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (node && IsA(node, RelabelType))\n\t\t{\n\t\t\t/* We don't really expect this case, but may as well cope */\n\t\t\tnode = (Node *) ((RelabelType *) node)->arg;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn node;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "node",
            "RelabelType"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "((RelabelType *) acoerce->elemexpr)->arg",
            "CaseTestExpr"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "acoerce->elemexpr",
            "RelabelType"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "node",
            "ArrayCoerceExpr"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Node *\nstrip_array_coercion(Node *node)\n{\n\tfor (;;)\n\t{\n\t\tif (node && IsA(node, ArrayCoerceExpr))\n\t\t{\n\t\t\tArrayCoerceExpr *acoerce = (ArrayCoerceExpr *) node;\n\n\t\t\t/*\n\t\t\t * If the per-element expression is just a RelabelType on top of\n\t\t\t * CaseTestExpr, then we know it's a binary-compatible relabeling.\n\t\t\t */\n\t\t\tif (IsA(acoerce->elemexpr, RelabelType) &&\n\t\t\t\tIsA(((RelabelType *) acoerce->elemexpr)->arg, CaseTestExpr))\n\t\t\t\tnode = (Node *) acoerce->arg;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (node && IsA(node, RelabelType))\n\t\t{\n\t\t\t/* We don't really expect this case, but may as well cope */\n\t\t\tnode = (Node *) ((RelabelType *) node)->arg;\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn node;\n}"
  },
  {
    "function_name": "nulltestsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1750-1816",
    "snippet": "Selectivity\nnulltestsel(PlannerInfo *root, NullTestType nulltesttype, Node *arg,\n\t\t\tint varRelid, JoinType jointype, SpecialJoinInfo *sjinfo)\n{\n\tVariableStatData vardata;\n\tdouble\t\tselec;\n\n\texamine_variable(root, arg, varRelid, &vardata);\n\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tdouble\t\tfreq_null;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tfreq_null = stats->stanullfrac;\n\n\t\tswitch (nulltesttype)\n\t\t{\n\t\t\tcase IS_NULL:\n\n\t\t\t\t/*\n\t\t\t\t * Use freq_null directly.\n\t\t\t\t */\n\t\t\t\tselec = freq_null;\n\t\t\t\tbreak;\n\t\t\tcase IS_NOT_NULL:\n\n\t\t\t\t/*\n\t\t\t\t * Select not unknown (not null) values. Calculate from\n\t\t\t\t * freq_null.\n\t\t\t\t */\n\t\t\t\tselec = 1.0 - freq_null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized nulltesttype: %d\",\n\t\t\t\t\t (int) nulltesttype);\n\t\t\t\treturn (Selectivity) 0; /* keep compiler quiet */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess\n\t\t */\n\t\tswitch (nulltesttype)\n\t\t{\n\t\t\tcase IS_NULL:\n\t\t\t\tselec = DEFAULT_UNK_SEL;\n\t\t\t\tbreak;\n\t\t\tcase IS_NOT_NULL:\n\t\t\t\tselec = DEFAULT_NOT_UNK_SEL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized nulltesttype: %d\",\n\t\t\t\t\t (int) nulltesttype);\n\t\t\t\treturn (Selectivity) 0; /* keep compiler quiet */\n\t\t}\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn (Selectivity) selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized nulltesttype: %d\"",
            "(int) nulltesttype"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "examine_variable",
          "args": [
            "root",
            "arg",
            "varRelid",
            "&vardata"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "examine_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4775-4984",
          "snippet": "void\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "get_index_stats_hook_type get_index_stats_hook = NULL;",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nSelectivity\nnulltestsel(PlannerInfo *root, NullTestType nulltesttype, Node *arg,\n\t\t\tint varRelid, JoinType jointype, SpecialJoinInfo *sjinfo)\n{\n\tVariableStatData vardata;\n\tdouble\t\tselec;\n\n\texamine_variable(root, arg, varRelid, &vardata);\n\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tdouble\t\tfreq_null;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tfreq_null = stats->stanullfrac;\n\n\t\tswitch (nulltesttype)\n\t\t{\n\t\t\tcase IS_NULL:\n\n\t\t\t\t/*\n\t\t\t\t * Use freq_null directly.\n\t\t\t\t */\n\t\t\t\tselec = freq_null;\n\t\t\t\tbreak;\n\t\t\tcase IS_NOT_NULL:\n\n\t\t\t\t/*\n\t\t\t\t * Select not unknown (not null) values. Calculate from\n\t\t\t\t * freq_null.\n\t\t\t\t */\n\t\t\t\tselec = 1.0 - freq_null;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized nulltesttype: %d\",\n\t\t\t\t\t (int) nulltesttype);\n\t\t\t\treturn (Selectivity) 0; /* keep compiler quiet */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess\n\t\t */\n\t\tswitch (nulltesttype)\n\t\t{\n\t\t\tcase IS_NULL:\n\t\t\t\tselec = DEFAULT_UNK_SEL;\n\t\t\t\tbreak;\n\t\t\tcase IS_NOT_NULL:\n\t\t\t\tselec = DEFAULT_NOT_UNK_SEL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized nulltesttype: %d\",\n\t\t\t\t\t (int) nulltesttype);\n\t\t\t\treturn (Selectivity) 0; /* keep compiler quiet */\n\t\t}\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn (Selectivity) selec;\n}"
  },
  {
    "function_name": "booltestsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1592-1745",
    "snippet": "Selectivity\nbooltestsel(PlannerInfo *root, BoolTestType booltesttype, Node *arg,\n\t\t\tint varRelid, JoinType jointype, SpecialJoinInfo *sjinfo)\n{\n\tVariableStatData vardata;\n\tdouble\t\tselec;\n\n\texamine_variable(root, arg, varRelid, &vardata);\n\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tdouble\t\tfreq_null;\n\t\tAttStatsSlot sslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tfreq_null = stats->stanullfrac;\n\n\t\tif (get_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS)\n\t\t\t&& sslot.nnumbers > 0)\n\t\t{\n\t\t\tdouble\t\tfreq_true;\n\t\t\tdouble\t\tfreq_false;\n\n\t\t\t/*\n\t\t\t * Get first MCV frequency and derive frequency for true.\n\t\t\t */\n\t\t\tif (DatumGetBool(sslot.values[0]))\n\t\t\t\tfreq_true = sslot.numbers[0];\n\t\t\telse\n\t\t\t\tfreq_true = 1.0 - sslot.numbers[0] - freq_null;\n\n\t\t\t/*\n\t\t\t * Next derive frequency for false. Then use these as appropriate\n\t\t\t * to derive frequency for each case.\n\t\t\t */\n\t\t\tfreq_false = 1.0 - freq_true - freq_null;\n\n\t\t\tswitch (booltesttype)\n\t\t\t{\n\t\t\t\tcase IS_UNKNOWN:\n\t\t\t\t\t/* select only NULL values */\n\t\t\t\t\tselec = freq_null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_NOT_UNKNOWN:\n\t\t\t\t\t/* select non-NULL values */\n\t\t\t\t\tselec = 1.0 - freq_null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_TRUE:\n\t\t\t\t\t/* select only TRUE values */\n\t\t\t\t\tselec = freq_true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_NOT_TRUE:\n\t\t\t\t\t/* select non-TRUE values */\n\t\t\t\t\tselec = 1.0 - freq_true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_FALSE:\n\t\t\t\t\t/* select only FALSE values */\n\t\t\t\t\tselec = freq_false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_NOT_FALSE:\n\t\t\t\t\t/* select non-FALSE values */\n\t\t\t\t\tselec = 1.0 - freq_false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized booltesttype: %d\",\n\t\t\t\t\t\t (int) booltesttype);\n\t\t\t\t\tselec = 0.0;\t/* Keep compiler quiet */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * No most-common-value info available. Still have null fraction\n\t\t\t * information, so use it for IS [NOT] UNKNOWN. Otherwise adjust\n\t\t\t * for null fraction and assume a 50-50 split of TRUE and FALSE.\n\t\t\t */\n\t\t\tswitch (booltesttype)\n\t\t\t{\n\t\t\t\tcase IS_UNKNOWN:\n\t\t\t\t\t/* select only NULL values */\n\t\t\t\t\tselec = freq_null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_NOT_UNKNOWN:\n\t\t\t\t\t/* select non-NULL values */\n\t\t\t\t\tselec = 1.0 - freq_null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_TRUE:\n\t\t\t\tcase IS_FALSE:\n\t\t\t\t\t/* Assume we select half of the non-NULL values */\n\t\t\t\t\tselec = (1.0 - freq_null) / 2.0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_NOT_TRUE:\n\t\t\t\tcase IS_NOT_FALSE:\n\t\t\t\t\t/* Assume we select NULLs plus half of the non-NULLs */\n\t\t\t\t\t/* equiv. to freq_null + (1.0 - freq_null) / 2.0 */\n\t\t\t\t\tselec = (freq_null + 1.0) / 2.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized booltesttype: %d\",\n\t\t\t\t\t\t (int) booltesttype);\n\t\t\t\t\tselec = 0.0;\t/* Keep compiler quiet */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If we can't get variable statistics for the argument, perhaps\n\t\t * clause_selectivity can do something with it.  We ignore the\n\t\t * possibility of a NULL value when using clause_selectivity, and just\n\t\t * assume the value is either TRUE or FALSE.\n\t\t */\n\t\tswitch (booltesttype)\n\t\t{\n\t\t\tcase IS_UNKNOWN:\n\t\t\t\tselec = DEFAULT_UNK_SEL;\n\t\t\t\tbreak;\n\t\t\tcase IS_NOT_UNKNOWN:\n\t\t\t\tselec = DEFAULT_NOT_UNK_SEL;\n\t\t\t\tbreak;\n\t\t\tcase IS_TRUE:\n\t\t\tcase IS_NOT_FALSE:\n\t\t\t\tselec = (double) clause_selectivity(root, arg,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvarRelid,\n\t\t\t\t\t\t\t\t\t\t\t\t\tjointype, sjinfo);\n\t\t\t\tbreak;\n\t\t\tcase IS_FALSE:\n\t\t\tcase IS_NOT_TRUE:\n\t\t\t\tselec = 1.0 - (double) clause_selectivity(root, arg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  varRelid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  jointype, sjinfo);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized booltesttype: %d\",\n\t\t\t\t\t (int) booltesttype);\n\t\t\t\tselec = 0.0;\t/* Keep compiler quiet */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn (Selectivity) selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized booltesttype: %d\"",
            "(int) booltesttype"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clause_selectivity",
          "args": [
            "root",
            "arg",
            "varRelid",
            "jointype",
            "sjinfo"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clause_selectivity",
          "args": [
            "root",
            "arg",
            "varRelid",
            "jointype",
            "sjinfo"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "sslot.values[0]"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot",
            "vardata.statsTuple",
            "STATISTIC_KIND_MCV",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "examine_variable",
          "args": [
            "root",
            "arg",
            "varRelid",
            "&vardata"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "examine_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4775-4984",
          "snippet": "void\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "get_index_stats_hook_type get_index_stats_hook = NULL;",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nSelectivity\nbooltestsel(PlannerInfo *root, BoolTestType booltesttype, Node *arg,\n\t\t\tint varRelid, JoinType jointype, SpecialJoinInfo *sjinfo)\n{\n\tVariableStatData vardata;\n\tdouble\t\tselec;\n\n\texamine_variable(root, arg, varRelid, &vardata);\n\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tdouble\t\tfreq_null;\n\t\tAttStatsSlot sslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tfreq_null = stats->stanullfrac;\n\n\t\tif (get_attstatsslot(&sslot, vardata.statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS)\n\t\t\t&& sslot.nnumbers > 0)\n\t\t{\n\t\t\tdouble\t\tfreq_true;\n\t\t\tdouble\t\tfreq_false;\n\n\t\t\t/*\n\t\t\t * Get first MCV frequency and derive frequency for true.\n\t\t\t */\n\t\t\tif (DatumGetBool(sslot.values[0]))\n\t\t\t\tfreq_true = sslot.numbers[0];\n\t\t\telse\n\t\t\t\tfreq_true = 1.0 - sslot.numbers[0] - freq_null;\n\n\t\t\t/*\n\t\t\t * Next derive frequency for false. Then use these as appropriate\n\t\t\t * to derive frequency for each case.\n\t\t\t */\n\t\t\tfreq_false = 1.0 - freq_true - freq_null;\n\n\t\t\tswitch (booltesttype)\n\t\t\t{\n\t\t\t\tcase IS_UNKNOWN:\n\t\t\t\t\t/* select only NULL values */\n\t\t\t\t\tselec = freq_null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_NOT_UNKNOWN:\n\t\t\t\t\t/* select non-NULL values */\n\t\t\t\t\tselec = 1.0 - freq_null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_TRUE:\n\t\t\t\t\t/* select only TRUE values */\n\t\t\t\t\tselec = freq_true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_NOT_TRUE:\n\t\t\t\t\t/* select non-TRUE values */\n\t\t\t\t\tselec = 1.0 - freq_true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_FALSE:\n\t\t\t\t\t/* select only FALSE values */\n\t\t\t\t\tselec = freq_false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_NOT_FALSE:\n\t\t\t\t\t/* select non-FALSE values */\n\t\t\t\t\tselec = 1.0 - freq_false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized booltesttype: %d\",\n\t\t\t\t\t\t (int) booltesttype);\n\t\t\t\t\tselec = 0.0;\t/* Keep compiler quiet */\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * No most-common-value info available. Still have null fraction\n\t\t\t * information, so use it for IS [NOT] UNKNOWN. Otherwise adjust\n\t\t\t * for null fraction and assume a 50-50 split of TRUE and FALSE.\n\t\t\t */\n\t\t\tswitch (booltesttype)\n\t\t\t{\n\t\t\t\tcase IS_UNKNOWN:\n\t\t\t\t\t/* select only NULL values */\n\t\t\t\t\tselec = freq_null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_NOT_UNKNOWN:\n\t\t\t\t\t/* select non-NULL values */\n\t\t\t\t\tselec = 1.0 - freq_null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_TRUE:\n\t\t\t\tcase IS_FALSE:\n\t\t\t\t\t/* Assume we select half of the non-NULL values */\n\t\t\t\t\tselec = (1.0 - freq_null) / 2.0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_NOT_TRUE:\n\t\t\t\tcase IS_NOT_FALSE:\n\t\t\t\t\t/* Assume we select NULLs plus half of the non-NULLs */\n\t\t\t\t\t/* equiv. to freq_null + (1.0 - freq_null) / 2.0 */\n\t\t\t\t\tselec = (freq_null + 1.0) / 2.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\telog(ERROR, \"unrecognized booltesttype: %d\",\n\t\t\t\t\t\t (int) booltesttype);\n\t\t\t\t\tselec = 0.0;\t/* Keep compiler quiet */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If we can't get variable statistics for the argument, perhaps\n\t\t * clause_selectivity can do something with it.  We ignore the\n\t\t * possibility of a NULL value when using clause_selectivity, and just\n\t\t * assume the value is either TRUE or FALSE.\n\t\t */\n\t\tswitch (booltesttype)\n\t\t{\n\t\t\tcase IS_UNKNOWN:\n\t\t\t\tselec = DEFAULT_UNK_SEL;\n\t\t\t\tbreak;\n\t\t\tcase IS_NOT_UNKNOWN:\n\t\t\t\tselec = DEFAULT_NOT_UNK_SEL;\n\t\t\t\tbreak;\n\t\t\tcase IS_TRUE:\n\t\t\tcase IS_NOT_FALSE:\n\t\t\t\tselec = (double) clause_selectivity(root, arg,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvarRelid,\n\t\t\t\t\t\t\t\t\t\t\t\t\tjointype, sjinfo);\n\t\t\t\tbreak;\n\t\t\tcase IS_FALSE:\n\t\t\tcase IS_NOT_TRUE:\n\t\t\t\tselec = 1.0 - (double) clause_selectivity(root, arg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  varRelid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  jointype, sjinfo);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized booltesttype: %d\",\n\t\t\t\t\t (int) booltesttype);\n\t\t\t\tselec = 0.0;\t/* Keep compiler quiet */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn (Selectivity) selec;\n}"
  },
  {
    "function_name": "boolvarsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1553-1587",
    "snippet": "Selectivity\nboolvarsel(PlannerInfo *root, Node *arg, int varRelid)\n{\n\tVariableStatData vardata;\n\tdouble\t\tselec;\n\n\texamine_variable(root, arg, varRelid, &vardata);\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\t/*\n\t\t * A boolean variable V is equivalent to the clause V = 't', so we\n\t\t * compute the selectivity as if that is what we have.\n\t\t */\n\t\tselec = var_eq_const(&vardata, BooleanEqualOperator,\n\t\t\t\t\t\t\t BoolGetDatum(true), false, true, false);\n\t}\n\telse if (is_funcclause(arg))\n\t{\n\t\t/*\n\t\t * If we have no stats and it's a function call, estimate 0.3333333.\n\t\t * This seems a pretty unprincipled choice, but Postgres has been\n\t\t * using that estimate for function calls since 1992.  The hoariness\n\t\t * of this behavior suggests that we should not be in too much hurry\n\t\t * to use another value.\n\t\t */\n\t\tselec = 0.3333333;\n\t}\n\telse\n\t{\n\t\t/* Otherwise, the default estimate is 0.5 */\n\t\tselec = 0.5;\n\t}\n\tReleaseVariableStats(vardata);\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_funcclause",
          "args": [
            "arg"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var_eq_const",
          "args": [
            "&vardata",
            "BooleanEqualOperator",
            "BoolGetDatum(true)",
            "false",
            "true",
            "false"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "var_eq_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "297-444",
          "snippet": "static double\nvar_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\tOid\t\t\topfuncoid;\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (constisnull)\n\t\treturn 0.0;\n\n\t/*\n\t * Grab the nullfrac for use below.  Note we allow use of nullfrac\n\t * regardless of security check.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(operator))))\n\t{\n\t\tAttStatsSlot sslot;\n\t\tbool\t\tmatch = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * Is the constant \"=\" to any of the column's most common values?\n\t\t * (Although the given operator may not really be \"=\", we will assume\n\t\t * that seeing whether it returns TRUE is an appropriate test.  If you\n\t\t * don't like this, maybe you shouldn't be using eqsel for your\n\t\t * operator...)\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tFmgrInfo\teqproc;\n\n\t\t\tfmgr_info(opfuncoid, &eqproc);\n\n\t\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t\t{\n\t\t\t\t/* be careful to apply operator right way 'round */\n\t\t\t\tif (varonleft)\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\telse\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i]));\n\t\t\t\tif (match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no most-common-value info available */\n\t\t\ti = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/*\n\t\t\t * Constant is \"=\" to this common value.  We know selectivity\n\t\t\t * exactly (or as exactly as ANALYZE could calculate it, anyway).\n\t\t\t */\n\t\t\tselec = sslot.numbers[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Comparison is against a constant that is neither NULL nor any\n\t\t\t * of the common values.  Its selectivity cannot be more than\n\t\t\t * this:\n\t\t\t */\n\t\t\tdouble\t\tsumcommon = 0.0;\n\t\t\tdouble\t\totherdistinct;\n\n\t\t\tfor (i = 0; i < sslot.nnumbers; i++)\n\t\t\t\tsumcommon += sslot.numbers[i];\n\t\t\tselec = 1.0 - sumcommon - nullfrac;\n\t\t\tCLAMP_PROBABILITY(selec);\n\n\t\t\t/*\n\t\t\t * and in fact it's probably a good deal less. We approximate that\n\t\t\t * all the not-common values share this remaining fraction\n\t\t\t * equally, so we divide by the number of other distinct values.\n\t\t\t */\n\t\t\totherdistinct = get_variable_numdistinct(vardata, &isdefault) -\n\t\t\t\tsslot.nnumbers;\n\t\t\tif (otherdistinct > 1)\n\t\t\t\tselec /= otherdistinct;\n\n\t\t\t/*\n\t\t\t * Another cross-check: selectivity shouldn't be estimated as more\n\t\t\t * than the least common \"most common value\".\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[sslot.nnumbers - 1])\n\t\t\t\tselec = sslot.numbers[sslot.nnumbers - 1];\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\nvar_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\tOid\t\t\topfuncoid;\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (constisnull)\n\t\treturn 0.0;\n\n\t/*\n\t * Grab the nullfrac for use below.  Note we allow use of nullfrac\n\t * regardless of security check.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(operator))))\n\t{\n\t\tAttStatsSlot sslot;\n\t\tbool\t\tmatch = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * Is the constant \"=\" to any of the column's most common values?\n\t\t * (Although the given operator may not really be \"=\", we will assume\n\t\t * that seeing whether it returns TRUE is an appropriate test.  If you\n\t\t * don't like this, maybe you shouldn't be using eqsel for your\n\t\t * operator...)\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tFmgrInfo\teqproc;\n\n\t\t\tfmgr_info(opfuncoid, &eqproc);\n\n\t\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t\t{\n\t\t\t\t/* be careful to apply operator right way 'round */\n\t\t\t\tif (varonleft)\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\telse\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i]));\n\t\t\t\tif (match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no most-common-value info available */\n\t\t\ti = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/*\n\t\t\t * Constant is \"=\" to this common value.  We know selectivity\n\t\t\t * exactly (or as exactly as ANALYZE could calculate it, anyway).\n\t\t\t */\n\t\t\tselec = sslot.numbers[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Comparison is against a constant that is neither NULL nor any\n\t\t\t * of the common values.  Its selectivity cannot be more than\n\t\t\t * this:\n\t\t\t */\n\t\t\tdouble\t\tsumcommon = 0.0;\n\t\t\tdouble\t\totherdistinct;\n\n\t\t\tfor (i = 0; i < sslot.nnumbers; i++)\n\t\t\t\tsumcommon += sslot.numbers[i];\n\t\t\tselec = 1.0 - sumcommon - nullfrac;\n\t\t\tCLAMP_PROBABILITY(selec);\n\n\t\t\t/*\n\t\t\t * and in fact it's probably a good deal less. We approximate that\n\t\t\t * all the not-common values share this remaining fraction\n\t\t\t * equally, so we divide by the number of other distinct values.\n\t\t\t */\n\t\t\totherdistinct = get_variable_numdistinct(vardata, &isdefault) -\n\t\t\t\tsslot.nnumbers;\n\t\t\tif (otherdistinct > 1)\n\t\t\t\tselec /= otherdistinct;\n\n\t\t\t/*\n\t\t\t * Another cross-check: selectivity shouldn't be estimated as more\n\t\t\t * than the least common \"most common value\".\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[sslot.nnumbers - 1])\n\t\t\t\tselec = sslot.numbers[sslot.nnumbers - 1];\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "true"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "examine_variable",
          "args": [
            "root",
            "arg",
            "varRelid",
            "&vardata"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "examine_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4775-4984",
          "snippet": "void\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "get_index_stats_hook_type get_index_stats_hook = NULL;",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nSelectivity\nboolvarsel(PlannerInfo *root, Node *arg, int varRelid)\n{\n\tVariableStatData vardata;\n\tdouble\t\tselec;\n\n\texamine_variable(root, arg, varRelid, &vardata);\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\t/*\n\t\t * A boolean variable V is equivalent to the clause V = 't', so we\n\t\t * compute the selectivity as if that is what we have.\n\t\t */\n\t\tselec = var_eq_const(&vardata, BooleanEqualOperator,\n\t\t\t\t\t\t\t BoolGetDatum(true), false, true, false);\n\t}\n\telse if (is_funcclause(arg))\n\t{\n\t\t/*\n\t\t * If we have no stats and it's a function call, estimate 0.3333333.\n\t\t * This seems a pretty unprincipled choice, but Postgres has been\n\t\t * using that estimate for function calls since 1992.  The hoariness\n\t\t * of this behavior suggests that we should not be in too much hurry\n\t\t * to use another value.\n\t\t */\n\t\tselec = 0.3333333;\n\t}\n\telse\n\t{\n\t\t/* Otherwise, the default estimate is 0.5 */\n\t\tselec = 0.5;\n\t}\n\tReleaseVariableStats(vardata);\n\treturn selec;\n}"
  },
  {
    "function_name": "icnlikesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1539-1543",
    "snippet": "Datum\nicnlikesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Like_IC, true));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternsel(fcinfo, Pattern_Type_Like_IC, true)"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Like_IC",
            "true"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "patternsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1191-1461",
          "snippet": "static double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nicnlikesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Like_IC, true));\n}"
  },
  {
    "function_name": "nlikesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1530-1534",
    "snippet": "Datum\nnlikesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Like, true));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternsel(fcinfo, Pattern_Type_Like, true)"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Like",
            "true"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "patternsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1191-1461",
          "snippet": "static double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nnlikesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Like, true));\n}"
  },
  {
    "function_name": "icregexnesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1521-1525",
    "snippet": "Datum\nicregexnesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Regex_IC, true));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternsel(fcinfo, Pattern_Type_Regex_IC, true)"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Regex_IC",
            "true"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "patternsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1191-1461",
          "snippet": "static double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nicregexnesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Regex_IC, true));\n}"
  },
  {
    "function_name": "regexnesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1512-1516",
    "snippet": "Datum\nregexnesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Regex, true));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternsel(fcinfo, Pattern_Type_Regex, true)"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Regex",
            "true"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "patternsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1191-1461",
          "snippet": "static double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregexnesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Regex, true));\n}"
  },
  {
    "function_name": "iclikesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1503-1507",
    "snippet": "Datum\niclikesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Like_IC, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternsel(fcinfo, Pattern_Type_Like_IC, false)"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Like_IC",
            "false"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "patternsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1191-1461",
          "snippet": "static double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\niclikesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Like_IC, false));\n}"
  },
  {
    "function_name": "prefixsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1493-1497",
    "snippet": "Datum\nprefixsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Prefix, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternsel(fcinfo, Pattern_Type_Prefix, false)"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Prefix",
            "false"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "patternsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1191-1461",
          "snippet": "static double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nprefixsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Prefix, false));\n}"
  },
  {
    "function_name": "likesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1484-1488",
    "snippet": "Datum\nlikesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Like, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternsel(fcinfo, Pattern_Type_Like, false)"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Like",
            "false"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "patternsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1191-1461",
          "snippet": "static double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nlikesel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Like, false));\n}"
  },
  {
    "function_name": "icregexeqsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1475-1479",
    "snippet": "Datum\nicregexeqsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Regex_IC, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternsel(fcinfo, Pattern_Type_Regex_IC, false)"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Regex_IC",
            "false"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "patternsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1191-1461",
          "snippet": "static double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nicregexeqsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Regex_IC, false));\n}"
  },
  {
    "function_name": "regexeqsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1466-1470",
    "snippet": "Datum\nregexeqsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Regex, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "patternsel(fcinfo, Pattern_Type_Regex, false)"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "patternsel",
          "args": [
            "fcinfo",
            "Pattern_Type_Regex",
            "false"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "patternsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1191-1461",
          "snippet": "static double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregexeqsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Regex, false));\n}"
  },
  {
    "function_name": "patternsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1191-1461",
    "snippet": "static double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
      "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
      "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
      "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "prefix"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "prefix->constvalue"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "result"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcv_selectivity",
          "args": [
            "&vardata",
            "&opproc",
            "constval",
            "true",
            "&sumcommon"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "mcv_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "638-676",
          "snippet": "double\nmcv_selectivity(VariableStatData *vardata, FmgrInfo *opproc,\n\t\t\t\tDatum constval, bool varonleft,\n\t\t\t\tdouble *sumcommonp)\n{\n\tdouble\t\tmcv_selec,\n\t\t\t\tsumcommon;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\tmcv_selec = 0.0;\n\tsumcommon = 0.0;\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t{\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (varonleft ?\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t   constval)) :\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])))\n\t\t\t\tmcv_selec += sslot.numbers[i];\n\t\t\tsumcommon += sslot.numbers[i];\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*sumcommonp = sumcommon;\n\treturn mcv_selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nmcv_selectivity(VariableStatData *vardata, FmgrInfo *opproc,\n\t\t\t\tDatum constval, bool varonleft,\n\t\t\t\tdouble *sumcommonp)\n{\n\tdouble\t\tmcv_selec,\n\t\t\t\tsumcommon;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\tmcv_selec = 0.0;\n\tsumcommon = 0.0;\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t{\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (varonleft ?\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t   constval)) :\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])))\n\t\t\t\tmcv_selec += sslot.numbers[i];\n\t\t\tsumcommon += sslot.numbers[i];\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*sumcommonp = sumcommon;\n\treturn mcv_selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix_selectivity",
          "args": [
            "root",
            "&vardata",
            "vartype",
            "opfamily",
            "prefix"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "prefix_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6024-6107",
          "snippet": "static Selectivity\nprefix_selectivity(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid vartype, Oid opfamily, Const *prefixcon)\n{\n\tSelectivity prefixsel;\n\tOid\t\t\tcmpopr;\n\tFmgrInfo\topproc;\n\tConst\t   *greaterstrcon;\n\tSelectivity eq_sel;\n\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTGreaterEqualStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no >= operator for opfamily %u\", opfamily);\n\tfmgr_info(get_opcode(cmpopr), &opproc);\n\n\tprefixsel = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t   &opproc, true, true,\n\t\t\t\t\t\t\t\t\t\t   prefixcon->constvalue,\n\t\t\t\t\t\t\t\t\t\t   prefixcon->consttype);\n\n\tif (prefixsel < 0.0)\n\t{\n\t\t/* No histogram is present ... return a suitable default estimate */\n\t\treturn DEFAULT_MATCH_SEL;\n\t}\n\n\t/*-------\n\t * If we can create a string larger than the prefix, say\n\t *\t\"x < greaterstr\".\n\t *-------\n\t */\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no < operator for opfamily %u\", opfamily);\n\tfmgr_info(get_opcode(cmpopr), &opproc);\n\tgreaterstrcon = make_greater_string(prefixcon, &opproc,\n\t\t\t\t\t\t\t\t\t\tDEFAULT_COLLATION_OID);\n\tif (greaterstrcon)\n\t{\n\t\tSelectivity topsel;\n\n\t\ttopsel = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t\t&opproc, false, false,\n\t\t\t\t\t\t\t\t\t\t\tgreaterstrcon->constvalue,\n\t\t\t\t\t\t\t\t\t\t\tgreaterstrcon->consttype);\n\n\t\t/* ineq_histogram_selectivity worked before, it shouldn't fail now */\n\t\tAssert(topsel >= 0.0);\n\n\t\t/*\n\t\t * Merge the two selectivities in the same way as for a range query\n\t\t * (see clauselist_selectivity()).  Note that we don't need to worry\n\t\t * about double-exclusion of nulls, since ineq_histogram_selectivity\n\t\t * doesn't count those anyway.\n\t\t */\n\t\tprefixsel = topsel + prefixsel - 1.0;\n\t}\n\n\t/*\n\t * If the prefix is long then the two bounding values might be too close\n\t * together for the histogram to distinguish them usefully, resulting in a\n\t * zero estimate (plus or minus roundoff error). To avoid returning a\n\t * ridiculously small estimate, compute the estimated selectivity for\n\t * \"variable = 'foo'\", and clamp to that. (Obviously, the resultant\n\t * estimate should be at least that.)\n\t *\n\t * We apply this even if we couldn't make a greater string.  That case\n\t * suggests that the prefix is near the maximum possible, and thus\n\t * probably off the end of the histogram, and thus we probably got a very\n\t * small estimate from the >= condition; so we still need to clamp.\n\t */\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\teq_sel = var_eq_const(vardata, cmpopr, prefixcon->constvalue,\n\t\t\t\t\t\t  false, true, false);\n\n\tprefixsel = Max(prefixsel, eq_sel);\n\n\treturn prefixsel;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
            "static Selectivity prefix_selectivity(PlannerInfo *root,\n\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t   Oid vartype, Oid opfamily, Const *prefixcon);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic Selectivity prefix_selectivity(PlannerInfo *root,\n\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t   Oid vartype, Oid opfamily, Const *prefixcon);\n\nstatic Selectivity\nprefix_selectivity(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid vartype, Oid opfamily, Const *prefixcon)\n{\n\tSelectivity prefixsel;\n\tOid\t\t\tcmpopr;\n\tFmgrInfo\topproc;\n\tConst\t   *greaterstrcon;\n\tSelectivity eq_sel;\n\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTGreaterEqualStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no >= operator for opfamily %u\", opfamily);\n\tfmgr_info(get_opcode(cmpopr), &opproc);\n\n\tprefixsel = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t   &opproc, true, true,\n\t\t\t\t\t\t\t\t\t\t   prefixcon->constvalue,\n\t\t\t\t\t\t\t\t\t\t   prefixcon->consttype);\n\n\tif (prefixsel < 0.0)\n\t{\n\t\t/* No histogram is present ... return a suitable default estimate */\n\t\treturn DEFAULT_MATCH_SEL;\n\t}\n\n\t/*-------\n\t * If we can create a string larger than the prefix, say\n\t *\t\"x < greaterstr\".\n\t *-------\n\t */\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no < operator for opfamily %u\", opfamily);\n\tfmgr_info(get_opcode(cmpopr), &opproc);\n\tgreaterstrcon = make_greater_string(prefixcon, &opproc,\n\t\t\t\t\t\t\t\t\t\tDEFAULT_COLLATION_OID);\n\tif (greaterstrcon)\n\t{\n\t\tSelectivity topsel;\n\n\t\ttopsel = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t\t&opproc, false, false,\n\t\t\t\t\t\t\t\t\t\t\tgreaterstrcon->constvalue,\n\t\t\t\t\t\t\t\t\t\t\tgreaterstrcon->consttype);\n\n\t\t/* ineq_histogram_selectivity worked before, it shouldn't fail now */\n\t\tAssert(topsel >= 0.0);\n\n\t\t/*\n\t\t * Merge the two selectivities in the same way as for a range query\n\t\t * (see clauselist_selectivity()).  Note that we don't need to worry\n\t\t * about double-exclusion of nulls, since ineq_histogram_selectivity\n\t\t * doesn't count those anyway.\n\t\t */\n\t\tprefixsel = topsel + prefixsel - 1.0;\n\t}\n\n\t/*\n\t * If the prefix is long then the two bounding values might be too close\n\t * together for the histogram to distinguish them usefully, resulting in a\n\t * zero estimate (plus or minus roundoff error). To avoid returning a\n\t * ridiculously small estimate, compute the estimated selectivity for\n\t * \"variable = 'foo'\", and clamp to that. (Obviously, the resultant\n\t * estimate should be at least that.)\n\t *\n\t * We apply this even if we couldn't make a greater string.  That case\n\t * suggests that the prefix is near the maximum possible, and thus\n\t * probably off the end of the histogram, and thus we probably got a very\n\t * small estimate from the >= condition; so we still need to clamp.\n\t */\n\tcmpopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\tif (cmpopr == InvalidOid)\n\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\teq_sel = var_eq_const(vardata, cmpopr, prefixcon->constvalue,\n\t\t\t\t\t\t  false, true, false);\n\n\tprefixsel = Max(prefixsel, eq_sel);\n\n\treturn prefixsel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "histogram_selectivity",
          "args": [
            "&vardata",
            "&opproc",
            "constval",
            "true",
            "10",
            "1",
            "&hist_size"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "ineq_histogram_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "776-1079",
          "snippet": "static double\nineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype)\n{\n\tdouble\t\thist_selec;\n\tAttStatsSlot sslot;\n\n\thist_selec = -1.0;\n\n\t/*\n\t * Someday, ANALYZE might store more than one histogram per rel/att,\n\t * corresponding to more than one possible sort ordering defined for the\n\t * column type.  However, to make that work we will need to figure out\n\t * which staop to search for --- it's not necessarily the one we have at\n\t * hand!  (For example, we might have a '<=' operator rather than the '<'\n\t * operator that will appear in staop.)  For now, assume that whatever\n\t * appears in pg_statistic is sorted the same way our operator sorts, or\n\t * the reverse way if isgt is true.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * Use binary search to find the desired location, namely the\n\t\t\t * right end of the histogram bin containing the comparison value,\n\t\t\t * which is the leftmost entry for which the comparison operator\n\t\t\t * succeeds (if isgt) or fails (if !isgt).  (If the given operator\n\t\t\t * isn't actually sort-compatible with the histogram, you'll get\n\t\t\t * garbage results ... but probably not any more garbage-y than\n\t\t\t * you would have from the old linear search.)\n\t\t\t *\n\t\t\t * In this loop, we pay no attention to whether the operator iseq\n\t\t\t * or not; that detail will be mopped up below.  (We cannot tell,\n\t\t\t * anyway, whether the operator thinks the values are equal.)\n\t\t\t *\n\t\t\t * If the binary search accesses the first or last histogram\n\t\t\t * entry, we try to replace that endpoint with the true column min\n\t\t\t * or max as found by get_actual_variable_range().  This\n\t\t\t * ameliorates misestimates when the min or max is moving as a\n\t\t\t * result of changes since the last ANALYZE.  Note that this could\n\t\t\t * result in effectively including MCVs into the histogram that\n\t\t\t * weren't there before, but we don't try to correct for that.\n\t\t\t */\n\t\t\tdouble\t\thistfrac;\n\t\t\tint\t\t\tlobound = 0;\t/* first possible slot to search */\n\t\t\tint\t\t\thibound = sslot.nvalues;\t/* last+1 slot to search */\n\t\t\tbool\t\thave_end = false;\n\n\t\t\t/*\n\t\t\t * If there are only two histogram entries, we'll want up-to-date\n\t\t\t * values for both.  (If there are more than two, we need at most\n\t\t\t * one of them to be updated, so we deal with that within the\n\t\t\t * loop.)\n\t\t\t */\n\t\t\tif (sslot.nvalues == 2)\n\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[1]);\n\n\t\t\twhile (lobound < hibound)\n\t\t\t{\n\t\t\t\tint\t\t\tprobe = (lobound + hibound) / 2;\n\t\t\t\tbool\t\tltcmp;\n\n\t\t\t\t/*\n\t\t\t\t * If we find ourselves about to compare to the first or last\n\t\t\t\t * histogram entry, first try to replace it with the actual\n\t\t\t\t * current min or max (unless we already did so above).\n\t\t\t\t */\n\t\t\t\tif (probe == 0 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\t\telse if (probe == sslot.nvalues - 1 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[probe]);\n\n\t\t\t\tltcmp = DatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[probe],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\tif (isgt)\n\t\t\t\t\tltcmp = !ltcmp;\n\t\t\t\tif (ltcmp)\n\t\t\t\t\tlobound = probe + 1;\n\t\t\t\telse\n\t\t\t\t\thibound = probe;\n\t\t\t}\n\n\t\t\tif (lobound <= 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Constant is below lower histogram boundary.  More\n\t\t\t\t * precisely, we have found that no entry in the histogram\n\t\t\t\t * satisfies the inequality clause (if !isgt) or they all do\n\t\t\t\t * (if isgt).  We estimate that that's true of the entire\n\t\t\t\t * table, so set histfrac to 0.0 (which we'll flip to 1.0\n\t\t\t\t * below, if isgt).\n\t\t\t\t */\n\t\t\t\thistfrac = 0.0;\n\t\t\t}\n\t\t\telse if (lobound >= sslot.nvalues)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Inverse case: constant is above upper histogram boundary.\n\t\t\t\t */\n\t\t\t\thistfrac = 1.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We have values[i-1] <= constant <= values[i]. */\n\t\t\t\tint\t\t\ti = lobound;\n\t\t\t\tdouble\t\teq_selec = 0;\n\t\t\t\tdouble\t\tval,\n\t\t\t\t\t\t\thigh,\n\t\t\t\t\t\t\tlow;\n\t\t\t\tdouble\t\tbinfrac;\n\n\t\t\t\t/*\n\t\t\t\t * In the cases where we'll need it below, obtain an estimate\n\t\t\t\t * of the selectivity of \"x = constval\".  We use a calculation\n\t\t\t\t * similar to what var_eq_const() does for a non-MCV constant,\n\t\t\t\t * ie, estimate that all distinct non-MCV values occur equally\n\t\t\t\t * often.  But multiplication by \"1.0 - sumcommon - nullfrac\"\n\t\t\t\t * will be done by our caller, so we shouldn't do that here.\n\t\t\t\t * Therefore we can't try to clamp the estimate by reference\n\t\t\t\t * to the least common MCV; the result would be too small.\n\t\t\t\t *\n\t\t\t\t * Note: since this is effectively assuming that constval\n\t\t\t\t * isn't an MCV, it's logically dubious if constval in fact is\n\t\t\t\t * one.  But we have to apply *some* correction for equality,\n\t\t\t\t * and anyway we cannot tell if constval is an MCV, since we\n\t\t\t\t * don't have a suitable equality operator at hand.\n\t\t\t\t */\n\t\t\t\tif (i == 1 || isgt == iseq)\n\t\t\t\t{\n\t\t\t\t\tdouble\t\totherdistinct;\n\t\t\t\t\tbool\t\tisdefault;\n\t\t\t\t\tAttStatsSlot mcvslot;\n\n\t\t\t\t\t/* Get estimated number of distinct values */\n\t\t\t\t\totherdistinct = get_variable_numdistinct(vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &isdefault);\n\n\t\t\t\t\t/* Subtract off the number of known MCVs */\n\t\t\t\t\tif (get_attstatsslot(&mcvslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t\t\t\t{\n\t\t\t\t\t\totherdistinct -= mcvslot.nnumbers;\n\t\t\t\t\t\tfree_attstatsslot(&mcvslot);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If result doesn't seem sane, leave eq_selec at 0 */\n\t\t\t\t\tif (otherdistinct > 1)\n\t\t\t\t\t\teq_selec = 1.0 / otherdistinct;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Convert the constant and the two nearest bin boundary\n\t\t\t\t * values to a uniform comparison scale, and do a linear\n\t\t\t\t * interpolation within this bin.\n\t\t\t\t */\n\t\t\t\tif (convert_to_scalar(constval, consttype, &val,\n\t\t\t\t\t\t\t\t\t  sslot.values[i - 1], sslot.values[i],\n\t\t\t\t\t\t\t\t\t  vardata->vartype,\n\t\t\t\t\t\t\t\t\t  &low, &high))\n\t\t\t\t{\n\t\t\t\t\tif (high <= low)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* cope if bin boundaries appear identical */\n\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t\telse if (val <= low)\n\t\t\t\t\t\tbinfrac = 0.0;\n\t\t\t\t\telse if (val >= high)\n\t\t\t\t\t\tbinfrac = 1.0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbinfrac = (val - low) / (high - low);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Watch out for the possibility that we got a NaN or\n\t\t\t\t\t\t * Infinity from the division.  This can happen\n\t\t\t\t\t\t * despite the previous checks, if for example \"low\"\n\t\t\t\t\t\t * is -Infinity.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (isnan(binfrac) ||\n\t\t\t\t\t\t\tbinfrac < 0.0 || binfrac > 1.0)\n\t\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Ideally we'd produce an error here, on the grounds that\n\t\t\t\t\t * the given operator shouldn't have scalarXXsel\n\t\t\t\t\t * registered as its selectivity func unless we can deal\n\t\t\t\t\t * with its operand types.  But currently, all manner of\n\t\t\t\t\t * stuff is invoking scalarXXsel, so give a default\n\t\t\t\t\t * estimate until that can be fixed.\n\t\t\t\t\t */\n\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Now, compute the overall selectivity across the values\n\t\t\t\t * represented by the histogram.  We have i-1 full bins and\n\t\t\t\t * binfrac partial bin below the constant.\n\t\t\t\t */\n\t\t\t\thistfrac = (double) (i - 1) + binfrac;\n\t\t\t\thistfrac /= (double) (sslot.nvalues - 1);\n\n\t\t\t\t/*\n\t\t\t\t * At this point, histfrac is an estimate of the fraction of\n\t\t\t\t * the population represented by the histogram that satisfies\n\t\t\t\t * \"x <= constval\".  Somewhat remarkably, this statement is\n\t\t\t\t * true regardless of which operator we were doing the probes\n\t\t\t\t * with, so long as convert_to_scalar() delivers reasonable\n\t\t\t\t * results.  If the probe constant is equal to some histogram\n\t\t\t\t * entry, we would have considered the bin to the left of that\n\t\t\t\t * entry if probing with \"<\" or \">=\", or the bin to the right\n\t\t\t\t * if probing with \"<=\" or \">\"; but binfrac would have come\n\t\t\t\t * out as 1.0 in the first case and 0.0 in the second, leading\n\t\t\t\t * to the same histfrac in either case.  For probe constants\n\t\t\t\t * between histogram entries, we find the same bin and get the\n\t\t\t\t * same estimate with any operator.\n\t\t\t\t *\n\t\t\t\t * The fact that the estimate corresponds to \"x <= constval\"\n\t\t\t\t * and not \"x < constval\" is because of the way that ANALYZE\n\t\t\t\t * constructs the histogram: each entry is, effectively, the\n\t\t\t\t * rightmost value in its sample bucket.  So selectivity\n\t\t\t\t * values that are exact multiples of 1/(histogram_size-1)\n\t\t\t\t * should be understood as estimates including a histogram\n\t\t\t\t * entry plus everything to its left.\n\t\t\t\t *\n\t\t\t\t * However, that breaks down for the first histogram entry,\n\t\t\t\t * which necessarily is the leftmost value in its sample\n\t\t\t\t * bucket.  That means the first histogram bin is slightly\n\t\t\t\t * narrower than the rest, by an amount equal to eq_selec.\n\t\t\t\t * Another way to say that is that we want \"x <= leftmost\" to\n\t\t\t\t * be estimated as eq_selec not zero.  So, if we're dealing\n\t\t\t\t * with the first bin (i==1), rescale to make that true while\n\t\t\t\t * adjusting the rest of that bin linearly.\n\t\t\t\t */\n\t\t\t\tif (i == 1)\n\t\t\t\t\thistfrac += eq_selec * (1.0 - binfrac);\n\n\t\t\t\t/*\n\t\t\t\t * \"x <= constval\" is good if we want an estimate for \"<=\" or\n\t\t\t\t * \">\", but if we are estimating for \"<\" or \">=\", we now need\n\t\t\t\t * to decrease the estimate by eq_selec.\n\t\t\t\t */\n\t\t\t\tif (isgt == iseq)\n\t\t\t\t\thistfrac -= eq_selec;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now the estimate is finished for \"<\" and \"<=\" cases.  If we are\n\t\t\t * estimating for \">\" or \">=\", flip it.\n\t\t\t */\n\t\t\thist_selec = isgt ? (1.0 - histfrac) : histfrac;\n\n\t\t\t/*\n\t\t\t * The histogram boundaries are only approximate to begin with,\n\t\t\t * and may well be out of date anyway.  Therefore, don't believe\n\t\t\t * extremely small or large selectivity estimates --- unless we\n\t\t\t * got actual current endpoint values from the table, in which\n\t\t\t * case just do the usual sanity clamp.  Somewhat arbitrarily, we\n\t\t\t * set the cutoff for other cases at a hundredth of the histogram\n\t\t\t * resolution.\n\t\t\t */\n\t\t\tif (have_end)\n\t\t\t\tCLAMP_PROBABILITY(hist_selec);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble\t\tcutoff = 0.01 / (double) (sslot.nvalues - 1);\n\n\t\t\t\tif (hist_selec < cutoff)\n\t\t\t\t\thist_selec = cutoff;\n\t\t\t\telse if (hist_selec > 1.0 - cutoff)\n\t\t\t\t\thist_selec = 1.0 - cutoff;\n\t\t\t}\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\treturn hist_selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
            "static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);",
            "static bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);\nstatic bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);\n\nstatic double\nineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype)\n{\n\tdouble\t\thist_selec;\n\tAttStatsSlot sslot;\n\n\thist_selec = -1.0;\n\n\t/*\n\t * Someday, ANALYZE might store more than one histogram per rel/att,\n\t * corresponding to more than one possible sort ordering defined for the\n\t * column type.  However, to make that work we will need to figure out\n\t * which staop to search for --- it's not necessarily the one we have at\n\t * hand!  (For example, we might have a '<=' operator rather than the '<'\n\t * operator that will appear in staop.)  For now, assume that whatever\n\t * appears in pg_statistic is sorted the same way our operator sorts, or\n\t * the reverse way if isgt is true.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * Use binary search to find the desired location, namely the\n\t\t\t * right end of the histogram bin containing the comparison value,\n\t\t\t * which is the leftmost entry for which the comparison operator\n\t\t\t * succeeds (if isgt) or fails (if !isgt).  (If the given operator\n\t\t\t * isn't actually sort-compatible with the histogram, you'll get\n\t\t\t * garbage results ... but probably not any more garbage-y than\n\t\t\t * you would have from the old linear search.)\n\t\t\t *\n\t\t\t * In this loop, we pay no attention to whether the operator iseq\n\t\t\t * or not; that detail will be mopped up below.  (We cannot tell,\n\t\t\t * anyway, whether the operator thinks the values are equal.)\n\t\t\t *\n\t\t\t * If the binary search accesses the first or last histogram\n\t\t\t * entry, we try to replace that endpoint with the true column min\n\t\t\t * or max as found by get_actual_variable_range().  This\n\t\t\t * ameliorates misestimates when the min or max is moving as a\n\t\t\t * result of changes since the last ANALYZE.  Note that this could\n\t\t\t * result in effectively including MCVs into the histogram that\n\t\t\t * weren't there before, but we don't try to correct for that.\n\t\t\t */\n\t\t\tdouble\t\thistfrac;\n\t\t\tint\t\t\tlobound = 0;\t/* first possible slot to search */\n\t\t\tint\t\t\thibound = sslot.nvalues;\t/* last+1 slot to search */\n\t\t\tbool\t\thave_end = false;\n\n\t\t\t/*\n\t\t\t * If there are only two histogram entries, we'll want up-to-date\n\t\t\t * values for both.  (If there are more than two, we need at most\n\t\t\t * one of them to be updated, so we deal with that within the\n\t\t\t * loop.)\n\t\t\t */\n\t\t\tif (sslot.nvalues == 2)\n\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[1]);\n\n\t\t\twhile (lobound < hibound)\n\t\t\t{\n\t\t\t\tint\t\t\tprobe = (lobound + hibound) / 2;\n\t\t\t\tbool\t\tltcmp;\n\n\t\t\t\t/*\n\t\t\t\t * If we find ourselves about to compare to the first or last\n\t\t\t\t * histogram entry, first try to replace it with the actual\n\t\t\t\t * current min or max (unless we already did so above).\n\t\t\t\t */\n\t\t\t\tif (probe == 0 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\t\telse if (probe == sslot.nvalues - 1 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[probe]);\n\n\t\t\t\tltcmp = DatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[probe],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\tif (isgt)\n\t\t\t\t\tltcmp = !ltcmp;\n\t\t\t\tif (ltcmp)\n\t\t\t\t\tlobound = probe + 1;\n\t\t\t\telse\n\t\t\t\t\thibound = probe;\n\t\t\t}\n\n\t\t\tif (lobound <= 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Constant is below lower histogram boundary.  More\n\t\t\t\t * precisely, we have found that no entry in the histogram\n\t\t\t\t * satisfies the inequality clause (if !isgt) or they all do\n\t\t\t\t * (if isgt).  We estimate that that's true of the entire\n\t\t\t\t * table, so set histfrac to 0.0 (which we'll flip to 1.0\n\t\t\t\t * below, if isgt).\n\t\t\t\t */\n\t\t\t\thistfrac = 0.0;\n\t\t\t}\n\t\t\telse if (lobound >= sslot.nvalues)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Inverse case: constant is above upper histogram boundary.\n\t\t\t\t */\n\t\t\t\thistfrac = 1.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We have values[i-1] <= constant <= values[i]. */\n\t\t\t\tint\t\t\ti = lobound;\n\t\t\t\tdouble\t\teq_selec = 0;\n\t\t\t\tdouble\t\tval,\n\t\t\t\t\t\t\thigh,\n\t\t\t\t\t\t\tlow;\n\t\t\t\tdouble\t\tbinfrac;\n\n\t\t\t\t/*\n\t\t\t\t * In the cases where we'll need it below, obtain an estimate\n\t\t\t\t * of the selectivity of \"x = constval\".  We use a calculation\n\t\t\t\t * similar to what var_eq_const() does for a non-MCV constant,\n\t\t\t\t * ie, estimate that all distinct non-MCV values occur equally\n\t\t\t\t * often.  But multiplication by \"1.0 - sumcommon - nullfrac\"\n\t\t\t\t * will be done by our caller, so we shouldn't do that here.\n\t\t\t\t * Therefore we can't try to clamp the estimate by reference\n\t\t\t\t * to the least common MCV; the result would be too small.\n\t\t\t\t *\n\t\t\t\t * Note: since this is effectively assuming that constval\n\t\t\t\t * isn't an MCV, it's logically dubious if constval in fact is\n\t\t\t\t * one.  But we have to apply *some* correction for equality,\n\t\t\t\t * and anyway we cannot tell if constval is an MCV, since we\n\t\t\t\t * don't have a suitable equality operator at hand.\n\t\t\t\t */\n\t\t\t\tif (i == 1 || isgt == iseq)\n\t\t\t\t{\n\t\t\t\t\tdouble\t\totherdistinct;\n\t\t\t\t\tbool\t\tisdefault;\n\t\t\t\t\tAttStatsSlot mcvslot;\n\n\t\t\t\t\t/* Get estimated number of distinct values */\n\t\t\t\t\totherdistinct = get_variable_numdistinct(vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &isdefault);\n\n\t\t\t\t\t/* Subtract off the number of known MCVs */\n\t\t\t\t\tif (get_attstatsslot(&mcvslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t\t\t\t{\n\t\t\t\t\t\totherdistinct -= mcvslot.nnumbers;\n\t\t\t\t\t\tfree_attstatsslot(&mcvslot);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If result doesn't seem sane, leave eq_selec at 0 */\n\t\t\t\t\tif (otherdistinct > 1)\n\t\t\t\t\t\teq_selec = 1.0 / otherdistinct;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Convert the constant and the two nearest bin boundary\n\t\t\t\t * values to a uniform comparison scale, and do a linear\n\t\t\t\t * interpolation within this bin.\n\t\t\t\t */\n\t\t\t\tif (convert_to_scalar(constval, consttype, &val,\n\t\t\t\t\t\t\t\t\t  sslot.values[i - 1], sslot.values[i],\n\t\t\t\t\t\t\t\t\t  vardata->vartype,\n\t\t\t\t\t\t\t\t\t  &low, &high))\n\t\t\t\t{\n\t\t\t\t\tif (high <= low)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* cope if bin boundaries appear identical */\n\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t\telse if (val <= low)\n\t\t\t\t\t\tbinfrac = 0.0;\n\t\t\t\t\telse if (val >= high)\n\t\t\t\t\t\tbinfrac = 1.0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbinfrac = (val - low) / (high - low);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Watch out for the possibility that we got a NaN or\n\t\t\t\t\t\t * Infinity from the division.  This can happen\n\t\t\t\t\t\t * despite the previous checks, if for example \"low\"\n\t\t\t\t\t\t * is -Infinity.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (isnan(binfrac) ||\n\t\t\t\t\t\t\tbinfrac < 0.0 || binfrac > 1.0)\n\t\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Ideally we'd produce an error here, on the grounds that\n\t\t\t\t\t * the given operator shouldn't have scalarXXsel\n\t\t\t\t\t * registered as its selectivity func unless we can deal\n\t\t\t\t\t * with its operand types.  But currently, all manner of\n\t\t\t\t\t * stuff is invoking scalarXXsel, so give a default\n\t\t\t\t\t * estimate until that can be fixed.\n\t\t\t\t\t */\n\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Now, compute the overall selectivity across the values\n\t\t\t\t * represented by the histogram.  We have i-1 full bins and\n\t\t\t\t * binfrac partial bin below the constant.\n\t\t\t\t */\n\t\t\t\thistfrac = (double) (i - 1) + binfrac;\n\t\t\t\thistfrac /= (double) (sslot.nvalues - 1);\n\n\t\t\t\t/*\n\t\t\t\t * At this point, histfrac is an estimate of the fraction of\n\t\t\t\t * the population represented by the histogram that satisfies\n\t\t\t\t * \"x <= constval\".  Somewhat remarkably, this statement is\n\t\t\t\t * true regardless of which operator we were doing the probes\n\t\t\t\t * with, so long as convert_to_scalar() delivers reasonable\n\t\t\t\t * results.  If the probe constant is equal to some histogram\n\t\t\t\t * entry, we would have considered the bin to the left of that\n\t\t\t\t * entry if probing with \"<\" or \">=\", or the bin to the right\n\t\t\t\t * if probing with \"<=\" or \">\"; but binfrac would have come\n\t\t\t\t * out as 1.0 in the first case and 0.0 in the second, leading\n\t\t\t\t * to the same histfrac in either case.  For probe constants\n\t\t\t\t * between histogram entries, we find the same bin and get the\n\t\t\t\t * same estimate with any operator.\n\t\t\t\t *\n\t\t\t\t * The fact that the estimate corresponds to \"x <= constval\"\n\t\t\t\t * and not \"x < constval\" is because of the way that ANALYZE\n\t\t\t\t * constructs the histogram: each entry is, effectively, the\n\t\t\t\t * rightmost value in its sample bucket.  So selectivity\n\t\t\t\t * values that are exact multiples of 1/(histogram_size-1)\n\t\t\t\t * should be understood as estimates including a histogram\n\t\t\t\t * entry plus everything to its left.\n\t\t\t\t *\n\t\t\t\t * However, that breaks down for the first histogram entry,\n\t\t\t\t * which necessarily is the leftmost value in its sample\n\t\t\t\t * bucket.  That means the first histogram bin is slightly\n\t\t\t\t * narrower than the rest, by an amount equal to eq_selec.\n\t\t\t\t * Another way to say that is that we want \"x <= leftmost\" to\n\t\t\t\t * be estimated as eq_selec not zero.  So, if we're dealing\n\t\t\t\t * with the first bin (i==1), rescale to make that true while\n\t\t\t\t * adjusting the rest of that bin linearly.\n\t\t\t\t */\n\t\t\t\tif (i == 1)\n\t\t\t\t\thistfrac += eq_selec * (1.0 - binfrac);\n\n\t\t\t\t/*\n\t\t\t\t * \"x <= constval\" is good if we want an estimate for \"<=\" or\n\t\t\t\t * \">\", but if we are estimating for \"<\" or \">=\", we now need\n\t\t\t\t * to decrease the estimate by eq_selec.\n\t\t\t\t */\n\t\t\t\tif (isgt == iseq)\n\t\t\t\t\thistfrac -= eq_selec;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now the estimate is finished for \"<\" and \"<=\" cases.  If we are\n\t\t\t * estimating for \">\" or \">=\", flip it.\n\t\t\t */\n\t\t\thist_selec = isgt ? (1.0 - histfrac) : histfrac;\n\n\t\t\t/*\n\t\t\t * The histogram boundaries are only approximate to begin with,\n\t\t\t * and may well be out of date anyway.  Therefore, don't believe\n\t\t\t * extremely small or large selectivity estimates --- unless we\n\t\t\t * got actual current endpoint values from the table, in which\n\t\t\t * case just do the usual sanity clamp.  Somewhat arbitrarily, we\n\t\t\t * set the cutoff for other cases at a hundredth of the histogram\n\t\t\t * resolution.\n\t\t\t */\n\t\t\tif (have_end)\n\t\t\t\tCLAMP_PROBABILITY(hist_selec);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble\t\tcutoff = 0.01 / (double) (sslot.nvalues - 1);\n\n\t\t\t\tif (hist_selec < cutoff)\n\t\t\t\t\thist_selec = cutoff;\n\t\t\t\telse if (hist_selec > 1.0 - cutoff)\n\t\t\t\t\thist_selec = 1.0 - cutoff;\n\t\t\t}\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\treturn hist_selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "get_opcode(operator)",
            "&opproc"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "operator"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "var_eq_const",
          "args": [
            "&vardata",
            "eqopr",
            "prefix->constvalue",
            "false",
            "true",
            "false"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "var_eq_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "297-444",
          "snippet": "static double\nvar_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\tOid\t\t\topfuncoid;\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (constisnull)\n\t\treturn 0.0;\n\n\t/*\n\t * Grab the nullfrac for use below.  Note we allow use of nullfrac\n\t * regardless of security check.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(operator))))\n\t{\n\t\tAttStatsSlot sslot;\n\t\tbool\t\tmatch = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * Is the constant \"=\" to any of the column's most common values?\n\t\t * (Although the given operator may not really be \"=\", we will assume\n\t\t * that seeing whether it returns TRUE is an appropriate test.  If you\n\t\t * don't like this, maybe you shouldn't be using eqsel for your\n\t\t * operator...)\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tFmgrInfo\teqproc;\n\n\t\t\tfmgr_info(opfuncoid, &eqproc);\n\n\t\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t\t{\n\t\t\t\t/* be careful to apply operator right way 'round */\n\t\t\t\tif (varonleft)\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\telse\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i]));\n\t\t\t\tif (match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no most-common-value info available */\n\t\t\ti = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/*\n\t\t\t * Constant is \"=\" to this common value.  We know selectivity\n\t\t\t * exactly (or as exactly as ANALYZE could calculate it, anyway).\n\t\t\t */\n\t\t\tselec = sslot.numbers[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Comparison is against a constant that is neither NULL nor any\n\t\t\t * of the common values.  Its selectivity cannot be more than\n\t\t\t * this:\n\t\t\t */\n\t\t\tdouble\t\tsumcommon = 0.0;\n\t\t\tdouble\t\totherdistinct;\n\n\t\t\tfor (i = 0; i < sslot.nnumbers; i++)\n\t\t\t\tsumcommon += sslot.numbers[i];\n\t\t\tselec = 1.0 - sumcommon - nullfrac;\n\t\t\tCLAMP_PROBABILITY(selec);\n\n\t\t\t/*\n\t\t\t * and in fact it's probably a good deal less. We approximate that\n\t\t\t * all the not-common values share this remaining fraction\n\t\t\t * equally, so we divide by the number of other distinct values.\n\t\t\t */\n\t\t\totherdistinct = get_variable_numdistinct(vardata, &isdefault) -\n\t\t\t\tsslot.nnumbers;\n\t\t\tif (otherdistinct > 1)\n\t\t\t\tselec /= otherdistinct;\n\n\t\t\t/*\n\t\t\t * Another cross-check: selectivity shouldn't be estimated as more\n\t\t\t * than the least common \"most common value\".\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[sslot.nnumbers - 1])\n\t\t\t\tselec = sslot.numbers[sslot.nnumbers - 1];\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\nvar_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\tOid\t\t\topfuncoid;\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (constisnull)\n\t\treturn 0.0;\n\n\t/*\n\t * Grab the nullfrac for use below.  Note we allow use of nullfrac\n\t * regardless of security check.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(operator))))\n\t{\n\t\tAttStatsSlot sslot;\n\t\tbool\t\tmatch = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * Is the constant \"=\" to any of the column's most common values?\n\t\t * (Although the given operator may not really be \"=\", we will assume\n\t\t * that seeing whether it returns TRUE is an appropriate test.  If you\n\t\t * don't like this, maybe you shouldn't be using eqsel for your\n\t\t * operator...)\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tFmgrInfo\teqproc;\n\n\t\t\tfmgr_info(opfuncoid, &eqproc);\n\n\t\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t\t{\n\t\t\t\t/* be careful to apply operator right way 'round */\n\t\t\t\tif (varonleft)\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\telse\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i]));\n\t\t\t\tif (match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no most-common-value info available */\n\t\t\ti = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/*\n\t\t\t * Constant is \"=\" to this common value.  We know selectivity\n\t\t\t * exactly (or as exactly as ANALYZE could calculate it, anyway).\n\t\t\t */\n\t\t\tselec = sslot.numbers[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Comparison is against a constant that is neither NULL nor any\n\t\t\t * of the common values.  Its selectivity cannot be more than\n\t\t\t * this:\n\t\t\t */\n\t\t\tdouble\t\tsumcommon = 0.0;\n\t\t\tdouble\t\totherdistinct;\n\n\t\t\tfor (i = 0; i < sslot.nnumbers; i++)\n\t\t\t\tsumcommon += sslot.numbers[i];\n\t\t\tselec = 1.0 - sumcommon - nullfrac;\n\t\t\tCLAMP_PROBABILITY(selec);\n\n\t\t\t/*\n\t\t\t * and in fact it's probably a good deal less. We approximate that\n\t\t\t * all the not-common values share this remaining fraction\n\t\t\t * equally, so we divide by the number of other distinct values.\n\t\t\t */\n\t\t\totherdistinct = get_variable_numdistinct(vardata, &isdefault) -\n\t\t\t\tsslot.nnumbers;\n\t\t\tif (otherdistinct > 1)\n\t\t\t\tselec /= otherdistinct;\n\n\t\t\t/*\n\t\t\t * Another cross-check: selectivity shouldn't be estimated as more\n\t\t\t * than the least common \"most common value\".\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[sslot.nnumbers - 1])\n\t\t\t\tselec = sslot.numbers[sslot.nnumbers - 1];\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"no = operator for opfamily %u\"",
            "opfamily"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opfamily_member",
          "args": [
            "opfamily",
            "vartype",
            "vartype",
            "BTEqualStrategyNumber"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "get_opfamily_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "162-181",
          "snippet": "Oid\nget_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,\n\t\t\t\t\tint16 strategy)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache4(AMOPSTRATEGY,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(strategy));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopopr;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_opfamily_member(Oid opfamily, Oid lefttype, Oid righttype,\n\t\t\t\t\tint16 strategy)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tOid\t\t\tresult;\n\n\ttp = SearchSysCache4(AMOPSTRATEGY,\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily),\n\t\t\t\t\t\t ObjectIdGetDatum(lefttype),\n\t\t\t\t\t\t ObjectIdGetDatum(righttype),\n\t\t\t\t\t\t Int16GetDatum(strategy));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn InvalidOid;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopopr;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string_to_const",
          "args": [
            "prefixstr",
            "vartype"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "string_to_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "6502-6540",
          "snippet": "static Const *\nstring_to_const(const char *str, Oid datatype)\n{\n\tDatum\t\tconval = string_to_datum(str, datatype);\n\tOid\t\t\tcollation;\n\tint\t\t\tconstlen;\n\n\t/*\n\t * We only need to support a few datatypes here, so hard-wire properties\n\t * instead of incurring the expense of catalog lookups.\n\t */\n\tswitch (datatype)\n\t{\n\t\tcase TEXTOID:\n\t\tcase VARCHAROID:\n\t\tcase BPCHAROID:\n\t\t\tcollation = DEFAULT_COLLATION_OID;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tcase NAMEOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = NAMEDATALEN;\n\t\t\tbreak;\n\n\t\tcase BYTEAOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected datatype in string_to_const: %u\",\n\t\t\t\t datatype);\n\t\t\treturn NULL;\n\t}\n\n\treturn makeConst(datatype, -1, collation, constlen,\n\t\t\t\t\t conval, false, false);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum string_to_datum(const char *str, Oid datatype);",
            "static Const *string_to_const(const char *str, Oid datatype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum string_to_datum(const char *str, Oid datatype);\nstatic Const *string_to_const(const char *str, Oid datatype);\n\nstatic Const *\nstring_to_const(const char *str, Oid datatype)\n{\n\tDatum\t\tconval = string_to_datum(str, datatype);\n\tOid\t\t\tcollation;\n\tint\t\t\tconstlen;\n\n\t/*\n\t * We only need to support a few datatypes here, so hard-wire properties\n\t * instead of incurring the expense of catalog lookups.\n\t */\n\tswitch (datatype)\n\t{\n\t\tcase TEXTOID:\n\t\tcase VARCHAROID:\n\t\tcase BPCHAROID:\n\t\t\tcollation = DEFAULT_COLLATION_OID;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tcase NAMEOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = NAMEDATALEN;\n\t\t\tbreak;\n\n\t\tcase BYTEAOID:\n\t\t\tcollation = InvalidOid;\n\t\t\tconstlen = -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected datatype in string_to_const: %u\",\n\t\t\t\t datatype);\n\t\t\treturn NULL;\n\t}\n\n\treturn makeConst(datatype, -1, collation, constlen,\n\t\t\t\t\t conval, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue)"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "byteaout",
            "prefix->constvalue"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "prefix->constvalue"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pattern_fixed_prefix",
          "args": [
            "patt",
            "ptype",
            "collation",
            "&prefix",
            "&rest_selec"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "pattern_fixed_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5959-6003",
          "snippet": "Pattern_Prefix_Status\npattern_fixed_prefix(Const *patt, Pattern_Type ptype, Oid collation,\n\t\t\t\t\t Const **prefix, Selectivity *rest_selec)\n{\n\tPattern_Prefix_Status result;\n\n\tswitch (ptype)\n\t{\n\t\tcase Pattern_Type_Like:\n\t\t\tresult = like_fixed_prefix(patt, false, collation,\n\t\t\t\t\t\t\t\t\t   prefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Like_IC:\n\t\t\tresult = like_fixed_prefix(patt, true, collation,\n\t\t\t\t\t\t\t\t\t   prefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Regex:\n\t\t\tresult = regex_fixed_prefix(patt, false, collation,\n\t\t\t\t\t\t\t\t\t\tprefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Regex_IC:\n\t\t\tresult = regex_fixed_prefix(patt, true, collation,\n\t\t\t\t\t\t\t\t\t\tprefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Prefix:\n\t\t\t/* Prefix type work is trivial.  */\n\t\t\tresult = Pattern_Prefix_Partial;\n\t\t\t*rest_selec = 1.0;\t/* all */\n\t\t\t*prefix = makeConst(patt->consttype,\n\t\t\t\t\t\t\t\tpatt->consttypmod,\n\t\t\t\t\t\t\t\tpatt->constcollid,\n\t\t\t\t\t\t\t\tpatt->constlen,\n\t\t\t\t\t\t\t\tdatumCopy(patt->constvalue,\n\t\t\t\t\t\t\t\t\t\t  patt->constbyval,\n\t\t\t\t\t\t\t\t\t\t  patt->constlen),\n\t\t\t\t\t\t\t\tpatt->constisnull,\n\t\t\t\t\t\t\t\tpatt->constbyval);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized ptype: %d\", (int) ptype);\n\t\t\tresult = Pattern_Prefix_None;\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\n\nPattern_Prefix_Status\npattern_fixed_prefix(Const *patt, Pattern_Type ptype, Oid collation,\n\t\t\t\t\t Const **prefix, Selectivity *rest_selec)\n{\n\tPattern_Prefix_Status result;\n\n\tswitch (ptype)\n\t{\n\t\tcase Pattern_Type_Like:\n\t\t\tresult = like_fixed_prefix(patt, false, collation,\n\t\t\t\t\t\t\t\t\t   prefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Like_IC:\n\t\t\tresult = like_fixed_prefix(patt, true, collation,\n\t\t\t\t\t\t\t\t\t   prefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Regex:\n\t\t\tresult = regex_fixed_prefix(patt, false, collation,\n\t\t\t\t\t\t\t\t\t\tprefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Regex_IC:\n\t\t\tresult = regex_fixed_prefix(patt, true, collation,\n\t\t\t\t\t\t\t\t\t\tprefix, rest_selec);\n\t\t\tbreak;\n\t\tcase Pattern_Type_Prefix:\n\t\t\t/* Prefix type work is trivial.  */\n\t\t\tresult = Pattern_Prefix_Partial;\n\t\t\t*rest_selec = 1.0;\t/* all */\n\t\t\t*prefix = makeConst(patt->consttype,\n\t\t\t\t\t\t\t\tpatt->consttypmod,\n\t\t\t\t\t\t\t\tpatt->constcollid,\n\t\t\t\t\t\t\t\tpatt->constlen,\n\t\t\t\t\t\t\t\tdatumCopy(patt->constvalue,\n\t\t\t\t\t\t\t\t\t\t  patt->constbyval,\n\t\t\t\t\t\t\t\t\t\t  patt->constlen),\n\t\t\t\t\t\t\t\tpatt->constisnull,\n\t\t\t\t\t\t\t\tpatt->constbyval);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized ptype: %d\", (int) ptype);\n\t\t\tresult = Pattern_Prefix_None;\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata.statsTuple"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "other",
            "Const"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_restriction_variable",
          "args": [
            "root",
            "args",
            "varRelid",
            "&vardata",
            "&other",
            "&varonleft"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "get_restriction_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4653-4701",
          "snippet": "bool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "operator"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_negator",
          "args": [
            "operator"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "get_negator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1321-1338",
          "snippet": "Oid\nget_negator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprnegate;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_negator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprnegate;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\npatternsel(PG_FUNCTION_ARGS, Pattern_Type ptype, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tOid\t\t\tvartype;\n\tOid\t\t\topfamily;\n\tPattern_Prefix_Status pstatus;\n\tConst\t   *patt;\n\tConst\t   *prefix = NULL;\n\tSelectivity rest_selec = 0;\n\tdouble\t\tnullfrac = 0.0;\n\tdouble\t\tresult;\n\n\t/*\n\t * If this is for a NOT LIKE or similar operator, get the corresponding\n\t * positive-match operator and work with that.  Set result to the correct\n\t * default estimate, too.\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t\telog(ERROR, \"patternsel called for operator without a negator\");\n\t\tresult = 1.0 - DEFAULT_MATCH_SEL;\n\t}\n\telse\n\t{\n\t\tresult = DEFAULT_MATCH_SEL;\n\t}\n\n\t/*\n\t * If expression is not variable op constant, then punt and return a\n\t * default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn result;\n\tif (!varonleft || !IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn 0.0;\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * The right-hand const is type text or bytea for all supported operators.\n\t * We do not expect to see binary-compatible types here, since\n\t * const-folding should have relabeled the const to exactly match the\n\t * operator's declared type.\n\t */\n\tif (consttype != TEXTOID && consttype != BYTEAOID)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\treturn result;\n\t}\n\n\t/*\n\t * Similarly, the exposed type of the left-hand side should be one of\n\t * those we know.  (Do not look at vardata.atttype, which might be\n\t * something binary-compatible but different.)\tWe can use it to choose\n\t * the index opfamily from which we must draw the comparison operators.\n\t *\n\t * NOTE: It would be more correct to use the PATTERN opfamilies than the\n\t * simple ones, but at the moment ANALYZE will not generate statistics for\n\t * the PATTERN operators.  But our results are so approximate anyway that\n\t * it probably hardly matters.\n\t */\n\tvartype = vardata.vartype;\n\n\tswitch (vartype)\n\t{\n\t\tcase TEXTOID:\n\t\t\topfamily = TEXT_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BPCHAROID:\n\t\t\topfamily = BPCHAR_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase NAMEOID:\n\t\t\topfamily = NAME_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tcase BYTEAOID:\n\t\t\topfamily = BYTEA_BTREE_FAM_OID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tReleaseVariableStats(vardata);\n\t\t\treturn result;\n\t}\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata.statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata.statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * Pull out any fixed prefix implied by the pattern, and estimate the\n\t * fractional selectivity of the remainder of the pattern.  Unlike many of\n\t * the other functions in this file, we use the pattern operator's actual\n\t * collation for this step.  This is not because we expect the collation\n\t * to make a big difference in the selectivity estimate (it seldom would),\n\t * but because we want to be sure we cache compiled regexps under the\n\t * right cache key, so that they can be re-used at runtime.\n\t */\n\tpatt = (Const *) other;\n\tpstatus = pattern_fixed_prefix(patt, ptype, collation,\n\t\t\t\t\t\t\t\t   &prefix, &rest_selec);\n\n\t/*\n\t * If necessary, coerce the prefix constant to the right type.\n\t */\n\tif (prefix && prefix->consttype != vartype)\n\t{\n\t\tchar\t   *prefixstr;\n\n\t\tswitch (prefix->consttype)\n\t\t{\n\t\t\tcase TEXTOID:\n\t\t\t\tprefixstr = TextDatumGetCString(prefix->constvalue);\n\t\t\t\tbreak;\n\t\t\tcase BYTEAOID:\n\t\t\t\tprefixstr = DatumGetCString(DirectFunctionCall1(byteaout,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprefix->constvalue));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized consttype: %u\",\n\t\t\t\t\t prefix->consttype);\n\t\t\t\tReleaseVariableStats(vardata);\n\t\t\t\treturn result;\n\t\t}\n\t\tprefix = string_to_const(prefixstr, vartype);\n\t\tpfree(prefixstr);\n\t}\n\n\tif (pstatus == Pattern_Prefix_Exact)\n\t{\n\t\t/*\n\t\t * Pattern specifies an exact match, so pretend operator is '='\n\t\t */\n\t\tOid\t\t\teqopr = get_opfamily_member(opfamily, vartype, vartype,\n\t\t\t\t\t\t\t\t\t\t\t\tBTEqualStrategyNumber);\n\n\t\tif (eqopr == InvalidOid)\n\t\t\telog(ERROR, \"no = operator for opfamily %u\", opfamily);\n\t\tresult = var_eq_const(&vardata, eqopr, prefix->constvalue,\n\t\t\t\t\t\t\t  false, true, false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not exact-match pattern.  If we have a sufficiently large\n\t\t * histogram, estimate selectivity for the histogram part of the\n\t\t * population by counting matches in the histogram.  If not, estimate\n\t\t * selectivity of the fixed prefix and remainder of pattern\n\t\t * separately, then combine the two to get an estimate of the\n\t\t * selectivity for the part of the column population represented by\n\t\t * the histogram.  (For small histograms, we combine these\n\t\t * approaches.)\n\t\t *\n\t\t * We then add up data for any most-common-values values; these are\n\t\t * not in the histogram population, and we can get exact answers for\n\t\t * them by applying the pattern operator, so there's no reason to\n\t\t * approximate.  (If the MCVs cover a significant part of the total\n\t\t * population, this gives us a big leg up in accuracy.)\n\t\t */\n\t\tSelectivity selec;\n\t\tint\t\t\thist_size;\n\t\tFmgrInfo\topproc;\n\t\tdouble\t\tmcv_selec,\n\t\t\t\t\tsumcommon;\n\n\t\t/* Try to use the histogram entries to get selectivity */\n\t\tfmgr_info(get_opcode(operator), &opproc);\n\n\t\tselec = histogram_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t  10, 1, &hist_size);\n\n\t\t/* If not at least 100 entries, use the heuristic method */\n\t\tif (hist_size < 100)\n\t\t{\n\t\t\tSelectivity heursel;\n\t\t\tSelectivity prefixsel;\n\n\t\t\tif (pstatus == Pattern_Prefix_Partial)\n\t\t\t\tprefixsel = prefix_selectivity(root, &vardata, vartype,\n\t\t\t\t\t\t\t\t\t\t\t   opfamily, prefix);\n\t\t\telse\n\t\t\t\tprefixsel = 1.0;\n\t\t\theursel = prefixsel * rest_selec;\n\n\t\t\tif (selec < 0)\t\t/* fewer than 10 histogram entries? */\n\t\t\t\tselec = heursel;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For histogram sizes from 10 to 100, we combine the\n\t\t\t\t * histogram and heuristic selectivities, putting increasingly\n\t\t\t\t * more trust in the histogram for larger sizes.\n\t\t\t\t */\n\t\t\t\tdouble\t\thist_weight = hist_size / 100.0;\n\n\t\t\t\tselec = selec * hist_weight + heursel * (1.0 - hist_weight);\n\t\t\t}\n\t\t}\n\n\t\t/* In any case, don't believe extremely small or large estimates. */\n\t\tif (selec < 0.0001)\n\t\t\tselec = 0.0001;\n\t\telse if (selec > 0.9999)\n\t\t\tselec = 0.9999;\n\n\t\t/*\n\t\t * If we have most-common-values info, add up the fractions of the MCV\n\t\t * entries that satisfy MCV OP PATTERN.  These fractions contribute\n\t\t * directly to the result selectivity.  Also add up the total fraction\n\t\t * represented by MCV entries.\n\t\t */\n\t\tmcv_selec = mcv_selectivity(&vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t\t&sumcommon);\n\n\t\t/*\n\t\t * Now merge the results from the MCV and histogram calculations,\n\t\t * realizing that the histogram covers only the non-null values that\n\t\t * are not listed in MCV.\n\t\t */\n\t\tselec *= 1.0 - nullfrac - sumcommon;\n\t\tselec += mcv_selec;\n\t\tresult = selec;\n\t}\n\n\t/* now adjust if we wanted not-match rather than match */\n\tif (negate)\n\t\tresult = 1.0 - result - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(result);\n\n\tif (prefix)\n\t{\n\t\tpfree(DatumGetPointer(prefix->constvalue));\n\t\tpfree(prefix);\n\t}\n\n\tReleaseVariableStats(vardata);\n\n\treturn result;\n}"
  },
  {
    "function_name": "scalargesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1182-1186",
    "snippet": "Datum\nscalargesel(PG_FUNCTION_ARGS)\n{\n\treturn scalarineqsel_wrapper(fcinfo, true, true);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scalarineqsel_wrapper",
          "args": [
            "fcinfo",
            "true",
            "true"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "scalarineqsel_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1085-1150",
          "snippet": "static Datum\nscalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tdouble\t\tselec;\n\n\t/*\n\t * If expression is not variable op something or something op variable,\n\t * then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * Force the var to be on the left to simplify logic in scalarineqsel.\n\t */\n\tif (!varonleft)\n\t{\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t\t}\n\t\tisgt = !isgt;\n\t}\n\n\t/* The rest of the work is done by scalarineqsel(). */\n\tselec = scalarineqsel(root, operator, isgt, iseq,\n\t\t\t\t\t\t  &vardata, constval, consttype);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic Datum\nscalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tdouble\t\tselec;\n\n\t/*\n\t * If expression is not variable op something or something op variable,\n\t * then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * Force the var to be on the left to simplify logic in scalarineqsel.\n\t */\n\tif (!varonleft)\n\t{\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t\t}\n\t\tisgt = !isgt;\n\t}\n\n\t/* The rest of the work is done by scalarineqsel(). */\n\tselec = scalarineqsel(root, operator, isgt, iseq,\n\t\t\t\t\t\t  &vardata, constval, consttype);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nscalargesel(PG_FUNCTION_ARGS)\n{\n\treturn scalarineqsel_wrapper(fcinfo, true, true);\n}"
  },
  {
    "function_name": "scalargtsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1173-1177",
    "snippet": "Datum\nscalargtsel(PG_FUNCTION_ARGS)\n{\n\treturn scalarineqsel_wrapper(fcinfo, true, false);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scalarineqsel_wrapper",
          "args": [
            "fcinfo",
            "true",
            "false"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "scalarineqsel_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1085-1150",
          "snippet": "static Datum\nscalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tdouble\t\tselec;\n\n\t/*\n\t * If expression is not variable op something or something op variable,\n\t * then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * Force the var to be on the left to simplify logic in scalarineqsel.\n\t */\n\tif (!varonleft)\n\t{\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t\t}\n\t\tisgt = !isgt;\n\t}\n\n\t/* The rest of the work is done by scalarineqsel(). */\n\tselec = scalarineqsel(root, operator, isgt, iseq,\n\t\t\t\t\t\t  &vardata, constval, consttype);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic Datum\nscalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tdouble\t\tselec;\n\n\t/*\n\t * If expression is not variable op something or something op variable,\n\t * then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * Force the var to be on the left to simplify logic in scalarineqsel.\n\t */\n\tif (!varonleft)\n\t{\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t\t}\n\t\tisgt = !isgt;\n\t}\n\n\t/* The rest of the work is done by scalarineqsel(). */\n\tselec = scalarineqsel(root, operator, isgt, iseq,\n\t\t\t\t\t\t  &vardata, constval, consttype);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nscalargtsel(PG_FUNCTION_ARGS)\n{\n\treturn scalarineqsel_wrapper(fcinfo, true, false);\n}"
  },
  {
    "function_name": "scalarlesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1164-1168",
    "snippet": "Datum\nscalarlesel(PG_FUNCTION_ARGS)\n{\n\treturn scalarineqsel_wrapper(fcinfo, false, true);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scalarineqsel_wrapper",
          "args": [
            "fcinfo",
            "false",
            "true"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "scalarineqsel_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1085-1150",
          "snippet": "static Datum\nscalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tdouble\t\tselec;\n\n\t/*\n\t * If expression is not variable op something or something op variable,\n\t * then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * Force the var to be on the left to simplify logic in scalarineqsel.\n\t */\n\tif (!varonleft)\n\t{\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t\t}\n\t\tisgt = !isgt;\n\t}\n\n\t/* The rest of the work is done by scalarineqsel(). */\n\tselec = scalarineqsel(root, operator, isgt, iseq,\n\t\t\t\t\t\t  &vardata, constval, consttype);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic Datum\nscalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tdouble\t\tselec;\n\n\t/*\n\t * If expression is not variable op something or something op variable,\n\t * then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * Force the var to be on the left to simplify logic in scalarineqsel.\n\t */\n\tif (!varonleft)\n\t{\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t\t}\n\t\tisgt = !isgt;\n\t}\n\n\t/* The rest of the work is done by scalarineqsel(). */\n\tselec = scalarineqsel(root, operator, isgt, iseq,\n\t\t\t\t\t\t  &vardata, constval, consttype);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nscalarlesel(PG_FUNCTION_ARGS)\n{\n\treturn scalarineqsel_wrapper(fcinfo, false, true);\n}"
  },
  {
    "function_name": "scalarltsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1155-1159",
    "snippet": "Datum\nscalarltsel(PG_FUNCTION_ARGS)\n{\n\treturn scalarineqsel_wrapper(fcinfo, false, false);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scalarineqsel_wrapper",
          "args": [
            "fcinfo",
            "false",
            "false"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "scalarineqsel_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "1085-1150",
          "snippet": "static Datum\nscalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tdouble\t\tselec;\n\n\t/*\n\t * If expression is not variable op something or something op variable,\n\t * then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * Force the var to be on the left to simplify logic in scalarineqsel.\n\t */\n\tif (!varonleft)\n\t{\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t\t}\n\t\tisgt = !isgt;\n\t}\n\n\t/* The rest of the work is done by scalarineqsel(). */\n\tselec = scalarineqsel(root, operator, isgt, iseq,\n\t\t\t\t\t\t  &vardata, constval, consttype);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic Datum\nscalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tdouble\t\tselec;\n\n\t/*\n\t * If expression is not variable op something or something op variable,\n\t * then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * Force the var to be on the left to simplify logic in scalarineqsel.\n\t */\n\tif (!varonleft)\n\t{\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t\t}\n\t\tisgt = !isgt;\n\t}\n\n\t/* The rest of the work is done by scalarineqsel(). */\n\tselec = scalarineqsel(root, operator, isgt, iseq,\n\t\t\t\t\t\t  &vardata, constval, consttype);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nscalarltsel(PG_FUNCTION_ARGS)\n{\n\treturn scalarineqsel_wrapper(fcinfo, false, false);\n}"
  },
  {
    "function_name": "scalarineqsel_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "1085-1150",
    "snippet": "static Datum\nscalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tdouble\t\tselec;\n\n\t/*\n\t * If expression is not variable op something or something op variable,\n\t * then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * Force the var to be on the left to simplify logic in scalarineqsel.\n\t */\n\tif (!varonleft)\n\t{\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t\t}\n\t\tisgt = !isgt;\n\t}\n\n\t/* The rest of the work is done by scalarineqsel(). */\n\tselec = scalarineqsel(root, operator, isgt, iseq,\n\t\t\t\t\t\t  &vardata, constval, consttype);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) selec"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scalarineqsel",
          "args": [
            "root",
            "operator",
            "isgt",
            "iseq",
            "&vardata",
            "constval",
            "consttype"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "scalarineqsel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "563-624",
          "snippet": "static double\nscalarineqsel(PlannerInfo *root, Oid operator, bool isgt, bool iseq,\n\t\t\t  VariableStatData *vardata, Datum constval, Oid consttype)\n{\n\tForm_pg_statistic stats;\n\tFmgrInfo\topproc;\n\tdouble\t\tmcv_selec,\n\t\t\t\thist_selec,\n\t\t\t\tsumcommon;\n\tdouble\t\tselec;\n\n\tif (!HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* no stats available, so default result */\n\t\treturn DEFAULT_INEQ_SEL;\n\t}\n\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\n\tfmgr_info(get_opcode(operator), &opproc);\n\n\t/*\n\t * If we have most-common-values info, add up the fractions of the MCV\n\t * entries that satisfy MCV OP CONST.  These fractions contribute directly\n\t * to the result selectivity.  Also add up the total fraction represented\n\t * by MCV entries.\n\t */\n\tmcv_selec = mcv_selectivity(vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t&sumcommon);\n\n\t/*\n\t * If there is a histogram, determine which bin the constant falls in, and\n\t * compute the resulting contribution to selectivity.\n\t */\n\thist_selec = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t\t&opproc, isgt, iseq,\n\t\t\t\t\t\t\t\t\t\t\tconstval, consttype);\n\n\t/*\n\t * Now merge the results from the MCV and histogram calculations,\n\t * realizing that the histogram covers only the non-null values that are\n\t * not listed in MCV.\n\t */\n\tselec = 1.0 - stats->stanullfrac - sumcommon;\n\n\tif (hist_selec >= 0.0)\n\t\tselec *= hist_selec;\n\telse\n\t{\n\t\t/*\n\t\t * If no histogram but there are values not accounted for by MCV,\n\t\t * arbitrarily assume half of them will match.\n\t\t */\n\t\tselec *= 0.5;\n\t}\n\n\tselec += mcv_selec;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\nscalarineqsel(PlannerInfo *root, Oid operator, bool isgt, bool iseq,\n\t\t\t  VariableStatData *vardata, Datum constval, Oid consttype)\n{\n\tForm_pg_statistic stats;\n\tFmgrInfo\topproc;\n\tdouble\t\tmcv_selec,\n\t\t\t\thist_selec,\n\t\t\t\tsumcommon;\n\tdouble\t\tselec;\n\n\tif (!HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* no stats available, so default result */\n\t\treturn DEFAULT_INEQ_SEL;\n\t}\n\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\n\tfmgr_info(get_opcode(operator), &opproc);\n\n\t/*\n\t * If we have most-common-values info, add up the fractions of the MCV\n\t * entries that satisfy MCV OP CONST.  These fractions contribute directly\n\t * to the result selectivity.  Also add up the total fraction represented\n\t * by MCV entries.\n\t */\n\tmcv_selec = mcv_selectivity(vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t&sumcommon);\n\n\t/*\n\t * If there is a histogram, determine which bin the constant falls in, and\n\t * compute the resulting contribution to selectivity.\n\t */\n\thist_selec = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t\t&opproc, isgt, iseq,\n\t\t\t\t\t\t\t\t\t\t\tconstval, consttype);\n\n\t/*\n\t * Now merge the results from the MCV and histogram calculations,\n\t * realizing that the histogram covers only the non-null values that are\n\t * not listed in MCV.\n\t */\n\tselec = 1.0 - stats->stanullfrac - sumcommon;\n\n\tif (hist_selec >= 0.0)\n\t\tselec *= hist_selec;\n\telse\n\t{\n\t\t/*\n\t\t * If no histogram but there are values not accounted for by MCV,\n\t\t * arbitrarily assume half of them will match.\n\t\t */\n\t\tselec *= 0.5;\n\t}\n\n\tselec += mcv_selec;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_INEQ_SEL"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_commutator",
          "args": [
            "operator"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "get_commutator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1297-1314",
          "snippet": "Oid\nget_commutator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprcom;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_commutator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprcom;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_INEQ_SEL"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "other",
            "Const"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "DEFAULT_INEQ_SEL"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_restriction_variable",
          "args": [
            "root",
            "args",
            "varRelid",
            "&vardata",
            "&other",
            "&varonleft"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "get_restriction_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4653-4701",
          "snippet": "bool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic Datum\nscalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tDatum\t\tconstval;\n\tOid\t\t\tconsttype;\n\tdouble\t\tselec;\n\n\t/*\n\t * If expression is not variable op something or something op variable,\n\t * then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t}\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\tconstval = ((Const *) other)->constvalue;\n\tconsttype = ((Const *) other)->consttype;\n\n\t/*\n\t * Force the var to be on the left to simplify logic in scalarineqsel.\n\t */\n\tif (!varonleft)\n\t{\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(DEFAULT_INEQ_SEL);\n\t\t}\n\t\tisgt = !isgt;\n\t}\n\n\t/* The rest of the work is done by scalarineqsel(). */\n\tselec = scalarineqsel(root, operator, isgt, iseq,\n\t\t\t\t\t\t  &vardata, constval, consttype);\n\n\tReleaseVariableStats(vardata);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}"
  },
  {
    "function_name": "ineq_histogram_selectivity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "776-1079",
    "snippet": "static double\nineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype)\n{\n\tdouble\t\thist_selec;\n\tAttStatsSlot sslot;\n\n\thist_selec = -1.0;\n\n\t/*\n\t * Someday, ANALYZE might store more than one histogram per rel/att,\n\t * corresponding to more than one possible sort ordering defined for the\n\t * column type.  However, to make that work we will need to figure out\n\t * which staop to search for --- it's not necessarily the one we have at\n\t * hand!  (For example, we might have a '<=' operator rather than the '<'\n\t * operator that will appear in staop.)  For now, assume that whatever\n\t * appears in pg_statistic is sorted the same way our operator sorts, or\n\t * the reverse way if isgt is true.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * Use binary search to find the desired location, namely the\n\t\t\t * right end of the histogram bin containing the comparison value,\n\t\t\t * which is the leftmost entry for which the comparison operator\n\t\t\t * succeeds (if isgt) or fails (if !isgt).  (If the given operator\n\t\t\t * isn't actually sort-compatible with the histogram, you'll get\n\t\t\t * garbage results ... but probably not any more garbage-y than\n\t\t\t * you would have from the old linear search.)\n\t\t\t *\n\t\t\t * In this loop, we pay no attention to whether the operator iseq\n\t\t\t * or not; that detail will be mopped up below.  (We cannot tell,\n\t\t\t * anyway, whether the operator thinks the values are equal.)\n\t\t\t *\n\t\t\t * If the binary search accesses the first or last histogram\n\t\t\t * entry, we try to replace that endpoint with the true column min\n\t\t\t * or max as found by get_actual_variable_range().  This\n\t\t\t * ameliorates misestimates when the min or max is moving as a\n\t\t\t * result of changes since the last ANALYZE.  Note that this could\n\t\t\t * result in effectively including MCVs into the histogram that\n\t\t\t * weren't there before, but we don't try to correct for that.\n\t\t\t */\n\t\t\tdouble\t\thistfrac;\n\t\t\tint\t\t\tlobound = 0;\t/* first possible slot to search */\n\t\t\tint\t\t\thibound = sslot.nvalues;\t/* last+1 slot to search */\n\t\t\tbool\t\thave_end = false;\n\n\t\t\t/*\n\t\t\t * If there are only two histogram entries, we'll want up-to-date\n\t\t\t * values for both.  (If there are more than two, we need at most\n\t\t\t * one of them to be updated, so we deal with that within the\n\t\t\t * loop.)\n\t\t\t */\n\t\t\tif (sslot.nvalues == 2)\n\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[1]);\n\n\t\t\twhile (lobound < hibound)\n\t\t\t{\n\t\t\t\tint\t\t\tprobe = (lobound + hibound) / 2;\n\t\t\t\tbool\t\tltcmp;\n\n\t\t\t\t/*\n\t\t\t\t * If we find ourselves about to compare to the first or last\n\t\t\t\t * histogram entry, first try to replace it with the actual\n\t\t\t\t * current min or max (unless we already did so above).\n\t\t\t\t */\n\t\t\t\tif (probe == 0 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\t\telse if (probe == sslot.nvalues - 1 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[probe]);\n\n\t\t\t\tltcmp = DatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[probe],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\tif (isgt)\n\t\t\t\t\tltcmp = !ltcmp;\n\t\t\t\tif (ltcmp)\n\t\t\t\t\tlobound = probe + 1;\n\t\t\t\telse\n\t\t\t\t\thibound = probe;\n\t\t\t}\n\n\t\t\tif (lobound <= 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Constant is below lower histogram boundary.  More\n\t\t\t\t * precisely, we have found that no entry in the histogram\n\t\t\t\t * satisfies the inequality clause (if !isgt) or they all do\n\t\t\t\t * (if isgt).  We estimate that that's true of the entire\n\t\t\t\t * table, so set histfrac to 0.0 (which we'll flip to 1.0\n\t\t\t\t * below, if isgt).\n\t\t\t\t */\n\t\t\t\thistfrac = 0.0;\n\t\t\t}\n\t\t\telse if (lobound >= sslot.nvalues)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Inverse case: constant is above upper histogram boundary.\n\t\t\t\t */\n\t\t\t\thistfrac = 1.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We have values[i-1] <= constant <= values[i]. */\n\t\t\t\tint\t\t\ti = lobound;\n\t\t\t\tdouble\t\teq_selec = 0;\n\t\t\t\tdouble\t\tval,\n\t\t\t\t\t\t\thigh,\n\t\t\t\t\t\t\tlow;\n\t\t\t\tdouble\t\tbinfrac;\n\n\t\t\t\t/*\n\t\t\t\t * In the cases where we'll need it below, obtain an estimate\n\t\t\t\t * of the selectivity of \"x = constval\".  We use a calculation\n\t\t\t\t * similar to what var_eq_const() does for a non-MCV constant,\n\t\t\t\t * ie, estimate that all distinct non-MCV values occur equally\n\t\t\t\t * often.  But multiplication by \"1.0 - sumcommon - nullfrac\"\n\t\t\t\t * will be done by our caller, so we shouldn't do that here.\n\t\t\t\t * Therefore we can't try to clamp the estimate by reference\n\t\t\t\t * to the least common MCV; the result would be too small.\n\t\t\t\t *\n\t\t\t\t * Note: since this is effectively assuming that constval\n\t\t\t\t * isn't an MCV, it's logically dubious if constval in fact is\n\t\t\t\t * one.  But we have to apply *some* correction for equality,\n\t\t\t\t * and anyway we cannot tell if constval is an MCV, since we\n\t\t\t\t * don't have a suitable equality operator at hand.\n\t\t\t\t */\n\t\t\t\tif (i == 1 || isgt == iseq)\n\t\t\t\t{\n\t\t\t\t\tdouble\t\totherdistinct;\n\t\t\t\t\tbool\t\tisdefault;\n\t\t\t\t\tAttStatsSlot mcvslot;\n\n\t\t\t\t\t/* Get estimated number of distinct values */\n\t\t\t\t\totherdistinct = get_variable_numdistinct(vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &isdefault);\n\n\t\t\t\t\t/* Subtract off the number of known MCVs */\n\t\t\t\t\tif (get_attstatsslot(&mcvslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t\t\t\t{\n\t\t\t\t\t\totherdistinct -= mcvslot.nnumbers;\n\t\t\t\t\t\tfree_attstatsslot(&mcvslot);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If result doesn't seem sane, leave eq_selec at 0 */\n\t\t\t\t\tif (otherdistinct > 1)\n\t\t\t\t\t\teq_selec = 1.0 / otherdistinct;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Convert the constant and the two nearest bin boundary\n\t\t\t\t * values to a uniform comparison scale, and do a linear\n\t\t\t\t * interpolation within this bin.\n\t\t\t\t */\n\t\t\t\tif (convert_to_scalar(constval, consttype, &val,\n\t\t\t\t\t\t\t\t\t  sslot.values[i - 1], sslot.values[i],\n\t\t\t\t\t\t\t\t\t  vardata->vartype,\n\t\t\t\t\t\t\t\t\t  &low, &high))\n\t\t\t\t{\n\t\t\t\t\tif (high <= low)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* cope if bin boundaries appear identical */\n\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t\telse if (val <= low)\n\t\t\t\t\t\tbinfrac = 0.0;\n\t\t\t\t\telse if (val >= high)\n\t\t\t\t\t\tbinfrac = 1.0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbinfrac = (val - low) / (high - low);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Watch out for the possibility that we got a NaN or\n\t\t\t\t\t\t * Infinity from the division.  This can happen\n\t\t\t\t\t\t * despite the previous checks, if for example \"low\"\n\t\t\t\t\t\t * is -Infinity.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (isnan(binfrac) ||\n\t\t\t\t\t\t\tbinfrac < 0.0 || binfrac > 1.0)\n\t\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Ideally we'd produce an error here, on the grounds that\n\t\t\t\t\t * the given operator shouldn't have scalarXXsel\n\t\t\t\t\t * registered as its selectivity func unless we can deal\n\t\t\t\t\t * with its operand types.  But currently, all manner of\n\t\t\t\t\t * stuff is invoking scalarXXsel, so give a default\n\t\t\t\t\t * estimate until that can be fixed.\n\t\t\t\t\t */\n\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Now, compute the overall selectivity across the values\n\t\t\t\t * represented by the histogram.  We have i-1 full bins and\n\t\t\t\t * binfrac partial bin below the constant.\n\t\t\t\t */\n\t\t\t\thistfrac = (double) (i - 1) + binfrac;\n\t\t\t\thistfrac /= (double) (sslot.nvalues - 1);\n\n\t\t\t\t/*\n\t\t\t\t * At this point, histfrac is an estimate of the fraction of\n\t\t\t\t * the population represented by the histogram that satisfies\n\t\t\t\t * \"x <= constval\".  Somewhat remarkably, this statement is\n\t\t\t\t * true regardless of which operator we were doing the probes\n\t\t\t\t * with, so long as convert_to_scalar() delivers reasonable\n\t\t\t\t * results.  If the probe constant is equal to some histogram\n\t\t\t\t * entry, we would have considered the bin to the left of that\n\t\t\t\t * entry if probing with \"<\" or \">=\", or the bin to the right\n\t\t\t\t * if probing with \"<=\" or \">\"; but binfrac would have come\n\t\t\t\t * out as 1.0 in the first case and 0.0 in the second, leading\n\t\t\t\t * to the same histfrac in either case.  For probe constants\n\t\t\t\t * between histogram entries, we find the same bin and get the\n\t\t\t\t * same estimate with any operator.\n\t\t\t\t *\n\t\t\t\t * The fact that the estimate corresponds to \"x <= constval\"\n\t\t\t\t * and not \"x < constval\" is because of the way that ANALYZE\n\t\t\t\t * constructs the histogram: each entry is, effectively, the\n\t\t\t\t * rightmost value in its sample bucket.  So selectivity\n\t\t\t\t * values that are exact multiples of 1/(histogram_size-1)\n\t\t\t\t * should be understood as estimates including a histogram\n\t\t\t\t * entry plus everything to its left.\n\t\t\t\t *\n\t\t\t\t * However, that breaks down for the first histogram entry,\n\t\t\t\t * which necessarily is the leftmost value in its sample\n\t\t\t\t * bucket.  That means the first histogram bin is slightly\n\t\t\t\t * narrower than the rest, by an amount equal to eq_selec.\n\t\t\t\t * Another way to say that is that we want \"x <= leftmost\" to\n\t\t\t\t * be estimated as eq_selec not zero.  So, if we're dealing\n\t\t\t\t * with the first bin (i==1), rescale to make that true while\n\t\t\t\t * adjusting the rest of that bin linearly.\n\t\t\t\t */\n\t\t\t\tif (i == 1)\n\t\t\t\t\thistfrac += eq_selec * (1.0 - binfrac);\n\n\t\t\t\t/*\n\t\t\t\t * \"x <= constval\" is good if we want an estimate for \"<=\" or\n\t\t\t\t * \">\", but if we are estimating for \"<\" or \">=\", we now need\n\t\t\t\t * to decrease the estimate by eq_selec.\n\t\t\t\t */\n\t\t\t\tif (isgt == iseq)\n\t\t\t\t\thistfrac -= eq_selec;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now the estimate is finished for \"<\" and \"<=\" cases.  If we are\n\t\t\t * estimating for \">\" or \">=\", flip it.\n\t\t\t */\n\t\t\thist_selec = isgt ? (1.0 - histfrac) : histfrac;\n\n\t\t\t/*\n\t\t\t * The histogram boundaries are only approximate to begin with,\n\t\t\t * and may well be out of date anyway.  Therefore, don't believe\n\t\t\t * extremely small or large selectivity estimates --- unless we\n\t\t\t * got actual current endpoint values from the table, in which\n\t\t\t * case just do the usual sanity clamp.  Somewhat arbitrarily, we\n\t\t\t * set the cutoff for other cases at a hundredth of the histogram\n\t\t\t * resolution.\n\t\t\t */\n\t\t\tif (have_end)\n\t\t\t\tCLAMP_PROBABILITY(hist_selec);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble\t\tcutoff = 0.01 / (double) (sslot.nvalues - 1);\n\n\t\t\t\tif (hist_selec < cutoff)\n\t\t\t\t\thist_selec = cutoff;\n\t\t\t\telse if (hist_selec > 1.0 - cutoff)\n\t\t\t\t\thist_selec = 1.0 - cutoff;\n\t\t\t}\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\treturn hist_selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
      "static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);",
      "static bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "hist_selec"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "binfrac"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "convert_to_scalar",
          "args": [
            "constval",
            "consttype",
            "&val",
            "sslot.values[i - 1]",
            "sslot.values[i]",
            "vardata->vartype",
            "&low",
            "&high"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "convert_to_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4052-4193",
          "snippet": "static bool\nconvert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound)\n{\n\tbool\t\tfailure = false;\n\n\t/*\n\t * Both the valuetypid and the boundstypid should exactly match the\n\t * declared input type(s) of the operator we are invoked for.  However,\n\t * extensions might try to use scalarineqsel as estimator for operators\n\t * with input type(s) we don't handle here; in such cases, we want to\n\t * return false, not fail.  In any case, we mustn't assume that valuetypid\n\t * and boundstypid are identical.\n\t *\n\t * XXX The histogram we are interpolating between points of could belong\n\t * to a column that's only binary-compatible with the declared type. In\n\t * essence we are assuming that the semantics of binary-compatible types\n\t * are enough alike that we can use a histogram generated with one type's\n\t * operators to estimate selectivity for the other's.  This is outright\n\t * wrong in some cases --- in particular signed versus unsigned\n\t * interpretation could trip us up.  But it's useful enough in the\n\t * majority of cases that we do it anyway.  Should think about more\n\t * rigorous ways to do it.\n\t */\n\tswitch (valuetypid)\n\t{\n\t\t\t/*\n\t\t\t * Built-in numeric types\n\t\t\t */\n\t\tcase BOOLOID:\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t*scaledvalue = convert_numeric_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledlobound = convert_numeric_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledhibound = convert_numeric_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\treturn !failure;\n\n\t\t\t/*\n\t\t\t * Built-in string types\n\t\t\t */\n\t\tcase CHAROID:\n\t\tcase BPCHAROID:\n\t\tcase VARCHAROID:\n\t\tcase TEXTOID:\n\t\tcase NAMEOID:\n\t\t\t{\n\t\t\t\tchar\t   *valstr = convert_string_datum(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &failure);\n\t\t\t\tchar\t   *lostr = convert_string_datum(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t\tchar\t   *histr = convert_string_datum(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\n\t\t\t\t/*\n\t\t\t\t * Bail out if any of the values is not of string type.  We\n\t\t\t\t * might leak converted strings for the other value(s), but\n\t\t\t\t * that's not worth troubling over.\n\t\t\t\t */\n\t\t\t\tif (failure)\n\t\t\t\t\treturn false;\n\n\t\t\t\tconvert_string_to_scalar(valstr, scaledvalue,\n\t\t\t\t\t\t\t\t\t\t lostr, scaledlobound,\n\t\t\t\t\t\t\t\t\t\t histr, scaledhibound);\n\t\t\t\tpfree(valstr);\n\t\t\t\tpfree(lostr);\n\t\t\t\tpfree(histr);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Built-in bytea type\n\t\t\t */\n\t\tcase BYTEAOID:\n\t\t\t{\n\t\t\t\t/* We only support bytea vs bytea comparison */\n\t\t\t\tif (boundstypid != BYTEAOID)\n\t\t\t\t\treturn false;\n\t\t\t\tconvert_bytea_to_scalar(value, scaledvalue,\n\t\t\t\t\t\t\t\t\t\tlobound, scaledlobound,\n\t\t\t\t\t\t\t\t\t\thibound, scaledhibound);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Built-in time types\n\t\t\t */\n\t\tcase TIMESTAMPOID:\n\t\tcase TIMESTAMPTZOID:\n\t\tcase ABSTIMEOID:\n\t\tcase DATEOID:\n\t\tcase INTERVALOID:\n\t\tcase RELTIMEOID:\n\t\tcase TINTERVALOID:\n\t\tcase TIMEOID:\n\t\tcase TIMETZOID:\n\t\t\t*scaledvalue = convert_timevalue_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledlobound = convert_timevalue_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledhibound = convert_timevalue_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\treturn !failure;\n\n\t\t\t/*\n\t\t\t * Built-in network types\n\t\t\t */\n\t\tcase INETOID:\n\t\tcase CIDROID:\n\t\tcase MACADDROID:\n\t\tcase MACADDR8OID:\n\t\t\t*scaledvalue = convert_network_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledlobound = convert_network_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledhibound = convert_network_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\treturn !failure;\n\t}\n\t/* Don't know how to convert */\n\t*scaledvalue = *scaledlobound = *scaledhibound = 0;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);",
            "static double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);",
            "static void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);",
            "static void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);",
            "static char *convert_string_datum(Datum value, Oid typid, bool *failure);",
            "static double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool convert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound);\nstatic double convert_numeric_to_scalar(Datum value, Oid typid, bool *failure);\nstatic void convert_string_to_scalar(char *value,\n\t\t\t\t\t\t double *scaledvalue,\n\t\t\t\t\t\t char *lobound,\n\t\t\t\t\t\t double *scaledlobound,\n\t\t\t\t\t\t char *hibound,\n\t\t\t\t\t\t double *scaledhibound);\nstatic void convert_bytea_to_scalar(Datum value,\n\t\t\t\t\t\tdouble *scaledvalue,\n\t\t\t\t\t\tDatum lobound,\n\t\t\t\t\t\tdouble *scaledlobound,\n\t\t\t\t\t\tDatum hibound,\n\t\t\t\t\t\tdouble *scaledhibound);\nstatic char *convert_string_datum(Datum value, Oid typid, bool *failure);\nstatic double convert_timevalue_to_scalar(Datum value, Oid typid,\n\t\t\t\t\t\t\tbool *failure);\n\nstatic bool\nconvert_to_scalar(Datum value, Oid valuetypid, double *scaledvalue,\n\t\t\t\t  Datum lobound, Datum hibound, Oid boundstypid,\n\t\t\t\t  double *scaledlobound, double *scaledhibound)\n{\n\tbool\t\tfailure = false;\n\n\t/*\n\t * Both the valuetypid and the boundstypid should exactly match the\n\t * declared input type(s) of the operator we are invoked for.  However,\n\t * extensions might try to use scalarineqsel as estimator for operators\n\t * with input type(s) we don't handle here; in such cases, we want to\n\t * return false, not fail.  In any case, we mustn't assume that valuetypid\n\t * and boundstypid are identical.\n\t *\n\t * XXX The histogram we are interpolating between points of could belong\n\t * to a column that's only binary-compatible with the declared type. In\n\t * essence we are assuming that the semantics of binary-compatible types\n\t * are enough alike that we can use a histogram generated with one type's\n\t * operators to estimate selectivity for the other's.  This is outright\n\t * wrong in some cases --- in particular signed versus unsigned\n\t * interpretation could trip us up.  But it's useful enough in the\n\t * majority of cases that we do it anyway.  Should think about more\n\t * rigorous ways to do it.\n\t */\n\tswitch (valuetypid)\n\t{\n\t\t\t/*\n\t\t\t * Built-in numeric types\n\t\t\t */\n\t\tcase BOOLOID:\n\t\tcase INT2OID:\n\t\tcase INT4OID:\n\t\tcase INT8OID:\n\t\tcase FLOAT4OID:\n\t\tcase FLOAT8OID:\n\t\tcase NUMERICOID:\n\t\tcase OIDOID:\n\t\tcase REGPROCOID:\n\t\tcase REGPROCEDUREOID:\n\t\tcase REGOPEROID:\n\t\tcase REGOPERATOROID:\n\t\tcase REGCLASSOID:\n\t\tcase REGTYPEOID:\n\t\tcase REGCONFIGOID:\n\t\tcase REGDICTIONARYOID:\n\t\tcase REGROLEOID:\n\t\tcase REGNAMESPACEOID:\n\t\t\t*scaledvalue = convert_numeric_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledlobound = convert_numeric_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledhibound = convert_numeric_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\treturn !failure;\n\n\t\t\t/*\n\t\t\t * Built-in string types\n\t\t\t */\n\t\tcase CHAROID:\n\t\tcase BPCHAROID:\n\t\tcase VARCHAROID:\n\t\tcase TEXTOID:\n\t\tcase NAMEOID:\n\t\t\t{\n\t\t\t\tchar\t   *valstr = convert_string_datum(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &failure);\n\t\t\t\tchar\t   *lostr = convert_string_datum(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t\tchar\t   *histr = convert_string_datum(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\n\t\t\t\t/*\n\t\t\t\t * Bail out if any of the values is not of string type.  We\n\t\t\t\t * might leak converted strings for the other value(s), but\n\t\t\t\t * that's not worth troubling over.\n\t\t\t\t */\n\t\t\t\tif (failure)\n\t\t\t\t\treturn false;\n\n\t\t\t\tconvert_string_to_scalar(valstr, scaledvalue,\n\t\t\t\t\t\t\t\t\t\t lostr, scaledlobound,\n\t\t\t\t\t\t\t\t\t\t histr, scaledhibound);\n\t\t\t\tpfree(valstr);\n\t\t\t\tpfree(lostr);\n\t\t\t\tpfree(histr);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Built-in bytea type\n\t\t\t */\n\t\tcase BYTEAOID:\n\t\t\t{\n\t\t\t\t/* We only support bytea vs bytea comparison */\n\t\t\t\tif (boundstypid != BYTEAOID)\n\t\t\t\t\treturn false;\n\t\t\t\tconvert_bytea_to_scalar(value, scaledvalue,\n\t\t\t\t\t\t\t\t\t\tlobound, scaledlobound,\n\t\t\t\t\t\t\t\t\t\thibound, scaledhibound);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Built-in time types\n\t\t\t */\n\t\tcase TIMESTAMPOID:\n\t\tcase TIMESTAMPTZOID:\n\t\tcase ABSTIMEOID:\n\t\tcase DATEOID:\n\t\tcase INTERVALOID:\n\t\tcase RELTIMEOID:\n\t\tcase TINTERVALOID:\n\t\tcase TIMEOID:\n\t\tcase TIMETZOID:\n\t\t\t*scaledvalue = convert_timevalue_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledlobound = convert_timevalue_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledhibound = convert_timevalue_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\treturn !failure;\n\n\t\t\t/*\n\t\t\t * Built-in network types\n\t\t\t */\n\t\tcase INETOID:\n\t\tcase CIDROID:\n\t\tcase MACADDROID:\n\t\tcase MACADDR8OID:\n\t\t\t*scaledvalue = convert_network_to_scalar(value, valuetypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &failure);\n\t\t\t*scaledlobound = convert_network_to_scalar(lobound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\t*scaledhibound = convert_network_to_scalar(hibound, boundstypid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   &failure);\n\t\t\treturn !failure;\n\t}\n\t/* Don't know how to convert */\n\t*scaledvalue = *scaledlobound = *scaledhibound = 0;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&mcvslot",
            "vardata->statsTuple",
            "STATISTIC_KIND_MCV",
            "InvalidOid",
            "ATTSTATSSLOT_NUMBERS"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_variable_numdistinct",
          "args": [
            "vardata",
            "&isdefault"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "get_variable_numdistinct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5196-5318",
          "snippet": "double\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[probe],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   constval)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "opproc",
            "DEFAULT_COLLATION_OID",
            "sslot.values[probe]",
            "constval"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_actual_variable_range",
          "args": [
            "root",
            "vardata",
            "sslot.staop",
            "NULL",
            "&sslot.values[probe]"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "get_actual_variable_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5463-5693",
          "snippet": "static bool\nget_actual_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max)\n{\n\tbool\t\thave_data = false;\n\tRelOptInfo *rel = vardata->rel;\n\tRangeTblEntry *rte;\n\tListCell   *lc;\n\n\t/* No hope if no relation or it doesn't have indexes */\n\tif (rel == NULL || rel->indexlist == NIL)\n\t\treturn false;\n\t/* If it has indexes it must be a plain relation */\n\trte = root->simple_rte_array[rel->relid];\n\tAssert(rte->rtekind == RTE_RELATION);\n\n\t/* Search through the indexes to see if any match our problem */\n\tforeach(lc, rel->indexlist)\n\t{\n\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(lc);\n\t\tScanDirection indexscandir;\n\n\t\t/* Ignore non-btree indexes */\n\t\tif (index->relam != BTREE_AM_OID)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore partial indexes --- we only want stats that cover the entire\n\t\t * relation.\n\t\t */\n\t\tif (index->indpred != NIL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The index list might include hypothetical indexes inserted by a\n\t\t * get_relation_info hook --- don't try to access them.\n\t\t */\n\t\tif (index->hypothetical)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The first index column must match the desired variable and sort\n\t\t * operator --- but we can use a descending-order index.\n\t\t */\n\t\tif (!match_index_to_operand(vardata->var, 0, index))\n\t\t\tcontinue;\n\t\tswitch (get_op_opfamily_strategy(sortop, index->sortopfamily[0]))\n\t\t{\n\t\t\tcase BTLessStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tcase BTGreaterStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* index doesn't match the sortop */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Found a suitable index to extract data from.  We'll need an EState\n\t\t * and a bunch of other infrastructure.\n\t\t */\n\t\t{\n\t\t\tEState\t   *estate;\n\t\t\tExprContext *econtext;\n\t\t\tMemoryContext tmpcontext;\n\t\t\tMemoryContext oldcontext;\n\t\t\tRelation\theapRel;\n\t\t\tRelation\tindexRel;\n\t\t\tIndexInfo  *indexInfo;\n\t\t\tTupleTableSlot *slot;\n\t\t\tint16\t\ttypLen;\n\t\t\tbool\t\ttypByVal;\n\t\t\tScanKeyData scankeys[1];\n\t\t\tIndexScanDesc index_scan;\n\t\t\tHeapTuple\ttup;\n\t\t\tDatum\t\tvalues[INDEX_MAX_KEYS];\n\t\t\tbool\t\tisnull[INDEX_MAX_KEYS];\n\t\t\tSnapshotData SnapshotNonVacuumable;\n\n\t\t\testate = CreateExecutorState();\n\t\t\tecontext = GetPerTupleExprContext(estate);\n\t\t\t/* Make sure any cruft is generated in the econtext's memory */\n\t\t\ttmpcontext = econtext->ecxt_per_tuple_memory;\n\t\t\toldcontext = MemoryContextSwitchTo(tmpcontext);\n\n\t\t\t/*\n\t\t\t * Open the table and index so we can read from them.  We should\n\t\t\t * already have at least AccessShareLock on the table, but not\n\t\t\t * necessarily on the index.\n\t\t\t */\n\t\t\theapRel = heap_open(rte->relid, NoLock);\n\t\t\tindexRel = index_open(index->indexoid, AccessShareLock);\n\n\t\t\t/* extract index key information from the index's pg_index info */\n\t\t\tindexInfo = BuildIndexInfo(indexRel);\n\n\t\t\t/* some other stuff */\n\t\t\tslot = MakeSingleTupleTableSlot(RelationGetDescr(heapRel));\n\t\t\tecontext->ecxt_scantuple = slot;\n\t\t\tget_typlenbyval(vardata->atttype, &typLen, &typByVal);\n\t\t\tInitNonVacuumableSnapshot(SnapshotNonVacuumable, RecentGlobalXmin);\n\n\t\t\t/* set up an IS NOT NULL scan key so that we ignore nulls */\n\t\t\tScanKeyEntryInitialize(&scankeys[0],\n\t\t\t\t\t\t\t\t   SK_ISNULL | SK_SEARCHNOTNULL,\n\t\t\t\t\t\t\t\t   1,\t/* index col to scan */\n\t\t\t\t\t\t\t\t   InvalidStrategy, /* no strategy */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no strategy subtype */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no collation */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no reg proc for this */\n\t\t\t\t\t\t\t\t   (Datum) 0);\t/* constant */\n\n\t\t\thave_data = true;\n\n\t\t\t/* If min is requested ... */\n\t\t\tif (min)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * In principle, we should scan the index with our current\n\t\t\t\t * active snapshot, which is the best approximation we've got\n\t\t\t\t * to what the query will see when executed.  But that won't\n\t\t\t\t * be exact if a new snap is taken before running the query,\n\t\t\t\t * and it can be very expensive if a lot of recently-dead or\n\t\t\t\t * uncommitted rows exist at the beginning or end of the index\n\t\t\t\t * (because we'll laboriously fetch each one and reject it).\n\t\t\t\t * Instead, we use SnapshotNonVacuumable.  That will accept\n\t\t\t\t * recently-dead and uncommitted rows as well as normal\n\t\t\t\t * visible rows.  On the other hand, it will reject known-dead\n\t\t\t\t * rows, and thus not give a bogus answer when the extreme\n\t\t\t\t * value has been deleted (unless the deletion was quite\n\t\t\t\t * recent); that case motivates not using SnapshotAny here.\n\t\t\t\t *\n\t\t\t\t * A crucial point here is that SnapshotNonVacuumable, with\n\t\t\t\t * RecentGlobalXmin as horizon, yields the inverse of the\n\t\t\t\t * condition that the indexscan will use to decide that index\n\t\t\t\t * entries are killable (see heap_hot_search_buffer()).\n\t\t\t\t * Therefore, if the snapshot rejects a tuple and we have to\n\t\t\t\t * continue scanning past it, we know that the indexscan will\n\t\t\t\t * mark that index entry killed.  That means that the next\n\t\t\t\t * get_actual_variable_range() call will not have to visit\n\t\t\t\t * that heap entry.  In this way we avoid repetitive work when\n\t\t\t\t * this function is used a lot during planning.\n\t\t\t\t */\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in sortop's direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*min = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* If max is requested, and we didn't find the index is empty */\n\t\t\tif (max && have_data)\n\t\t\t{\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in reverse direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t -indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*max = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* Clean everything up */\n\t\t\tExecDropSingleTupleTableSlot(slot);\n\n\t\t\tindex_close(indexRel, AccessShareLock);\n\t\t\theap_close(heapRel, NoLock);\n\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\tFreeExecutorState(estate);\n\n\t\t\t/* And we're done */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn have_data;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
            "static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);",
            "static bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);\nstatic bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);\n\nstatic bool\nget_actual_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max)\n{\n\tbool\t\thave_data = false;\n\tRelOptInfo *rel = vardata->rel;\n\tRangeTblEntry *rte;\n\tListCell   *lc;\n\n\t/* No hope if no relation or it doesn't have indexes */\n\tif (rel == NULL || rel->indexlist == NIL)\n\t\treturn false;\n\t/* If it has indexes it must be a plain relation */\n\trte = root->simple_rte_array[rel->relid];\n\tAssert(rte->rtekind == RTE_RELATION);\n\n\t/* Search through the indexes to see if any match our problem */\n\tforeach(lc, rel->indexlist)\n\t{\n\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(lc);\n\t\tScanDirection indexscandir;\n\n\t\t/* Ignore non-btree indexes */\n\t\tif (index->relam != BTREE_AM_OID)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore partial indexes --- we only want stats that cover the entire\n\t\t * relation.\n\t\t */\n\t\tif (index->indpred != NIL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The index list might include hypothetical indexes inserted by a\n\t\t * get_relation_info hook --- don't try to access them.\n\t\t */\n\t\tif (index->hypothetical)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The first index column must match the desired variable and sort\n\t\t * operator --- but we can use a descending-order index.\n\t\t */\n\t\tif (!match_index_to_operand(vardata->var, 0, index))\n\t\t\tcontinue;\n\t\tswitch (get_op_opfamily_strategy(sortop, index->sortopfamily[0]))\n\t\t{\n\t\t\tcase BTLessStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tcase BTGreaterStrategyNumber:\n\t\t\t\tif (index->reverse_sort[0])\n\t\t\t\t\tindexscandir = ForwardScanDirection;\n\t\t\t\telse\n\t\t\t\t\tindexscandir = BackwardScanDirection;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* index doesn't match the sortop */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Found a suitable index to extract data from.  We'll need an EState\n\t\t * and a bunch of other infrastructure.\n\t\t */\n\t\t{\n\t\t\tEState\t   *estate;\n\t\t\tExprContext *econtext;\n\t\t\tMemoryContext tmpcontext;\n\t\t\tMemoryContext oldcontext;\n\t\t\tRelation\theapRel;\n\t\t\tRelation\tindexRel;\n\t\t\tIndexInfo  *indexInfo;\n\t\t\tTupleTableSlot *slot;\n\t\t\tint16\t\ttypLen;\n\t\t\tbool\t\ttypByVal;\n\t\t\tScanKeyData scankeys[1];\n\t\t\tIndexScanDesc index_scan;\n\t\t\tHeapTuple\ttup;\n\t\t\tDatum\t\tvalues[INDEX_MAX_KEYS];\n\t\t\tbool\t\tisnull[INDEX_MAX_KEYS];\n\t\t\tSnapshotData SnapshotNonVacuumable;\n\n\t\t\testate = CreateExecutorState();\n\t\t\tecontext = GetPerTupleExprContext(estate);\n\t\t\t/* Make sure any cruft is generated in the econtext's memory */\n\t\t\ttmpcontext = econtext->ecxt_per_tuple_memory;\n\t\t\toldcontext = MemoryContextSwitchTo(tmpcontext);\n\n\t\t\t/*\n\t\t\t * Open the table and index so we can read from them.  We should\n\t\t\t * already have at least AccessShareLock on the table, but not\n\t\t\t * necessarily on the index.\n\t\t\t */\n\t\t\theapRel = heap_open(rte->relid, NoLock);\n\t\t\tindexRel = index_open(index->indexoid, AccessShareLock);\n\n\t\t\t/* extract index key information from the index's pg_index info */\n\t\t\tindexInfo = BuildIndexInfo(indexRel);\n\n\t\t\t/* some other stuff */\n\t\t\tslot = MakeSingleTupleTableSlot(RelationGetDescr(heapRel));\n\t\t\tecontext->ecxt_scantuple = slot;\n\t\t\tget_typlenbyval(vardata->atttype, &typLen, &typByVal);\n\t\t\tInitNonVacuumableSnapshot(SnapshotNonVacuumable, RecentGlobalXmin);\n\n\t\t\t/* set up an IS NOT NULL scan key so that we ignore nulls */\n\t\t\tScanKeyEntryInitialize(&scankeys[0],\n\t\t\t\t\t\t\t\t   SK_ISNULL | SK_SEARCHNOTNULL,\n\t\t\t\t\t\t\t\t   1,\t/* index col to scan */\n\t\t\t\t\t\t\t\t   InvalidStrategy, /* no strategy */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no strategy subtype */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no collation */\n\t\t\t\t\t\t\t\t   InvalidOid,\t/* no reg proc for this */\n\t\t\t\t\t\t\t\t   (Datum) 0);\t/* constant */\n\n\t\t\thave_data = true;\n\n\t\t\t/* If min is requested ... */\n\t\t\tif (min)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * In principle, we should scan the index with our current\n\t\t\t\t * active snapshot, which is the best approximation we've got\n\t\t\t\t * to what the query will see when executed.  But that won't\n\t\t\t\t * be exact if a new snap is taken before running the query,\n\t\t\t\t * and it can be very expensive if a lot of recently-dead or\n\t\t\t\t * uncommitted rows exist at the beginning or end of the index\n\t\t\t\t * (because we'll laboriously fetch each one and reject it).\n\t\t\t\t * Instead, we use SnapshotNonVacuumable.  That will accept\n\t\t\t\t * recently-dead and uncommitted rows as well as normal\n\t\t\t\t * visible rows.  On the other hand, it will reject known-dead\n\t\t\t\t * rows, and thus not give a bogus answer when the extreme\n\t\t\t\t * value has been deleted (unless the deletion was quite\n\t\t\t\t * recent); that case motivates not using SnapshotAny here.\n\t\t\t\t *\n\t\t\t\t * A crucial point here is that SnapshotNonVacuumable, with\n\t\t\t\t * RecentGlobalXmin as horizon, yields the inverse of the\n\t\t\t\t * condition that the indexscan will use to decide that index\n\t\t\t\t * entries are killable (see heap_hot_search_buffer()).\n\t\t\t\t * Therefore, if the snapshot rejects a tuple and we have to\n\t\t\t\t * continue scanning past it, we know that the indexscan will\n\t\t\t\t * mark that index entry killed.  That means that the next\n\t\t\t\t * get_actual_variable_range() call will not have to visit\n\t\t\t\t * that heap entry.  In this way we avoid repetitive work when\n\t\t\t\t * this function is used a lot during planning.\n\t\t\t\t */\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in sortop's direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*min = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* If max is requested, and we didn't find the index is empty */\n\t\t\tif (max && have_data)\n\t\t\t{\n\t\t\t\tindex_scan = index_beginscan(heapRel, indexRel,\n\t\t\t\t\t\t\t\t\t\t\t &SnapshotNonVacuumable,\n\t\t\t\t\t\t\t\t\t\t\t 1, 0);\n\t\t\t\tindex_rescan(index_scan, scankeys, 1, NULL, 0);\n\n\t\t\t\t/* Fetch first tuple in reverse direction */\n\t\t\t\tif ((tup = index_getnext(index_scan,\n\t\t\t\t\t\t\t\t\t\t -indexscandir)) != NULL)\n\t\t\t\t{\n\t\t\t\t\t/* Extract the index column values from the heap tuple */\n\t\t\t\t\tExecStoreTuple(tup, slot, InvalidBuffer, false);\n\t\t\t\t\tFormIndexDatum(indexInfo, slot, estate,\n\t\t\t\t\t\t\t\t   values, isnull);\n\n\t\t\t\t\t/* Shouldn't have got a null, but be careful */\n\t\t\t\t\tif (isnull[0])\n\t\t\t\t\t\telog(ERROR, \"found unexpected null value in index \\\"%s\\\"\",\n\t\t\t\t\t\t\t RelationGetRelationName(indexRel));\n\n\t\t\t\t\t/* Copy the index column value out to caller's context */\n\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t*max = datumCopy(values[0], typByVal, typLen);\n\t\t\t\t\tMemoryContextSwitchTo(tmpcontext);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\thave_data = false;\n\n\t\t\t\tindex_endscan(index_scan);\n\t\t\t}\n\n\t\t\t/* Clean everything up */\n\t\t\tExecDropSingleTupleTableSlot(slot);\n\n\t\t\tindex_close(indexRel, AccessShareLock);\n\t\t\theap_close(heapRel, NoLock);\n\n\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\tFreeExecutorState(estate);\n\n\t\t\t/* And we're done */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn have_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statistic_proc_security_check",
          "args": [
            "vardata",
            "opproc->fn_oid"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "statistic_proc_security_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5167-5183",
          "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);\nstatic bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);\n\nstatic double\nineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype)\n{\n\tdouble\t\thist_selec;\n\tAttStatsSlot sslot;\n\n\thist_selec = -1.0;\n\n\t/*\n\t * Someday, ANALYZE might store more than one histogram per rel/att,\n\t * corresponding to more than one possible sort ordering defined for the\n\t * column type.  However, to make that work we will need to figure out\n\t * which staop to search for --- it's not necessarily the one we have at\n\t * hand!  (For example, we might have a '<=' operator rather than the '<'\n\t * operator that will appear in staop.)  For now, assume that whatever\n\t * appears in pg_statistic is sorted the same way our operator sorts, or\n\t * the reverse way if isgt is true.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * Use binary search to find the desired location, namely the\n\t\t\t * right end of the histogram bin containing the comparison value,\n\t\t\t * which is the leftmost entry for which the comparison operator\n\t\t\t * succeeds (if isgt) or fails (if !isgt).  (If the given operator\n\t\t\t * isn't actually sort-compatible with the histogram, you'll get\n\t\t\t * garbage results ... but probably not any more garbage-y than\n\t\t\t * you would have from the old linear search.)\n\t\t\t *\n\t\t\t * In this loop, we pay no attention to whether the operator iseq\n\t\t\t * or not; that detail will be mopped up below.  (We cannot tell,\n\t\t\t * anyway, whether the operator thinks the values are equal.)\n\t\t\t *\n\t\t\t * If the binary search accesses the first or last histogram\n\t\t\t * entry, we try to replace that endpoint with the true column min\n\t\t\t * or max as found by get_actual_variable_range().  This\n\t\t\t * ameliorates misestimates when the min or max is moving as a\n\t\t\t * result of changes since the last ANALYZE.  Note that this could\n\t\t\t * result in effectively including MCVs into the histogram that\n\t\t\t * weren't there before, but we don't try to correct for that.\n\t\t\t */\n\t\t\tdouble\t\thistfrac;\n\t\t\tint\t\t\tlobound = 0;\t/* first possible slot to search */\n\t\t\tint\t\t\thibound = sslot.nvalues;\t/* last+1 slot to search */\n\t\t\tbool\t\thave_end = false;\n\n\t\t\t/*\n\t\t\t * If there are only two histogram entries, we'll want up-to-date\n\t\t\t * values for both.  (If there are more than two, we need at most\n\t\t\t * one of them to be updated, so we deal with that within the\n\t\t\t * loop.)\n\t\t\t */\n\t\t\tif (sslot.nvalues == 2)\n\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[1]);\n\n\t\t\twhile (lobound < hibound)\n\t\t\t{\n\t\t\t\tint\t\t\tprobe = (lobound + hibound) / 2;\n\t\t\t\tbool\t\tltcmp;\n\n\t\t\t\t/*\n\t\t\t\t * If we find ourselves about to compare to the first or last\n\t\t\t\t * histogram entry, first try to replace it with the actual\n\t\t\t\t * current min or max (unless we already did so above).\n\t\t\t\t */\n\t\t\t\tif (probe == 0 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\t\telse if (probe == sslot.nvalues - 1 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[probe]);\n\n\t\t\t\tltcmp = DatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[probe],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\tif (isgt)\n\t\t\t\t\tltcmp = !ltcmp;\n\t\t\t\tif (ltcmp)\n\t\t\t\t\tlobound = probe + 1;\n\t\t\t\telse\n\t\t\t\t\thibound = probe;\n\t\t\t}\n\n\t\t\tif (lobound <= 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Constant is below lower histogram boundary.  More\n\t\t\t\t * precisely, we have found that no entry in the histogram\n\t\t\t\t * satisfies the inequality clause (if !isgt) or they all do\n\t\t\t\t * (if isgt).  We estimate that that's true of the entire\n\t\t\t\t * table, so set histfrac to 0.0 (which we'll flip to 1.0\n\t\t\t\t * below, if isgt).\n\t\t\t\t */\n\t\t\t\thistfrac = 0.0;\n\t\t\t}\n\t\t\telse if (lobound >= sslot.nvalues)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Inverse case: constant is above upper histogram boundary.\n\t\t\t\t */\n\t\t\t\thistfrac = 1.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We have values[i-1] <= constant <= values[i]. */\n\t\t\t\tint\t\t\ti = lobound;\n\t\t\t\tdouble\t\teq_selec = 0;\n\t\t\t\tdouble\t\tval,\n\t\t\t\t\t\t\thigh,\n\t\t\t\t\t\t\tlow;\n\t\t\t\tdouble\t\tbinfrac;\n\n\t\t\t\t/*\n\t\t\t\t * In the cases where we'll need it below, obtain an estimate\n\t\t\t\t * of the selectivity of \"x = constval\".  We use a calculation\n\t\t\t\t * similar to what var_eq_const() does for a non-MCV constant,\n\t\t\t\t * ie, estimate that all distinct non-MCV values occur equally\n\t\t\t\t * often.  But multiplication by \"1.0 - sumcommon - nullfrac\"\n\t\t\t\t * will be done by our caller, so we shouldn't do that here.\n\t\t\t\t * Therefore we can't try to clamp the estimate by reference\n\t\t\t\t * to the least common MCV; the result would be too small.\n\t\t\t\t *\n\t\t\t\t * Note: since this is effectively assuming that constval\n\t\t\t\t * isn't an MCV, it's logically dubious if constval in fact is\n\t\t\t\t * one.  But we have to apply *some* correction for equality,\n\t\t\t\t * and anyway we cannot tell if constval is an MCV, since we\n\t\t\t\t * don't have a suitable equality operator at hand.\n\t\t\t\t */\n\t\t\t\tif (i == 1 || isgt == iseq)\n\t\t\t\t{\n\t\t\t\t\tdouble\t\totherdistinct;\n\t\t\t\t\tbool\t\tisdefault;\n\t\t\t\t\tAttStatsSlot mcvslot;\n\n\t\t\t\t\t/* Get estimated number of distinct values */\n\t\t\t\t\totherdistinct = get_variable_numdistinct(vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &isdefault);\n\n\t\t\t\t\t/* Subtract off the number of known MCVs */\n\t\t\t\t\tif (get_attstatsslot(&mcvslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t\t\t\t{\n\t\t\t\t\t\totherdistinct -= mcvslot.nnumbers;\n\t\t\t\t\t\tfree_attstatsslot(&mcvslot);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If result doesn't seem sane, leave eq_selec at 0 */\n\t\t\t\t\tif (otherdistinct > 1)\n\t\t\t\t\t\teq_selec = 1.0 / otherdistinct;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Convert the constant and the two nearest bin boundary\n\t\t\t\t * values to a uniform comparison scale, and do a linear\n\t\t\t\t * interpolation within this bin.\n\t\t\t\t */\n\t\t\t\tif (convert_to_scalar(constval, consttype, &val,\n\t\t\t\t\t\t\t\t\t  sslot.values[i - 1], sslot.values[i],\n\t\t\t\t\t\t\t\t\t  vardata->vartype,\n\t\t\t\t\t\t\t\t\t  &low, &high))\n\t\t\t\t{\n\t\t\t\t\tif (high <= low)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* cope if bin boundaries appear identical */\n\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t\telse if (val <= low)\n\t\t\t\t\t\tbinfrac = 0.0;\n\t\t\t\t\telse if (val >= high)\n\t\t\t\t\t\tbinfrac = 1.0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbinfrac = (val - low) / (high - low);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Watch out for the possibility that we got a NaN or\n\t\t\t\t\t\t * Infinity from the division.  This can happen\n\t\t\t\t\t\t * despite the previous checks, if for example \"low\"\n\t\t\t\t\t\t * is -Infinity.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (isnan(binfrac) ||\n\t\t\t\t\t\t\tbinfrac < 0.0 || binfrac > 1.0)\n\t\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Ideally we'd produce an error here, on the grounds that\n\t\t\t\t\t * the given operator shouldn't have scalarXXsel\n\t\t\t\t\t * registered as its selectivity func unless we can deal\n\t\t\t\t\t * with its operand types.  But currently, all manner of\n\t\t\t\t\t * stuff is invoking scalarXXsel, so give a default\n\t\t\t\t\t * estimate until that can be fixed.\n\t\t\t\t\t */\n\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Now, compute the overall selectivity across the values\n\t\t\t\t * represented by the histogram.  We have i-1 full bins and\n\t\t\t\t * binfrac partial bin below the constant.\n\t\t\t\t */\n\t\t\t\thistfrac = (double) (i - 1) + binfrac;\n\t\t\t\thistfrac /= (double) (sslot.nvalues - 1);\n\n\t\t\t\t/*\n\t\t\t\t * At this point, histfrac is an estimate of the fraction of\n\t\t\t\t * the population represented by the histogram that satisfies\n\t\t\t\t * \"x <= constval\".  Somewhat remarkably, this statement is\n\t\t\t\t * true regardless of which operator we were doing the probes\n\t\t\t\t * with, so long as convert_to_scalar() delivers reasonable\n\t\t\t\t * results.  If the probe constant is equal to some histogram\n\t\t\t\t * entry, we would have considered the bin to the left of that\n\t\t\t\t * entry if probing with \"<\" or \">=\", or the bin to the right\n\t\t\t\t * if probing with \"<=\" or \">\"; but binfrac would have come\n\t\t\t\t * out as 1.0 in the first case and 0.0 in the second, leading\n\t\t\t\t * to the same histfrac in either case.  For probe constants\n\t\t\t\t * between histogram entries, we find the same bin and get the\n\t\t\t\t * same estimate with any operator.\n\t\t\t\t *\n\t\t\t\t * The fact that the estimate corresponds to \"x <= constval\"\n\t\t\t\t * and not \"x < constval\" is because of the way that ANALYZE\n\t\t\t\t * constructs the histogram: each entry is, effectively, the\n\t\t\t\t * rightmost value in its sample bucket.  So selectivity\n\t\t\t\t * values that are exact multiples of 1/(histogram_size-1)\n\t\t\t\t * should be understood as estimates including a histogram\n\t\t\t\t * entry plus everything to its left.\n\t\t\t\t *\n\t\t\t\t * However, that breaks down for the first histogram entry,\n\t\t\t\t * which necessarily is the leftmost value in its sample\n\t\t\t\t * bucket.  That means the first histogram bin is slightly\n\t\t\t\t * narrower than the rest, by an amount equal to eq_selec.\n\t\t\t\t * Another way to say that is that we want \"x <= leftmost\" to\n\t\t\t\t * be estimated as eq_selec not zero.  So, if we're dealing\n\t\t\t\t * with the first bin (i==1), rescale to make that true while\n\t\t\t\t * adjusting the rest of that bin linearly.\n\t\t\t\t */\n\t\t\t\tif (i == 1)\n\t\t\t\t\thistfrac += eq_selec * (1.0 - binfrac);\n\n\t\t\t\t/*\n\t\t\t\t * \"x <= constval\" is good if we want an estimate for \"<=\" or\n\t\t\t\t * \">\", but if we are estimating for \"<\" or \">=\", we now need\n\t\t\t\t * to decrease the estimate by eq_selec.\n\t\t\t\t */\n\t\t\t\tif (isgt == iseq)\n\t\t\t\t\thistfrac -= eq_selec;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now the estimate is finished for \"<\" and \"<=\" cases.  If we are\n\t\t\t * estimating for \">\" or \">=\", flip it.\n\t\t\t */\n\t\t\thist_selec = isgt ? (1.0 - histfrac) : histfrac;\n\n\t\t\t/*\n\t\t\t * The histogram boundaries are only approximate to begin with,\n\t\t\t * and may well be out of date anyway.  Therefore, don't believe\n\t\t\t * extremely small or large selectivity estimates --- unless we\n\t\t\t * got actual current endpoint values from the table, in which\n\t\t\t * case just do the usual sanity clamp.  Somewhat arbitrarily, we\n\t\t\t * set the cutoff for other cases at a hundredth of the histogram\n\t\t\t * resolution.\n\t\t\t */\n\t\t\tif (have_end)\n\t\t\t\tCLAMP_PROBABILITY(hist_selec);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble\t\tcutoff = 0.01 / (double) (sslot.nvalues - 1);\n\n\t\t\t\tif (hist_selec < cutoff)\n\t\t\t\t\thist_selec = cutoff;\n\t\t\t\telse if (hist_selec > 1.0 - cutoff)\n\t\t\t\t\thist_selec = 1.0 - cutoff;\n\t\t\t}\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\treturn hist_selec;\n}"
  },
  {
    "function_name": "histogram_selectivity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "710-761",
    "snippet": "double\nhistogram_selectivity(VariableStatData *vardata, FmgrInfo *opproc,\n\t\t\t\t\t  Datum constval, bool varonleft,\n\t\t\t\t\t  int min_hist_size, int n_skip,\n\t\t\t\t\t  int *hist_size)\n{\n\tdouble\t\tresult;\n\tAttStatsSlot sslot;\n\n\t/* check sanity of parameters */\n\tAssert(n_skip >= 0);\n\tAssert(min_hist_size > 2 * n_skip);\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\t*hist_size = sslot.nvalues;\n\t\tif (sslot.nvalues >= min_hist_size)\n\t\t{\n\t\t\tint\t\t\tnmatch = 0;\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = n_skip; i < sslot.nvalues - n_skip; i++)\n\t\t\t{\n\t\t\t\tif (varonleft ?\n\t\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   constval)) :\n\t\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])))\n\t\t\t\t\tnmatch++;\n\t\t\t}\n\t\t\tresult = ((double) nmatch) / ((double) (sslot.nvalues - 2 * n_skip));\n\t\t}\n\t\telse\n\t\t\tresult = -1;\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t*hist_size = 0;\n\t\tresult = -1;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "opproc",
            "DEFAULT_COLLATION_OID",
            "constval",
            "sslot.values[i]"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   constval)"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot",
            "vardata->statsTuple",
            "STATISTIC_KIND_HISTOGRAM",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statistic_proc_security_check",
          "args": [
            "vardata",
            "opproc->fn_oid"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "statistic_proc_security_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5167-5183",
          "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "min_hist_size > 2 * n_skip"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "n_skip >= 0"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nhistogram_selectivity(VariableStatData *vardata, FmgrInfo *opproc,\n\t\t\t\t\t  Datum constval, bool varonleft,\n\t\t\t\t\t  int min_hist_size, int n_skip,\n\t\t\t\t\t  int *hist_size)\n{\n\tdouble\t\tresult;\n\tAttStatsSlot sslot;\n\n\t/* check sanity of parameters */\n\tAssert(n_skip >= 0);\n\tAssert(min_hist_size > 2 * n_skip);\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\t*hist_size = sslot.nvalues;\n\t\tif (sslot.nvalues >= min_hist_size)\n\t\t{\n\t\t\tint\t\t\tnmatch = 0;\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = n_skip; i < sslot.nvalues - n_skip; i++)\n\t\t\t{\n\t\t\t\tif (varonleft ?\n\t\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t   constval)) :\n\t\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])))\n\t\t\t\t\tnmatch++;\n\t\t\t}\n\t\t\tresult = ((double) nmatch) / ((double) (sslot.nvalues - 2 * n_skip));\n\t\t}\n\t\telse\n\t\t\tresult = -1;\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t*hist_size = 0;\n\t\tresult = -1;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "mcv_selectivity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "638-676",
    "snippet": "double\nmcv_selectivity(VariableStatData *vardata, FmgrInfo *opproc,\n\t\t\t\tDatum constval, bool varonleft,\n\t\t\t\tdouble *sumcommonp)\n{\n\tdouble\t\tmcv_selec,\n\t\t\t\tsumcommon;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\tmcv_selec = 0.0;\n\tsumcommon = 0.0;\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t{\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (varonleft ?\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t   constval)) :\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])))\n\t\t\t\tmcv_selec += sslot.numbers[i];\n\t\t\tsumcommon += sslot.numbers[i];\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*sumcommonp = sumcommon;\n\treturn mcv_selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "opproc",
            "DEFAULT_COLLATION_OID",
            "constval",
            "sslot.values[i]"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t   constval)"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot",
            "vardata->statsTuple",
            "STATISTIC_KIND_MCV",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statistic_proc_security_check",
          "args": [
            "vardata",
            "opproc->fn_oid"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "statistic_proc_security_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5167-5183",
          "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nmcv_selectivity(VariableStatData *vardata, FmgrInfo *opproc,\n\t\t\t\tDatum constval, bool varonleft,\n\t\t\t\tdouble *sumcommonp)\n{\n\tdouble\t\tmcv_selec,\n\t\t\t\tsumcommon;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\tmcv_selec = 0.0;\n\tsumcommon = 0.0;\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t{\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (varonleft ?\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t   constval)) :\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])))\n\t\t\t\tmcv_selec += sslot.numbers[i];\n\t\t\tsumcommon += sslot.numbers[i];\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*sumcommonp = sumcommon;\n\treturn mcv_selec;\n}"
  },
  {
    "function_name": "scalarineqsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "563-624",
    "snippet": "static double\nscalarineqsel(PlannerInfo *root, Oid operator, bool isgt, bool iseq,\n\t\t\t  VariableStatData *vardata, Datum constval, Oid consttype)\n{\n\tForm_pg_statistic stats;\n\tFmgrInfo\topproc;\n\tdouble\t\tmcv_selec,\n\t\t\t\thist_selec,\n\t\t\t\tsumcommon;\n\tdouble\t\tselec;\n\n\tif (!HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* no stats available, so default result */\n\t\treturn DEFAULT_INEQ_SEL;\n\t}\n\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\n\tfmgr_info(get_opcode(operator), &opproc);\n\n\t/*\n\t * If we have most-common-values info, add up the fractions of the MCV\n\t * entries that satisfy MCV OP CONST.  These fractions contribute directly\n\t * to the result selectivity.  Also add up the total fraction represented\n\t * by MCV entries.\n\t */\n\tmcv_selec = mcv_selectivity(vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t&sumcommon);\n\n\t/*\n\t * If there is a histogram, determine which bin the constant falls in, and\n\t * compute the resulting contribution to selectivity.\n\t */\n\thist_selec = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t\t&opproc, isgt, iseq,\n\t\t\t\t\t\t\t\t\t\t\tconstval, consttype);\n\n\t/*\n\t * Now merge the results from the MCV and histogram calculations,\n\t * realizing that the histogram covers only the non-null values that are\n\t * not listed in MCV.\n\t */\n\tselec = 1.0 - stats->stanullfrac - sumcommon;\n\n\tif (hist_selec >= 0.0)\n\t\tselec *= hist_selec;\n\telse\n\t{\n\t\t/*\n\t\t * If no histogram but there are values not accounted for by MCV,\n\t\t * arbitrarily assume half of them will match.\n\t\t */\n\t\tselec *= 0.5;\n\t}\n\n\tselec += mcv_selec;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ineq_histogram_selectivity",
          "args": [
            "root",
            "vardata",
            "&opproc",
            "isgt",
            "iseq",
            "constval",
            "consttype"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "ineq_histogram_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "776-1079",
          "snippet": "static double\nineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype)\n{\n\tdouble\t\thist_selec;\n\tAttStatsSlot sslot;\n\n\thist_selec = -1.0;\n\n\t/*\n\t * Someday, ANALYZE might store more than one histogram per rel/att,\n\t * corresponding to more than one possible sort ordering defined for the\n\t * column type.  However, to make that work we will need to figure out\n\t * which staop to search for --- it's not necessarily the one we have at\n\t * hand!  (For example, we might have a '<=' operator rather than the '<'\n\t * operator that will appear in staop.)  For now, assume that whatever\n\t * appears in pg_statistic is sorted the same way our operator sorts, or\n\t * the reverse way if isgt is true.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * Use binary search to find the desired location, namely the\n\t\t\t * right end of the histogram bin containing the comparison value,\n\t\t\t * which is the leftmost entry for which the comparison operator\n\t\t\t * succeeds (if isgt) or fails (if !isgt).  (If the given operator\n\t\t\t * isn't actually sort-compatible with the histogram, you'll get\n\t\t\t * garbage results ... but probably not any more garbage-y than\n\t\t\t * you would have from the old linear search.)\n\t\t\t *\n\t\t\t * In this loop, we pay no attention to whether the operator iseq\n\t\t\t * or not; that detail will be mopped up below.  (We cannot tell,\n\t\t\t * anyway, whether the operator thinks the values are equal.)\n\t\t\t *\n\t\t\t * If the binary search accesses the first or last histogram\n\t\t\t * entry, we try to replace that endpoint with the true column min\n\t\t\t * or max as found by get_actual_variable_range().  This\n\t\t\t * ameliorates misestimates when the min or max is moving as a\n\t\t\t * result of changes since the last ANALYZE.  Note that this could\n\t\t\t * result in effectively including MCVs into the histogram that\n\t\t\t * weren't there before, but we don't try to correct for that.\n\t\t\t */\n\t\t\tdouble\t\thistfrac;\n\t\t\tint\t\t\tlobound = 0;\t/* first possible slot to search */\n\t\t\tint\t\t\thibound = sslot.nvalues;\t/* last+1 slot to search */\n\t\t\tbool\t\thave_end = false;\n\n\t\t\t/*\n\t\t\t * If there are only two histogram entries, we'll want up-to-date\n\t\t\t * values for both.  (If there are more than two, we need at most\n\t\t\t * one of them to be updated, so we deal with that within the\n\t\t\t * loop.)\n\t\t\t */\n\t\t\tif (sslot.nvalues == 2)\n\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[1]);\n\n\t\t\twhile (lobound < hibound)\n\t\t\t{\n\t\t\t\tint\t\t\tprobe = (lobound + hibound) / 2;\n\t\t\t\tbool\t\tltcmp;\n\n\t\t\t\t/*\n\t\t\t\t * If we find ourselves about to compare to the first or last\n\t\t\t\t * histogram entry, first try to replace it with the actual\n\t\t\t\t * current min or max (unless we already did so above).\n\t\t\t\t */\n\t\t\t\tif (probe == 0 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\t\telse if (probe == sslot.nvalues - 1 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[probe]);\n\n\t\t\t\tltcmp = DatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[probe],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\tif (isgt)\n\t\t\t\t\tltcmp = !ltcmp;\n\t\t\t\tif (ltcmp)\n\t\t\t\t\tlobound = probe + 1;\n\t\t\t\telse\n\t\t\t\t\thibound = probe;\n\t\t\t}\n\n\t\t\tif (lobound <= 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Constant is below lower histogram boundary.  More\n\t\t\t\t * precisely, we have found that no entry in the histogram\n\t\t\t\t * satisfies the inequality clause (if !isgt) or they all do\n\t\t\t\t * (if isgt).  We estimate that that's true of the entire\n\t\t\t\t * table, so set histfrac to 0.0 (which we'll flip to 1.0\n\t\t\t\t * below, if isgt).\n\t\t\t\t */\n\t\t\t\thistfrac = 0.0;\n\t\t\t}\n\t\t\telse if (lobound >= sslot.nvalues)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Inverse case: constant is above upper histogram boundary.\n\t\t\t\t */\n\t\t\t\thistfrac = 1.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We have values[i-1] <= constant <= values[i]. */\n\t\t\t\tint\t\t\ti = lobound;\n\t\t\t\tdouble\t\teq_selec = 0;\n\t\t\t\tdouble\t\tval,\n\t\t\t\t\t\t\thigh,\n\t\t\t\t\t\t\tlow;\n\t\t\t\tdouble\t\tbinfrac;\n\n\t\t\t\t/*\n\t\t\t\t * In the cases where we'll need it below, obtain an estimate\n\t\t\t\t * of the selectivity of \"x = constval\".  We use a calculation\n\t\t\t\t * similar to what var_eq_const() does for a non-MCV constant,\n\t\t\t\t * ie, estimate that all distinct non-MCV values occur equally\n\t\t\t\t * often.  But multiplication by \"1.0 - sumcommon - nullfrac\"\n\t\t\t\t * will be done by our caller, so we shouldn't do that here.\n\t\t\t\t * Therefore we can't try to clamp the estimate by reference\n\t\t\t\t * to the least common MCV; the result would be too small.\n\t\t\t\t *\n\t\t\t\t * Note: since this is effectively assuming that constval\n\t\t\t\t * isn't an MCV, it's logically dubious if constval in fact is\n\t\t\t\t * one.  But we have to apply *some* correction for equality,\n\t\t\t\t * and anyway we cannot tell if constval is an MCV, since we\n\t\t\t\t * don't have a suitable equality operator at hand.\n\t\t\t\t */\n\t\t\t\tif (i == 1 || isgt == iseq)\n\t\t\t\t{\n\t\t\t\t\tdouble\t\totherdistinct;\n\t\t\t\t\tbool\t\tisdefault;\n\t\t\t\t\tAttStatsSlot mcvslot;\n\n\t\t\t\t\t/* Get estimated number of distinct values */\n\t\t\t\t\totherdistinct = get_variable_numdistinct(vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &isdefault);\n\n\t\t\t\t\t/* Subtract off the number of known MCVs */\n\t\t\t\t\tif (get_attstatsslot(&mcvslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t\t\t\t{\n\t\t\t\t\t\totherdistinct -= mcvslot.nnumbers;\n\t\t\t\t\t\tfree_attstatsslot(&mcvslot);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If result doesn't seem sane, leave eq_selec at 0 */\n\t\t\t\t\tif (otherdistinct > 1)\n\t\t\t\t\t\teq_selec = 1.0 / otherdistinct;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Convert the constant and the two nearest bin boundary\n\t\t\t\t * values to a uniform comparison scale, and do a linear\n\t\t\t\t * interpolation within this bin.\n\t\t\t\t */\n\t\t\t\tif (convert_to_scalar(constval, consttype, &val,\n\t\t\t\t\t\t\t\t\t  sslot.values[i - 1], sslot.values[i],\n\t\t\t\t\t\t\t\t\t  vardata->vartype,\n\t\t\t\t\t\t\t\t\t  &low, &high))\n\t\t\t\t{\n\t\t\t\t\tif (high <= low)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* cope if bin boundaries appear identical */\n\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t\telse if (val <= low)\n\t\t\t\t\t\tbinfrac = 0.0;\n\t\t\t\t\telse if (val >= high)\n\t\t\t\t\t\tbinfrac = 1.0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbinfrac = (val - low) / (high - low);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Watch out for the possibility that we got a NaN or\n\t\t\t\t\t\t * Infinity from the division.  This can happen\n\t\t\t\t\t\t * despite the previous checks, if for example \"low\"\n\t\t\t\t\t\t * is -Infinity.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (isnan(binfrac) ||\n\t\t\t\t\t\t\tbinfrac < 0.0 || binfrac > 1.0)\n\t\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Ideally we'd produce an error here, on the grounds that\n\t\t\t\t\t * the given operator shouldn't have scalarXXsel\n\t\t\t\t\t * registered as its selectivity func unless we can deal\n\t\t\t\t\t * with its operand types.  But currently, all manner of\n\t\t\t\t\t * stuff is invoking scalarXXsel, so give a default\n\t\t\t\t\t * estimate until that can be fixed.\n\t\t\t\t\t */\n\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Now, compute the overall selectivity across the values\n\t\t\t\t * represented by the histogram.  We have i-1 full bins and\n\t\t\t\t * binfrac partial bin below the constant.\n\t\t\t\t */\n\t\t\t\thistfrac = (double) (i - 1) + binfrac;\n\t\t\t\thistfrac /= (double) (sslot.nvalues - 1);\n\n\t\t\t\t/*\n\t\t\t\t * At this point, histfrac is an estimate of the fraction of\n\t\t\t\t * the population represented by the histogram that satisfies\n\t\t\t\t * \"x <= constval\".  Somewhat remarkably, this statement is\n\t\t\t\t * true regardless of which operator we were doing the probes\n\t\t\t\t * with, so long as convert_to_scalar() delivers reasonable\n\t\t\t\t * results.  If the probe constant is equal to some histogram\n\t\t\t\t * entry, we would have considered the bin to the left of that\n\t\t\t\t * entry if probing with \"<\" or \">=\", or the bin to the right\n\t\t\t\t * if probing with \"<=\" or \">\"; but binfrac would have come\n\t\t\t\t * out as 1.0 in the first case and 0.0 in the second, leading\n\t\t\t\t * to the same histfrac in either case.  For probe constants\n\t\t\t\t * between histogram entries, we find the same bin and get the\n\t\t\t\t * same estimate with any operator.\n\t\t\t\t *\n\t\t\t\t * The fact that the estimate corresponds to \"x <= constval\"\n\t\t\t\t * and not \"x < constval\" is because of the way that ANALYZE\n\t\t\t\t * constructs the histogram: each entry is, effectively, the\n\t\t\t\t * rightmost value in its sample bucket.  So selectivity\n\t\t\t\t * values that are exact multiples of 1/(histogram_size-1)\n\t\t\t\t * should be understood as estimates including a histogram\n\t\t\t\t * entry plus everything to its left.\n\t\t\t\t *\n\t\t\t\t * However, that breaks down for the first histogram entry,\n\t\t\t\t * which necessarily is the leftmost value in its sample\n\t\t\t\t * bucket.  That means the first histogram bin is slightly\n\t\t\t\t * narrower than the rest, by an amount equal to eq_selec.\n\t\t\t\t * Another way to say that is that we want \"x <= leftmost\" to\n\t\t\t\t * be estimated as eq_selec not zero.  So, if we're dealing\n\t\t\t\t * with the first bin (i==1), rescale to make that true while\n\t\t\t\t * adjusting the rest of that bin linearly.\n\t\t\t\t */\n\t\t\t\tif (i == 1)\n\t\t\t\t\thistfrac += eq_selec * (1.0 - binfrac);\n\n\t\t\t\t/*\n\t\t\t\t * \"x <= constval\" is good if we want an estimate for \"<=\" or\n\t\t\t\t * \">\", but if we are estimating for \"<\" or \">=\", we now need\n\t\t\t\t * to decrease the estimate by eq_selec.\n\t\t\t\t */\n\t\t\t\tif (isgt == iseq)\n\t\t\t\t\thistfrac -= eq_selec;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now the estimate is finished for \"<\" and \"<=\" cases.  If we are\n\t\t\t * estimating for \">\" or \">=\", flip it.\n\t\t\t */\n\t\t\thist_selec = isgt ? (1.0 - histfrac) : histfrac;\n\n\t\t\t/*\n\t\t\t * The histogram boundaries are only approximate to begin with,\n\t\t\t * and may well be out of date anyway.  Therefore, don't believe\n\t\t\t * extremely small or large selectivity estimates --- unless we\n\t\t\t * got actual current endpoint values from the table, in which\n\t\t\t * case just do the usual sanity clamp.  Somewhat arbitrarily, we\n\t\t\t * set the cutoff for other cases at a hundredth of the histogram\n\t\t\t * resolution.\n\t\t\t */\n\t\t\tif (have_end)\n\t\t\t\tCLAMP_PROBABILITY(hist_selec);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble\t\tcutoff = 0.01 / (double) (sslot.nvalues - 1);\n\n\t\t\t\tif (hist_selec < cutoff)\n\t\t\t\t\thist_selec = cutoff;\n\t\t\t\telse if (hist_selec > 1.0 - cutoff)\n\t\t\t\t\thist_selec = 1.0 - cutoff;\n\t\t\t}\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\treturn hist_selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);",
            "static bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);",
            "static bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\nstatic bool get_variable_range(PlannerInfo *root, VariableStatData *vardata,\n\t\t\t\t   Oid sortop, Datum *min, Datum *max);\nstatic bool get_actual_variable_range(PlannerInfo *root,\n\t\t\t\t\t\t  VariableStatData *vardata,\n\t\t\t\t\t\t  Oid sortop,\n\t\t\t\t\t\t  Datum *min, Datum *max);\n\nstatic double\nineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype)\n{\n\tdouble\t\thist_selec;\n\tAttStatsSlot sslot;\n\n\thist_selec = -1.0;\n\n\t/*\n\t * Someday, ANALYZE might store more than one histogram per rel/att,\n\t * corresponding to more than one possible sort ordering defined for the\n\t * column type.  However, to make that work we will need to figure out\n\t * which staop to search for --- it's not necessarily the one we have at\n\t * hand!  (For example, we might have a '<=' operator rather than the '<'\n\t * operator that will appear in staop.)  For now, assume that whatever\n\t * appears in pg_statistic is sorted the same way our operator sorts, or\n\t * the reverse way if isgt is true.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES))\n\t{\n\t\tif (sslot.nvalues > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * Use binary search to find the desired location, namely the\n\t\t\t * right end of the histogram bin containing the comparison value,\n\t\t\t * which is the leftmost entry for which the comparison operator\n\t\t\t * succeeds (if isgt) or fails (if !isgt).  (If the given operator\n\t\t\t * isn't actually sort-compatible with the histogram, you'll get\n\t\t\t * garbage results ... but probably not any more garbage-y than\n\t\t\t * you would have from the old linear search.)\n\t\t\t *\n\t\t\t * In this loop, we pay no attention to whether the operator iseq\n\t\t\t * or not; that detail will be mopped up below.  (We cannot tell,\n\t\t\t * anyway, whether the operator thinks the values are equal.)\n\t\t\t *\n\t\t\t * If the binary search accesses the first or last histogram\n\t\t\t * entry, we try to replace that endpoint with the true column min\n\t\t\t * or max as found by get_actual_variable_range().  This\n\t\t\t * ameliorates misestimates when the min or max is moving as a\n\t\t\t * result of changes since the last ANALYZE.  Note that this could\n\t\t\t * result in effectively including MCVs into the histogram that\n\t\t\t * weren't there before, but we don't try to correct for that.\n\t\t\t */\n\t\t\tdouble\t\thistfrac;\n\t\t\tint\t\t\tlobound = 0;\t/* first possible slot to search */\n\t\t\tint\t\t\thibound = sslot.nvalues;\t/* last+1 slot to search */\n\t\t\tbool\t\thave_end = false;\n\n\t\t\t/*\n\t\t\t * If there are only two histogram entries, we'll want up-to-date\n\t\t\t * values for both.  (If there are more than two, we need at most\n\t\t\t * one of them to be updated, so we deal with that within the\n\t\t\t * loop.)\n\t\t\t */\n\t\t\tif (sslot.nvalues == 2)\n\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[1]);\n\n\t\t\twhile (lobound < hibound)\n\t\t\t{\n\t\t\t\tint\t\t\tprobe = (lobound + hibound) / 2;\n\t\t\t\tbool\t\tltcmp;\n\n\t\t\t\t/*\n\t\t\t\t * If we find ourselves about to compare to the first or last\n\t\t\t\t * histogram entry, first try to replace it with the actual\n\t\t\t\t * current min or max (unless we already did so above).\n\t\t\t\t */\n\t\t\t\tif (probe == 0 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\t\telse if (probe == sslot.nvalues - 1 && sslot.nvalues > 2)\n\t\t\t\t\thave_end = get_actual_variable_range(root,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sslot.staop,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t &sslot.values[probe]);\n\n\t\t\t\tltcmp = DatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[probe],\n\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\tif (isgt)\n\t\t\t\t\tltcmp = !ltcmp;\n\t\t\t\tif (ltcmp)\n\t\t\t\t\tlobound = probe + 1;\n\t\t\t\telse\n\t\t\t\t\thibound = probe;\n\t\t\t}\n\n\t\t\tif (lobound <= 0)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Constant is below lower histogram boundary.  More\n\t\t\t\t * precisely, we have found that no entry in the histogram\n\t\t\t\t * satisfies the inequality clause (if !isgt) or they all do\n\t\t\t\t * (if isgt).  We estimate that that's true of the entire\n\t\t\t\t * table, so set histfrac to 0.0 (which we'll flip to 1.0\n\t\t\t\t * below, if isgt).\n\t\t\t\t */\n\t\t\t\thistfrac = 0.0;\n\t\t\t}\n\t\t\telse if (lobound >= sslot.nvalues)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Inverse case: constant is above upper histogram boundary.\n\t\t\t\t */\n\t\t\t\thistfrac = 1.0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We have values[i-1] <= constant <= values[i]. */\n\t\t\t\tint\t\t\ti = lobound;\n\t\t\t\tdouble\t\teq_selec = 0;\n\t\t\t\tdouble\t\tval,\n\t\t\t\t\t\t\thigh,\n\t\t\t\t\t\t\tlow;\n\t\t\t\tdouble\t\tbinfrac;\n\n\t\t\t\t/*\n\t\t\t\t * In the cases where we'll need it below, obtain an estimate\n\t\t\t\t * of the selectivity of \"x = constval\".  We use a calculation\n\t\t\t\t * similar to what var_eq_const() does for a non-MCV constant,\n\t\t\t\t * ie, estimate that all distinct non-MCV values occur equally\n\t\t\t\t * often.  But multiplication by \"1.0 - sumcommon - nullfrac\"\n\t\t\t\t * will be done by our caller, so we shouldn't do that here.\n\t\t\t\t * Therefore we can't try to clamp the estimate by reference\n\t\t\t\t * to the least common MCV; the result would be too small.\n\t\t\t\t *\n\t\t\t\t * Note: since this is effectively assuming that constval\n\t\t\t\t * isn't an MCV, it's logically dubious if constval in fact is\n\t\t\t\t * one.  But we have to apply *some* correction for equality,\n\t\t\t\t * and anyway we cannot tell if constval is an MCV, since we\n\t\t\t\t * don't have a suitable equality operator at hand.\n\t\t\t\t */\n\t\t\t\tif (i == 1 || isgt == iseq)\n\t\t\t\t{\n\t\t\t\t\tdouble\t\totherdistinct;\n\t\t\t\t\tbool\t\tisdefault;\n\t\t\t\t\tAttStatsSlot mcvslot;\n\n\t\t\t\t\t/* Get estimated number of distinct values */\n\t\t\t\t\totherdistinct = get_variable_numdistinct(vardata,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t &isdefault);\n\n\t\t\t\t\t/* Subtract off the number of known MCVs */\n\t\t\t\t\tif (get_attstatsslot(&mcvslot, vardata->statsTuple,\n\t\t\t\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t\t\t\t{\n\t\t\t\t\t\totherdistinct -= mcvslot.nnumbers;\n\t\t\t\t\t\tfree_attstatsslot(&mcvslot);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If result doesn't seem sane, leave eq_selec at 0 */\n\t\t\t\t\tif (otherdistinct > 1)\n\t\t\t\t\t\teq_selec = 1.0 / otherdistinct;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Convert the constant and the two nearest bin boundary\n\t\t\t\t * values to a uniform comparison scale, and do a linear\n\t\t\t\t * interpolation within this bin.\n\t\t\t\t */\n\t\t\t\tif (convert_to_scalar(constval, consttype, &val,\n\t\t\t\t\t\t\t\t\t  sslot.values[i - 1], sslot.values[i],\n\t\t\t\t\t\t\t\t\t  vardata->vartype,\n\t\t\t\t\t\t\t\t\t  &low, &high))\n\t\t\t\t{\n\t\t\t\t\tif (high <= low)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* cope if bin boundaries appear identical */\n\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t\telse if (val <= low)\n\t\t\t\t\t\tbinfrac = 0.0;\n\t\t\t\t\telse if (val >= high)\n\t\t\t\t\t\tbinfrac = 1.0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbinfrac = (val - low) / (high - low);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Watch out for the possibility that we got a NaN or\n\t\t\t\t\t\t * Infinity from the division.  This can happen\n\t\t\t\t\t\t * despite the previous checks, if for example \"low\"\n\t\t\t\t\t\t * is -Infinity.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (isnan(binfrac) ||\n\t\t\t\t\t\t\tbinfrac < 0.0 || binfrac > 1.0)\n\t\t\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Ideally we'd produce an error here, on the grounds that\n\t\t\t\t\t * the given operator shouldn't have scalarXXsel\n\t\t\t\t\t * registered as its selectivity func unless we can deal\n\t\t\t\t\t * with its operand types.  But currently, all manner of\n\t\t\t\t\t * stuff is invoking scalarXXsel, so give a default\n\t\t\t\t\t * estimate until that can be fixed.\n\t\t\t\t\t */\n\t\t\t\t\tbinfrac = 0.5;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Now, compute the overall selectivity across the values\n\t\t\t\t * represented by the histogram.  We have i-1 full bins and\n\t\t\t\t * binfrac partial bin below the constant.\n\t\t\t\t */\n\t\t\t\thistfrac = (double) (i - 1) + binfrac;\n\t\t\t\thistfrac /= (double) (sslot.nvalues - 1);\n\n\t\t\t\t/*\n\t\t\t\t * At this point, histfrac is an estimate of the fraction of\n\t\t\t\t * the population represented by the histogram that satisfies\n\t\t\t\t * \"x <= constval\".  Somewhat remarkably, this statement is\n\t\t\t\t * true regardless of which operator we were doing the probes\n\t\t\t\t * with, so long as convert_to_scalar() delivers reasonable\n\t\t\t\t * results.  If the probe constant is equal to some histogram\n\t\t\t\t * entry, we would have considered the bin to the left of that\n\t\t\t\t * entry if probing with \"<\" or \">=\", or the bin to the right\n\t\t\t\t * if probing with \"<=\" or \">\"; but binfrac would have come\n\t\t\t\t * out as 1.0 in the first case and 0.0 in the second, leading\n\t\t\t\t * to the same histfrac in either case.  For probe constants\n\t\t\t\t * between histogram entries, we find the same bin and get the\n\t\t\t\t * same estimate with any operator.\n\t\t\t\t *\n\t\t\t\t * The fact that the estimate corresponds to \"x <= constval\"\n\t\t\t\t * and not \"x < constval\" is because of the way that ANALYZE\n\t\t\t\t * constructs the histogram: each entry is, effectively, the\n\t\t\t\t * rightmost value in its sample bucket.  So selectivity\n\t\t\t\t * values that are exact multiples of 1/(histogram_size-1)\n\t\t\t\t * should be understood as estimates including a histogram\n\t\t\t\t * entry plus everything to its left.\n\t\t\t\t *\n\t\t\t\t * However, that breaks down for the first histogram entry,\n\t\t\t\t * which necessarily is the leftmost value in its sample\n\t\t\t\t * bucket.  That means the first histogram bin is slightly\n\t\t\t\t * narrower than the rest, by an amount equal to eq_selec.\n\t\t\t\t * Another way to say that is that we want \"x <= leftmost\" to\n\t\t\t\t * be estimated as eq_selec not zero.  So, if we're dealing\n\t\t\t\t * with the first bin (i==1), rescale to make that true while\n\t\t\t\t * adjusting the rest of that bin linearly.\n\t\t\t\t */\n\t\t\t\tif (i == 1)\n\t\t\t\t\thistfrac += eq_selec * (1.0 - binfrac);\n\n\t\t\t\t/*\n\t\t\t\t * \"x <= constval\" is good if we want an estimate for \"<=\" or\n\t\t\t\t * \">\", but if we are estimating for \"<\" or \">=\", we now need\n\t\t\t\t * to decrease the estimate by eq_selec.\n\t\t\t\t */\n\t\t\t\tif (isgt == iseq)\n\t\t\t\t\thistfrac -= eq_selec;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now the estimate is finished for \"<\" and \"<=\" cases.  If we are\n\t\t\t * estimating for \">\" or \">=\", flip it.\n\t\t\t */\n\t\t\thist_selec = isgt ? (1.0 - histfrac) : histfrac;\n\n\t\t\t/*\n\t\t\t * The histogram boundaries are only approximate to begin with,\n\t\t\t * and may well be out of date anyway.  Therefore, don't believe\n\t\t\t * extremely small or large selectivity estimates --- unless we\n\t\t\t * got actual current endpoint values from the table, in which\n\t\t\t * case just do the usual sanity clamp.  Somewhat arbitrarily, we\n\t\t\t * set the cutoff for other cases at a hundredth of the histogram\n\t\t\t * resolution.\n\t\t\t */\n\t\t\tif (have_end)\n\t\t\t\tCLAMP_PROBABILITY(hist_selec);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble\t\tcutoff = 0.01 / (double) (sslot.nvalues - 1);\n\n\t\t\t\tif (hist_selec < cutoff)\n\t\t\t\t\thist_selec = cutoff;\n\t\t\t\telse if (hist_selec > 1.0 - cutoff)\n\t\t\t\t\thist_selec = 1.0 - cutoff;\n\t\t\t}\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\treturn hist_selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mcv_selectivity",
          "args": [
            "vardata",
            "&opproc",
            "constval",
            "true",
            "&sumcommon"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "mcv_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "638-676",
          "snippet": "double\nmcv_selectivity(VariableStatData *vardata, FmgrInfo *opproc,\n\t\t\t\tDatum constval, bool varonleft,\n\t\t\t\tdouble *sumcommonp)\n{\n\tdouble\t\tmcv_selec,\n\t\t\t\tsumcommon;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\tmcv_selec = 0.0;\n\tsumcommon = 0.0;\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t{\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (varonleft ?\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t   constval)) :\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])))\n\t\t\t\tmcv_selec += sslot.numbers[i];\n\t\t\tsumcommon += sslot.numbers[i];\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*sumcommonp = sumcommon;\n\treturn mcv_selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nmcv_selectivity(VariableStatData *vardata, FmgrInfo *opproc,\n\t\t\t\tDatum constval, bool varonleft,\n\t\t\t\tdouble *sumcommonp)\n{\n\tdouble\t\tmcv_selec,\n\t\t\t\tsumcommon;\n\tAttStatsSlot sslot;\n\tint\t\t\ti;\n\n\tmcv_selec = 0.0;\n\tsumcommon = 0.0;\n\n\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\tstatistic_proc_security_check(vardata, opproc->fn_oid) &&\n\t\tget_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t{\n\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t{\n\t\t\tif (varonleft ?\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t   constval)) :\n\t\t\t\tDatumGetBool(FunctionCall2Coll(opproc,\n\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])))\n\t\t\t\tmcv_selec += sslot.numbers[i];\n\t\t\tsumcommon += sslot.numbers[i];\n\t\t}\n\t\tfree_attstatsslot(&sslot);\n\t}\n\n\t*sumcommonp = sumcommon;\n\treturn mcv_selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "get_opcode(operator)",
            "&opproc"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "operator"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double ineq_histogram_selectivity(PlannerInfo *root,\n\t\t\t\t\t\t   VariableStatData *vardata,\n\t\t\t\t\t\t   FmgrInfo *opproc, bool isgt, bool iseq,\n\t\t\t\t\t\t   Datum constval, Oid consttype);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\nscalarineqsel(PlannerInfo *root, Oid operator, bool isgt, bool iseq,\n\t\t\t  VariableStatData *vardata, Datum constval, Oid consttype)\n{\n\tForm_pg_statistic stats;\n\tFmgrInfo\topproc;\n\tdouble\t\tmcv_selec,\n\t\t\t\thist_selec,\n\t\t\t\tsumcommon;\n\tdouble\t\tselec;\n\n\tif (!HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* no stats available, so default result */\n\t\treturn DEFAULT_INEQ_SEL;\n\t}\n\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\n\tfmgr_info(get_opcode(operator), &opproc);\n\n\t/*\n\t * If we have most-common-values info, add up the fractions of the MCV\n\t * entries that satisfy MCV OP CONST.  These fractions contribute directly\n\t * to the result selectivity.  Also add up the total fraction represented\n\t * by MCV entries.\n\t */\n\tmcv_selec = mcv_selectivity(vardata, &opproc, constval, true,\n\t\t\t\t\t\t\t\t&sumcommon);\n\n\t/*\n\t * If there is a histogram, determine which bin the constant falls in, and\n\t * compute the resulting contribution to selectivity.\n\t */\n\thist_selec = ineq_histogram_selectivity(root, vardata,\n\t\t\t\t\t\t\t\t\t\t\t&opproc, isgt, iseq,\n\t\t\t\t\t\t\t\t\t\t\tconstval, consttype);\n\n\t/*\n\t * Now merge the results from the MCV and histogram calculations,\n\t * realizing that the histogram covers only the non-null values that are\n\t * not listed in MCV.\n\t */\n\tselec = 1.0 - stats->stanullfrac - sumcommon;\n\n\tif (hist_selec >= 0.0)\n\t\tselec *= hist_selec;\n\telse\n\t{\n\t\t/*\n\t\t * If no histogram but there are values not accounted for by MCV,\n\t\t * arbitrarily assume half of them will match.\n\t\t */\n\t\tselec *= 0.5;\n\t}\n\n\tselec += mcv_selec;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "neqsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "540-544",
    "snippet": "Datum\nneqsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8((float8) eqsel_internal(fcinfo, true));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) eqsel_internal(fcinfo, true)"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eqsel_internal",
          "args": [
            "fcinfo",
            "true"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "eqsel_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "239-290",
          "snippet": "static double\neqsel_internal(PG_FUNCTION_ARGS, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tdouble\t\tselec;\n\n\t/*\n\t * When asked about <>, we do the estimation using the corresponding =\n\t * operator, then convert to <> via \"1.0 - eq_selectivity - nullfrac\".\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\treturn 1.0 - DEFAULT_EQ_SEL;\n\t\t}\n\t}\n\n\t/*\n\t * If expression is not variable = something or something = variable, then\n\t * punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn negate ? (1.0 - DEFAULT_EQ_SEL) : DEFAULT_EQ_SEL;\n\n\t/*\n\t * We can do a lot better if the something is a constant.  (Note: the\n\t * Const might result from estimation rather than being a simple constant\n\t * in the query.)\n\t */\n\tif (IsA(other, Const))\n\t\tselec = var_eq_const(&vardata, operator,\n\t\t\t\t\t\t\t ((Const *) other)->constvalue,\n\t\t\t\t\t\t\t ((Const *) other)->constisnull,\n\t\t\t\t\t\t\t varonleft, negate);\n\telse\n\t\tselec = var_eq_non_const(&vardata, operator, other,\n\t\t\t\t\t\t\t\t varonleft, negate);\n\n\tReleaseVariableStats(vardata);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\neqsel_internal(PG_FUNCTION_ARGS, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tdouble\t\tselec;\n\n\t/*\n\t * When asked about <>, we do the estimation using the corresponding =\n\t * operator, then convert to <> via \"1.0 - eq_selectivity - nullfrac\".\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\treturn 1.0 - DEFAULT_EQ_SEL;\n\t\t}\n\t}\n\n\t/*\n\t * If expression is not variable = something or something = variable, then\n\t * punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn negate ? (1.0 - DEFAULT_EQ_SEL) : DEFAULT_EQ_SEL;\n\n\t/*\n\t * We can do a lot better if the something is a constant.  (Note: the\n\t * Const might result from estimation rather than being a simple constant\n\t * in the query.)\n\t */\n\tif (IsA(other, Const))\n\t\tselec = var_eq_const(&vardata, operator,\n\t\t\t\t\t\t\t ((Const *) other)->constvalue,\n\t\t\t\t\t\t\t ((Const *) other)->constisnull,\n\t\t\t\t\t\t\t varonleft, negate);\n\telse\n\t\tselec = var_eq_non_const(&vardata, operator, other,\n\t\t\t\t\t\t\t\t varonleft, negate);\n\n\tReleaseVariableStats(vardata);\n\n\treturn selec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nneqsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8((float8) eqsel_internal(fcinfo, true));\n}"
  },
  {
    "function_name": "var_eq_non_const",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "449-531",
    "snippet": "static double\nvar_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tdouble\t\tndistinct;\n\t\tAttStatsSlot sslot;\n\n\t\t/*\n\t\t * Search is for a value that we do not know a priori, but we will\n\t\t * assume it is not NULL.  Estimate the selectivity as non-null\n\t\t * fraction divided by number of distinct values, so that we get a\n\t\t * result averaged over all possible values whether common or\n\t\t * uncommon.  (Essentially, we are assuming that the not-yet-known\n\t\t * comparison value is equally likely to be any of the possible\n\t\t * values, regardless of their frequency in the table.  Is that a good\n\t\t * idea?)\n\t\t */\n\t\tselec = 1.0 - nullfrac;\n\t\tndistinct = get_variable_numdistinct(vardata, &isdefault);\n\t\tif (ndistinct > 1)\n\t\t\tselec /= ndistinct;\n\n\t\t/*\n\t\t * Cross-check: selectivity should never be estimated as more than the\n\t\t * most common value's.\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[0])\n\t\t\t\tselec = sslot.numbers[0];\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
      "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
      "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
      "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_variable_numdistinct",
          "args": [
            "vardata",
            "&isdefault"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "get_variable_numdistinct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5196-5318",
          "snippet": "double\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot",
            "vardata->statsTuple",
            "STATISTIC_KIND_MCV",
            "InvalidOid",
            "ATTSTATSSLOT_NUMBERS"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\nvar_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tdouble\t\tndistinct;\n\t\tAttStatsSlot sslot;\n\n\t\t/*\n\t\t * Search is for a value that we do not know a priori, but we will\n\t\t * assume it is not NULL.  Estimate the selectivity as non-null\n\t\t * fraction divided by number of distinct values, so that we get a\n\t\t * result averaged over all possible values whether common or\n\t\t * uncommon.  (Essentially, we are assuming that the not-yet-known\n\t\t * comparison value is equally likely to be any of the possible\n\t\t * values, regardless of their frequency in the table.  Is that a good\n\t\t * idea?)\n\t\t */\n\t\tselec = 1.0 - nullfrac;\n\t\tndistinct = get_variable_numdistinct(vardata, &isdefault);\n\t\tif (ndistinct > 1)\n\t\t\tselec /= ndistinct;\n\n\t\t/*\n\t\t * Cross-check: selectivity should never be estimated as more than the\n\t\t * most common value's.\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[0])\n\t\t\t\tselec = sslot.numbers[0];\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "var_eq_const",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "297-444",
    "snippet": "static double\nvar_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\tOid\t\t\topfuncoid;\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (constisnull)\n\t\treturn 0.0;\n\n\t/*\n\t * Grab the nullfrac for use below.  Note we allow use of nullfrac\n\t * regardless of security check.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(operator))))\n\t{\n\t\tAttStatsSlot sslot;\n\t\tbool\t\tmatch = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * Is the constant \"=\" to any of the column's most common values?\n\t\t * (Although the given operator may not really be \"=\", we will assume\n\t\t * that seeing whether it returns TRUE is an appropriate test.  If you\n\t\t * don't like this, maybe you shouldn't be using eqsel for your\n\t\t * operator...)\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tFmgrInfo\teqproc;\n\n\t\t\tfmgr_info(opfuncoid, &eqproc);\n\n\t\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t\t{\n\t\t\t\t/* be careful to apply operator right way 'round */\n\t\t\t\tif (varonleft)\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\telse\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i]));\n\t\t\t\tif (match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no most-common-value info available */\n\t\t\ti = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/*\n\t\t\t * Constant is \"=\" to this common value.  We know selectivity\n\t\t\t * exactly (or as exactly as ANALYZE could calculate it, anyway).\n\t\t\t */\n\t\t\tselec = sslot.numbers[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Comparison is against a constant that is neither NULL nor any\n\t\t\t * of the common values.  Its selectivity cannot be more than\n\t\t\t * this:\n\t\t\t */\n\t\t\tdouble\t\tsumcommon = 0.0;\n\t\t\tdouble\t\totherdistinct;\n\n\t\t\tfor (i = 0; i < sslot.nnumbers; i++)\n\t\t\t\tsumcommon += sslot.numbers[i];\n\t\t\tselec = 1.0 - sumcommon - nullfrac;\n\t\t\tCLAMP_PROBABILITY(selec);\n\n\t\t\t/*\n\t\t\t * and in fact it's probably a good deal less. We approximate that\n\t\t\t * all the not-common values share this remaining fraction\n\t\t\t * equally, so we divide by the number of other distinct values.\n\t\t\t */\n\t\t\totherdistinct = get_variable_numdistinct(vardata, &isdefault) -\n\t\t\t\tsslot.nnumbers;\n\t\t\tif (otherdistinct > 1)\n\t\t\t\tselec /= otherdistinct;\n\n\t\t\t/*\n\t\t\t * Another cross-check: selectivity shouldn't be estimated as more\n\t\t\t * than the least common \"most common value\".\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[sslot.nnumbers - 1])\n\t\t\t\tselec = sslot.numbers[sslot.nnumbers - 1];\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
      "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
      "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_variable_numdistinct",
          "args": [
            "vardata",
            "&isdefault"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "get_variable_numdistinct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5196-5318",
          "snippet": "double\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\ndouble\nget_variable_numdistinct(VariableStatData *vardata, bool *isdefault)\n{\n\tdouble\t\tstadistinct;\n\tdouble\t\tstanullfrac = 0.0;\n\tdouble\t\tntuples;\n\n\t*isdefault = false;\n\n\t/*\n\t * Determine the stadistinct value to use.  There are cases where we can\n\t * get an estimate even without a pg_statistic entry, or can get a better\n\t * value than is in pg_statistic.  Grab stanullfrac too if we can find it\n\t * (otherwise, assume no nulls, for lack of any better idea).\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\t/* Use the pg_statistic entry */\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tstadistinct = stats->stadistinct;\n\t\tstanullfrac = stats->stanullfrac;\n\t}\n\telse if (vardata->vartype == BOOLOID)\n\t{\n\t\t/*\n\t\t * Special-case boolean columns: presumably, two distinct values.\n\t\t *\n\t\t * Are there any other datatypes we should wire in special estimates\n\t\t * for?\n\t\t */\n\t\tstadistinct = 2.0;\n\t}\n\telse if (vardata->rel && vardata->rel->rtekind == RTE_VALUES)\n\t{\n\t\t/*\n\t\t * If the Var represents a column of a VALUES RTE, assume it's unique.\n\t\t * This could of course be very wrong, but it should tend to be true\n\t\t * in well-written queries.  We could consider examining the VALUES'\n\t\t * contents to get some real statistics; but that only works if the\n\t\t * entries are all constants, and it would be pretty expensive anyway.\n\t\t */\n\t\tstadistinct = -1.0;\t\t/* unique (and all non null) */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't keep statistics for system columns, but in some cases we\n\t\t * can infer distinctness anyway.\n\t\t */\n\t\tif (vardata->var && IsA(vardata->var, Var))\n\t\t{\n\t\t\tswitch (((Var *) vardata->var)->varattno)\n\t\t\t{\n\t\t\t\tcase ObjectIdAttributeNumber:\n\t\t\t\tcase SelfItemPointerAttributeNumber:\n\t\t\t\t\tstadistinct = -1.0; /* unique (and all non null) */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TableOidAttributeNumber:\n\t\t\t\t\tstadistinct = 1.0;\t/* only 1 value */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tstadistinct = 0.0;\t/* means \"unknown\" */\n\n\t\t/*\n\t\t * XXX consider using estimate_num_groups on expressions?\n\t\t */\n\t}\n\n\t/*\n\t * If there is a unique index or DISTINCT clause for the variable, assume\n\t * it is unique no matter what pg_statistic says; the statistics could be\n\t * out of date, or we might have found a partial unique index that proves\n\t * the var is unique for this query.  However, we'd better still believe\n\t * the null-fraction statistic.\n\t */\n\tif (vardata->isunique)\n\t\tstadistinct = -1.0 * (1.0 - stanullfrac);\n\n\t/*\n\t * If we had an absolute estimate, use that.\n\t */\n\tif (stadistinct > 0.0)\n\t\treturn clamp_row_est(stadistinct);\n\n\t/*\n\t * Otherwise we need to get the relation size; punt if not available.\n\t */\n\tif (vardata->rel == NULL)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\tntuples = vardata->rel->tuples;\n\tif (ntuples <= 0.0)\n\t{\n\t\t*isdefault = true;\n\t\treturn DEFAULT_NUM_DISTINCT;\n\t}\n\n\t/*\n\t * If we had a relative estimate, use that.\n\t */\n\tif (stadistinct < 0.0)\n\t\treturn clamp_row_est(-stadistinct * ntuples);\n\n\t/*\n\t * With no data, estimate ndistinct = ntuples if the table is small, else\n\t * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for \"small\" so\n\t * that the behavior isn't discontinuous.\n\t */\n\tif (ntuples < DEFAULT_NUM_DISTINCT)\n\t\treturn clamp_row_est(ntuples);\n\n\t*isdefault = true;\n\treturn DEFAULT_NUM_DISTINCT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i])"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&eqproc",
            "DEFAULT_COLLATION_OID",
            "constval",
            "sslot.values[i]"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "opfuncoid",
            "&eqproc"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot",
            "vardata->statsTuple",
            "STATISTIC_KIND_MCV",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "statistic_proc_security_check",
          "args": [
            "vardata",
            "(opfuncoid = get_opcode(operator))"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "statistic_proc_security_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5167-5183",
          "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "operator"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\nvar_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\tOid\t\t\topfuncoid;\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (constisnull)\n\t\treturn 0.0;\n\n\t/*\n\t * Grab the nullfrac for use below.  Note we allow use of nullfrac\n\t * regardless of security check.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(operator))))\n\t{\n\t\tAttStatsSlot sslot;\n\t\tbool\t\tmatch = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * Is the constant \"=\" to any of the column's most common values?\n\t\t * (Although the given operator may not really be \"=\", we will assume\n\t\t * that seeing whether it returns TRUE is an appropriate test.  If you\n\t\t * don't like this, maybe you shouldn't be using eqsel for your\n\t\t * operator...)\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tFmgrInfo\teqproc;\n\n\t\t\tfmgr_info(opfuncoid, &eqproc);\n\n\t\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t\t{\n\t\t\t\t/* be careful to apply operator right way 'round */\n\t\t\t\tif (varonleft)\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\telse\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i]));\n\t\t\t\tif (match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no most-common-value info available */\n\t\t\ti = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/*\n\t\t\t * Constant is \"=\" to this common value.  We know selectivity\n\t\t\t * exactly (or as exactly as ANALYZE could calculate it, anyway).\n\t\t\t */\n\t\t\tselec = sslot.numbers[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Comparison is against a constant that is neither NULL nor any\n\t\t\t * of the common values.  Its selectivity cannot be more than\n\t\t\t * this:\n\t\t\t */\n\t\t\tdouble\t\tsumcommon = 0.0;\n\t\t\tdouble\t\totherdistinct;\n\n\t\t\tfor (i = 0; i < sslot.nnumbers; i++)\n\t\t\t\tsumcommon += sslot.numbers[i];\n\t\t\tselec = 1.0 - sumcommon - nullfrac;\n\t\t\tCLAMP_PROBABILITY(selec);\n\n\t\t\t/*\n\t\t\t * and in fact it's probably a good deal less. We approximate that\n\t\t\t * all the not-common values share this remaining fraction\n\t\t\t * equally, so we divide by the number of other distinct values.\n\t\t\t */\n\t\t\totherdistinct = get_variable_numdistinct(vardata, &isdefault) -\n\t\t\t\tsslot.nnumbers;\n\t\t\tif (otherdistinct > 1)\n\t\t\t\tselec /= otherdistinct;\n\n\t\t\t/*\n\t\t\t * Another cross-check: selectivity shouldn't be estimated as more\n\t\t\t * than the least common \"most common value\".\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[sslot.nnumbers - 1])\n\t\t\t\tselec = sslot.numbers[sslot.nnumbers - 1];\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "eqsel_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "239-290",
    "snippet": "static double\neqsel_internal(PG_FUNCTION_ARGS, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tdouble\t\tselec;\n\n\t/*\n\t * When asked about <>, we do the estimation using the corresponding =\n\t * operator, then convert to <> via \"1.0 - eq_selectivity - nullfrac\".\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\treturn 1.0 - DEFAULT_EQ_SEL;\n\t\t}\n\t}\n\n\t/*\n\t * If expression is not variable = something or something = variable, then\n\t * punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn negate ? (1.0 - DEFAULT_EQ_SEL) : DEFAULT_EQ_SEL;\n\n\t/*\n\t * We can do a lot better if the something is a constant.  (Note: the\n\t * Const might result from estimation rather than being a simple constant\n\t * in the query.)\n\t */\n\tif (IsA(other, Const))\n\t\tselec = var_eq_const(&vardata, operator,\n\t\t\t\t\t\t\t ((Const *) other)->constvalue,\n\t\t\t\t\t\t\t ((Const *) other)->constisnull,\n\t\t\t\t\t\t\t varonleft, negate);\n\telse\n\t\tselec = var_eq_non_const(&vardata, operator, other,\n\t\t\t\t\t\t\t\t varonleft, negate);\n\n\tReleaseVariableStats(vardata);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
      "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
      "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
      "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "var_eq_non_const",
          "args": [
            "&vardata",
            "operator",
            "other",
            "varonleft",
            "negate"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "var_eq_non_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "449-531",
          "snippet": "static double\nvar_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tdouble\t\tndistinct;\n\t\tAttStatsSlot sslot;\n\n\t\t/*\n\t\t * Search is for a value that we do not know a priori, but we will\n\t\t * assume it is not NULL.  Estimate the selectivity as non-null\n\t\t * fraction divided by number of distinct values, so that we get a\n\t\t * result averaged over all possible values whether common or\n\t\t * uncommon.  (Essentially, we are assuming that the not-yet-known\n\t\t * comparison value is equally likely to be any of the possible\n\t\t * values, regardless of their frequency in the table.  Is that a good\n\t\t * idea?)\n\t\t */\n\t\tselec = 1.0 - nullfrac;\n\t\tndistinct = get_variable_numdistinct(vardata, &isdefault);\n\t\tif (ndistinct > 1)\n\t\t\tselec /= ndistinct;\n\n\t\t/*\n\t\t * Cross-check: selectivity should never be estimated as more than the\n\t\t * most common value's.\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[0])\n\t\t\t\tselec = sslot.numbers[0];\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic bool estimate_multivariate_ndistinct(PlannerInfo *root,\n\t\t\t\t\t\t\t\tRelOptInfo *rel, List **varinfos, double *ndistinct);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\nvar_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\n\t/*\n\t * Grab the nullfrac for use below.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tdouble\t\tndistinct;\n\t\tAttStatsSlot sslot;\n\n\t\t/*\n\t\t * Search is for a value that we do not know a priori, but we will\n\t\t * assume it is not NULL.  Estimate the selectivity as non-null\n\t\t * fraction divided by number of distinct values, so that we get a\n\t\t * result averaged over all possible values whether common or\n\t\t * uncommon.  (Essentially, we are assuming that the not-yet-known\n\t\t * comparison value is equally likely to be any of the possible\n\t\t * values, regardless of their frequency in the table.  Is that a good\n\t\t * idea?)\n\t\t */\n\t\tselec = 1.0 - nullfrac;\n\t\tndistinct = get_variable_numdistinct(vardata, &isdefault);\n\t\tif (ndistinct > 1)\n\t\t\tselec /= ndistinct;\n\n\t\t/*\n\t\t * Cross-check: selectivity should never be estimated as more than the\n\t\t * most common value's.\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[0])\n\t\t\t\tselec = sslot.numbers[0];\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "var_eq_const",
          "args": [
            "&vardata",
            "operator",
            "((Const *) other)->constvalue",
            "((Const *) other)->constisnull",
            "varonleft",
            "negate"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "var_eq_const",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "297-444",
          "snippet": "static double\nvar_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\tOid\t\t\topfuncoid;\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (constisnull)\n\t\treturn 0.0;\n\n\t/*\n\t * Grab the nullfrac for use below.  Note we allow use of nullfrac\n\t * regardless of security check.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(operator))))\n\t{\n\t\tAttStatsSlot sslot;\n\t\tbool\t\tmatch = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * Is the constant \"=\" to any of the column's most common values?\n\t\t * (Although the given operator may not really be \"=\", we will assume\n\t\t * that seeing whether it returns TRUE is an appropriate test.  If you\n\t\t * don't like this, maybe you shouldn't be using eqsel for your\n\t\t * operator...)\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tFmgrInfo\teqproc;\n\n\t\t\tfmgr_info(opfuncoid, &eqproc);\n\n\t\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t\t{\n\t\t\t\t/* be careful to apply operator right way 'round */\n\t\t\t\tif (varonleft)\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\telse\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i]));\n\t\t\t\tif (match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no most-common-value info available */\n\t\t\ti = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/*\n\t\t\t * Constant is \"=\" to this common value.  We know selectivity\n\t\t\t * exactly (or as exactly as ANALYZE could calculate it, anyway).\n\t\t\t */\n\t\t\tselec = sslot.numbers[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Comparison is against a constant that is neither NULL nor any\n\t\t\t * of the common values.  Its selectivity cannot be more than\n\t\t\t * this:\n\t\t\t */\n\t\t\tdouble\t\tsumcommon = 0.0;\n\t\t\tdouble\t\totherdistinct;\n\n\t\t\tfor (i = 0; i < sslot.nnumbers; i++)\n\t\t\t\tsumcommon += sslot.numbers[i];\n\t\t\tselec = 1.0 - sumcommon - nullfrac;\n\t\t\tCLAMP_PROBABILITY(selec);\n\n\t\t\t/*\n\t\t\t * and in fact it's probably a good deal less. We approximate that\n\t\t\t * all the not-common values share this remaining fraction\n\t\t\t * equally, so we divide by the number of other distinct values.\n\t\t\t */\n\t\t\totherdistinct = get_variable_numdistinct(vardata, &isdefault) -\n\t\t\t\tsslot.nnumbers;\n\t\t\tif (otherdistinct > 1)\n\t\t\t\tselec /= otherdistinct;\n\n\t\t\t/*\n\t\t\t * Another cross-check: selectivity shouldn't be estimated as more\n\t\t\t * than the least common \"most common value\".\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[sslot.nnumbers - 1])\n\t\t\t\tselec = sslot.numbers[sslot.nnumbers - 1];\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\nvar_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate)\n{\n\tdouble\t\tselec;\n\tdouble\t\tnullfrac = 0.0;\n\tbool\t\tisdefault;\n\tOid\t\t\topfuncoid;\n\n\t/*\n\t * If the constant is NULL, assume operator is strict and return zero, ie,\n\t * operator will never return TRUE.  (It's zero even for a negator op.)\n\t */\n\tif (constisnull)\n\t\treturn 0.0;\n\n\t/*\n\t * Grab the nullfrac for use below.  Note we allow use of nullfrac\n\t * regardless of security check.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnullfrac = stats->stanullfrac;\n\t}\n\n\t/*\n\t * If we matched the var to a unique index or DISTINCT clause, assume\n\t * there is exactly one match regardless of anything else.  (This is\n\t * slightly bogus, since the index or clause's equality operator might be\n\t * different from ours, but it's much more likely to be right than\n\t * ignoring the information.)\n\t */\n\tif (vardata->isunique && vardata->rel && vardata->rel->tuples >= 1.0)\n\t{\n\t\tselec = 1.0 / vardata->rel->tuples;\n\t}\n\telse if (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t\t   (opfuncoid = get_opcode(operator))))\n\t{\n\t\tAttStatsSlot sslot;\n\t\tbool\t\tmatch = false;\n\t\tint\t\t\ti;\n\n\t\t/*\n\t\t * Is the constant \"=\" to any of the column's most common values?\n\t\t * (Although the given operator may not really be \"=\", we will assume\n\t\t * that seeing whether it returns TRUE is an appropriate test.  If you\n\t\t * don't like this, maybe you shouldn't be using eqsel for your\n\t\t * operator...)\n\t\t */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_MCV, InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_VALUES | ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tFmgrInfo\teqproc;\n\n\t\t\tfmgr_info(opfuncoid, &eqproc);\n\n\t\t\tfor (i = 0; i < sslot.nvalues; i++)\n\t\t\t{\n\t\t\t\t/* be careful to apply operator right way 'round */\n\t\t\t\tif (varonleft)\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval));\n\t\t\t\telse\n\t\t\t\t\tmatch = DatumGetBool(FunctionCall2Coll(&eqproc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   DEFAULT_COLLATION_OID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   constval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   sslot.values[i]));\n\t\t\t\tif (match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no most-common-value info available */\n\t\t\ti = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\n\t\tif (match)\n\t\t{\n\t\t\t/*\n\t\t\t * Constant is \"=\" to this common value.  We know selectivity\n\t\t\t * exactly (or as exactly as ANALYZE could calculate it, anyway).\n\t\t\t */\n\t\t\tselec = sslot.numbers[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Comparison is against a constant that is neither NULL nor any\n\t\t\t * of the common values.  Its selectivity cannot be more than\n\t\t\t * this:\n\t\t\t */\n\t\t\tdouble\t\tsumcommon = 0.0;\n\t\t\tdouble\t\totherdistinct;\n\n\t\t\tfor (i = 0; i < sslot.nnumbers; i++)\n\t\t\t\tsumcommon += sslot.numbers[i];\n\t\t\tselec = 1.0 - sumcommon - nullfrac;\n\t\t\tCLAMP_PROBABILITY(selec);\n\n\t\t\t/*\n\t\t\t * and in fact it's probably a good deal less. We approximate that\n\t\t\t * all the not-common values share this remaining fraction\n\t\t\t * equally, so we divide by the number of other distinct values.\n\t\t\t */\n\t\t\totherdistinct = get_variable_numdistinct(vardata, &isdefault) -\n\t\t\t\tsslot.nnumbers;\n\t\t\tif (otherdistinct > 1)\n\t\t\t\tselec /= otherdistinct;\n\n\t\t\t/*\n\t\t\t * Another cross-check: selectivity shouldn't be estimated as more\n\t\t\t * than the least common \"most common value\".\n\t\t\t */\n\t\t\tif (sslot.nnumbers > 0 && selec > sslot.numbers[sslot.nnumbers - 1])\n\t\t\t\tselec = sslot.numbers[sslot.nnumbers - 1];\n\t\t}\n\n\t\tfree_attstatsslot(&sslot);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No ANALYZE stats available, so make a guess using estimated number\n\t\t * of distinct values and assuming they are equally common. (The guess\n\t\t * is unlikely to be very good, but we do know a few special cases.)\n\t\t */\n\t\tselec = 1.0 / get_variable_numdistinct(vardata, &isdefault);\n\t}\n\n\t/* now adjust if we wanted <> rather than = */\n\tif (negate)\n\t\tselec = 1.0 - selec - nullfrac;\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "other",
            "Const"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_restriction_variable",
          "args": [
            "root",
            "args",
            "varRelid",
            "&vardata",
            "&other",
            "&varonleft"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "get_restriction_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4653-4701",
          "snippet": "bool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "operator"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_negator",
          "args": [
            "operator"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "get_negator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1321-1338",
          "snippet": "Oid\nget_negator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprnegate;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_negator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprnegate;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\neqsel_internal(PG_FUNCTION_ARGS, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tdouble\t\tselec;\n\n\t/*\n\t * When asked about <>, we do the estimation using the corresponding =\n\t * operator, then convert to <> via \"1.0 - eq_selectivity - nullfrac\".\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\treturn 1.0 - DEFAULT_EQ_SEL;\n\t\t}\n\t}\n\n\t/*\n\t * If expression is not variable = something or something = variable, then\n\t * punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn negate ? (1.0 - DEFAULT_EQ_SEL) : DEFAULT_EQ_SEL;\n\n\t/*\n\t * We can do a lot better if the something is a constant.  (Note: the\n\t * Const might result from estimation rather than being a simple constant\n\t * in the query.)\n\t */\n\tif (IsA(other, Const))\n\t\tselec = var_eq_const(&vardata, operator,\n\t\t\t\t\t\t\t ((Const *) other)->constvalue,\n\t\t\t\t\t\t\t ((Const *) other)->constisnull,\n\t\t\t\t\t\t\t varonleft, negate);\n\telse\n\t\tselec = var_eq_non_const(&vardata, operator, other,\n\t\t\t\t\t\t\t\t varonleft, negate);\n\n\tReleaseVariableStats(vardata);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "eqsel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
    "lines": "230-234",
    "snippet": "Datum\neqsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8((float8) eqsel_internal(fcinfo, false));\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/typcache.h\"",
      "#include \"utils/tqual.h\"",
      "#include \"utils/timestamp.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/spccache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/pg_locale.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/index_selfuncs.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/bytea.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"statistics/statistics.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"parser/parse_clause.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/restrictinfo.h\"",
      "#include \"optimizer/predtest.h\"",
      "#include \"optimizer/plancat.h\"",
      "#include \"optimizer/paths.h\"",
      "#include \"optimizer/pathnode.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"nodes/makefuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_opfamily.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/index.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/gin.h\"",
      "#include \"access/brin.h\"",
      "#include <math.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) eqsel_internal(fcinfo, false)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eqsel_internal",
          "args": [
            "fcinfo",
            "false"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "eqsel_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "239-290",
          "snippet": "static double\neqsel_internal(PG_FUNCTION_ARGS, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tdouble\t\tselec;\n\n\t/*\n\t * When asked about <>, we do the estimation using the corresponding =\n\t * operator, then convert to <> via \"1.0 - eq_selectivity - nullfrac\".\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\treturn 1.0 - DEFAULT_EQ_SEL;\n\t\t}\n\t}\n\n\t/*\n\t * If expression is not variable = something or something = variable, then\n\t * punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn negate ? (1.0 - DEFAULT_EQ_SEL) : DEFAULT_EQ_SEL;\n\n\t/*\n\t * We can do a lot better if the something is a constant.  (Note: the\n\t * Const might result from estimation rather than being a simple constant\n\t * in the query.)\n\t */\n\tif (IsA(other, Const))\n\t\tselec = var_eq_const(&vardata, operator,\n\t\t\t\t\t\t\t ((Const *) other)->constvalue,\n\t\t\t\t\t\t\t ((Const *) other)->constisnull,\n\t\t\t\t\t\t\t varonleft, negate);\n\telse\n\t\tselec = var_eq_non_const(&vardata, operator, other,\n\t\t\t\t\t\t\t\t varonleft, negate);\n\n\tReleaseVariableStats(vardata);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double eqsel_internal(PG_FUNCTION_ARGS, bool negate);",
            "static double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);",
            "static double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);",
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double eqsel_internal(PG_FUNCTION_ARGS, bool negate);\nstatic double var_eq_const(VariableStatData *vardata, Oid operator,\n\t\t\t Datum constval, bool constisnull,\n\t\t\t bool varonleft, bool negate);\nstatic double var_eq_non_const(VariableStatData *vardata, Oid operator,\n\t\t\t\t Node *other,\n\t\t\t\t bool varonleft, bool negate);\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic double\neqsel_internal(PG_FUNCTION_ARGS, bool negate)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tdouble\t\tselec;\n\n\t/*\n\t * When asked about <>, we do the estimation using the corresponding =\n\t * operator, then convert to <> via \"1.0 - eq_selectivity - nullfrac\".\n\t */\n\tif (negate)\n\t{\n\t\toperator = get_negator(operator);\n\t\tif (!OidIsValid(operator))\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\treturn 1.0 - DEFAULT_EQ_SEL;\n\t\t}\n\t}\n\n\t/*\n\t * If expression is not variable = something or something = variable, then\n\t * punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\treturn negate ? (1.0 - DEFAULT_EQ_SEL) : DEFAULT_EQ_SEL;\n\n\t/*\n\t * We can do a lot better if the something is a constant.  (Note: the\n\t * Const might result from estimation rather than being a simple constant\n\t * in the query.)\n\t */\n\tif (IsA(other, Const))\n\t\tselec = var_eq_const(&vardata, operator,\n\t\t\t\t\t\t\t ((Const *) other)->constvalue,\n\t\t\t\t\t\t\t ((Const *) other)->constisnull,\n\t\t\t\t\t\t\t varonleft, negate);\n\telse\n\t\tselec = var_eq_non_const(&vardata, operator, other,\n\t\t\t\t\t\t\t\t varonleft, negate);\n\n\tReleaseVariableStats(vardata);\n\n\treturn selec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\neqsel(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_FLOAT8((float8) eqsel_internal(fcinfo, false));\n}"
  }
]