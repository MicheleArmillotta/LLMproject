[
  {
    "function_name": "extract_variadic_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "1478-1575",
    "snippet": "int\nextract_variadic_args(FunctionCallInfo fcinfo, int variadic_start,\n\t\t\t\t\t  bool convert_unknown, Datum **args, Oid **types,\n\t\t\t\t\t  bool **nulls)\n{\n\tbool\t\tvariadic = get_fn_expr_variadic(fcinfo->flinfo);\n\tDatum\t   *args_res;\n\tbool\t   *nulls_res;\n\tOid\t\t   *types_res;\n\tint\t\t\tnargs,\n\t\t\t\ti;\n\n\t*args = NULL;\n\t*types = NULL;\n\t*nulls = NULL;\n\n\tif (variadic)\n\t{\n\t\tArrayType  *array_in;\n\t\tOid\t\t\telement_type;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tint16\t\ttyplen;\n\n\t\tAssert(PG_NARGS() == variadic_start + 1);\n\n\t\tif (PG_ARGISNULL(variadic_start))\n\t\t\treturn -1;\n\n\t\tarray_in = PG_GETARG_ARRAYTYPE_P(variadic_start);\n\t\telement_type = ARR_ELEMTYPE(array_in);\n\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\t\tdeconstruct_array(array_in, element_type, typlen, typbyval,\n\t\t\t\t\t\t  typalign, &args_res, &nulls_res,\n\t\t\t\t\t\t  &nargs);\n\n\t\t/* All the elements of the array have the same type */\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\ttypes_res[i] = element_type;\n\t}\n\telse\n\t{\n\t\tnargs = PG_NARGS() - variadic_start;\n\t\tAssert(nargs > 0);\n\t\tnulls_res = (bool *) palloc0(nargs * sizeof(bool));\n\t\targs_res = (Datum *) palloc0(nargs * sizeof(Datum));\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tnulls_res[i] = PG_ARGISNULL(i + variadic_start);\n\t\t\ttypes_res[i] = get_fn_expr_argtype(fcinfo->flinfo,\n\t\t\t\t\t\t\t\t\t\t\t   i + variadic_start);\n\n\t\t\t/*\n\t\t\t * Turn a constant (more or less literal) value that's of unknown\n\t\t\t * type into text if required. Unknowns come in as a cstring\n\t\t\t * pointer. Note: for functions declared as taking type \"any\", the\n\t\t\t * parser will not do any type conversion on unknown-type literals\n\t\t\t * (that is, undecorated strings or NULLs).\n\t\t\t */\n\t\t\tif (convert_unknown &&\n\t\t\t\ttypes_res[i] == UNKNOWNOID &&\n\t\t\t\tget_fn_expr_arg_stable(fcinfo->flinfo, i + variadic_start))\n\t\t\t{\n\t\t\t\ttypes_res[i] = TEXTOID;\n\n\t\t\t\tif (PG_ARGISNULL(i + variadic_start))\n\t\t\t\t\targs_res[i] = (Datum) 0;\n\t\t\t\telse\n\t\t\t\t\targs_res[i] =\n\t\t\t\t\t\tCStringGetTextDatum(PG_GETARG_POINTER(i + variadic_start));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no conversion needed, just take the datum as given */\n\t\t\t\targs_res[i] = PG_GETARG_DATUM(i + variadic_start);\n\t\t\t}\n\n\t\t\tif (!OidIsValid(types_res[i]) ||\n\t\t\t\t(convert_unknown && types_res[i] == UNKNOWNOID))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\t\t}\n\t}\n\n\t/* Fill in results */\n\t*args = args_res;\n\t*nulls = nulls_res;\n\t*types = types_res;\n\n\treturn nargs;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1))"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine data type for argument %d\"",
            "i + 1"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "types_res[i]"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "i + variadic_start"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "PG_GETARG_POINTER(i + variadic_start)"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "i + variadic_start"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "i + variadic_start"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_arg_stable",
          "args": [
            "fcinfo->flinfo",
            "i + variadic_start"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_arg_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "2059-2070",
          "snippet": "bool\nget_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\treturn get_call_expr_arg_stable(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbool\nget_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\treturn get_call_expr_arg_stable(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "i + variadic_start"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "i + variadic_start"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nargs * sizeof(Oid)"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nargs > 0"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "array_in",
            "element_type",
            "typlen",
            "typbyval",
            "typalign",
            "&args_res",
            "&nulls_res",
            "&nargs"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "element_type",
            "&typlen",
            "&typbyval",
            "&typalign"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array_in"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "variadic_start"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "variadic_start"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "PG_NARGS() == variadic_start + 1"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_variadic",
          "args": [
            "fcinfo->flinfo"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_variadic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "2128-2146",
          "snippet": "bool\nget_fn_expr_variadic(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\texpr = flinfo->fn_expr;\n\n\tif (IsA(expr, FuncExpr))\n\t\treturn ((FuncExpr *) expr)->funcvariadic;\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbool\nget_fn_expr_variadic(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\texpr = flinfo->fn_expr;\n\n\tif (IsA(expr, FuncExpr))\n\t\treturn ((FuncExpr *) expr)->funcvariadic;\n\telse\n\t\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nextract_variadic_args(FunctionCallInfo fcinfo, int variadic_start,\n\t\t\t\t\t  bool convert_unknown, Datum **args, Oid **types,\n\t\t\t\t\t  bool **nulls)\n{\n\tbool\t\tvariadic = get_fn_expr_variadic(fcinfo->flinfo);\n\tDatum\t   *args_res;\n\tbool\t   *nulls_res;\n\tOid\t\t   *types_res;\n\tint\t\t\tnargs,\n\t\t\t\ti;\n\n\t*args = NULL;\n\t*types = NULL;\n\t*nulls = NULL;\n\n\tif (variadic)\n\t{\n\t\tArrayType  *array_in;\n\t\tOid\t\t\telement_type;\n\t\tbool\t\ttypbyval;\n\t\tchar\t\ttypalign;\n\t\tint16\t\ttyplen;\n\n\t\tAssert(PG_NARGS() == variadic_start + 1);\n\n\t\tif (PG_ARGISNULL(variadic_start))\n\t\t\treturn -1;\n\n\t\tarray_in = PG_GETARG_ARRAYTYPE_P(variadic_start);\n\t\telement_type = ARR_ELEMTYPE(array_in);\n\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &typlen, &typbyval, &typalign);\n\t\tdeconstruct_array(array_in, element_type, typlen, typbyval,\n\t\t\t\t\t\t  typalign, &args_res, &nulls_res,\n\t\t\t\t\t\t  &nargs);\n\n\t\t/* All the elements of the array have the same type */\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\ttypes_res[i] = element_type;\n\t}\n\telse\n\t{\n\t\tnargs = PG_NARGS() - variadic_start;\n\t\tAssert(nargs > 0);\n\t\tnulls_res = (bool *) palloc0(nargs * sizeof(bool));\n\t\targs_res = (Datum *) palloc0(nargs * sizeof(Datum));\n\t\ttypes_res = (Oid *) palloc0(nargs * sizeof(Oid));\n\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tnulls_res[i] = PG_ARGISNULL(i + variadic_start);\n\t\t\ttypes_res[i] = get_fn_expr_argtype(fcinfo->flinfo,\n\t\t\t\t\t\t\t\t\t\t\t   i + variadic_start);\n\n\t\t\t/*\n\t\t\t * Turn a constant (more or less literal) value that's of unknown\n\t\t\t * type into text if required. Unknowns come in as a cstring\n\t\t\t * pointer. Note: for functions declared as taking type \"any\", the\n\t\t\t * parser will not do any type conversion on unknown-type literals\n\t\t\t * (that is, undecorated strings or NULLs).\n\t\t\t */\n\t\t\tif (convert_unknown &&\n\t\t\t\ttypes_res[i] == UNKNOWNOID &&\n\t\t\t\tget_fn_expr_arg_stable(fcinfo->flinfo, i + variadic_start))\n\t\t\t{\n\t\t\t\ttypes_res[i] = TEXTOID;\n\n\t\t\t\tif (PG_ARGISNULL(i + variadic_start))\n\t\t\t\t\targs_res[i] = (Datum) 0;\n\t\t\t\telse\n\t\t\t\t\targs_res[i] =\n\t\t\t\t\t\tCStringGetTextDatum(PG_GETARG_POINTER(i + variadic_start));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* no conversion needed, just take the datum as given */\n\t\t\t\targs_res[i] = PG_GETARG_DATUM(i + variadic_start);\n\t\t\t}\n\n\t\t\tif (!OidIsValid(types_res[i]) ||\n\t\t\t\t(convert_unknown && types_res[i] == UNKNOWNOID))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"could not determine data type for argument %d\",\n\t\t\t\t\t\t\t\ti + 1)));\n\t\t}\n\t}\n\n\t/* Fill in results */\n\t*args = args_res;\n\t*nulls = nulls_res;\n\t*types = types_res;\n\n\treturn nargs;\n}"
  },
  {
    "function_name": "TypeGetTupleDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "1376-1462",
    "snippet": "TupleDesc\nTypeGetTupleDesc(Oid typeoid, List *colaliases)\n{\n\tOid\t\t\tbase_typeoid;\n\tTypeFuncClass functypclass = get_type_func_class(typeoid, &base_typeoid);\n\tTupleDesc\ttupdesc = NULL;\n\n\t/*\n\t * Build a suitable tupledesc representing the output rows.  We\n\t * intentionally do not support TYPEFUNC_COMPOSITE_DOMAIN here, as it's\n\t * unlikely that legacy callers of this obsolete function would be\n\t * prepared to apply domain constraints.\n\t */\n\tif (functypclass == TYPEFUNC_COMPOSITE)\n\t{\n\t\t/* Composite data type, e.g. a table's row type */\n\t\ttupdesc = lookup_rowtype_tupdesc_copy(base_typeoid, -1);\n\n\t\tif (colaliases != NIL)\n\t\t{\n\t\t\tint\t\t\tnatts = tupdesc->natts;\n\t\t\tint\t\t\tvarattno;\n\n\t\t\t/* does the list length match the number of attributes? */\n\t\t\tif (list_length(colaliases) != natts)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"number of aliases does not match number of columns\")));\n\n\t\t\t/* OK, use the aliases instead */\n\t\t\tfor (varattno = 0; varattno < natts; varattno++)\n\t\t\t{\n\t\t\t\tchar\t   *label = strVal(list_nth(colaliases, varattno));\n\t\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, varattno);\n\n\t\t\t\tif (label != NULL)\n\t\t\t\t\tnamestrcpy(&(attr->attname), label);\n\t\t\t}\n\n\t\t\t/* The tuple type is now an anonymous record type */\n\t\t\ttupdesc->tdtypeid = RECORDOID;\n\t\t\ttupdesc->tdtypmod = -1;\n\t\t}\n\t}\n\telse if (functypclass == TYPEFUNC_SCALAR)\n\t{\n\t\t/* Base data type, i.e. scalar */\n\t\tchar\t   *attname;\n\n\t\t/* the alias list is required for base types */\n\t\tif (colaliases == NIL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"no column alias was provided\")));\n\n\t\t/* the alias list length must be 1 */\n\t\tif (list_length(colaliases) != 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"number of aliases does not match number of columns\")));\n\n\t\t/* OK, get the column alias */\n\t\tattname = strVal(linitial(colaliases));\n\n\t\ttupdesc = CreateTemplateTupleDesc(1, false);\n\t\tTupleDescInitEntry(tupdesc,\n\t\t\t\t\t\t   (AttrNumber) 1,\n\t\t\t\t\t\t   attname,\n\t\t\t\t\t\t   typeoid,\n\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t   0);\n\t}\n\telse if (functypclass == TYPEFUNC_RECORD)\n\t{\n\t\t/* XXX can't support this because typmod wasn't passed in ... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"could not determine row description for function returning record\")));\n\t}\n\telse\n\t{\n\t\t/* crummy error message, but parser should have caught this */\n\t\telog(ERROR, \"function in FROM has unsupported return type\");\n\t}\n\n\treturn tupdesc;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function in FROM has unsupported return type\""
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"could not determine row description for function returning record\"))"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine row description for function returning record\""
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 1",
            "attname",
            "typeoid",
            "-1",
            "0"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "1",
            "false"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strVal",
          "args": [
            "linitial(colaliases)"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "colaliases"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"number of aliases does not match number of columns\"))"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "colaliases"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"no column alias was provided\"))"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namestrcpy",
          "args": [
            "&(attr->attname)",
            "label"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "varattno"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strVal",
          "args": [
            "list_nth(colaliases, varattno)"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_nth",
          "args": [
            "colaliases",
            "varattno"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"number of aliases does not match number of columns\"))"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "colaliases"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc_copy",
          "args": [
            "base_typeoid",
            "-1"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_type_func_class",
          "args": [
            "typeoid",
            "&base_typeoid"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "get_type_func_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "795-830",
          "snippet": "static TypeFuncClass\nget_type_func_class(Oid typid, Oid *base_typeid)\n{\n\t*base_typeid = typid;\n\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn TYPEFUNC_COMPOSITE;\n\t\tcase TYPTYPE_BASE:\n\t\tcase TYPTYPE_ENUM:\n\t\tcase TYPTYPE_RANGE:\n\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\t*base_typeid = typid = getBaseType(typid);\n\t\t\tif (get_typtype(typid) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn TYPEFUNC_COMPOSITE_DOMAIN;\n\t\t\telse\t\t\t\t/* domain base type can't be a pseudotype */\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_PSEUDO:\n\t\t\tif (typid == RECORDOID)\n\t\t\t\treturn TYPEFUNC_RECORD;\n\n\t\t\t/*\n\t\t\t * We treat VOID and CSTRING as legitimate scalar datatypes,\n\t\t\t * mostly for the convenience of the JDBC driver (which wants to\n\t\t\t * be able to do \"SELECT * FROM foo()\" for all legitimately\n\t\t\t * user-callable functions).\n\t\t\t */\n\t\t\tif (typid == VOIDOID || typid == CSTRINGOID)\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\t\treturn TYPEFUNC_OTHER;\n\t}\n\t/* shouldn't get here, probably */\n\treturn TYPEFUNC_OTHER;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass get_type_func_class(Oid typid, Oid *base_typeid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass get_type_func_class(Oid typid, Oid *base_typeid);\n\nstatic TypeFuncClass\nget_type_func_class(Oid typid, Oid *base_typeid)\n{\n\t*base_typeid = typid;\n\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn TYPEFUNC_COMPOSITE;\n\t\tcase TYPTYPE_BASE:\n\t\tcase TYPTYPE_ENUM:\n\t\tcase TYPTYPE_RANGE:\n\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\t*base_typeid = typid = getBaseType(typid);\n\t\t\tif (get_typtype(typid) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn TYPEFUNC_COMPOSITE_DOMAIN;\n\t\t\telse\t\t\t\t/* domain base type can't be a pseudotype */\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_PSEUDO:\n\t\t\tif (typid == RECORDOID)\n\t\t\t\treturn TYPEFUNC_RECORD;\n\n\t\t\t/*\n\t\t\t * We treat VOID and CSTRING as legitimate scalar datatypes,\n\t\t\t * mostly for the convenience of the JDBC driver (which wants to\n\t\t\t * be able to do \"SELECT * FROM foo()\" for all legitimately\n\t\t\t * user-callable functions).\n\t\t\t */\n\t\t\tif (typid == VOIDOID || typid == CSTRINGOID)\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\t\treturn TYPEFUNC_OTHER;\n\t}\n\t/* shouldn't get here, probably */\n\treturn TYPEFUNC_OTHER;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nTupleDesc\nTypeGetTupleDesc(Oid typeoid, List *colaliases)\n{\n\tOid\t\t\tbase_typeoid;\n\tTypeFuncClass functypclass = get_type_func_class(typeoid, &base_typeoid);\n\tTupleDesc\ttupdesc = NULL;\n\n\t/*\n\t * Build a suitable tupledesc representing the output rows.  We\n\t * intentionally do not support TYPEFUNC_COMPOSITE_DOMAIN here, as it's\n\t * unlikely that legacy callers of this obsolete function would be\n\t * prepared to apply domain constraints.\n\t */\n\tif (functypclass == TYPEFUNC_COMPOSITE)\n\t{\n\t\t/* Composite data type, e.g. a table's row type */\n\t\ttupdesc = lookup_rowtype_tupdesc_copy(base_typeoid, -1);\n\n\t\tif (colaliases != NIL)\n\t\t{\n\t\t\tint\t\t\tnatts = tupdesc->natts;\n\t\t\tint\t\t\tvarattno;\n\n\t\t\t/* does the list length match the number of attributes? */\n\t\t\tif (list_length(colaliases) != natts)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t\t errmsg(\"number of aliases does not match number of columns\")));\n\n\t\t\t/* OK, use the aliases instead */\n\t\t\tfor (varattno = 0; varattno < natts; varattno++)\n\t\t\t{\n\t\t\t\tchar\t   *label = strVal(list_nth(colaliases, varattno));\n\t\t\t\tForm_pg_attribute attr = TupleDescAttr(tupdesc, varattno);\n\n\t\t\t\tif (label != NULL)\n\t\t\t\t\tnamestrcpy(&(attr->attname), label);\n\t\t\t}\n\n\t\t\t/* The tuple type is now an anonymous record type */\n\t\t\ttupdesc->tdtypeid = RECORDOID;\n\t\t\ttupdesc->tdtypmod = -1;\n\t\t}\n\t}\n\telse if (functypclass == TYPEFUNC_SCALAR)\n\t{\n\t\t/* Base data type, i.e. scalar */\n\t\tchar\t   *attname;\n\n\t\t/* the alias list is required for base types */\n\t\tif (colaliases == NIL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"no column alias was provided\")));\n\n\t\t/* the alias list length must be 1 */\n\t\tif (list_length(colaliases) != 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"number of aliases does not match number of columns\")));\n\n\t\t/* OK, get the column alias */\n\t\tattname = strVal(linitial(colaliases));\n\n\t\ttupdesc = CreateTemplateTupleDesc(1, false);\n\t\tTupleDescInitEntry(tupdesc,\n\t\t\t\t\t\t   (AttrNumber) 1,\n\t\t\t\t\t\t   attname,\n\t\t\t\t\t\t   typeoid,\n\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t   0);\n\t}\n\telse if (functypclass == TYPEFUNC_RECORD)\n\t{\n\t\t/* XXX can't support this because typmod wasn't passed in ... */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"could not determine row description for function returning record\")));\n\t}\n\telse\n\t{\n\t\t/* crummy error message, but parser should have caught this */\n\t\telog(ERROR, \"function in FROM has unsupported return type\");\n\t}\n\n\treturn tupdesc;\n}"
  },
  {
    "function_name": "RelationNameGetTupleDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "1343-1359",
    "snippet": "TupleDesc\nRelationNameGetTupleDesc(const char *relname)\n{\n\tRangeVar   *relvar;\n\tRelation\trel;\n\tTupleDesc\ttupdesc;\n\tList\t   *relname_list;\n\n\t/* Open relation and copy the tuple description */\n\trelname_list = stringToQualifiedNameList(relname);\n\trelvar = makeRangeVarFromNameList(relname_list);\n\trel = relation_openrv(relvar, AccessShareLock);\n\ttupdesc = CreateTupleDescCopy(RelationGetDescr(rel));\n\trelation_close(rel, AccessShareLock);\n\n\treturn tupdesc;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "relation_close",
          "args": [
            "rel",
            "AccessShareLock"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "RelationGetDescr(rel)"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "rel"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relation_openrv",
          "args": [
            "relvar",
            "AccessShareLock"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeRangeVarFromNameList",
          "args": [
            "relname_list"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "relname"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nTupleDesc\nRelationNameGetTupleDesc(const char *relname)\n{\n\tRangeVar   *relvar;\n\tRelation\trel;\n\tTupleDesc\ttupdesc;\n\tList\t   *relname_list;\n\n\t/* Open relation and copy the tuple description */\n\trelname_list = stringToQualifiedNameList(relname);\n\trelvar = makeRangeVarFromNameList(relname_list);\n\trel = relation_openrv(relvar, AccessShareLock);\n\ttupdesc = CreateTupleDescCopy(RelationGetDescr(rel));\n\trelation_close(rel, AccessShareLock);\n\n\treturn tupdesc;\n}"
  },
  {
    "function_name": "build_function_result_tupdesc_d",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "1225-1331",
    "snippet": "TupleDesc\nbuild_function_result_tupdesc_d(char prokind,\n\t\t\t\t\t\t\t\tDatum proallargtypes,\n\t\t\t\t\t\t\t\tDatum proargmodes,\n\t\t\t\t\t\t\t\tDatum proargnames)\n{\n\tTupleDesc\tdesc;\n\tArrayType  *arr;\n\tint\t\t\tnumargs;\n\tOid\t\t   *argtypes;\n\tchar\t   *argmodes;\n\tDatum\t   *argnames = NULL;\n\tOid\t\t   *outargtypes;\n\tchar\t  **outargnames;\n\tint\t\t\tnumoutargs;\n\tint\t\t\tnargnames;\n\tint\t\t\ti;\n\n\t/* Can't have output args if columns are null */\n\tif (proallargtypes == PointerGetDatum(NULL) ||\n\t\tproargmodes == PointerGetDatum(NULL))\n\t\treturn NULL;\n\n\t/*\n\t * We expect the arrays to be 1-D arrays of the right types; verify that.\n\t * For the OID and char arrays, we don't need to use deconstruct_array()\n\t * since the array data is just going to look like a C array of values.\n\t */\n\tarr = DatumGetArrayTypeP(proallargtypes);\t/* ensure not toasted */\n\tnumargs = ARR_DIMS(arr)[0];\n\tif (ARR_NDIM(arr) != 1 ||\n\t\tnumargs < 0 ||\n\t\tARR_HASNULL(arr) ||\n\t\tARR_ELEMTYPE(arr) != OIDOID)\n\t\telog(ERROR, \"proallargtypes is not a 1-D Oid array\");\n\targtypes = (Oid *) ARR_DATA_PTR(arr);\n\tarr = DatumGetArrayTypeP(proargmodes);\t/* ensure not toasted */\n\tif (ARR_NDIM(arr) != 1 ||\n\t\tARR_DIMS(arr)[0] != numargs ||\n\t\tARR_HASNULL(arr) ||\n\t\tARR_ELEMTYPE(arr) != CHAROID)\n\t\telog(ERROR, \"proargmodes is not a 1-D char array\");\n\targmodes = (char *) ARR_DATA_PTR(arr);\n\tif (proargnames != PointerGetDatum(NULL))\n\t{\n\t\tarr = DatumGetArrayTypeP(proargnames);\t/* ensure not toasted */\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tARR_DIMS(arr)[0] != numargs ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != TEXTOID)\n\t\t\telog(ERROR, \"proargnames is not a 1-D text array\");\n\t\tdeconstruct_array(arr, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &argnames, NULL, &nargnames);\n\t\tAssert(nargnames == numargs);\n\t}\n\n\t/* zero elements probably shouldn't happen, but handle it gracefully */\n\tif (numargs <= 0)\n\t\treturn NULL;\n\n\t/* extract output-argument types and names */\n\toutargtypes = (Oid *) palloc(numargs * sizeof(Oid));\n\toutargnames = (char **) palloc(numargs * sizeof(char *));\n\tnumoutargs = 0;\n\tfor (i = 0; i < numargs; i++)\n\t{\n\t\tchar\t   *pname;\n\n\t\tif (argmodes[i] == PROARGMODE_IN ||\n\t\t\targmodes[i] == PROARGMODE_VARIADIC)\n\t\t\tcontinue;\n\t\tAssert(argmodes[i] == PROARGMODE_OUT ||\n\t\t\t   argmodes[i] == PROARGMODE_INOUT ||\n\t\t\t   argmodes[i] == PROARGMODE_TABLE);\n\t\toutargtypes[numoutargs] = argtypes[i];\n\t\tif (argnames)\n\t\t\tpname = TextDatumGetCString(argnames[i]);\n\t\telse\n\t\t\tpname = NULL;\n\t\tif (pname == NULL || pname[0] == '\\0')\n\t\t{\n\t\t\t/* Parameter is not named, so gin up a column name */\n\t\t\tpname = psprintf(\"column%d\", numoutargs + 1);\n\t\t}\n\t\toutargnames[numoutargs] = pname;\n\t\tnumoutargs++;\n\t}\n\n\t/*\n\t * If there is no output argument, or only one, the function does not\n\t * return tuples.\n\t */\n\tif (numoutargs < 2 && prokind != PROKIND_PROCEDURE)\n\t\treturn NULL;\n\n\tdesc = CreateTemplateTupleDesc(numoutargs, false);\n\tfor (i = 0; i < numoutargs; i++)\n\t{\n\t\tTupleDescInitEntry(desc, i + 1,\n\t\t\t\t\t\t   outargnames[i],\n\t\t\t\t\t\t   outargtypes[i],\n\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t   0);\n\t}\n\n\treturn desc;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "desc",
            "i + 1",
            "outargnames[i]",
            "outargtypes[i]",
            "-1",
            "0"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "numoutargs",
            "false"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"column%d\"",
            "numoutargs + 1"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "argnames[i]"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "argmodes[i] == PROARGMODE_OUT ||\n\t\t\t   argmodes[i] == PROARGMODE_INOUT ||\n\t\t\t   argmodes[i] == PROARGMODE_TABLE"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "numargs * sizeof(char *)"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nargnames == numargs"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "arr",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&argnames",
            "NULL",
            "&nargnames"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"proargnames is not a 1-D text array\""
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "proargnames"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "arr"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "proargmodes"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "arr"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "proallargtypes"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nTupleDesc\nbuild_function_result_tupdesc_d(char prokind,\n\t\t\t\t\t\t\t\tDatum proallargtypes,\n\t\t\t\t\t\t\t\tDatum proargmodes,\n\t\t\t\t\t\t\t\tDatum proargnames)\n{\n\tTupleDesc\tdesc;\n\tArrayType  *arr;\n\tint\t\t\tnumargs;\n\tOid\t\t   *argtypes;\n\tchar\t   *argmodes;\n\tDatum\t   *argnames = NULL;\n\tOid\t\t   *outargtypes;\n\tchar\t  **outargnames;\n\tint\t\t\tnumoutargs;\n\tint\t\t\tnargnames;\n\tint\t\t\ti;\n\n\t/* Can't have output args if columns are null */\n\tif (proallargtypes == PointerGetDatum(NULL) ||\n\t\tproargmodes == PointerGetDatum(NULL))\n\t\treturn NULL;\n\n\t/*\n\t * We expect the arrays to be 1-D arrays of the right types; verify that.\n\t * For the OID and char arrays, we don't need to use deconstruct_array()\n\t * since the array data is just going to look like a C array of values.\n\t */\n\tarr = DatumGetArrayTypeP(proallargtypes);\t/* ensure not toasted */\n\tnumargs = ARR_DIMS(arr)[0];\n\tif (ARR_NDIM(arr) != 1 ||\n\t\tnumargs < 0 ||\n\t\tARR_HASNULL(arr) ||\n\t\tARR_ELEMTYPE(arr) != OIDOID)\n\t\telog(ERROR, \"proallargtypes is not a 1-D Oid array\");\n\targtypes = (Oid *) ARR_DATA_PTR(arr);\n\tarr = DatumGetArrayTypeP(proargmodes);\t/* ensure not toasted */\n\tif (ARR_NDIM(arr) != 1 ||\n\t\tARR_DIMS(arr)[0] != numargs ||\n\t\tARR_HASNULL(arr) ||\n\t\tARR_ELEMTYPE(arr) != CHAROID)\n\t\telog(ERROR, \"proargmodes is not a 1-D char array\");\n\targmodes = (char *) ARR_DATA_PTR(arr);\n\tif (proargnames != PointerGetDatum(NULL))\n\t{\n\t\tarr = DatumGetArrayTypeP(proargnames);\t/* ensure not toasted */\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tARR_DIMS(arr)[0] != numargs ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != TEXTOID)\n\t\t\telog(ERROR, \"proargnames is not a 1-D text array\");\n\t\tdeconstruct_array(arr, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &argnames, NULL, &nargnames);\n\t\tAssert(nargnames == numargs);\n\t}\n\n\t/* zero elements probably shouldn't happen, but handle it gracefully */\n\tif (numargs <= 0)\n\t\treturn NULL;\n\n\t/* extract output-argument types and names */\n\toutargtypes = (Oid *) palloc(numargs * sizeof(Oid));\n\toutargnames = (char **) palloc(numargs * sizeof(char *));\n\tnumoutargs = 0;\n\tfor (i = 0; i < numargs; i++)\n\t{\n\t\tchar\t   *pname;\n\n\t\tif (argmodes[i] == PROARGMODE_IN ||\n\t\t\targmodes[i] == PROARGMODE_VARIADIC)\n\t\t\tcontinue;\n\t\tAssert(argmodes[i] == PROARGMODE_OUT ||\n\t\t\t   argmodes[i] == PROARGMODE_INOUT ||\n\t\t\t   argmodes[i] == PROARGMODE_TABLE);\n\t\toutargtypes[numoutargs] = argtypes[i];\n\t\tif (argnames)\n\t\t\tpname = TextDatumGetCString(argnames[i]);\n\t\telse\n\t\t\tpname = NULL;\n\t\tif (pname == NULL || pname[0] == '\\0')\n\t\t{\n\t\t\t/* Parameter is not named, so gin up a column name */\n\t\t\tpname = psprintf(\"column%d\", numoutargs + 1);\n\t\t}\n\t\toutargnames[numoutargs] = pname;\n\t\tnumoutargs++;\n\t}\n\n\t/*\n\t * If there is no output argument, or only one, the function does not\n\t * return tuples.\n\t */\n\tif (numoutargs < 2 && prokind != PROKIND_PROCEDURE)\n\t\treturn NULL;\n\n\tdesc = CreateTemplateTupleDesc(numoutargs, false);\n\tfor (i = 0; i < numoutargs; i++)\n\t{\n\t\tTupleDescInitEntry(desc, i + 1,\n\t\t\t\t\t\t   outargnames[i],\n\t\t\t\t\t\t   outargtypes[i],\n\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t   0);\n\t}\n\n\treturn desc;\n}"
  },
  {
    "function_name": "build_function_result_tupdesc_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "1175-1212",
    "snippet": "TupleDesc\nbuild_function_result_tupdesc_t(HeapTuple procTuple)\n{\n\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(procTuple);\n\tDatum\t\tproallargtypes;\n\tDatum\t\tproargmodes;\n\tDatum\t\tproargnames;\n\tbool\t\tisnull;\n\n\t/* Return NULL if the function isn't declared to return RECORD */\n\tif (procform->prorettype != RECORDOID)\n\t\treturn NULL;\n\n\t/* If there are no OUT parameters, return NULL */\n\tif (heap_attisnull(procTuple, Anum_pg_proc_proallargtypes, NULL) ||\n\t\theap_attisnull(procTuple, Anum_pg_proc_proargmodes, NULL))\n\t\treturn NULL;\n\n\t/* Get the data out of the tuple */\n\tproallargtypes = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_proallargtypes,\n\t\t\t\t\t\t\t\t\t &isnull);\n\tAssert(!isnull);\n\tproargmodes = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargmodes,\n\t\t\t\t\t\t\t\t  &isnull);\n\tAssert(!isnull);\n\tproargnames = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargnames,\n\t\t\t\t\t\t\t\t  &isnull);\n\tif (isnull)\n\t\tproargnames = PointerGetDatum(NULL);\t/* just to be sure */\n\n\treturn build_function_result_tupdesc_d(procform->prokind,\n\t\t\t\t\t\t\t\t\t\t   proallargtypes,\n\t\t\t\t\t\t\t\t\t\t   proargmodes,\n\t\t\t\t\t\t\t\t\t\t   proargnames);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "build_function_result_tupdesc_d",
          "args": [
            "procform->prokind",
            "proallargtypes",
            "proargmodes",
            "proargnames"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "build_function_result_tupdesc_d",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "1225-1331",
          "snippet": "TupleDesc\nbuild_function_result_tupdesc_d(char prokind,\n\t\t\t\t\t\t\t\tDatum proallargtypes,\n\t\t\t\t\t\t\t\tDatum proargmodes,\n\t\t\t\t\t\t\t\tDatum proargnames)\n{\n\tTupleDesc\tdesc;\n\tArrayType  *arr;\n\tint\t\t\tnumargs;\n\tOid\t\t   *argtypes;\n\tchar\t   *argmodes;\n\tDatum\t   *argnames = NULL;\n\tOid\t\t   *outargtypes;\n\tchar\t  **outargnames;\n\tint\t\t\tnumoutargs;\n\tint\t\t\tnargnames;\n\tint\t\t\ti;\n\n\t/* Can't have output args if columns are null */\n\tif (proallargtypes == PointerGetDatum(NULL) ||\n\t\tproargmodes == PointerGetDatum(NULL))\n\t\treturn NULL;\n\n\t/*\n\t * We expect the arrays to be 1-D arrays of the right types; verify that.\n\t * For the OID and char arrays, we don't need to use deconstruct_array()\n\t * since the array data is just going to look like a C array of values.\n\t */\n\tarr = DatumGetArrayTypeP(proallargtypes);\t/* ensure not toasted */\n\tnumargs = ARR_DIMS(arr)[0];\n\tif (ARR_NDIM(arr) != 1 ||\n\t\tnumargs < 0 ||\n\t\tARR_HASNULL(arr) ||\n\t\tARR_ELEMTYPE(arr) != OIDOID)\n\t\telog(ERROR, \"proallargtypes is not a 1-D Oid array\");\n\targtypes = (Oid *) ARR_DATA_PTR(arr);\n\tarr = DatumGetArrayTypeP(proargmodes);\t/* ensure not toasted */\n\tif (ARR_NDIM(arr) != 1 ||\n\t\tARR_DIMS(arr)[0] != numargs ||\n\t\tARR_HASNULL(arr) ||\n\t\tARR_ELEMTYPE(arr) != CHAROID)\n\t\telog(ERROR, \"proargmodes is not a 1-D char array\");\n\targmodes = (char *) ARR_DATA_PTR(arr);\n\tif (proargnames != PointerGetDatum(NULL))\n\t{\n\t\tarr = DatumGetArrayTypeP(proargnames);\t/* ensure not toasted */\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tARR_DIMS(arr)[0] != numargs ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != TEXTOID)\n\t\t\telog(ERROR, \"proargnames is not a 1-D text array\");\n\t\tdeconstruct_array(arr, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &argnames, NULL, &nargnames);\n\t\tAssert(nargnames == numargs);\n\t}\n\n\t/* zero elements probably shouldn't happen, but handle it gracefully */\n\tif (numargs <= 0)\n\t\treturn NULL;\n\n\t/* extract output-argument types and names */\n\toutargtypes = (Oid *) palloc(numargs * sizeof(Oid));\n\toutargnames = (char **) palloc(numargs * sizeof(char *));\n\tnumoutargs = 0;\n\tfor (i = 0; i < numargs; i++)\n\t{\n\t\tchar\t   *pname;\n\n\t\tif (argmodes[i] == PROARGMODE_IN ||\n\t\t\targmodes[i] == PROARGMODE_VARIADIC)\n\t\t\tcontinue;\n\t\tAssert(argmodes[i] == PROARGMODE_OUT ||\n\t\t\t   argmodes[i] == PROARGMODE_INOUT ||\n\t\t\t   argmodes[i] == PROARGMODE_TABLE);\n\t\toutargtypes[numoutargs] = argtypes[i];\n\t\tif (argnames)\n\t\t\tpname = TextDatumGetCString(argnames[i]);\n\t\telse\n\t\t\tpname = NULL;\n\t\tif (pname == NULL || pname[0] == '\\0')\n\t\t{\n\t\t\t/* Parameter is not named, so gin up a column name */\n\t\t\tpname = psprintf(\"column%d\", numoutargs + 1);\n\t\t}\n\t\toutargnames[numoutargs] = pname;\n\t\tnumoutargs++;\n\t}\n\n\t/*\n\t * If there is no output argument, or only one, the function does not\n\t * return tuples.\n\t */\n\tif (numoutargs < 2 && prokind != PROKIND_PROCEDURE)\n\t\treturn NULL;\n\n\tdesc = CreateTemplateTupleDesc(numoutargs, false);\n\tfor (i = 0; i < numoutargs; i++)\n\t{\n\t\tTupleDescInitEntry(desc, i + 1,\n\t\t\t\t\t\t   outargnames[i],\n\t\t\t\t\t\t   outargtypes[i],\n\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t   0);\n\t}\n\n\treturn desc;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nTupleDesc\nbuild_function_result_tupdesc_d(char prokind,\n\t\t\t\t\t\t\t\tDatum proallargtypes,\n\t\t\t\t\t\t\t\tDatum proargmodes,\n\t\t\t\t\t\t\t\tDatum proargnames)\n{\n\tTupleDesc\tdesc;\n\tArrayType  *arr;\n\tint\t\t\tnumargs;\n\tOid\t\t   *argtypes;\n\tchar\t   *argmodes;\n\tDatum\t   *argnames = NULL;\n\tOid\t\t   *outargtypes;\n\tchar\t  **outargnames;\n\tint\t\t\tnumoutargs;\n\tint\t\t\tnargnames;\n\tint\t\t\ti;\n\n\t/* Can't have output args if columns are null */\n\tif (proallargtypes == PointerGetDatum(NULL) ||\n\t\tproargmodes == PointerGetDatum(NULL))\n\t\treturn NULL;\n\n\t/*\n\t * We expect the arrays to be 1-D arrays of the right types; verify that.\n\t * For the OID and char arrays, we don't need to use deconstruct_array()\n\t * since the array data is just going to look like a C array of values.\n\t */\n\tarr = DatumGetArrayTypeP(proallargtypes);\t/* ensure not toasted */\n\tnumargs = ARR_DIMS(arr)[0];\n\tif (ARR_NDIM(arr) != 1 ||\n\t\tnumargs < 0 ||\n\t\tARR_HASNULL(arr) ||\n\t\tARR_ELEMTYPE(arr) != OIDOID)\n\t\telog(ERROR, \"proallargtypes is not a 1-D Oid array\");\n\targtypes = (Oid *) ARR_DATA_PTR(arr);\n\tarr = DatumGetArrayTypeP(proargmodes);\t/* ensure not toasted */\n\tif (ARR_NDIM(arr) != 1 ||\n\t\tARR_DIMS(arr)[0] != numargs ||\n\t\tARR_HASNULL(arr) ||\n\t\tARR_ELEMTYPE(arr) != CHAROID)\n\t\telog(ERROR, \"proargmodes is not a 1-D char array\");\n\targmodes = (char *) ARR_DATA_PTR(arr);\n\tif (proargnames != PointerGetDatum(NULL))\n\t{\n\t\tarr = DatumGetArrayTypeP(proargnames);\t/* ensure not toasted */\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tARR_DIMS(arr)[0] != numargs ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != TEXTOID)\n\t\t\telog(ERROR, \"proargnames is not a 1-D text array\");\n\t\tdeconstruct_array(arr, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &argnames, NULL, &nargnames);\n\t\tAssert(nargnames == numargs);\n\t}\n\n\t/* zero elements probably shouldn't happen, but handle it gracefully */\n\tif (numargs <= 0)\n\t\treturn NULL;\n\n\t/* extract output-argument types and names */\n\toutargtypes = (Oid *) palloc(numargs * sizeof(Oid));\n\toutargnames = (char **) palloc(numargs * sizeof(char *));\n\tnumoutargs = 0;\n\tfor (i = 0; i < numargs; i++)\n\t{\n\t\tchar\t   *pname;\n\n\t\tif (argmodes[i] == PROARGMODE_IN ||\n\t\t\targmodes[i] == PROARGMODE_VARIADIC)\n\t\t\tcontinue;\n\t\tAssert(argmodes[i] == PROARGMODE_OUT ||\n\t\t\t   argmodes[i] == PROARGMODE_INOUT ||\n\t\t\t   argmodes[i] == PROARGMODE_TABLE);\n\t\toutargtypes[numoutargs] = argtypes[i];\n\t\tif (argnames)\n\t\t\tpname = TextDatumGetCString(argnames[i]);\n\t\telse\n\t\t\tpname = NULL;\n\t\tif (pname == NULL || pname[0] == '\\0')\n\t\t{\n\t\t\t/* Parameter is not named, so gin up a column name */\n\t\t\tpname = psprintf(\"column%d\", numoutargs + 1);\n\t\t}\n\t\toutargnames[numoutargs] = pname;\n\t\tnumoutargs++;\n\t}\n\n\t/*\n\t * If there is no output argument, or only one, the function does not\n\t * return tuples.\n\t */\n\tif (numoutargs < 2 && prokind != PROKIND_PROCEDURE)\n\t\treturn NULL;\n\n\tdesc = CreateTemplateTupleDesc(numoutargs, false);\n\tfor (i = 0; i < numoutargs; i++)\n\t{\n\t\tTupleDescInitEntry(desc, i + 1,\n\t\t\t\t\t\t   outargnames[i],\n\t\t\t\t\t\t   outargtypes[i],\n\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t   0);\n\t}\n\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "PROCOID",
            "procTuple",
            "Anum_pg_proc_proargnames",
            "&isnull"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_attisnull",
          "args": [
            "procTuple",
            "Anum_pg_proc_proargmodes",
            "NULL"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_attisnull",
          "args": [
            "procTuple",
            "Anum_pg_proc_proallargtypes",
            "NULL"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "procTuple"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nTupleDesc\nbuild_function_result_tupdesc_t(HeapTuple procTuple)\n{\n\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(procTuple);\n\tDatum\t\tproallargtypes;\n\tDatum\t\tproargmodes;\n\tDatum\t\tproargnames;\n\tbool\t\tisnull;\n\n\t/* Return NULL if the function isn't declared to return RECORD */\n\tif (procform->prorettype != RECORDOID)\n\t\treturn NULL;\n\n\t/* If there are no OUT parameters, return NULL */\n\tif (heap_attisnull(procTuple, Anum_pg_proc_proallargtypes, NULL) ||\n\t\theap_attisnull(procTuple, Anum_pg_proc_proargmodes, NULL))\n\t\treturn NULL;\n\n\t/* Get the data out of the tuple */\n\tproallargtypes = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_proallargtypes,\n\t\t\t\t\t\t\t\t\t &isnull);\n\tAssert(!isnull);\n\tproargmodes = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargmodes,\n\t\t\t\t\t\t\t\t  &isnull);\n\tAssert(!isnull);\n\tproargnames = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargnames,\n\t\t\t\t\t\t\t\t  &isnull);\n\tif (isnull)\n\t\tproargnames = PointerGetDatum(NULL);\t/* just to be sure */\n\n\treturn build_function_result_tupdesc_d(procform->prokind,\n\t\t\t\t\t\t\t\t\t\t   proallargtypes,\n\t\t\t\t\t\t\t\t\t\t   proargmodes,\n\t\t\t\t\t\t\t\t\t\t   proargnames);\n}"
  },
  {
    "function_name": "get_func_result_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "1072-1163",
    "snippet": "char *\nget_func_result_name(Oid functionId)\n{\n\tchar\t   *result;\n\tHeapTuple\tprocTuple;\n\tDatum\t\tproargmodes;\n\tDatum\t\tproargnames;\n\tbool\t\tisnull;\n\tArrayType  *arr;\n\tint\t\t\tnumargs;\n\tchar\t   *argmodes;\n\tDatum\t   *argnames;\n\tint\t\t\tnumoutargs;\n\tint\t\t\tnargnames;\n\tint\t\t\ti;\n\n\t/* First fetch the function's pg_proc row */\n\tprocTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\n\t/* If there are no named OUT parameters, return NULL */\n\tif (heap_attisnull(procTuple, Anum_pg_proc_proargmodes, NULL) ||\n\t\theap_attisnull(procTuple, Anum_pg_proc_proargnames, NULL))\n\t\tresult = NULL;\n\telse\n\t{\n\t\t/* Get the data out of the tuple */\n\t\tproargmodes = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t\t  Anum_pg_proc_proargmodes,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\tproargnames = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t\t  Anum_pg_proc_proargnames,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\n\t\t/*\n\t\t * We expect the arrays to be 1-D arrays of the right types; verify\n\t\t * that.  For the char array, we don't need to use deconstruct_array()\n\t\t * since the array data is just going to look like a C array of\n\t\t * values.\n\t\t */\n\t\tarr = DatumGetArrayTypeP(proargmodes);\t/* ensure not toasted */\n\t\tnumargs = ARR_DIMS(arr)[0];\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tnumargs < 0 ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != CHAROID)\n\t\t\telog(ERROR, \"proargmodes is not a 1-D char array\");\n\t\targmodes = (char *) ARR_DATA_PTR(arr);\n\t\tarr = DatumGetArrayTypeP(proargnames);\t/* ensure not toasted */\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tARR_DIMS(arr)[0] != numargs ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != TEXTOID)\n\t\t\telog(ERROR, \"proargnames is not a 1-D text array\");\n\t\tdeconstruct_array(arr, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &argnames, NULL, &nargnames);\n\t\tAssert(nargnames == numargs);\n\n\t\t/* scan for output argument(s) */\n\t\tresult = NULL;\n\t\tnumoutargs = 0;\n\t\tfor (i = 0; i < numargs; i++)\n\t\t{\n\t\t\tif (argmodes[i] == PROARGMODE_IN ||\n\t\t\t\targmodes[i] == PROARGMODE_VARIADIC)\n\t\t\t\tcontinue;\n\t\t\tAssert(argmodes[i] == PROARGMODE_OUT ||\n\t\t\t\t   argmodes[i] == PROARGMODE_INOUT ||\n\t\t\t\t   argmodes[i] == PROARGMODE_TABLE);\n\t\t\tif (++numoutargs > 1)\n\t\t\t{\n\t\t\t\t/* multiple out args, so forget it */\n\t\t\t\tresult = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = TextDatumGetCString(argnames[i]);\n\t\t\tif (result == NULL || result[0] == '\\0')\n\t\t\t{\n\t\t\t\t/* Parameter is not named, so forget it */\n\t\t\t\tresult = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tReleaseSysCache(procTuple);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "procTuple"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "argnames[i]"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "argmodes[i] == PROARGMODE_OUT ||\n\t\t\t\t   argmodes[i] == PROARGMODE_INOUT ||\n\t\t\t\t   argmodes[i] == PROARGMODE_TABLE"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nargnames == numargs"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "arr",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&argnames",
            "NULL",
            "&nargnames"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"proargnames is not a 1-D text array\""
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "proargnames"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "arr"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "proargmodes"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "PROCOID",
            "procTuple",
            "Anum_pg_proc_proargnames",
            "&isnull"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_attisnull",
          "args": [
            "procTuple",
            "Anum_pg_proc_proargnames",
            "NULL"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_attisnull",
          "args": [
            "procTuple",
            "Anum_pg_proc_proargmodes",
            "NULL"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "procTuple"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "PROCOID",
            "ObjectIdGetDatum(functionId)"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "functionId"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nchar *\nget_func_result_name(Oid functionId)\n{\n\tchar\t   *result;\n\tHeapTuple\tprocTuple;\n\tDatum\t\tproargmodes;\n\tDatum\t\tproargnames;\n\tbool\t\tisnull;\n\tArrayType  *arr;\n\tint\t\t\tnumargs;\n\tchar\t   *argmodes;\n\tDatum\t   *argnames;\n\tint\t\t\tnumoutargs;\n\tint\t\t\tnargnames;\n\tint\t\t\ti;\n\n\t/* First fetch the function's pg_proc row */\n\tprocTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\n\t/* If there are no named OUT parameters, return NULL */\n\tif (heap_attisnull(procTuple, Anum_pg_proc_proargmodes, NULL) ||\n\t\theap_attisnull(procTuple, Anum_pg_proc_proargnames, NULL))\n\t\tresult = NULL;\n\telse\n\t{\n\t\t/* Get the data out of the tuple */\n\t\tproargmodes = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t\t  Anum_pg_proc_proargmodes,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\tproargnames = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t\t  Anum_pg_proc_proargnames,\n\t\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\n\t\t/*\n\t\t * We expect the arrays to be 1-D arrays of the right types; verify\n\t\t * that.  For the char array, we don't need to use deconstruct_array()\n\t\t * since the array data is just going to look like a C array of\n\t\t * values.\n\t\t */\n\t\tarr = DatumGetArrayTypeP(proargmodes);\t/* ensure not toasted */\n\t\tnumargs = ARR_DIMS(arr)[0];\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tnumargs < 0 ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != CHAROID)\n\t\t\telog(ERROR, \"proargmodes is not a 1-D char array\");\n\t\targmodes = (char *) ARR_DATA_PTR(arr);\n\t\tarr = DatumGetArrayTypeP(proargnames);\t/* ensure not toasted */\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tARR_DIMS(arr)[0] != numargs ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != TEXTOID)\n\t\t\telog(ERROR, \"proargnames is not a 1-D text array\");\n\t\tdeconstruct_array(arr, TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &argnames, NULL, &nargnames);\n\t\tAssert(nargnames == numargs);\n\n\t\t/* scan for output argument(s) */\n\t\tresult = NULL;\n\t\tnumoutargs = 0;\n\t\tfor (i = 0; i < numargs; i++)\n\t\t{\n\t\t\tif (argmodes[i] == PROARGMODE_IN ||\n\t\t\t\targmodes[i] == PROARGMODE_VARIADIC)\n\t\t\t\tcontinue;\n\t\t\tAssert(argmodes[i] == PROARGMODE_OUT ||\n\t\t\t\t   argmodes[i] == PROARGMODE_INOUT ||\n\t\t\t\t   argmodes[i] == PROARGMODE_TABLE);\n\t\t\tif (++numoutargs > 1)\n\t\t\t{\n\t\t\t\t/* multiple out args, so forget it */\n\t\t\t\tresult = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = TextDatumGetCString(argnames[i]);\n\t\t\tif (result == NULL || result[0] == '\\0')\n\t\t\t{\n\t\t\t\t/* Parameter is not named, so forget it */\n\t\t\t\tresult = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tReleaseSysCache(procTuple);\n\n\treturn result;\n}"
  },
  {
    "function_name": "get_func_input_arg_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "987-1060",
    "snippet": "int\nget_func_input_arg_names(Datum proargnames, Datum proargmodes,\n\t\t\t\t\t\t char ***arg_names)\n{\n\tArrayType  *arr;\n\tint\t\t\tnumargs;\n\tDatum\t   *argnames;\n\tchar\t   *argmodes;\n\tchar\t  **inargnames;\n\tint\t\t\tnuminargs;\n\tint\t\t\ti;\n\n\t/* Do nothing if null proargnames */\n\tif (proargnames == PointerGetDatum(NULL))\n\t{\n\t\t*arg_names = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We expect the arrays to be 1-D arrays of the right types; verify that.\n\t * For proargmodes, we don't need to use deconstruct_array() since the\n\t * array data is just going to look like a C array of values.\n\t */\n\tarr = DatumGetArrayTypeP(proargnames);\t/* ensure not toasted */\n\tif (ARR_NDIM(arr) != 1 ||\n\t\tARR_HASNULL(arr) ||\n\t\tARR_ELEMTYPE(arr) != TEXTOID)\n\t\telog(ERROR, \"proargnames is not a 1-D text array\");\n\tdeconstruct_array(arr, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &argnames, NULL, &numargs);\n\tif (proargmodes != PointerGetDatum(NULL))\n\t{\n\t\tarr = DatumGetArrayTypeP(proargmodes);\t/* ensure not toasted */\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tARR_DIMS(arr)[0] != numargs ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != CHAROID)\n\t\t\telog(ERROR, \"proargmodes is not a 1-D char array\");\n\t\targmodes = (char *) ARR_DATA_PTR(arr);\n\t}\n\telse\n\t\targmodes = NULL;\n\n\t/* zero elements probably shouldn't happen, but handle it gracefully */\n\tif (numargs <= 0)\n\t{\n\t\t*arg_names = NULL;\n\t\treturn 0;\n\t}\n\n\t/* extract input-argument names */\n\tinargnames = (char **) palloc(numargs * sizeof(char *));\n\tnuminargs = 0;\n\tfor (i = 0; i < numargs; i++)\n\t{\n\t\tif (argmodes == NULL ||\n\t\t\targmodes[i] == PROARGMODE_IN ||\n\t\t\targmodes[i] == PROARGMODE_INOUT ||\n\t\t\targmodes[i] == PROARGMODE_VARIADIC)\n\t\t{\n\t\t\tchar\t   *pname = TextDatumGetCString(argnames[i]);\n\n\t\t\tif (pname[0] != '\\0')\n\t\t\t\tinargnames[numinargs] = pname;\n\t\t\telse\n\t\t\t\tinargnames[numinargs] = NULL;\n\t\t\tnuminargs++;\n\t\t}\n\t}\n\n\t*arg_names = inargnames;\n\treturn numinargs;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "argnames[i]"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "numargs * sizeof(char *)"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "arr"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"proargmodes is not a 1-D char array\""
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "proargmodes"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "arr",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&argnames",
            "NULL",
            "&numargs"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "proargnames"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "NULL"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nget_func_input_arg_names(Datum proargnames, Datum proargmodes,\n\t\t\t\t\t\t char ***arg_names)\n{\n\tArrayType  *arr;\n\tint\t\t\tnumargs;\n\tDatum\t   *argnames;\n\tchar\t   *argmodes;\n\tchar\t  **inargnames;\n\tint\t\t\tnuminargs;\n\tint\t\t\ti;\n\n\t/* Do nothing if null proargnames */\n\tif (proargnames == PointerGetDatum(NULL))\n\t{\n\t\t*arg_names = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We expect the arrays to be 1-D arrays of the right types; verify that.\n\t * For proargmodes, we don't need to use deconstruct_array() since the\n\t * array data is just going to look like a C array of values.\n\t */\n\tarr = DatumGetArrayTypeP(proargnames);\t/* ensure not toasted */\n\tif (ARR_NDIM(arr) != 1 ||\n\t\tARR_HASNULL(arr) ||\n\t\tARR_ELEMTYPE(arr) != TEXTOID)\n\t\telog(ERROR, \"proargnames is not a 1-D text array\");\n\tdeconstruct_array(arr, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &argnames, NULL, &numargs);\n\tif (proargmodes != PointerGetDatum(NULL))\n\t{\n\t\tarr = DatumGetArrayTypeP(proargmodes);\t/* ensure not toasted */\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tARR_DIMS(arr)[0] != numargs ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != CHAROID)\n\t\t\telog(ERROR, \"proargmodes is not a 1-D char array\");\n\t\targmodes = (char *) ARR_DATA_PTR(arr);\n\t}\n\telse\n\t\targmodes = NULL;\n\n\t/* zero elements probably shouldn't happen, but handle it gracefully */\n\tif (numargs <= 0)\n\t{\n\t\t*arg_names = NULL;\n\t\treturn 0;\n\t}\n\n\t/* extract input-argument names */\n\tinargnames = (char **) palloc(numargs * sizeof(char *));\n\tnuminargs = 0;\n\tfor (i = 0; i < numargs; i++)\n\t{\n\t\tif (argmodes == NULL ||\n\t\t\targmodes[i] == PROARGMODE_IN ||\n\t\t\targmodes[i] == PROARGMODE_INOUT ||\n\t\t\targmodes[i] == PROARGMODE_VARIADIC)\n\t\t{\n\t\t\tchar\t   *pname = TextDatumGetCString(argnames[i]);\n\n\t\t\tif (pname[0] != '\\0')\n\t\t\t\tinargnames[numinargs] = pname;\n\t\t\telse\n\t\t\t\tinargnames[numinargs] = NULL;\n\t\t\tnuminargs++;\n\t\t}\n\t}\n\n\t*arg_names = inargnames;\n\treturn numinargs;\n}"
  },
  {
    "function_name": "get_func_trftypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "939-975",
    "snippet": "int\nget_func_trftypes(HeapTuple procTup,\n\t\t\t\t  Oid **p_trftypes)\n{\n\tDatum\t\tprotrftypes;\n\tArrayType  *arr;\n\tint\t\t\tnelems;\n\tbool\t\tisNull;\n\n\tprotrftypes = SysCacheGetAttr(PROCOID, procTup,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_protrftypes,\n\t\t\t\t\t\t\t\t  &isNull);\n\tif (!isNull)\n\t{\n\t\t/*\n\t\t * We expect the arrays to be 1-D arrays of the right types; verify\n\t\t * that.  For the OID and char arrays, we don't need to use\n\t\t * deconstruct_array() since the array data is just going to look like\n\t\t * a C array of values.\n\t\t */\n\t\tarr = DatumGetArrayTypeP(protrftypes);\t/* ensure not toasted */\n\t\tnelems = ARR_DIMS(arr)[0];\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tnelems < 0 ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != OIDOID)\n\t\t\telog(ERROR, \"protrftypes is not a 1-D Oid array\");\n\t\tAssert(nelems >= ((Form_pg_proc) GETSTRUCT(procTup))->pronargs);\n\t\t*p_trftypes = (Oid *) palloc(nelems * sizeof(Oid));\n\t\tmemcpy(*p_trftypes, ARR_DATA_PTR(arr),\n\t\t\t   nelems * sizeof(Oid));\n\n\t\treturn nelems;\n\t}\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*p_trftypes",
            "ARR_DATA_PTR(arr)",
            "nelems * sizeof(Oid)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "arr"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nelems * sizeof(Oid)"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nelems >= ((Form_pg_proc) GETSTRUCT(procTup))->pronargs"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "procTup"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"protrftypes is not a 1-D Oid array\""
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "protrftypes"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "PROCOID",
            "procTup",
            "Anum_pg_proc_protrftypes",
            "&isNull"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nget_func_trftypes(HeapTuple procTup,\n\t\t\t\t  Oid **p_trftypes)\n{\n\tDatum\t\tprotrftypes;\n\tArrayType  *arr;\n\tint\t\t\tnelems;\n\tbool\t\tisNull;\n\n\tprotrftypes = SysCacheGetAttr(PROCOID, procTup,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_protrftypes,\n\t\t\t\t\t\t\t\t  &isNull);\n\tif (!isNull)\n\t{\n\t\t/*\n\t\t * We expect the arrays to be 1-D arrays of the right types; verify\n\t\t * that.  For the OID and char arrays, we don't need to use\n\t\t * deconstruct_array() since the array data is just going to look like\n\t\t * a C array of values.\n\t\t */\n\t\tarr = DatumGetArrayTypeP(protrftypes);\t/* ensure not toasted */\n\t\tnelems = ARR_DIMS(arr)[0];\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tnelems < 0 ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != OIDOID)\n\t\t\telog(ERROR, \"protrftypes is not a 1-D Oid array\");\n\t\tAssert(nelems >= ((Form_pg_proc) GETSTRUCT(procTup))->pronargs);\n\t\t*p_trftypes = (Oid *) palloc(nelems * sizeof(Oid));\n\t\tmemcpy(*p_trftypes, ARR_DATA_PTR(arr),\n\t\t\t   nelems * sizeof(Oid));\n\n\t\treturn nelems;\n\t}\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "get_func_arg_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "845-932",
    "snippet": "int\nget_func_arg_info(HeapTuple procTup,\n\t\t\t\t  Oid **p_argtypes, char ***p_argnames, char **p_argmodes)\n{\n\tForm_pg_proc procStruct = (Form_pg_proc) GETSTRUCT(procTup);\n\tDatum\t\tproallargtypes;\n\tDatum\t\tproargmodes;\n\tDatum\t\tproargnames;\n\tbool\t\tisNull;\n\tArrayType  *arr;\n\tint\t\t\tnumargs;\n\tDatum\t   *elems;\n\tint\t\t\tnelems;\n\tint\t\t\ti;\n\n\t/* First discover the total number of parameters and get their types */\n\tproallargtypes = SysCacheGetAttr(PROCOID, procTup,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_proallargtypes,\n\t\t\t\t\t\t\t\t\t &isNull);\n\tif (!isNull)\n\t{\n\t\t/*\n\t\t * We expect the arrays to be 1-D arrays of the right types; verify\n\t\t * that.  For the OID and char arrays, we don't need to use\n\t\t * deconstruct_array() since the array data is just going to look like\n\t\t * a C array of values.\n\t\t */\n\t\tarr = DatumGetArrayTypeP(proallargtypes);\t/* ensure not toasted */\n\t\tnumargs = ARR_DIMS(arr)[0];\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tnumargs < 0 ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != OIDOID)\n\t\t\telog(ERROR, \"proallargtypes is not a 1-D Oid array\");\n\t\tAssert(numargs >= procStruct->pronargs);\n\t\t*p_argtypes = (Oid *) palloc(numargs * sizeof(Oid));\n\t\tmemcpy(*p_argtypes, ARR_DATA_PTR(arr),\n\t\t\t   numargs * sizeof(Oid));\n\t}\n\telse\n\t{\n\t\t/* If no proallargtypes, use proargtypes */\n\t\tnumargs = procStruct->proargtypes.dim1;\n\t\tAssert(numargs == procStruct->pronargs);\n\t\t*p_argtypes = (Oid *) palloc(numargs * sizeof(Oid));\n\t\tmemcpy(*p_argtypes, procStruct->proargtypes.values,\n\t\t\t   numargs * sizeof(Oid));\n\t}\n\n\t/* Get argument names, if available */\n\tproargnames = SysCacheGetAttr(PROCOID, procTup,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargnames,\n\t\t\t\t\t\t\t\t  &isNull);\n\tif (isNull)\n\t\t*p_argnames = NULL;\n\telse\n\t{\n\t\tdeconstruct_array(DatumGetArrayTypeP(proargnames),\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &elems, NULL, &nelems);\n\t\tif (nelems != numargs)\t/* should not happen */\n\t\t\telog(ERROR, \"proargnames must have the same number of elements as the function has arguments\");\n\t\t*p_argnames = (char **) palloc(sizeof(char *) * numargs);\n\t\tfor (i = 0; i < numargs; i++)\n\t\t\t(*p_argnames)[i] = TextDatumGetCString(elems[i]);\n\t}\n\n\t/* Get argument modes, if available */\n\tproargmodes = SysCacheGetAttr(PROCOID, procTup,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargmodes,\n\t\t\t\t\t\t\t\t  &isNull);\n\tif (isNull)\n\t\t*p_argmodes = NULL;\n\telse\n\t{\n\t\tarr = DatumGetArrayTypeP(proargmodes);\t/* ensure not toasted */\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tARR_DIMS(arr)[0] != numargs ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != CHAROID)\n\t\t\telog(ERROR, \"proargmodes is not a 1-D char array\");\n\t\t*p_argmodes = (char *) palloc(numargs * sizeof(char));\n\t\tmemcpy(*p_argmodes, ARR_DATA_PTR(arr),\n\t\t\t   numargs * sizeof(char));\n\t}\n\n\treturn numargs;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*p_argmodes",
            "ARR_DATA_PTR(arr)",
            "numargs * sizeof(char)"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "arr"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "numargs * sizeof(char)"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"proargmodes is not a 1-D char array\""
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "proargmodes"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "PROCOID",
            "procTup",
            "Anum_pg_proc_proargmodes",
            "&isNull"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "elems[i]"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "DatumGetArrayTypeP(proargnames)",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&elems",
            "NULL",
            "&nelems"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "proargnames"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*p_argtypes",
            "procStruct->proargtypes.values",
            "numargs * sizeof(Oid)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "numargs == procStruct->pronargs"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*p_argtypes",
            "ARR_DATA_PTR(arr)",
            "numargs * sizeof(Oid)"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "arr"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "numargs >= procStruct->pronargs"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "proallargtypes"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "procTup"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nget_func_arg_info(HeapTuple procTup,\n\t\t\t\t  Oid **p_argtypes, char ***p_argnames, char **p_argmodes)\n{\n\tForm_pg_proc procStruct = (Form_pg_proc) GETSTRUCT(procTup);\n\tDatum\t\tproallargtypes;\n\tDatum\t\tproargmodes;\n\tDatum\t\tproargnames;\n\tbool\t\tisNull;\n\tArrayType  *arr;\n\tint\t\t\tnumargs;\n\tDatum\t   *elems;\n\tint\t\t\tnelems;\n\tint\t\t\ti;\n\n\t/* First discover the total number of parameters and get their types */\n\tproallargtypes = SysCacheGetAttr(PROCOID, procTup,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_proallargtypes,\n\t\t\t\t\t\t\t\t\t &isNull);\n\tif (!isNull)\n\t{\n\t\t/*\n\t\t * We expect the arrays to be 1-D arrays of the right types; verify\n\t\t * that.  For the OID and char arrays, we don't need to use\n\t\t * deconstruct_array() since the array data is just going to look like\n\t\t * a C array of values.\n\t\t */\n\t\tarr = DatumGetArrayTypeP(proallargtypes);\t/* ensure not toasted */\n\t\tnumargs = ARR_DIMS(arr)[0];\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tnumargs < 0 ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != OIDOID)\n\t\t\telog(ERROR, \"proallargtypes is not a 1-D Oid array\");\n\t\tAssert(numargs >= procStruct->pronargs);\n\t\t*p_argtypes = (Oid *) palloc(numargs * sizeof(Oid));\n\t\tmemcpy(*p_argtypes, ARR_DATA_PTR(arr),\n\t\t\t   numargs * sizeof(Oid));\n\t}\n\telse\n\t{\n\t\t/* If no proallargtypes, use proargtypes */\n\t\tnumargs = procStruct->proargtypes.dim1;\n\t\tAssert(numargs == procStruct->pronargs);\n\t\t*p_argtypes = (Oid *) palloc(numargs * sizeof(Oid));\n\t\tmemcpy(*p_argtypes, procStruct->proargtypes.values,\n\t\t\t   numargs * sizeof(Oid));\n\t}\n\n\t/* Get argument names, if available */\n\tproargnames = SysCacheGetAttr(PROCOID, procTup,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargnames,\n\t\t\t\t\t\t\t\t  &isNull);\n\tif (isNull)\n\t\t*p_argnames = NULL;\n\telse\n\t{\n\t\tdeconstruct_array(DatumGetArrayTypeP(proargnames),\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &elems, NULL, &nelems);\n\t\tif (nelems != numargs)\t/* should not happen */\n\t\t\telog(ERROR, \"proargnames must have the same number of elements as the function has arguments\");\n\t\t*p_argnames = (char **) palloc(sizeof(char *) * numargs);\n\t\tfor (i = 0; i < numargs; i++)\n\t\t\t(*p_argnames)[i] = TextDatumGetCString(elems[i]);\n\t}\n\n\t/* Get argument modes, if available */\n\tproargmodes = SysCacheGetAttr(PROCOID, procTup,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargmodes,\n\t\t\t\t\t\t\t\t  &isNull);\n\tif (isNull)\n\t\t*p_argmodes = NULL;\n\telse\n\t{\n\t\tarr = DatumGetArrayTypeP(proargmodes);\t/* ensure not toasted */\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tARR_DIMS(arr)[0] != numargs ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != CHAROID)\n\t\t\telog(ERROR, \"proargmodes is not a 1-D char array\");\n\t\t*p_argmodes = (char *) palloc(numargs * sizeof(char));\n\t\tmemcpy(*p_argmodes, ARR_DATA_PTR(arr),\n\t\t\t   numargs * sizeof(char));\n\t}\n\n\treturn numargs;\n}"
  },
  {
    "function_name": "get_type_func_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "795-830",
    "snippet": "static TypeFuncClass\nget_type_func_class(Oid typid, Oid *base_typeid)\n{\n\t*base_typeid = typid;\n\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn TYPEFUNC_COMPOSITE;\n\t\tcase TYPTYPE_BASE:\n\t\tcase TYPTYPE_ENUM:\n\t\tcase TYPTYPE_RANGE:\n\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\t*base_typeid = typid = getBaseType(typid);\n\t\t\tif (get_typtype(typid) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn TYPEFUNC_COMPOSITE_DOMAIN;\n\t\t\telse\t\t\t\t/* domain base type can't be a pseudotype */\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_PSEUDO:\n\t\t\tif (typid == RECORDOID)\n\t\t\t\treturn TYPEFUNC_RECORD;\n\n\t\t\t/*\n\t\t\t * We treat VOID and CSTRING as legitimate scalar datatypes,\n\t\t\t * mostly for the convenience of the JDBC driver (which wants to\n\t\t\t * be able to do \"SELECT * FROM foo()\" for all legitimately\n\t\t\t * user-callable functions).\n\t\t\t */\n\t\t\tif (typid == VOIDOID || typid == CSTRINGOID)\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\t\treturn TYPEFUNC_OTHER;\n\t}\n\t/* shouldn't get here, probably */\n\treturn TYPEFUNC_OTHER;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TypeFuncClass get_type_func_class(Oid typid, Oid *base_typeid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_typtype",
          "args": [
            "typid"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "get_typtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2406-2423",
          "snippet": "char\nget_typtype(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tchar\t\tresult;\n\n\t\tresult = typtup->typtype;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn '\\0';\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar\nget_typtype(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tchar\t\tresult;\n\n\t\tresult = typtup->typtype;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "getBaseType",
          "args": [
            "typid"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "getBaseType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2298-2304",
          "snippet": "Oid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\ngetBaseType(Oid typid)\n{\n\tint32\t\ttypmod = -1;\n\n\treturn getBaseTypeAndTypmod(typid, &typmod);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass get_type_func_class(Oid typid, Oid *base_typeid);\n\nstatic TypeFuncClass\nget_type_func_class(Oid typid, Oid *base_typeid)\n{\n\t*base_typeid = typid;\n\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn TYPEFUNC_COMPOSITE;\n\t\tcase TYPTYPE_BASE:\n\t\tcase TYPTYPE_ENUM:\n\t\tcase TYPTYPE_RANGE:\n\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\t*base_typeid = typid = getBaseType(typid);\n\t\t\tif (get_typtype(typid) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn TYPEFUNC_COMPOSITE_DOMAIN;\n\t\t\telse\t\t\t\t/* domain base type can't be a pseudotype */\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_PSEUDO:\n\t\t\tif (typid == RECORDOID)\n\t\t\t\treturn TYPEFUNC_RECORD;\n\n\t\t\t/*\n\t\t\t * We treat VOID and CSTRING as legitimate scalar datatypes,\n\t\t\t * mostly for the convenience of the JDBC driver (which wants to\n\t\t\t * be able to do \"SELECT * FROM foo()\" for all legitimately\n\t\t\t * user-callable functions).\n\t\t\t */\n\t\t\tif (typid == VOIDOID || typid == CSTRINGOID)\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\t\treturn TYPEFUNC_OTHER;\n\t}\n\t/* shouldn't get here, probably */\n\treturn TYPEFUNC_OTHER;\n}"
  },
  {
    "function_name": "resolve_polymorphic_argtypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "643-784",
    "snippet": "bool\nresolve_polymorphic_argtypes(int numargs, Oid *argtypes, char *argmodes,\n\t\t\t\t\t\t\t Node *call_expr)\n{\n\tbool\t\thave_anyelement_result = false;\n\tbool\t\thave_anyarray_result = false;\n\tbool\t\thave_anyrange_result = false;\n\tOid\t\t\tanyelement_type = InvalidOid;\n\tOid\t\t\tanyarray_type = InvalidOid;\n\tOid\t\t\tanyrange_type = InvalidOid;\n\tint\t\t\tinargno;\n\tint\t\t\ti;\n\n\t/* First pass: resolve polymorphic inputs, check for outputs */\n\tinargno = 0;\n\tfor (i = 0; i < numargs; i++)\n\t{\n\t\tchar\t\targmode = argmodes ? argmodes[i] : PROARGMODE_IN;\n\n\t\tswitch (argtypes[i])\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\tif (argmode == PROARGMODE_OUT || argmode == PROARGMODE_TABLE)\n\t\t\t\t\thave_anyelement_result = true;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!OidIsValid(anyelement_type))\n\t\t\t\t\t{\n\t\t\t\t\t\tanyelement_type = get_call_expr_argtype(call_expr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinargno);\n\t\t\t\t\t\tif (!OidIsValid(anyelement_type))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\targtypes[i] = anyelement_type;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\tif (argmode == PROARGMODE_OUT || argmode == PROARGMODE_TABLE)\n\t\t\t\t\thave_anyarray_result = true;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!OidIsValid(anyarray_type))\n\t\t\t\t\t{\n\t\t\t\t\t\tanyarray_type = get_call_expr_argtype(call_expr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  inargno);\n\t\t\t\t\t\tif (!OidIsValid(anyarray_type))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\targtypes[i] = anyarray_type;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\tif (argmode == PROARGMODE_OUT || argmode == PROARGMODE_TABLE)\n\t\t\t\t\thave_anyrange_result = true;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!OidIsValid(anyrange_type))\n\t\t\t\t\t{\n\t\t\t\t\t\tanyrange_type = get_call_expr_argtype(call_expr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  inargno);\n\t\t\t\t\t\tif (!OidIsValid(anyrange_type))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\targtypes[i] = anyrange_type;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif (argmode != PROARGMODE_OUT && argmode != PROARGMODE_TABLE)\n\t\t\tinargno++;\n\t}\n\n\t/* Done? */\n\tif (!have_anyelement_result && !have_anyarray_result &&\n\t\t!have_anyrange_result)\n\t\treturn true;\n\n\t/* If no input polymorphics, parser messed up */\n\tif (!OidIsValid(anyelement_type) && !OidIsValid(anyarray_type) &&\n\t\t!OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* If needed, deduce one polymorphic type from others */\n\tif (have_anyelement_result && !OidIsValid(anyelement_type))\n\t{\n\t\tif (OidIsValid(anyarray_type))\n\t\t\tanyelement_type = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t   anyarray_type,\n\t\t\t\t\t\t\t\t\t\t\t\t   ANYARRAYOID);\n\t\tif (OidIsValid(anyrange_type))\n\t\t{\n\t\t\tOid\t\t\tsubtype = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   anyrange_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ANYRANGEOID);\n\n\t\t\t/* check for inconsistent array and range results */\n\t\t\tif (OidIsValid(anyelement_type) && anyelement_type != subtype)\n\t\t\t\treturn false;\n\t\t\tanyelement_type = subtype;\n\t\t}\n\t}\n\n\tif (have_anyarray_result && !OidIsValid(anyarray_type))\n\t\tanyarray_type = resolve_generic_type(ANYARRAYOID,\n\t\t\t\t\t\t\t\t\t\t\t anyelement_type,\n\t\t\t\t\t\t\t\t\t\t\t ANYELEMENTOID);\n\n\t/*\n\t * We can't deduce a range type from other polymorphic inputs, because\n\t * there may be multiple range types for the same subtype.\n\t */\n\tif (have_anyrange_result && !OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* XXX do we need to enforce ANYNONARRAY or ANYENUM here?  I think not */\n\n\t/* And finally replace the output column types as needed */\n\tfor (i = 0; i < numargs; i++)\n\t{\n\t\tswitch (argtypes[i])\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\targtypes[i] = anyelement_type;\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\targtypes[i] = anyarray_type;\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\targtypes[i] = anyrange_type;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyrange_type"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_generic_type",
          "args": [
            "ANYARRAYOID",
            "anyelement_type",
            "ANYELEMENTOID"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyarray_type"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyelement_type"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_generic_type",
          "args": [
            "ANYELEMENTOID",
            "anyrange_type",
            "ANYRANGEOID"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyrange_type"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_generic_type",
          "args": [
            "ANYELEMENTOID",
            "anyarray_type",
            "ANYARRAYOID"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyarray_type"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyelement_type"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyrange_type"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyarray_type"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyelement_type"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyrange_type"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_call_expr_argtype",
          "args": [
            "call_expr",
            "inargno"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "get_call_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "2013-2051",
          "snippet": "Oid\nget_call_expr_argtype(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tOid\t\t\targtype;\n\n\tif (expr == NULL)\n\t\treturn InvalidOid;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn InvalidOid;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn InvalidOid;\n\n\targtype = exprType((Node *) list_nth(args, argnum));\n\n\t/*\n\t * special hack for ScalarArrayOpExpr: what the underlying function will\n\t * actually get passed is the element type of the array.\n\t */\n\tif (IsA(expr, ScalarArrayOpExpr) &&\n\t\targnum == 1)\n\t\targtype = get_base_element_type(argtype);\n\n\treturn argtype;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_call_expr_argtype(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tOid\t\t\targtype;\n\n\tif (expr == NULL)\n\t\treturn InvalidOid;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn InvalidOid;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn InvalidOid;\n\n\targtype = exprType((Node *) list_nth(args, argnum));\n\n\t/*\n\t * special hack for ScalarArrayOpExpr: what the underlying function will\n\t * actually get passed is the element type of the array.\n\t */\n\tif (IsA(expr, ScalarArrayOpExpr) &&\n\t\targnum == 1)\n\t\targtype = get_base_element_type(argtype);\n\n\treturn argtype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyrange_type"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyarray_type"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyarray_type"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyelement_type"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyelement_type"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);\n\nbool\nresolve_polymorphic_argtypes(int numargs, Oid *argtypes, char *argmodes,\n\t\t\t\t\t\t\t Node *call_expr)\n{\n\tbool\t\thave_anyelement_result = false;\n\tbool\t\thave_anyarray_result = false;\n\tbool\t\thave_anyrange_result = false;\n\tOid\t\t\tanyelement_type = InvalidOid;\n\tOid\t\t\tanyarray_type = InvalidOid;\n\tOid\t\t\tanyrange_type = InvalidOid;\n\tint\t\t\tinargno;\n\tint\t\t\ti;\n\n\t/* First pass: resolve polymorphic inputs, check for outputs */\n\tinargno = 0;\n\tfor (i = 0; i < numargs; i++)\n\t{\n\t\tchar\t\targmode = argmodes ? argmodes[i] : PROARGMODE_IN;\n\n\t\tswitch (argtypes[i])\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\tif (argmode == PROARGMODE_OUT || argmode == PROARGMODE_TABLE)\n\t\t\t\t\thave_anyelement_result = true;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!OidIsValid(anyelement_type))\n\t\t\t\t\t{\n\t\t\t\t\t\tanyelement_type = get_call_expr_argtype(call_expr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinargno);\n\t\t\t\t\t\tif (!OidIsValid(anyelement_type))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\targtypes[i] = anyelement_type;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\tif (argmode == PROARGMODE_OUT || argmode == PROARGMODE_TABLE)\n\t\t\t\t\thave_anyarray_result = true;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!OidIsValid(anyarray_type))\n\t\t\t\t\t{\n\t\t\t\t\t\tanyarray_type = get_call_expr_argtype(call_expr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  inargno);\n\t\t\t\t\t\tif (!OidIsValid(anyarray_type))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\targtypes[i] = anyarray_type;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\tif (argmode == PROARGMODE_OUT || argmode == PROARGMODE_TABLE)\n\t\t\t\t\thave_anyrange_result = true;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!OidIsValid(anyrange_type))\n\t\t\t\t\t{\n\t\t\t\t\t\tanyrange_type = get_call_expr_argtype(call_expr,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  inargno);\n\t\t\t\t\t\tif (!OidIsValid(anyrange_type))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\targtypes[i] = anyrange_type;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif (argmode != PROARGMODE_OUT && argmode != PROARGMODE_TABLE)\n\t\t\tinargno++;\n\t}\n\n\t/* Done? */\n\tif (!have_anyelement_result && !have_anyarray_result &&\n\t\t!have_anyrange_result)\n\t\treturn true;\n\n\t/* If no input polymorphics, parser messed up */\n\tif (!OidIsValid(anyelement_type) && !OidIsValid(anyarray_type) &&\n\t\t!OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* If needed, deduce one polymorphic type from others */\n\tif (have_anyelement_result && !OidIsValid(anyelement_type))\n\t{\n\t\tif (OidIsValid(anyarray_type))\n\t\t\tanyelement_type = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t   anyarray_type,\n\t\t\t\t\t\t\t\t\t\t\t\t   ANYARRAYOID);\n\t\tif (OidIsValid(anyrange_type))\n\t\t{\n\t\t\tOid\t\t\tsubtype = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   anyrange_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ANYRANGEOID);\n\n\t\t\t/* check for inconsistent array and range results */\n\t\t\tif (OidIsValid(anyelement_type) && anyelement_type != subtype)\n\t\t\t\treturn false;\n\t\t\tanyelement_type = subtype;\n\t\t}\n\t}\n\n\tif (have_anyarray_result && !OidIsValid(anyarray_type))\n\t\tanyarray_type = resolve_generic_type(ANYARRAYOID,\n\t\t\t\t\t\t\t\t\t\t\t anyelement_type,\n\t\t\t\t\t\t\t\t\t\t\t ANYELEMENTOID);\n\n\t/*\n\t * We can't deduce a range type from other polymorphic inputs, because\n\t * there may be multiple range types for the same subtype.\n\t */\n\tif (have_anyrange_result && !OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* XXX do we need to enforce ANYNONARRAY or ANYENUM here?  I think not */\n\n\t/* And finally replace the output column types as needed */\n\tfor (i = 0; i < numargs; i++)\n\t{\n\t\tswitch (argtypes[i])\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\targtypes[i] = anyelement_type;\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\targtypes[i] = anyarray_type;\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\targtypes[i] = anyrange_type;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "resolve_polymorphic_tupdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "447-632",
    "snippet": "static bool\nresolve_polymorphic_tupdesc(TupleDesc tupdesc, oidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr)\n{\n\tint\t\t\tnatts = tupdesc->natts;\n\tint\t\t\tnargs = declared_args->dim1;\n\tbool\t\thave_anyelement_result = false;\n\tbool\t\thave_anyarray_result = false;\n\tbool\t\thave_anyrange_result = false;\n\tbool\t\thave_anynonarray = false;\n\tbool\t\thave_anyenum = false;\n\tOid\t\t\tanyelement_type = InvalidOid;\n\tOid\t\t\tanyarray_type = InvalidOid;\n\tOid\t\t\tanyrange_type = InvalidOid;\n\tOid\t\t\tanycollation = InvalidOid;\n\tint\t\t\ti;\n\n\t/* See if there are any polymorphic outputs; quick out if not */\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tswitch (TupleDescAttr(tupdesc, i)->atttypid)\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\thave_anyarray_result = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYNONARRAYOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\thave_anynonarray = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYENUMOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\thave_anyenum = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\thave_anyrange_result = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!have_anyelement_result && !have_anyarray_result &&\n\t\t!have_anyrange_result)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, extract actual datatype(s) from input arguments.  (We assume\n\t * the parser already validated consistency of the arguments.)\n\t */\n\tif (!call_expr)\n\t\treturn false;\t\t\t/* no hope */\n\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tswitch (declared_args->values[i])\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\tif (!OidIsValid(anyelement_type))\n\t\t\t\t\tanyelement_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\tif (!OidIsValid(anyarray_type))\n\t\t\t\t\tanyarray_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\tif (!OidIsValid(anyrange_type))\n\t\t\t\t\tanyrange_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If nothing found, parser messed up */\n\tif (!OidIsValid(anyelement_type) && !OidIsValid(anyarray_type) &&\n\t\t!OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* If needed, deduce one polymorphic type from others */\n\tif (have_anyelement_result && !OidIsValid(anyelement_type))\n\t{\n\t\tif (OidIsValid(anyarray_type))\n\t\t\tanyelement_type = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t   anyarray_type,\n\t\t\t\t\t\t\t\t\t\t\t\t   ANYARRAYOID);\n\t\tif (OidIsValid(anyrange_type))\n\t\t{\n\t\t\tOid\t\t\tsubtype = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   anyrange_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ANYRANGEOID);\n\n\t\t\t/* check for inconsistent array and range results */\n\t\t\tif (OidIsValid(anyelement_type) && anyelement_type != subtype)\n\t\t\t\treturn false;\n\t\t\tanyelement_type = subtype;\n\t\t}\n\t}\n\n\tif (have_anyarray_result && !OidIsValid(anyarray_type))\n\t\tanyarray_type = resolve_generic_type(ANYARRAYOID,\n\t\t\t\t\t\t\t\t\t\t\t anyelement_type,\n\t\t\t\t\t\t\t\t\t\t\t ANYELEMENTOID);\n\n\t/*\n\t * We can't deduce a range type from other polymorphic inputs, because\n\t * there may be multiple range types for the same subtype.\n\t */\n\tif (have_anyrange_result && !OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* Enforce ANYNONARRAY if needed */\n\tif (have_anynonarray && type_is_array(anyelement_type))\n\t\treturn false;\n\n\t/* Enforce ANYENUM if needed */\n\tif (have_anyenum && !type_is_enum(anyelement_type))\n\t\treturn false;\n\n\t/*\n\t * Identify the collation to use for polymorphic OUT parameters. (It'll\n\t * necessarily be the same for both anyelement and anyarray.)  Note that\n\t * range types are not collatable, so any possible internal collation of a\n\t * range type is not considered here.\n\t */\n\tif (OidIsValid(anyelement_type))\n\t\tanycollation = get_typcollation(anyelement_type);\n\telse if (OidIsValid(anyarray_type))\n\t\tanycollation = get_typcollation(anyarray_type);\n\n\tif (OidIsValid(anycollation))\n\t{\n\t\t/*\n\t\t * The types are collatable, so consider whether to use a nondefault\n\t\t * collation.  We do so if we can identify the input collation used\n\t\t * for the function.\n\t\t */\n\t\tOid\t\t\tinputcollation = exprInputCollation(call_expr);\n\n\t\tif (OidIsValid(inputcollation))\n\t\t\tanycollation = inputcollation;\n\t}\n\n\t/* And finally replace the tuple column types as needed */\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tswitch (att->atttypid)\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyelement_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\tTupleDescInitEntryCollation(tupdesc, i + 1, anycollation);\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyarray_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\tTupleDescInitEntryCollation(tupdesc, i + 1, anycollation);\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyrange_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\t/* no collation should be attached to a range type */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "i + 1",
            "NameStr(att->attname)",
            "anyrange_type",
            "-1",
            "0"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "att->attname"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntryCollation",
          "args": [
            "tupdesc",
            "i + 1",
            "anycollation"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "i + 1",
            "NameStr(att->attname)",
            "anyarray_type",
            "-1",
            "0"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "att->attname"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntryCollation",
          "args": [
            "tupdesc",
            "i + 1",
            "anycollation"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "i + 1",
            "NameStr(att->attname)",
            "anyelement_type",
            "-1",
            "0"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "att->attname"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "inputcollation"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprInputCollation",
          "args": [
            "call_expr"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anycollation"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typcollation",
          "args": [
            "anyarray_type"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "get_typcollation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2822-2839",
          "snippet": "Oid\nget_typcollation(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = typtup->typcollation;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_typcollation(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = typtup->typcollation;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyarray_type"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyelement_type"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type_is_enum",
          "args": [
            "anyelement_type"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "type_is_enum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2455-2459",
          "snippet": "bool\ntype_is_enum(Oid typid)\n{\n\treturn (get_typtype(typid) == TYPTYPE_ENUM);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\ntype_is_enum(Oid typid)\n{\n\treturn (get_typtype(typid) == TYPTYPE_ENUM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "type_is_array",
          "args": [
            "anyelement_type"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyrange_type"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_generic_type",
          "args": [
            "ANYARRAYOID",
            "anyelement_type",
            "ANYELEMENTOID"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyarray_type"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyelement_type"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_generic_type",
          "args": [
            "ANYELEMENTOID",
            "anyrange_type",
            "ANYRANGEOID"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyrange_type"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolve_generic_type",
          "args": [
            "ANYELEMENTOID",
            "anyarray_type",
            "ANYARRAYOID"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyarray_type"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyelement_type"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyrange_type"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyarray_type"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyelement_type"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_call_expr_argtype",
          "args": [
            "call_expr",
            "i"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "get_call_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "2013-2051",
          "snippet": "Oid\nget_call_expr_argtype(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tOid\t\t\targtype;\n\n\tif (expr == NULL)\n\t\treturn InvalidOid;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn InvalidOid;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn InvalidOid;\n\n\targtype = exprType((Node *) list_nth(args, argnum));\n\n\t/*\n\t * special hack for ScalarArrayOpExpr: what the underlying function will\n\t * actually get passed is the element type of the array.\n\t */\n\tif (IsA(expr, ScalarArrayOpExpr) &&\n\t\targnum == 1)\n\t\targtype = get_base_element_type(argtype);\n\n\treturn argtype;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_call_expr_argtype(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tOid\t\t\targtype;\n\n\tif (expr == NULL)\n\t\treturn InvalidOid;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn InvalidOid;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn InvalidOid;\n\n\targtype = exprType((Node *) list_nth(args, argnum));\n\n\t/*\n\t * special hack for ScalarArrayOpExpr: what the underlying function will\n\t * actually get passed is the element type of the array.\n\t */\n\tif (IsA(expr, ScalarArrayOpExpr) &&\n\t\targnum == 1)\n\t\targtype = get_base_element_type(argtype);\n\n\treturn argtype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyrange_type"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyarray_type"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "anyelement_type"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "i"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);\n\nstatic bool\nresolve_polymorphic_tupdesc(TupleDesc tupdesc, oidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr)\n{\n\tint\t\t\tnatts = tupdesc->natts;\n\tint\t\t\tnargs = declared_args->dim1;\n\tbool\t\thave_anyelement_result = false;\n\tbool\t\thave_anyarray_result = false;\n\tbool\t\thave_anyrange_result = false;\n\tbool\t\thave_anynonarray = false;\n\tbool\t\thave_anyenum = false;\n\tOid\t\t\tanyelement_type = InvalidOid;\n\tOid\t\t\tanyarray_type = InvalidOid;\n\tOid\t\t\tanyrange_type = InvalidOid;\n\tOid\t\t\tanycollation = InvalidOid;\n\tint\t\t\ti;\n\n\t/* See if there are any polymorphic outputs; quick out if not */\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tswitch (TupleDescAttr(tupdesc, i)->atttypid)\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\thave_anyarray_result = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYNONARRAYOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\thave_anynonarray = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYENUMOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\thave_anyenum = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\thave_anyrange_result = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!have_anyelement_result && !have_anyarray_result &&\n\t\t!have_anyrange_result)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, extract actual datatype(s) from input arguments.  (We assume\n\t * the parser already validated consistency of the arguments.)\n\t */\n\tif (!call_expr)\n\t\treturn false;\t\t\t/* no hope */\n\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tswitch (declared_args->values[i])\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\tif (!OidIsValid(anyelement_type))\n\t\t\t\t\tanyelement_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\tif (!OidIsValid(anyarray_type))\n\t\t\t\t\tanyarray_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\tif (!OidIsValid(anyrange_type))\n\t\t\t\t\tanyrange_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If nothing found, parser messed up */\n\tif (!OidIsValid(anyelement_type) && !OidIsValid(anyarray_type) &&\n\t\t!OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* If needed, deduce one polymorphic type from others */\n\tif (have_anyelement_result && !OidIsValid(anyelement_type))\n\t{\n\t\tif (OidIsValid(anyarray_type))\n\t\t\tanyelement_type = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t   anyarray_type,\n\t\t\t\t\t\t\t\t\t\t\t\t   ANYARRAYOID);\n\t\tif (OidIsValid(anyrange_type))\n\t\t{\n\t\t\tOid\t\t\tsubtype = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   anyrange_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ANYRANGEOID);\n\n\t\t\t/* check for inconsistent array and range results */\n\t\t\tif (OidIsValid(anyelement_type) && anyelement_type != subtype)\n\t\t\t\treturn false;\n\t\t\tanyelement_type = subtype;\n\t\t}\n\t}\n\n\tif (have_anyarray_result && !OidIsValid(anyarray_type))\n\t\tanyarray_type = resolve_generic_type(ANYARRAYOID,\n\t\t\t\t\t\t\t\t\t\t\t anyelement_type,\n\t\t\t\t\t\t\t\t\t\t\t ANYELEMENTOID);\n\n\t/*\n\t * We can't deduce a range type from other polymorphic inputs, because\n\t * there may be multiple range types for the same subtype.\n\t */\n\tif (have_anyrange_result && !OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* Enforce ANYNONARRAY if needed */\n\tif (have_anynonarray && type_is_array(anyelement_type))\n\t\treturn false;\n\n\t/* Enforce ANYENUM if needed */\n\tif (have_anyenum && !type_is_enum(anyelement_type))\n\t\treturn false;\n\n\t/*\n\t * Identify the collation to use for polymorphic OUT parameters. (It'll\n\t * necessarily be the same for both anyelement and anyarray.)  Note that\n\t * range types are not collatable, so any possible internal collation of a\n\t * range type is not considered here.\n\t */\n\tif (OidIsValid(anyelement_type))\n\t\tanycollation = get_typcollation(anyelement_type);\n\telse if (OidIsValid(anyarray_type))\n\t\tanycollation = get_typcollation(anyarray_type);\n\n\tif (OidIsValid(anycollation))\n\t{\n\t\t/*\n\t\t * The types are collatable, so consider whether to use a nondefault\n\t\t * collation.  We do so if we can identify the input collation used\n\t\t * for the function.\n\t\t */\n\t\tOid\t\t\tinputcollation = exprInputCollation(call_expr);\n\n\t\tif (OidIsValid(inputcollation))\n\t\t\tanycollation = inputcollation;\n\t}\n\n\t/* And finally replace the tuple column types as needed */\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tswitch (att->atttypid)\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyelement_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\tTupleDescInitEntryCollation(tupdesc, i + 1, anycollation);\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyarray_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\tTupleDescInitEntryCollation(tupdesc, i + 1, anycollation);\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyrange_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\t/* no collation should be attached to a range type */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "get_expr_result_tupdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "411-439",
    "snippet": "TupleDesc\nget_expr_result_tupdesc(Node *expr, bool noError)\n{\n\tTupleDesc\ttupleDesc;\n\tTypeFuncClass functypclass;\n\n\tfunctypclass = get_expr_result_type(expr, NULL, &tupleDesc);\n\n\tif (functypclass == TYPEFUNC_COMPOSITE ||\n\t\tfunctypclass == TYPEFUNC_COMPOSITE_DOMAIN)\n\t\treturn tupleDesc;\n\n\tif (!noError)\n\t{\n\t\tOid\t\t\texprTypeId = exprType(expr);\n\n\t\tif (exprTypeId != RECORDOID)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(exprTypeId))));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\"))"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"record type has not been registered\""
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_WRONG_OBJECT_TYPE"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(exprTypeId)))"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "exprTypeId"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "expr"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_expr_result_type",
          "args": [
            "expr",
            "NULL",
            "&tupleDesc"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "get_expr_result_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "226-263",
          "snippet": "TypeFuncClass\nget_expr_result_type(Node *expr,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\n\tif (expr && IsA(expr, FuncExpr))\n\t\tresult = internal_get_result_type(((FuncExpr *) expr)->funcid,\n\t\t\t\t\t\t\t\t\t\t  expr,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  resultTypeId,\n\t\t\t\t\t\t\t\t\t\t  resultTupleDesc);\n\telse if (expr && IsA(expr, OpExpr))\n\t\tresult = internal_get_result_type(get_opcode(((OpExpr *) expr)->opno),\n\t\t\t\t\t\t\t\t\t\t  expr,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  resultTypeId,\n\t\t\t\t\t\t\t\t\t\t  resultTupleDesc);\n\telse\n\t{\n\t\t/* handle as a generic expression; no chance to resolve RECORD */\n\t\tOid\t\t\ttypid = exprType(expr);\n\t\tOid\t\t\tbase_typid;\n\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = typid;\n\t\tif (resultTupleDesc)\n\t\t\t*resultTupleDesc = NULL;\n\t\tresult = get_type_func_class(typid, &base_typid);\n\t\tif ((result == TYPEFUNC_COMPOSITE ||\n\t\t\t result == TYPEFUNC_COMPOSITE_DOMAIN) &&\n\t\t\tresultTupleDesc)\n\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_typid, -1);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\n\nTypeFuncClass\nget_expr_result_type(Node *expr,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\n\tif (expr && IsA(expr, FuncExpr))\n\t\tresult = internal_get_result_type(((FuncExpr *) expr)->funcid,\n\t\t\t\t\t\t\t\t\t\t  expr,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  resultTypeId,\n\t\t\t\t\t\t\t\t\t\t  resultTupleDesc);\n\telse if (expr && IsA(expr, OpExpr))\n\t\tresult = internal_get_result_type(get_opcode(((OpExpr *) expr)->opno),\n\t\t\t\t\t\t\t\t\t\t  expr,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  resultTypeId,\n\t\t\t\t\t\t\t\t\t\t  resultTupleDesc);\n\telse\n\t{\n\t\t/* handle as a generic expression; no chance to resolve RECORD */\n\t\tOid\t\t\ttypid = exprType(expr);\n\t\tOid\t\t\tbase_typid;\n\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = typid;\n\t\tif (resultTupleDesc)\n\t\t\t*resultTupleDesc = NULL;\n\t\tresult = get_type_func_class(typid, &base_typid);\n\t\tif ((result == TYPEFUNC_COMPOSITE ||\n\t\t\t result == TYPEFUNC_COMPOSITE_DOMAIN) &&\n\t\t\tresultTupleDesc)\n\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_typid, -1);\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nTupleDesc\nget_expr_result_tupdesc(Node *expr, bool noError)\n{\n\tTupleDesc\ttupleDesc;\n\tTypeFuncClass functypclass;\n\n\tfunctypclass = get_expr_result_type(expr, NULL, &tupleDesc);\n\n\tif (functypclass == TYPEFUNC_COMPOSITE ||\n\t\tfunctypclass == TYPEFUNC_COMPOSITE_DOMAIN)\n\t\treturn tupleDesc;\n\n\tif (!noError)\n\t{\n\t\tOid\t\t\texprTypeId = exprType(expr);\n\n\t\tif (exprTypeId != RECORDOID)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"type %s is not composite\",\n\t\t\t\t\t\t\tformat_type_be(exprTypeId))));\n\t\telse\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_WRONG_OBJECT_TYPE),\n\t\t\t\t\t errmsg(\"record type has not been registered\")));\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "internal_get_result_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "291-399",
    "snippet": "static TypeFuncClass\ninternal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\tHeapTuple\ttp;\n\tForm_pg_proc procform;\n\tOid\t\t\trettype;\n\tOid\t\t\tbase_rettype;\n\tTupleDesc\ttupdesc;\n\n\t/* First fetch the function's pg_proc row to inspect its rettype */\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\tprocform = (Form_pg_proc) GETSTRUCT(tp);\n\n\trettype = procform->prorettype;\n\n\t/* Check for OUT parameters defining a RECORD result */\n\ttupdesc = build_function_result_tupdesc_t(tp);\n\tif (tupdesc)\n\t{\n\t\t/*\n\t\t * It has OUT parameters, so it's basically like a regular composite\n\t\t * type, except we have to be able to resolve any polymorphic OUT\n\t\t * parameters.\n\t\t */\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = rettype;\n\n\t\tif (resolve_polymorphic_tupdesc(tupdesc,\n\t\t\t\t\t\t\t\t\t\t&procform->proargtypes,\n\t\t\t\t\t\t\t\t\t\tcall_expr))\n\t\t{\n\t\t\tif (tupdesc->tdtypeid == RECORDOID &&\n\t\t\t\ttupdesc->tdtypmod < 0)\n\t\t\t\tassign_record_type_typmod(tupdesc);\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = tupdesc;\n\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = NULL;\n\t\t\tresult = TYPEFUNC_RECORD;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\treturn result;\n\t}\n\n\t/*\n\t * If scalar polymorphic result, try to resolve it.\n\t */\n\tif (IsPolymorphicType(rettype))\n\t{\n\t\tOid\t\t\tnewrettype = exprType(call_expr);\n\n\t\tif (newrettype == InvalidOid)\t/* this probably should not happen */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"could not determine actual result type for function \\\"%s\\\" declared to return type %s\",\n\t\t\t\t\t\t\tNameStr(procform->proname),\n\t\t\t\t\t\t\tformat_type_be(rettype))));\n\t\trettype = newrettype;\n\t}\n\n\tif (resultTypeId)\n\t\t*resultTypeId = rettype;\n\tif (resultTupleDesc)\n\t\t*resultTupleDesc = NULL;\t/* default result */\n\n\t/* Classify the result type */\n\tresult = get_type_func_class(rettype, &base_rettype);\n\tswitch (result)\n\t{\n\t\tcase TYPEFUNC_COMPOSITE:\n\t\tcase TYPEFUNC_COMPOSITE_DOMAIN:\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_rettype, -1);\n\t\t\t/* Named composite types can't have any polymorphic columns */\n\t\t\tbreak;\n\t\tcase TYPEFUNC_SCALAR:\n\t\t\tbreak;\n\t\tcase TYPEFUNC_RECORD:\n\t\t\t/* We must get the tupledesc from call context */\n\t\t\tif (rsinfo && IsA(rsinfo, ReturnSetInfo) &&\n\t\t\t\trsinfo->expectedDesc != NULL)\n\t\t\t{\n\t\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t\t\tif (resultTupleDesc)\n\t\t\t\t\t*resultTupleDesc = rsinfo->expectedDesc;\n\t\t\t\t/* Assume no polymorphic columns here, either */\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tp);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);",
      "static bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tp"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "rsinfo",
            "ReturnSetInfo"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc_copy",
          "args": [
            "base_rettype",
            "-1"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_type_func_class",
          "args": [
            "rettype",
            "&base_rettype"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "get_type_func_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "795-830",
          "snippet": "static TypeFuncClass\nget_type_func_class(Oid typid, Oid *base_typeid)\n{\n\t*base_typeid = typid;\n\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn TYPEFUNC_COMPOSITE;\n\t\tcase TYPTYPE_BASE:\n\t\tcase TYPTYPE_ENUM:\n\t\tcase TYPTYPE_RANGE:\n\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\t*base_typeid = typid = getBaseType(typid);\n\t\t\tif (get_typtype(typid) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn TYPEFUNC_COMPOSITE_DOMAIN;\n\t\t\telse\t\t\t\t/* domain base type can't be a pseudotype */\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_PSEUDO:\n\t\t\tif (typid == RECORDOID)\n\t\t\t\treturn TYPEFUNC_RECORD;\n\n\t\t\t/*\n\t\t\t * We treat VOID and CSTRING as legitimate scalar datatypes,\n\t\t\t * mostly for the convenience of the JDBC driver (which wants to\n\t\t\t * be able to do \"SELECT * FROM foo()\" for all legitimately\n\t\t\t * user-callable functions).\n\t\t\t */\n\t\t\tif (typid == VOIDOID || typid == CSTRINGOID)\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\t\treturn TYPEFUNC_OTHER;\n\t}\n\t/* shouldn't get here, probably */\n\treturn TYPEFUNC_OTHER;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass get_type_func_class(Oid typid, Oid *base_typeid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass get_type_func_class(Oid typid, Oid *base_typeid);\n\nstatic TypeFuncClass\nget_type_func_class(Oid typid, Oid *base_typeid)\n{\n\t*base_typeid = typid;\n\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn TYPEFUNC_COMPOSITE;\n\t\tcase TYPTYPE_BASE:\n\t\tcase TYPTYPE_ENUM:\n\t\tcase TYPTYPE_RANGE:\n\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\t*base_typeid = typid = getBaseType(typid);\n\t\t\tif (get_typtype(typid) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn TYPEFUNC_COMPOSITE_DOMAIN;\n\t\t\telse\t\t\t\t/* domain base type can't be a pseudotype */\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_PSEUDO:\n\t\t\tif (typid == RECORDOID)\n\t\t\t\treturn TYPEFUNC_RECORD;\n\n\t\t\t/*\n\t\t\t * We treat VOID and CSTRING as legitimate scalar datatypes,\n\t\t\t * mostly for the convenience of the JDBC driver (which wants to\n\t\t\t * be able to do \"SELECT * FROM foo()\" for all legitimately\n\t\t\t * user-callable functions).\n\t\t\t */\n\t\t\tif (typid == VOIDOID || typid == CSTRINGOID)\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\t\treturn TYPEFUNC_OTHER;\n\t}\n\t/* shouldn't get here, probably */\n\treturn TYPEFUNC_OTHER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"could not determine actual result type for function \\\"%s\\\" declared to return type %s\",\n\t\t\t\t\t\t\tNameStr(procform->proname),\n\t\t\t\t\t\t\tformat_type_be(rettype)))"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine actual result type for function \\\"%s\\\" declared to return type %s\"",
            "NameStr(procform->proname)",
            "format_type_be(rettype)"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "rettype"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "procform->proname"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "call_expr"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsPolymorphicType",
          "args": [
            "rettype"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assign_record_type_typmod",
          "args": [
            "tupdesc"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "assign_record_type_typmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1760-1823",
          "snippet": "void\nassign_record_type_typmod(TupleDesc tupDesc)\n{\n\tRecordCacheEntry *recentry;\n\tTupleDesc\tentDesc;\n\tbool\t\tfound;\n\tMemoryContext oldcxt;\n\n\tAssert(tupDesc->tdtypeid == RECORDOID);\n\n\tif (RecordCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(TupleDesc);\t/* just the pointer */\n\t\tctl.entrysize = sizeof(RecordCacheEntry);\n\t\tctl.hash = record_type_typmod_hash;\n\t\tctl.match = record_type_typmod_compare;\n\t\tRecordCacheHash = hash_create(\"Record information cache\", 64,\n\t\t\t\t\t\t\t\t\t  &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_FUNCTION | HASH_COMPARE);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Find or create a hashtable entry for this tuple descriptor */\n\trecentry = (RecordCacheEntry *) hash_search(RecordCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t(void *) &tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\tHASH_ENTER, &found);\n\tif (found && recentry->tupdesc != NULL)\n\t{\n\t\ttupDesc->tdtypmod = recentry->tupdesc->tdtypmod;\n\t\treturn;\n\t}\n\n\t/* Not present, so need to manufacture an entry */\n\trecentry->tupdesc = NULL;\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/* Look in the SharedRecordTypmodRegistry, if attached */\n\tentDesc = find_or_make_matching_shared_tupledesc(tupDesc);\n\tif (entDesc == NULL)\n\t{\n\t\t/* Reference-counted local cache only. */\n\t\tentDesc = CreateTupleDescCopy(tupDesc);\n\t\tentDesc->tdrefcount = 1;\n\t\tentDesc->tdtypmod = NextRecordTypmod++;\n\t}\n\tensure_record_cache_typmod_slot_exists(entDesc->tdtypmod);\n\tRecordCacheArray[entDesc->tdtypmod] = entDesc;\n\trecentry->tupdesc = entDesc;\n\n\t/* Assign a unique tupdesc identifier, too. */\n\tRecordIdentifierArray[entDesc->tdtypmod] = ++tupledesc_id_counter;\n\n\t/* Update the caller's tuple descriptor. */\n\ttupDesc->tdtypmod = entDesc->tdtypmod;\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *RecordCacheHash = NULL;",
            "static TupleDesc *RecordCacheArray = NULL;",
            "static uint64 *RecordIdentifierArray = NULL;",
            "static int32 NextRecordTypmod = 0;",
            "static uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HTAB *RecordCacheHash = NULL;\nstatic TupleDesc *RecordCacheArray = NULL;\nstatic uint64 *RecordIdentifierArray = NULL;\nstatic int32 NextRecordTypmod = 0;\nstatic uint64 tupledesc_id_counter = INVALID_TUPLEDESC_IDENTIFIER;\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nvoid\nassign_record_type_typmod(TupleDesc tupDesc)\n{\n\tRecordCacheEntry *recentry;\n\tTupleDesc\tentDesc;\n\tbool\t\tfound;\n\tMemoryContext oldcxt;\n\n\tAssert(tupDesc->tdtypeid == RECORDOID);\n\n\tif (RecordCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(TupleDesc);\t/* just the pointer */\n\t\tctl.entrysize = sizeof(RecordCacheEntry);\n\t\tctl.hash = record_type_typmod_hash;\n\t\tctl.match = record_type_typmod_compare;\n\t\tRecordCacheHash = hash_create(\"Record information cache\", 64,\n\t\t\t\t\t\t\t\t\t  &ctl,\n\t\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_FUNCTION | HASH_COMPARE);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Find or create a hashtable entry for this tuple descriptor */\n\trecentry = (RecordCacheEntry *) hash_search(RecordCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t(void *) &tupDesc,\n\t\t\t\t\t\t\t\t\t\t\t\tHASH_ENTER, &found);\n\tif (found && recentry->tupdesc != NULL)\n\t{\n\t\ttupDesc->tdtypmod = recentry->tupdesc->tdtypmod;\n\t\treturn;\n\t}\n\n\t/* Not present, so need to manufacture an entry */\n\trecentry->tupdesc = NULL;\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/* Look in the SharedRecordTypmodRegistry, if attached */\n\tentDesc = find_or_make_matching_shared_tupledesc(tupDesc);\n\tif (entDesc == NULL)\n\t{\n\t\t/* Reference-counted local cache only. */\n\t\tentDesc = CreateTupleDescCopy(tupDesc);\n\t\tentDesc->tdrefcount = 1;\n\t\tentDesc->tdtypmod = NextRecordTypmod++;\n\t}\n\tensure_record_cache_typmod_slot_exists(entDesc->tdtypmod);\n\tRecordCacheArray[entDesc->tdtypmod] = entDesc;\n\trecentry->tupdesc = entDesc;\n\n\t/* Assign a unique tupdesc identifier, too. */\n\tRecordIdentifierArray[entDesc->tdtypmod] = ++tupledesc_id_counter;\n\n\t/* Update the caller's tuple descriptor. */\n\ttupDesc->tdtypmod = entDesc->tdtypmod;\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve_polymorphic_tupdesc",
          "args": [
            "tupdesc",
            "&procform->proargtypes",
            "call_expr"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_polymorphic_tupdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "447-632",
          "snippet": "static bool\nresolve_polymorphic_tupdesc(TupleDesc tupdesc, oidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr)\n{\n\tint\t\t\tnatts = tupdesc->natts;\n\tint\t\t\tnargs = declared_args->dim1;\n\tbool\t\thave_anyelement_result = false;\n\tbool\t\thave_anyarray_result = false;\n\tbool\t\thave_anyrange_result = false;\n\tbool\t\thave_anynonarray = false;\n\tbool\t\thave_anyenum = false;\n\tOid\t\t\tanyelement_type = InvalidOid;\n\tOid\t\t\tanyarray_type = InvalidOid;\n\tOid\t\t\tanyrange_type = InvalidOid;\n\tOid\t\t\tanycollation = InvalidOid;\n\tint\t\t\ti;\n\n\t/* See if there are any polymorphic outputs; quick out if not */\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tswitch (TupleDescAttr(tupdesc, i)->atttypid)\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\thave_anyarray_result = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYNONARRAYOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\thave_anynonarray = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYENUMOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\thave_anyenum = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\thave_anyrange_result = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!have_anyelement_result && !have_anyarray_result &&\n\t\t!have_anyrange_result)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, extract actual datatype(s) from input arguments.  (We assume\n\t * the parser already validated consistency of the arguments.)\n\t */\n\tif (!call_expr)\n\t\treturn false;\t\t\t/* no hope */\n\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tswitch (declared_args->values[i])\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\tif (!OidIsValid(anyelement_type))\n\t\t\t\t\tanyelement_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\tif (!OidIsValid(anyarray_type))\n\t\t\t\t\tanyarray_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\tif (!OidIsValid(anyrange_type))\n\t\t\t\t\tanyrange_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If nothing found, parser messed up */\n\tif (!OidIsValid(anyelement_type) && !OidIsValid(anyarray_type) &&\n\t\t!OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* If needed, deduce one polymorphic type from others */\n\tif (have_anyelement_result && !OidIsValid(anyelement_type))\n\t{\n\t\tif (OidIsValid(anyarray_type))\n\t\t\tanyelement_type = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t   anyarray_type,\n\t\t\t\t\t\t\t\t\t\t\t\t   ANYARRAYOID);\n\t\tif (OidIsValid(anyrange_type))\n\t\t{\n\t\t\tOid\t\t\tsubtype = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   anyrange_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ANYRANGEOID);\n\n\t\t\t/* check for inconsistent array and range results */\n\t\t\tif (OidIsValid(anyelement_type) && anyelement_type != subtype)\n\t\t\t\treturn false;\n\t\t\tanyelement_type = subtype;\n\t\t}\n\t}\n\n\tif (have_anyarray_result && !OidIsValid(anyarray_type))\n\t\tanyarray_type = resolve_generic_type(ANYARRAYOID,\n\t\t\t\t\t\t\t\t\t\t\t anyelement_type,\n\t\t\t\t\t\t\t\t\t\t\t ANYELEMENTOID);\n\n\t/*\n\t * We can't deduce a range type from other polymorphic inputs, because\n\t * there may be multiple range types for the same subtype.\n\t */\n\tif (have_anyrange_result && !OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* Enforce ANYNONARRAY if needed */\n\tif (have_anynonarray && type_is_array(anyelement_type))\n\t\treturn false;\n\n\t/* Enforce ANYENUM if needed */\n\tif (have_anyenum && !type_is_enum(anyelement_type))\n\t\treturn false;\n\n\t/*\n\t * Identify the collation to use for polymorphic OUT parameters. (It'll\n\t * necessarily be the same for both anyelement and anyarray.)  Note that\n\t * range types are not collatable, so any possible internal collation of a\n\t * range type is not considered here.\n\t */\n\tif (OidIsValid(anyelement_type))\n\t\tanycollation = get_typcollation(anyelement_type);\n\telse if (OidIsValid(anyarray_type))\n\t\tanycollation = get_typcollation(anyarray_type);\n\n\tif (OidIsValid(anycollation))\n\t{\n\t\t/*\n\t\t * The types are collatable, so consider whether to use a nondefault\n\t\t * collation.  We do so if we can identify the input collation used\n\t\t * for the function.\n\t\t */\n\t\tOid\t\t\tinputcollation = exprInputCollation(call_expr);\n\n\t\tif (OidIsValid(inputcollation))\n\t\t\tanycollation = inputcollation;\n\t}\n\n\t/* And finally replace the tuple column types as needed */\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tswitch (att->atttypid)\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyelement_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\tTupleDescInitEntryCollation(tupdesc, i + 1, anycollation);\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyarray_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\tTupleDescInitEntryCollation(tupdesc, i + 1, anycollation);\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyrange_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\t/* no collation should be attached to a range type */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);\n\nstatic bool\nresolve_polymorphic_tupdesc(TupleDesc tupdesc, oidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr)\n{\n\tint\t\t\tnatts = tupdesc->natts;\n\tint\t\t\tnargs = declared_args->dim1;\n\tbool\t\thave_anyelement_result = false;\n\tbool\t\thave_anyarray_result = false;\n\tbool\t\thave_anyrange_result = false;\n\tbool\t\thave_anynonarray = false;\n\tbool\t\thave_anyenum = false;\n\tOid\t\t\tanyelement_type = InvalidOid;\n\tOid\t\t\tanyarray_type = InvalidOid;\n\tOid\t\t\tanyrange_type = InvalidOid;\n\tOid\t\t\tanycollation = InvalidOid;\n\tint\t\t\ti;\n\n\t/* See if there are any polymorphic outputs; quick out if not */\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tswitch (TupleDescAttr(tupdesc, i)->atttypid)\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\thave_anyarray_result = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYNONARRAYOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\thave_anynonarray = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYENUMOID:\n\t\t\t\thave_anyelement_result = true;\n\t\t\t\thave_anyenum = true;\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\thave_anyrange_result = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!have_anyelement_result && !have_anyarray_result &&\n\t\t!have_anyrange_result)\n\t\treturn true;\n\n\t/*\n\t * Otherwise, extract actual datatype(s) from input arguments.  (We assume\n\t * the parser already validated consistency of the arguments.)\n\t */\n\tif (!call_expr)\n\t\treturn false;\t\t\t/* no hope */\n\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tswitch (declared_args->values[i])\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\tif (!OidIsValid(anyelement_type))\n\t\t\t\t\tanyelement_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\tif (!OidIsValid(anyarray_type))\n\t\t\t\t\tanyarray_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\tif (!OidIsValid(anyrange_type))\n\t\t\t\t\tanyrange_type = get_call_expr_argtype(call_expr, i);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If nothing found, parser messed up */\n\tif (!OidIsValid(anyelement_type) && !OidIsValid(anyarray_type) &&\n\t\t!OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* If needed, deduce one polymorphic type from others */\n\tif (have_anyelement_result && !OidIsValid(anyelement_type))\n\t{\n\t\tif (OidIsValid(anyarray_type))\n\t\t\tanyelement_type = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t   anyarray_type,\n\t\t\t\t\t\t\t\t\t\t\t\t   ANYARRAYOID);\n\t\tif (OidIsValid(anyrange_type))\n\t\t{\n\t\t\tOid\t\t\tsubtype = resolve_generic_type(ANYELEMENTOID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   anyrange_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ANYRANGEOID);\n\n\t\t\t/* check for inconsistent array and range results */\n\t\t\tif (OidIsValid(anyelement_type) && anyelement_type != subtype)\n\t\t\t\treturn false;\n\t\t\tanyelement_type = subtype;\n\t\t}\n\t}\n\n\tif (have_anyarray_result && !OidIsValid(anyarray_type))\n\t\tanyarray_type = resolve_generic_type(ANYARRAYOID,\n\t\t\t\t\t\t\t\t\t\t\t anyelement_type,\n\t\t\t\t\t\t\t\t\t\t\t ANYELEMENTOID);\n\n\t/*\n\t * We can't deduce a range type from other polymorphic inputs, because\n\t * there may be multiple range types for the same subtype.\n\t */\n\tif (have_anyrange_result && !OidIsValid(anyrange_type))\n\t\treturn false;\n\n\t/* Enforce ANYNONARRAY if needed */\n\tif (have_anynonarray && type_is_array(anyelement_type))\n\t\treturn false;\n\n\t/* Enforce ANYENUM if needed */\n\tif (have_anyenum && !type_is_enum(anyelement_type))\n\t\treturn false;\n\n\t/*\n\t * Identify the collation to use for polymorphic OUT parameters. (It'll\n\t * necessarily be the same for both anyelement and anyarray.)  Note that\n\t * range types are not collatable, so any possible internal collation of a\n\t * range type is not considered here.\n\t */\n\tif (OidIsValid(anyelement_type))\n\t\tanycollation = get_typcollation(anyelement_type);\n\telse if (OidIsValid(anyarray_type))\n\t\tanycollation = get_typcollation(anyarray_type);\n\n\tif (OidIsValid(anycollation))\n\t{\n\t\t/*\n\t\t * The types are collatable, so consider whether to use a nondefault\n\t\t * collation.  We do so if we can identify the input collation used\n\t\t * for the function.\n\t\t */\n\t\tOid\t\t\tinputcollation = exprInputCollation(call_expr);\n\n\t\tif (OidIsValid(inputcollation))\n\t\t\tanycollation = inputcollation;\n\t}\n\n\t/* And finally replace the tuple column types as needed */\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tForm_pg_attribute att = TupleDescAttr(tupdesc, i);\n\n\t\tswitch (att->atttypid)\n\t\t{\n\t\t\tcase ANYELEMENTOID:\n\t\t\tcase ANYNONARRAYOID:\n\t\t\tcase ANYENUMOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyelement_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\tTupleDescInitEntryCollation(tupdesc, i + 1, anycollation);\n\t\t\t\tbreak;\n\t\t\tcase ANYARRAYOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyarray_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\tTupleDescInitEntryCollation(tupdesc, i + 1, anycollation);\n\t\t\t\tbreak;\n\t\t\tcase ANYRANGEOID:\n\t\t\t\tTupleDescInitEntry(tupdesc, i + 1,\n\t\t\t\t\t\t\t\t   NameStr(att->attname),\n\t\t\t\t\t\t\t\t   anyrange_type,\n\t\t\t\t\t\t\t\t   -1,\n\t\t\t\t\t\t\t\t   0);\n\t\t\t\t/* no collation should be attached to a range type */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_function_result_tupdesc_t",
          "args": [
            "tp"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "build_function_result_tupdesc_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "1175-1212",
          "snippet": "TupleDesc\nbuild_function_result_tupdesc_t(HeapTuple procTuple)\n{\n\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(procTuple);\n\tDatum\t\tproallargtypes;\n\tDatum\t\tproargmodes;\n\tDatum\t\tproargnames;\n\tbool\t\tisnull;\n\n\t/* Return NULL if the function isn't declared to return RECORD */\n\tif (procform->prorettype != RECORDOID)\n\t\treturn NULL;\n\n\t/* If there are no OUT parameters, return NULL */\n\tif (heap_attisnull(procTuple, Anum_pg_proc_proallargtypes, NULL) ||\n\t\theap_attisnull(procTuple, Anum_pg_proc_proargmodes, NULL))\n\t\treturn NULL;\n\n\t/* Get the data out of the tuple */\n\tproallargtypes = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_proallargtypes,\n\t\t\t\t\t\t\t\t\t &isnull);\n\tAssert(!isnull);\n\tproargmodes = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargmodes,\n\t\t\t\t\t\t\t\t  &isnull);\n\tAssert(!isnull);\n\tproargnames = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargnames,\n\t\t\t\t\t\t\t\t  &isnull);\n\tif (isnull)\n\t\tproargnames = PointerGetDatum(NULL);\t/* just to be sure */\n\n\treturn build_function_result_tupdesc_d(procform->prokind,\n\t\t\t\t\t\t\t\t\t\t   proallargtypes,\n\t\t\t\t\t\t\t\t\t\t   proargmodes,\n\t\t\t\t\t\t\t\t\t\t   proargnames);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nTupleDesc\nbuild_function_result_tupdesc_t(HeapTuple procTuple)\n{\n\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(procTuple);\n\tDatum\t\tproallargtypes;\n\tDatum\t\tproargmodes;\n\tDatum\t\tproargnames;\n\tbool\t\tisnull;\n\n\t/* Return NULL if the function isn't declared to return RECORD */\n\tif (procform->prorettype != RECORDOID)\n\t\treturn NULL;\n\n\t/* If there are no OUT parameters, return NULL */\n\tif (heap_attisnull(procTuple, Anum_pg_proc_proallargtypes, NULL) ||\n\t\theap_attisnull(procTuple, Anum_pg_proc_proargmodes, NULL))\n\t\treturn NULL;\n\n\t/* Get the data out of the tuple */\n\tproallargtypes = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_proallargtypes,\n\t\t\t\t\t\t\t\t\t &isnull);\n\tAssert(!isnull);\n\tproargmodes = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargmodes,\n\t\t\t\t\t\t\t\t  &isnull);\n\tAssert(!isnull);\n\tproargnames = SysCacheGetAttr(PROCOID, procTuple,\n\t\t\t\t\t\t\t\t  Anum_pg_proc_proargnames,\n\t\t\t\t\t\t\t\t  &isnull);\n\tif (isnull)\n\t\tproargnames = PointerGetDatum(NULL);\t/* just to be sure */\n\n\treturn build_function_result_tupdesc_d(procform->prokind,\n\t\t\t\t\t\t\t\t\t\t   proallargtypes,\n\t\t\t\t\t\t\t\t\t\t   proargmodes,\n\t\t\t\t\t\t\t\t\t\t   proargnames);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tp"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for function %u\"",
            "funcid"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tp"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "PROCOID",
            "ObjectIdGetDatum(funcid)"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "funcid"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\nstatic bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);\n\nstatic TypeFuncClass\ninternal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\tHeapTuple\ttp;\n\tForm_pg_proc procform;\n\tOid\t\t\trettype;\n\tOid\t\t\tbase_rettype;\n\tTupleDesc\ttupdesc;\n\n\t/* First fetch the function's pg_proc row to inspect its rettype */\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\tprocform = (Form_pg_proc) GETSTRUCT(tp);\n\n\trettype = procform->prorettype;\n\n\t/* Check for OUT parameters defining a RECORD result */\n\ttupdesc = build_function_result_tupdesc_t(tp);\n\tif (tupdesc)\n\t{\n\t\t/*\n\t\t * It has OUT parameters, so it's basically like a regular composite\n\t\t * type, except we have to be able to resolve any polymorphic OUT\n\t\t * parameters.\n\t\t */\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = rettype;\n\n\t\tif (resolve_polymorphic_tupdesc(tupdesc,\n\t\t\t\t\t\t\t\t\t\t&procform->proargtypes,\n\t\t\t\t\t\t\t\t\t\tcall_expr))\n\t\t{\n\t\t\tif (tupdesc->tdtypeid == RECORDOID &&\n\t\t\t\ttupdesc->tdtypmod < 0)\n\t\t\t\tassign_record_type_typmod(tupdesc);\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = tupdesc;\n\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = NULL;\n\t\t\tresult = TYPEFUNC_RECORD;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\treturn result;\n\t}\n\n\t/*\n\t * If scalar polymorphic result, try to resolve it.\n\t */\n\tif (IsPolymorphicType(rettype))\n\t{\n\t\tOid\t\t\tnewrettype = exprType(call_expr);\n\n\t\tif (newrettype == InvalidOid)\t/* this probably should not happen */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"could not determine actual result type for function \\\"%s\\\" declared to return type %s\",\n\t\t\t\t\t\t\tNameStr(procform->proname),\n\t\t\t\t\t\t\tformat_type_be(rettype))));\n\t\trettype = newrettype;\n\t}\n\n\tif (resultTypeId)\n\t\t*resultTypeId = rettype;\n\tif (resultTupleDesc)\n\t\t*resultTupleDesc = NULL;\t/* default result */\n\n\t/* Classify the result type */\n\tresult = get_type_func_class(rettype, &base_rettype);\n\tswitch (result)\n\t{\n\t\tcase TYPEFUNC_COMPOSITE:\n\t\tcase TYPEFUNC_COMPOSITE_DOMAIN:\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_rettype, -1);\n\t\t\t/* Named composite types can't have any polymorphic columns */\n\t\t\tbreak;\n\t\tcase TYPEFUNC_SCALAR:\n\t\t\tbreak;\n\t\tcase TYPEFUNC_RECORD:\n\t\t\t/* We must get the tupledesc from call context */\n\t\t\tif (rsinfo && IsA(rsinfo, ReturnSetInfo) &&\n\t\t\t\trsinfo->expectedDesc != NULL)\n\t\t\t{\n\t\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t\t\tif (resultTupleDesc)\n\t\t\t\t\t*resultTupleDesc = rsinfo->expectedDesc;\n\t\t\t\t/* Assume no polymorphic columns here, either */\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tp);\n\n\treturn result;\n}"
  },
  {
    "function_name": "get_func_result_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "271-281",
    "snippet": "TypeFuncClass\nget_func_result_type(Oid functionId,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(functionId,\n\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_get_result_type",
          "args": [
            "functionId",
            "NULL",
            "NULL",
            "resultTypeId",
            "resultTupleDesc"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "internal_get_result_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "291-399",
          "snippet": "static TypeFuncClass\ninternal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\tHeapTuple\ttp;\n\tForm_pg_proc procform;\n\tOid\t\t\trettype;\n\tOid\t\t\tbase_rettype;\n\tTupleDesc\ttupdesc;\n\n\t/* First fetch the function's pg_proc row to inspect its rettype */\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\tprocform = (Form_pg_proc) GETSTRUCT(tp);\n\n\trettype = procform->prorettype;\n\n\t/* Check for OUT parameters defining a RECORD result */\n\ttupdesc = build_function_result_tupdesc_t(tp);\n\tif (tupdesc)\n\t{\n\t\t/*\n\t\t * It has OUT parameters, so it's basically like a regular composite\n\t\t * type, except we have to be able to resolve any polymorphic OUT\n\t\t * parameters.\n\t\t */\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = rettype;\n\n\t\tif (resolve_polymorphic_tupdesc(tupdesc,\n\t\t\t\t\t\t\t\t\t\t&procform->proargtypes,\n\t\t\t\t\t\t\t\t\t\tcall_expr))\n\t\t{\n\t\t\tif (tupdesc->tdtypeid == RECORDOID &&\n\t\t\t\ttupdesc->tdtypmod < 0)\n\t\t\t\tassign_record_type_typmod(tupdesc);\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = tupdesc;\n\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = NULL;\n\t\t\tresult = TYPEFUNC_RECORD;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\treturn result;\n\t}\n\n\t/*\n\t * If scalar polymorphic result, try to resolve it.\n\t */\n\tif (IsPolymorphicType(rettype))\n\t{\n\t\tOid\t\t\tnewrettype = exprType(call_expr);\n\n\t\tif (newrettype == InvalidOid)\t/* this probably should not happen */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"could not determine actual result type for function \\\"%s\\\" declared to return type %s\",\n\t\t\t\t\t\t\tNameStr(procform->proname),\n\t\t\t\t\t\t\tformat_type_be(rettype))));\n\t\trettype = newrettype;\n\t}\n\n\tif (resultTypeId)\n\t\t*resultTypeId = rettype;\n\tif (resultTupleDesc)\n\t\t*resultTupleDesc = NULL;\t/* default result */\n\n\t/* Classify the result type */\n\tresult = get_type_func_class(rettype, &base_rettype);\n\tswitch (result)\n\t{\n\t\tcase TYPEFUNC_COMPOSITE:\n\t\tcase TYPEFUNC_COMPOSITE_DOMAIN:\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_rettype, -1);\n\t\t\t/* Named composite types can't have any polymorphic columns */\n\t\t\tbreak;\n\t\tcase TYPEFUNC_SCALAR:\n\t\t\tbreak;\n\t\tcase TYPEFUNC_RECORD:\n\t\t\t/* We must get the tupledesc from call context */\n\t\t\tif (rsinfo && IsA(rsinfo, ReturnSetInfo) &&\n\t\t\t\trsinfo->expectedDesc != NULL)\n\t\t\t{\n\t\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t\t\tif (resultTupleDesc)\n\t\t\t\t\t*resultTupleDesc = rsinfo->expectedDesc;\n\t\t\t\t/* Assume no polymorphic columns here, either */\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tp);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);",
            "static bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\nstatic bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);\n\nstatic TypeFuncClass\ninternal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\tHeapTuple\ttp;\n\tForm_pg_proc procform;\n\tOid\t\t\trettype;\n\tOid\t\t\tbase_rettype;\n\tTupleDesc\ttupdesc;\n\n\t/* First fetch the function's pg_proc row to inspect its rettype */\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\tprocform = (Form_pg_proc) GETSTRUCT(tp);\n\n\trettype = procform->prorettype;\n\n\t/* Check for OUT parameters defining a RECORD result */\n\ttupdesc = build_function_result_tupdesc_t(tp);\n\tif (tupdesc)\n\t{\n\t\t/*\n\t\t * It has OUT parameters, so it's basically like a regular composite\n\t\t * type, except we have to be able to resolve any polymorphic OUT\n\t\t * parameters.\n\t\t */\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = rettype;\n\n\t\tif (resolve_polymorphic_tupdesc(tupdesc,\n\t\t\t\t\t\t\t\t\t\t&procform->proargtypes,\n\t\t\t\t\t\t\t\t\t\tcall_expr))\n\t\t{\n\t\t\tif (tupdesc->tdtypeid == RECORDOID &&\n\t\t\t\ttupdesc->tdtypmod < 0)\n\t\t\t\tassign_record_type_typmod(tupdesc);\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = tupdesc;\n\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = NULL;\n\t\t\tresult = TYPEFUNC_RECORD;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\treturn result;\n\t}\n\n\t/*\n\t * If scalar polymorphic result, try to resolve it.\n\t */\n\tif (IsPolymorphicType(rettype))\n\t{\n\t\tOid\t\t\tnewrettype = exprType(call_expr);\n\n\t\tif (newrettype == InvalidOid)\t/* this probably should not happen */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"could not determine actual result type for function \\\"%s\\\" declared to return type %s\",\n\t\t\t\t\t\t\tNameStr(procform->proname),\n\t\t\t\t\t\t\tformat_type_be(rettype))));\n\t\trettype = newrettype;\n\t}\n\n\tif (resultTypeId)\n\t\t*resultTypeId = rettype;\n\tif (resultTupleDesc)\n\t\t*resultTupleDesc = NULL;\t/* default result */\n\n\t/* Classify the result type */\n\tresult = get_type_func_class(rettype, &base_rettype);\n\tswitch (result)\n\t{\n\t\tcase TYPEFUNC_COMPOSITE:\n\t\tcase TYPEFUNC_COMPOSITE_DOMAIN:\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_rettype, -1);\n\t\t\t/* Named composite types can't have any polymorphic columns */\n\t\t\tbreak;\n\t\tcase TYPEFUNC_SCALAR:\n\t\t\tbreak;\n\t\tcase TYPEFUNC_RECORD:\n\t\t\t/* We must get the tupledesc from call context */\n\t\t\tif (rsinfo && IsA(rsinfo, ReturnSetInfo) &&\n\t\t\t\trsinfo->expectedDesc != NULL)\n\t\t\t{\n\t\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t\t\tif (resultTupleDesc)\n\t\t\t\t\t*resultTupleDesc = rsinfo->expectedDesc;\n\t\t\t\t/* Assume no polymorphic columns here, either */\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tp);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\n\nTypeFuncClass\nget_func_result_type(Oid functionId,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(functionId,\n\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}"
  },
  {
    "function_name": "get_expr_result_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "226-263",
    "snippet": "TypeFuncClass\nget_expr_result_type(Node *expr,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\n\tif (expr && IsA(expr, FuncExpr))\n\t\tresult = internal_get_result_type(((FuncExpr *) expr)->funcid,\n\t\t\t\t\t\t\t\t\t\t  expr,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  resultTypeId,\n\t\t\t\t\t\t\t\t\t\t  resultTupleDesc);\n\telse if (expr && IsA(expr, OpExpr))\n\t\tresult = internal_get_result_type(get_opcode(((OpExpr *) expr)->opno),\n\t\t\t\t\t\t\t\t\t\t  expr,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  resultTypeId,\n\t\t\t\t\t\t\t\t\t\t  resultTupleDesc);\n\telse\n\t{\n\t\t/* handle as a generic expression; no chance to resolve RECORD */\n\t\tOid\t\t\ttypid = exprType(expr);\n\t\tOid\t\t\tbase_typid;\n\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = typid;\n\t\tif (resultTupleDesc)\n\t\t\t*resultTupleDesc = NULL;\n\t\tresult = get_type_func_class(typid, &base_typid);\n\t\tif ((result == TYPEFUNC_COMPOSITE ||\n\t\t\t result == TYPEFUNC_COMPOSITE_DOMAIN) &&\n\t\t\tresultTupleDesc)\n\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_typid, -1);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_rowtype_tupdesc_copy",
          "args": [
            "base_typid",
            "-1"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_rowtype_tupdesc_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1674-1681",
          "snippet": "TupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic dsa_pointer share_tupledesc(dsa_area *area, TupleDesc tupdesc,\n\t\t\t\tuint32 typmod);\n\nTupleDesc\nlookup_rowtype_tupdesc_copy(Oid type_id, int32 typmod)\n{\n\tTupleDesc\ttmp;\n\n\ttmp = lookup_rowtype_tupdesc_internal(type_id, typmod, false);\n\treturn CreateTupleDescCopyConstr(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_type_func_class",
          "args": [
            "typid",
            "&base_typid"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "get_type_func_class",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "795-830",
          "snippet": "static TypeFuncClass\nget_type_func_class(Oid typid, Oid *base_typeid)\n{\n\t*base_typeid = typid;\n\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn TYPEFUNC_COMPOSITE;\n\t\tcase TYPTYPE_BASE:\n\t\tcase TYPTYPE_ENUM:\n\t\tcase TYPTYPE_RANGE:\n\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\t*base_typeid = typid = getBaseType(typid);\n\t\t\tif (get_typtype(typid) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn TYPEFUNC_COMPOSITE_DOMAIN;\n\t\t\telse\t\t\t\t/* domain base type can't be a pseudotype */\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_PSEUDO:\n\t\t\tif (typid == RECORDOID)\n\t\t\t\treturn TYPEFUNC_RECORD;\n\n\t\t\t/*\n\t\t\t * We treat VOID and CSTRING as legitimate scalar datatypes,\n\t\t\t * mostly for the convenience of the JDBC driver (which wants to\n\t\t\t * be able to do \"SELECT * FROM foo()\" for all legitimately\n\t\t\t * user-callable functions).\n\t\t\t */\n\t\t\tif (typid == VOIDOID || typid == CSTRINGOID)\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\t\treturn TYPEFUNC_OTHER;\n\t}\n\t/* shouldn't get here, probably */\n\treturn TYPEFUNC_OTHER;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass get_type_func_class(Oid typid, Oid *base_typeid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass get_type_func_class(Oid typid, Oid *base_typeid);\n\nstatic TypeFuncClass\nget_type_func_class(Oid typid, Oid *base_typeid)\n{\n\t*base_typeid = typid;\n\n\tswitch (get_typtype(typid))\n\t{\n\t\tcase TYPTYPE_COMPOSITE:\n\t\t\treturn TYPEFUNC_COMPOSITE;\n\t\tcase TYPTYPE_BASE:\n\t\tcase TYPTYPE_ENUM:\n\t\tcase TYPTYPE_RANGE:\n\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_DOMAIN:\n\t\t\t*base_typeid = typid = getBaseType(typid);\n\t\t\tif (get_typtype(typid) == TYPTYPE_COMPOSITE)\n\t\t\t\treturn TYPEFUNC_COMPOSITE_DOMAIN;\n\t\t\telse\t\t\t\t/* domain base type can't be a pseudotype */\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\tcase TYPTYPE_PSEUDO:\n\t\t\tif (typid == RECORDOID)\n\t\t\t\treturn TYPEFUNC_RECORD;\n\n\t\t\t/*\n\t\t\t * We treat VOID and CSTRING as legitimate scalar datatypes,\n\t\t\t * mostly for the convenience of the JDBC driver (which wants to\n\t\t\t * be able to do \"SELECT * FROM foo()\" for all legitimately\n\t\t\t * user-callable functions).\n\t\t\t */\n\t\t\tif (typid == VOIDOID || typid == CSTRINGOID)\n\t\t\t\treturn TYPEFUNC_SCALAR;\n\t\t\treturn TYPEFUNC_OTHER;\n\t}\n\t/* shouldn't get here, probably */\n\treturn TYPEFUNC_OTHER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "expr"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "internal_get_result_type",
          "args": [
            "get_opcode(((OpExpr *) expr)->opno)",
            "expr",
            "NULL",
            "resultTypeId",
            "resultTupleDesc"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "internal_get_result_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "291-399",
          "snippet": "static TypeFuncClass\ninternal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\tHeapTuple\ttp;\n\tForm_pg_proc procform;\n\tOid\t\t\trettype;\n\tOid\t\t\tbase_rettype;\n\tTupleDesc\ttupdesc;\n\n\t/* First fetch the function's pg_proc row to inspect its rettype */\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\tprocform = (Form_pg_proc) GETSTRUCT(tp);\n\n\trettype = procform->prorettype;\n\n\t/* Check for OUT parameters defining a RECORD result */\n\ttupdesc = build_function_result_tupdesc_t(tp);\n\tif (tupdesc)\n\t{\n\t\t/*\n\t\t * It has OUT parameters, so it's basically like a regular composite\n\t\t * type, except we have to be able to resolve any polymorphic OUT\n\t\t * parameters.\n\t\t */\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = rettype;\n\n\t\tif (resolve_polymorphic_tupdesc(tupdesc,\n\t\t\t\t\t\t\t\t\t\t&procform->proargtypes,\n\t\t\t\t\t\t\t\t\t\tcall_expr))\n\t\t{\n\t\t\tif (tupdesc->tdtypeid == RECORDOID &&\n\t\t\t\ttupdesc->tdtypmod < 0)\n\t\t\t\tassign_record_type_typmod(tupdesc);\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = tupdesc;\n\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = NULL;\n\t\t\tresult = TYPEFUNC_RECORD;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\treturn result;\n\t}\n\n\t/*\n\t * If scalar polymorphic result, try to resolve it.\n\t */\n\tif (IsPolymorphicType(rettype))\n\t{\n\t\tOid\t\t\tnewrettype = exprType(call_expr);\n\n\t\tif (newrettype == InvalidOid)\t/* this probably should not happen */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"could not determine actual result type for function \\\"%s\\\" declared to return type %s\",\n\t\t\t\t\t\t\tNameStr(procform->proname),\n\t\t\t\t\t\t\tformat_type_be(rettype))));\n\t\trettype = newrettype;\n\t}\n\n\tif (resultTypeId)\n\t\t*resultTypeId = rettype;\n\tif (resultTupleDesc)\n\t\t*resultTupleDesc = NULL;\t/* default result */\n\n\t/* Classify the result type */\n\tresult = get_type_func_class(rettype, &base_rettype);\n\tswitch (result)\n\t{\n\t\tcase TYPEFUNC_COMPOSITE:\n\t\tcase TYPEFUNC_COMPOSITE_DOMAIN:\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_rettype, -1);\n\t\t\t/* Named composite types can't have any polymorphic columns */\n\t\t\tbreak;\n\t\tcase TYPEFUNC_SCALAR:\n\t\t\tbreak;\n\t\tcase TYPEFUNC_RECORD:\n\t\t\t/* We must get the tupledesc from call context */\n\t\t\tif (rsinfo && IsA(rsinfo, ReturnSetInfo) &&\n\t\t\t\trsinfo->expectedDesc != NULL)\n\t\t\t{\n\t\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t\t\tif (resultTupleDesc)\n\t\t\t\t\t*resultTupleDesc = rsinfo->expectedDesc;\n\t\t\t\t/* Assume no polymorphic columns here, either */\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tp);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);",
            "static bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\nstatic bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);\n\nstatic TypeFuncClass\ninternal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\tHeapTuple\ttp;\n\tForm_pg_proc procform;\n\tOid\t\t\trettype;\n\tOid\t\t\tbase_rettype;\n\tTupleDesc\ttupdesc;\n\n\t/* First fetch the function's pg_proc row to inspect its rettype */\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\tprocform = (Form_pg_proc) GETSTRUCT(tp);\n\n\trettype = procform->prorettype;\n\n\t/* Check for OUT parameters defining a RECORD result */\n\ttupdesc = build_function_result_tupdesc_t(tp);\n\tif (tupdesc)\n\t{\n\t\t/*\n\t\t * It has OUT parameters, so it's basically like a regular composite\n\t\t * type, except we have to be able to resolve any polymorphic OUT\n\t\t * parameters.\n\t\t */\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = rettype;\n\n\t\tif (resolve_polymorphic_tupdesc(tupdesc,\n\t\t\t\t\t\t\t\t\t\t&procform->proargtypes,\n\t\t\t\t\t\t\t\t\t\tcall_expr))\n\t\t{\n\t\t\tif (tupdesc->tdtypeid == RECORDOID &&\n\t\t\t\ttupdesc->tdtypmod < 0)\n\t\t\t\tassign_record_type_typmod(tupdesc);\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = tupdesc;\n\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = NULL;\n\t\t\tresult = TYPEFUNC_RECORD;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\treturn result;\n\t}\n\n\t/*\n\t * If scalar polymorphic result, try to resolve it.\n\t */\n\tif (IsPolymorphicType(rettype))\n\t{\n\t\tOid\t\t\tnewrettype = exprType(call_expr);\n\n\t\tif (newrettype == InvalidOid)\t/* this probably should not happen */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"could not determine actual result type for function \\\"%s\\\" declared to return type %s\",\n\t\t\t\t\t\t\tNameStr(procform->proname),\n\t\t\t\t\t\t\tformat_type_be(rettype))));\n\t\trettype = newrettype;\n\t}\n\n\tif (resultTypeId)\n\t\t*resultTypeId = rettype;\n\tif (resultTupleDesc)\n\t\t*resultTupleDesc = NULL;\t/* default result */\n\n\t/* Classify the result type */\n\tresult = get_type_func_class(rettype, &base_rettype);\n\tswitch (result)\n\t{\n\t\tcase TYPEFUNC_COMPOSITE:\n\t\tcase TYPEFUNC_COMPOSITE_DOMAIN:\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_rettype, -1);\n\t\t\t/* Named composite types can't have any polymorphic columns */\n\t\t\tbreak;\n\t\tcase TYPEFUNC_SCALAR:\n\t\t\tbreak;\n\t\tcase TYPEFUNC_RECORD:\n\t\t\t/* We must get the tupledesc from call context */\n\t\t\tif (rsinfo && IsA(rsinfo, ReturnSetInfo) &&\n\t\t\t\trsinfo->expectedDesc != NULL)\n\t\t\t{\n\t\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t\t\tif (resultTupleDesc)\n\t\t\t\t\t*resultTupleDesc = rsinfo->expectedDesc;\n\t\t\t\t/* Assume no polymorphic columns here, either */\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tp);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "((OpExpr *) expr)->opno"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "OpExpr"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "FuncExpr"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\n\nTypeFuncClass\nget_expr_result_type(Node *expr,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\n\tif (expr && IsA(expr, FuncExpr))\n\t\tresult = internal_get_result_type(((FuncExpr *) expr)->funcid,\n\t\t\t\t\t\t\t\t\t\t  expr,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  resultTypeId,\n\t\t\t\t\t\t\t\t\t\t  resultTupleDesc);\n\telse if (expr && IsA(expr, OpExpr))\n\t\tresult = internal_get_result_type(get_opcode(((OpExpr *) expr)->opno),\n\t\t\t\t\t\t\t\t\t\t  expr,\n\t\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t\t  resultTypeId,\n\t\t\t\t\t\t\t\t\t\t  resultTupleDesc);\n\telse\n\t{\n\t\t/* handle as a generic expression; no chance to resolve RECORD */\n\t\tOid\t\t\ttypid = exprType(expr);\n\t\tOid\t\t\tbase_typid;\n\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = typid;\n\t\tif (resultTupleDesc)\n\t\t\t*resultTupleDesc = NULL;\n\t\tresult = get_type_func_class(typid, &base_typid);\n\t\tif ((result == TYPEFUNC_COMPOSITE ||\n\t\t\t result == TYPEFUNC_COMPOSITE_DOMAIN) &&\n\t\t\tresultTupleDesc)\n\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_typid, -1);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "get_call_result_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "210-220",
    "snippet": "TypeFuncClass\nget_call_result_type(FunctionCallInfo fcinfo,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(fcinfo->flinfo->fn_oid,\n\t\t\t\t\t\t\t\t\tfcinfo->flinfo->fn_expr,\n\t\t\t\t\t\t\t\t\t(ReturnSetInfo *) fcinfo->resultinfo,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_get_result_type",
          "args": [
            "fcinfo->flinfo->fn_oid",
            "fcinfo->flinfo->fn_expr",
            "(ReturnSetInfo *) fcinfo->resultinfo",
            "resultTypeId",
            "resultTupleDesc"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "internal_get_result_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "291-399",
          "snippet": "static TypeFuncClass\ninternal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\tHeapTuple\ttp;\n\tForm_pg_proc procform;\n\tOid\t\t\trettype;\n\tOid\t\t\tbase_rettype;\n\tTupleDesc\ttupdesc;\n\n\t/* First fetch the function's pg_proc row to inspect its rettype */\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\tprocform = (Form_pg_proc) GETSTRUCT(tp);\n\n\trettype = procform->prorettype;\n\n\t/* Check for OUT parameters defining a RECORD result */\n\ttupdesc = build_function_result_tupdesc_t(tp);\n\tif (tupdesc)\n\t{\n\t\t/*\n\t\t * It has OUT parameters, so it's basically like a regular composite\n\t\t * type, except we have to be able to resolve any polymorphic OUT\n\t\t * parameters.\n\t\t */\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = rettype;\n\n\t\tif (resolve_polymorphic_tupdesc(tupdesc,\n\t\t\t\t\t\t\t\t\t\t&procform->proargtypes,\n\t\t\t\t\t\t\t\t\t\tcall_expr))\n\t\t{\n\t\t\tif (tupdesc->tdtypeid == RECORDOID &&\n\t\t\t\ttupdesc->tdtypmod < 0)\n\t\t\t\tassign_record_type_typmod(tupdesc);\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = tupdesc;\n\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = NULL;\n\t\t\tresult = TYPEFUNC_RECORD;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\treturn result;\n\t}\n\n\t/*\n\t * If scalar polymorphic result, try to resolve it.\n\t */\n\tif (IsPolymorphicType(rettype))\n\t{\n\t\tOid\t\t\tnewrettype = exprType(call_expr);\n\n\t\tif (newrettype == InvalidOid)\t/* this probably should not happen */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"could not determine actual result type for function \\\"%s\\\" declared to return type %s\",\n\t\t\t\t\t\t\tNameStr(procform->proname),\n\t\t\t\t\t\t\tformat_type_be(rettype))));\n\t\trettype = newrettype;\n\t}\n\n\tif (resultTypeId)\n\t\t*resultTypeId = rettype;\n\tif (resultTupleDesc)\n\t\t*resultTupleDesc = NULL;\t/* default result */\n\n\t/* Classify the result type */\n\tresult = get_type_func_class(rettype, &base_rettype);\n\tswitch (result)\n\t{\n\t\tcase TYPEFUNC_COMPOSITE:\n\t\tcase TYPEFUNC_COMPOSITE_DOMAIN:\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_rettype, -1);\n\t\t\t/* Named composite types can't have any polymorphic columns */\n\t\t\tbreak;\n\t\tcase TYPEFUNC_SCALAR:\n\t\t\tbreak;\n\t\tcase TYPEFUNC_RECORD:\n\t\t\t/* We must get the tupledesc from call context */\n\t\t\tif (rsinfo && IsA(rsinfo, ReturnSetInfo) &&\n\t\t\t\trsinfo->expectedDesc != NULL)\n\t\t\t{\n\t\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t\t\tif (resultTupleDesc)\n\t\t\t\t\t*resultTupleDesc = rsinfo->expectedDesc;\n\t\t\t\t/* Assume no polymorphic columns here, either */\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tp);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);",
            "static bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\nstatic bool resolve_polymorphic_tupdesc(TupleDesc tupdesc,\n\t\t\t\t\t\t\toidvector *declared_args,\n\t\t\t\t\t\t\tNode *call_expr);\n\nstatic TypeFuncClass\ninternal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\tTypeFuncClass result;\n\tHeapTuple\ttp;\n\tForm_pg_proc procform;\n\tOid\t\t\trettype;\n\tOid\t\t\tbase_rettype;\n\tTupleDesc\ttupdesc;\n\n\t/* First fetch the function's pg_proc row to inspect its rettype */\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\tprocform = (Form_pg_proc) GETSTRUCT(tp);\n\n\trettype = procform->prorettype;\n\n\t/* Check for OUT parameters defining a RECORD result */\n\ttupdesc = build_function_result_tupdesc_t(tp);\n\tif (tupdesc)\n\t{\n\t\t/*\n\t\t * It has OUT parameters, so it's basically like a regular composite\n\t\t * type, except we have to be able to resolve any polymorphic OUT\n\t\t * parameters.\n\t\t */\n\t\tif (resultTypeId)\n\t\t\t*resultTypeId = rettype;\n\n\t\tif (resolve_polymorphic_tupdesc(tupdesc,\n\t\t\t\t\t\t\t\t\t\t&procform->proargtypes,\n\t\t\t\t\t\t\t\t\t\tcall_expr))\n\t\t{\n\t\t\tif (tupdesc->tdtypeid == RECORDOID &&\n\t\t\t\ttupdesc->tdtypmod < 0)\n\t\t\t\tassign_record_type_typmod(tupdesc);\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = tupdesc;\n\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = NULL;\n\t\t\tresult = TYPEFUNC_RECORD;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\n\t\treturn result;\n\t}\n\n\t/*\n\t * If scalar polymorphic result, try to resolve it.\n\t */\n\tif (IsPolymorphicType(rettype))\n\t{\n\t\tOid\t\t\tnewrettype = exprType(call_expr);\n\n\t\tif (newrettype == InvalidOid)\t/* this probably should not happen */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"could not determine actual result type for function \\\"%s\\\" declared to return type %s\",\n\t\t\t\t\t\t\tNameStr(procform->proname),\n\t\t\t\t\t\t\tformat_type_be(rettype))));\n\t\trettype = newrettype;\n\t}\n\n\tif (resultTypeId)\n\t\t*resultTypeId = rettype;\n\tif (resultTupleDesc)\n\t\t*resultTupleDesc = NULL;\t/* default result */\n\n\t/* Classify the result type */\n\tresult = get_type_func_class(rettype, &base_rettype);\n\tswitch (result)\n\t{\n\t\tcase TYPEFUNC_COMPOSITE:\n\t\tcase TYPEFUNC_COMPOSITE_DOMAIN:\n\t\t\tif (resultTupleDesc)\n\t\t\t\t*resultTupleDesc = lookup_rowtype_tupdesc_copy(base_rettype, -1);\n\t\t\t/* Named composite types can't have any polymorphic columns */\n\t\t\tbreak;\n\t\tcase TYPEFUNC_SCALAR:\n\t\t\tbreak;\n\t\tcase TYPEFUNC_RECORD:\n\t\t\t/* We must get the tupledesc from call context */\n\t\t\tif (rsinfo && IsA(rsinfo, ReturnSetInfo) &&\n\t\t\t\trsinfo->expectedDesc != NULL)\n\t\t\t{\n\t\t\t\tresult = TYPEFUNC_COMPOSITE;\n\t\t\t\tif (resultTupleDesc)\n\t\t\t\t\t*resultTupleDesc = rsinfo->expectedDesc;\n\t\t\t\t/* Assume no polymorphic columns here, either */\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(tp);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic TypeFuncClass internal_get_result_type(Oid funcid,\n\t\t\t\t\t\t Node *call_expr,\n\t\t\t\t\t\t ReturnSetInfo *rsinfo,\n\t\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t\t TupleDesc *resultTupleDesc);\n\nTypeFuncClass\nget_call_result_type(FunctionCallInfo fcinfo,\n\t\t\t\t\t Oid *resultTypeId,\n\t\t\t\t\t TupleDesc *resultTupleDesc)\n{\n\treturn internal_get_result_type(fcinfo->flinfo->fn_oid,\n\t\t\t\t\t\t\t\t\tfcinfo->flinfo->fn_expr,\n\t\t\t\t\t\t\t\t\t(ReturnSetInfo *) fcinfo->resultinfo,\n\t\t\t\t\t\t\t\t\tresultTypeId,\n\t\t\t\t\t\t\t\t\tresultTupleDesc);\n}"
  },
  {
    "function_name": "shutdown_MultiFuncCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "172-186",
    "snippet": "static void\nshutdown_MultiFuncCall(Datum arg)\n{\n\tFmgrInfo   *flinfo = (FmgrInfo *) DatumGetPointer(arg);\n\tFuncCallContext *funcctx = (FuncCallContext *) flinfo->fn_extra;\n\n\t/* unbind from flinfo */\n\tflinfo->fn_extra = NULL;\n\n\t/*\n\t * Delete context that holds all multi-call data, including the\n\t * FuncCallContext itself\n\t */\n\tMemoryContextDelete(funcctx->multi_call_memory_ctx);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void shutdown_MultiFuncCall(Datum arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "arg"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void shutdown_MultiFuncCall(Datum arg);\n\nstatic void\nshutdown_MultiFuncCall(Datum arg)\n{\n\tFmgrInfo   *flinfo = (FmgrInfo *) DatumGetPointer(arg);\n\tFuncCallContext *funcctx = (FuncCallContext *) flinfo->fn_extra;\n\n\t/* unbind from flinfo */\n\tflinfo->fn_extra = NULL;\n\n\t/*\n\t * Delete context that holds all multi-call data, including the\n\t * FuncCallContext itself\n\t */\n\tMemoryContextDelete(funcctx->multi_call_memory_ctx);\n}"
  },
  {
    "function_name": "end_MultiFuncCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "154-166",
    "snippet": "void\nend_MultiFuncCall(PG_FUNCTION_ARGS, FuncCallContext *funcctx)\n{\n\tReturnSetInfo *rsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\t/* Deregister the shutdown callback */\n\tUnregisterExprContextCallback(rsi->econtext,\n\t\t\t\t\t\t\t\t  shutdown_MultiFuncCall,\n\t\t\t\t\t\t\t\t  PointerGetDatum(fcinfo->flinfo));\n\n\t/* But use it to do the real work */\n\tshutdown_MultiFuncCall(PointerGetDatum(fcinfo->flinfo));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shutdown_MultiFuncCall",
          "args": [
            "PointerGetDatum(fcinfo->flinfo)"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "shutdown_MultiFuncCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
          "lines": "172-186",
          "snippet": "static void\nshutdown_MultiFuncCall(Datum arg)\n{\n\tFmgrInfo   *flinfo = (FmgrInfo *) DatumGetPointer(arg);\n\tFuncCallContext *funcctx = (FuncCallContext *) flinfo->fn_extra;\n\n\t/* unbind from flinfo */\n\tflinfo->fn_extra = NULL;\n\n\t/*\n\t * Delete context that holds all multi-call data, including the\n\t * FuncCallContext itself\n\t */\n\tMemoryContextDelete(funcctx->multi_call_memory_ctx);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void shutdown_MultiFuncCall(Datum arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void shutdown_MultiFuncCall(Datum arg);\n\nstatic void\nshutdown_MultiFuncCall(Datum arg)\n{\n\tFmgrInfo   *flinfo = (FmgrInfo *) DatumGetPointer(arg);\n\tFuncCallContext *funcctx = (FuncCallContext *) flinfo->fn_extra;\n\n\t/* unbind from flinfo */\n\tflinfo->fn_extra = NULL;\n\n\t/*\n\t * Delete context that holds all multi-call data, including the\n\t * FuncCallContext itself\n\t */\n\tMemoryContextDelete(funcctx->multi_call_memory_ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "fcinfo->flinfo"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnregisterExprContextCallback",
          "args": [
            "rsi->econtext",
            "shutdown_MultiFuncCall",
            "PointerGetDatum(fcinfo->flinfo)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "fcinfo->flinfo"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nend_MultiFuncCall(PG_FUNCTION_ARGS, FuncCallContext *funcctx)\n{\n\tReturnSetInfo *rsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\n\t/* Deregister the shutdown callback */\n\tUnregisterExprContextCallback(rsi->econtext,\n\t\t\t\t\t\t\t\t  shutdown_MultiFuncCall,\n\t\t\t\t\t\t\t\t  PointerGetDatum(fcinfo->flinfo));\n\n\t/* But use it to do the real work */\n\tshutdown_MultiFuncCall(PointerGetDatum(fcinfo->flinfo));\n}"
  },
  {
    "function_name": "per_MultiFuncCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "127-148",
    "snippet": "FuncCallContext *\nper_MultiFuncCall(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *retval = (FuncCallContext *) fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * Clear the TupleTableSlot, if present.  This is for safety's sake: the\n\t * Slot will be in a long-lived context (it better be, if the\n\t * FuncCallContext is pointing to it), but in most usage patterns the\n\t * tuples stored in it will be in the function's per-tuple context. So at\n\t * the beginning of each call, the Slot will hold a dangling pointer to an\n\t * already-recycled tuple.  We clear it out here.\n\t *\n\t * Note: use of retval->slot is obsolete as of 8.0, and we expect that it\n\t * will always be NULL.  This is just here for backwards compatibility in\n\t * case someone creates a slot anyway.\n\t */\n\tif (retval->slot != NULL)\n\t\tExecClearTuple(retval->slot);\n\n\treturn retval;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExecClearTuple",
          "args": [
            "retval->slot"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nFuncCallContext *\nper_MultiFuncCall(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *retval = (FuncCallContext *) fcinfo->flinfo->fn_extra;\n\n\t/*\n\t * Clear the TupleTableSlot, if present.  This is for safety's sake: the\n\t * Slot will be in a long-lived context (it better be, if the\n\t * FuncCallContext is pointing to it), but in most usage patterns the\n\t * tuples stored in it will be in the function's per-tuple context. So at\n\t * the beginning of each call, the Slot will hold a dangling pointer to an\n\t * already-recycled tuple.  We clear it out here.\n\t *\n\t * Note: use of retval->slot is obsolete as of 8.0, and we expect that it\n\t * will always be NULL.  This is just here for backwards compatibility in\n\t * case someone creates a slot anyway.\n\t */\n\tif (retval->slot != NULL)\n\t\tExecClearTuple(retval->slot);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "init_MultiFuncCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/funcapi.c",
    "lines": "51-120",
    "snippet": "FuncCallContext *\ninit_MultiFuncCall(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *retval;\n\n\t/*\n\t * Bail if we're called in the wrong context\n\t */\n\tif (fcinfo->resultinfo == NULL || !IsA(fcinfo->resultinfo, ReturnSetInfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that cannot accept a set\")));\n\n\tif (fcinfo->flinfo->fn_extra == NULL)\n\t{\n\t\t/*\n\t\t * First call\n\t\t */\n\t\tReturnSetInfo *rsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\t\tMemoryContext multi_call_ctx;\n\n\t\t/*\n\t\t * Create a suitably long-lived context to hold cross-call data\n\t\t */\n\t\tmulti_call_ctx = AllocSetContextCreate(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t   \"SRF multi-call context\",\n\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\n\t\t/*\n\t\t * Allocate suitably long-lived space and zero it\n\t\t */\n\t\tretval = (FuncCallContext *)\n\t\t\tMemoryContextAllocZero(multi_call_ctx,\n\t\t\t\t\t\t\t\t   sizeof(FuncCallContext));\n\n\t\t/*\n\t\t * initialize the elements\n\t\t */\n\t\tretval->call_cntr = 0;\n\t\tretval->max_calls = 0;\n\t\tretval->slot = NULL;\n\t\tretval->user_fctx = NULL;\n\t\tretval->attinmeta = NULL;\n\t\tretval->tuple_desc = NULL;\n\t\tretval->multi_call_memory_ctx = multi_call_ctx;\n\n\t\t/*\n\t\t * save the pointer for cross-call use\n\t\t */\n\t\tfcinfo->flinfo->fn_extra = retval;\n\n\t\t/*\n\t\t * Ensure we will get shut down cleanly if the exprcontext is not run\n\t\t * to completion.\n\t\t */\n\t\tRegisterExprContextCallback(rsi->econtext,\n\t\t\t\t\t\t\t\t\tshutdown_MultiFuncCall,\n\t\t\t\t\t\t\t\t\tPointerGetDatum(fcinfo->flinfo));\n\t}\n\telse\n\t{\n\t\t/* second and subsequent calls */\n\t\telog(ERROR, \"init_MultiFuncCall cannot be called more than once\");\n\n\t\t/* never reached, but keep compiler happy */\n\t\tretval = NULL;\n\t}\n\n\treturn retval;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"init_MultiFuncCall cannot be called more than once\""
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RegisterExprContextCallback",
          "args": [
            "rsi->econtext",
            "shutdown_MultiFuncCall",
            "PointerGetDatum(fcinfo->flinfo)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "fcinfo->flinfo"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "multi_call_ctx",
            "sizeof(FuncCallContext)"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "\"SRF multi-call context\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that cannot accept a set\"))"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"set-valued function called in context that cannot accept a set\""
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "fcinfo->resultinfo",
            "ReturnSetInfo"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/parse_coerce.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nFuncCallContext *\ninit_MultiFuncCall(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *retval;\n\n\t/*\n\t * Bail if we're called in the wrong context\n\t */\n\tif (fcinfo->resultinfo == NULL || !IsA(fcinfo->resultinfo, ReturnSetInfo))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"set-valued function called in context that cannot accept a set\")));\n\n\tif (fcinfo->flinfo->fn_extra == NULL)\n\t{\n\t\t/*\n\t\t * First call\n\t\t */\n\t\tReturnSetInfo *rsi = (ReturnSetInfo *) fcinfo->resultinfo;\n\t\tMemoryContext multi_call_ctx;\n\n\t\t/*\n\t\t * Create a suitably long-lived context to hold cross-call data\n\t\t */\n\t\tmulti_call_ctx = AllocSetContextCreate(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t   \"SRF multi-call context\",\n\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\n\t\t/*\n\t\t * Allocate suitably long-lived space and zero it\n\t\t */\n\t\tretval = (FuncCallContext *)\n\t\t\tMemoryContextAllocZero(multi_call_ctx,\n\t\t\t\t\t\t\t\t   sizeof(FuncCallContext));\n\n\t\t/*\n\t\t * initialize the elements\n\t\t */\n\t\tretval->call_cntr = 0;\n\t\tretval->max_calls = 0;\n\t\tretval->slot = NULL;\n\t\tretval->user_fctx = NULL;\n\t\tretval->attinmeta = NULL;\n\t\tretval->tuple_desc = NULL;\n\t\tretval->multi_call_memory_ctx = multi_call_ctx;\n\n\t\t/*\n\t\t * save the pointer for cross-call use\n\t\t */\n\t\tfcinfo->flinfo->fn_extra = retval;\n\n\t\t/*\n\t\t * Ensure we will get shut down cleanly if the exprcontext is not run\n\t\t * to completion.\n\t\t */\n\t\tRegisterExprContextCallback(rsi->econtext,\n\t\t\t\t\t\t\t\t\tshutdown_MultiFuncCall,\n\t\t\t\t\t\t\t\t\tPointerGetDatum(fcinfo->flinfo));\n\t}\n\telse\n\t{\n\t\t/* second and subsequent calls */\n\t\telog(ERROR, \"init_MultiFuncCall cannot be called more than once\");\n\n\t\t/* never reached, but keep compiler happy */\n\t\tretval = NULL;\n\t}\n\n\treturn retval;\n}"
  }
]