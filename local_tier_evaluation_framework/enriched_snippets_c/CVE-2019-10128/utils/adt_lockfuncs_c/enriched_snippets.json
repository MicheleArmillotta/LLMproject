[
  {
    "function_name": "pg_advisory_unlock_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "1064-1070",
    "snippet": "Datum\npg_advisory_unlock_all(PG_FUNCTION_ARGS)\n{\n\tLockReleaseSession(USER_LOCKMETHOD);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockReleaseSession",
          "args": [
            "USER_LOCKMETHOD"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_unlock_all(PG_FUNCTION_ARGS)\n{\n\tLockReleaseSession(USER_LOCKMETHOD);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "pg_advisory_unlock_shared_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "1045-1059",
    "snippet": "Datum\npg_advisory_unlock_shared_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tbool\t\tres;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockRelease(&tag, ShareLock, true);\n\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockRelease",
          "args": [
            "&tag",
            "ShareLock",
            "true"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT32",
          "args": [
            "tag",
            "key1",
            "key2"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_unlock_shared_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tbool\t\tres;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockRelease(&tag, ShareLock, true);\n\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "pg_advisory_unlock_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "1024-1038",
    "snippet": "Datum\npg_advisory_unlock_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tbool\t\tres;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockRelease(&tag, ExclusiveLock, true);\n\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockRelease",
          "args": [
            "&tag",
            "ExclusiveLock",
            "true"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT32",
          "args": [
            "tag",
            "key1",
            "key2"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_unlock_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tbool\t\tres;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockRelease(&tag, ExclusiveLock, true);\n\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "pg_try_advisory_xact_lock_shared_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "1003-1017",
    "snippet": "Datum\npg_try_advisory_xact_lock_shared_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockAcquire(&tag, ShareLock, false, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res != LOCKACQUIRE_NOT_AVAIL"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ShareLock",
            "false",
            "true"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT32",
          "args": [
            "tag",
            "key1",
            "key2"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_try_advisory_xact_lock_shared_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockAcquire(&tag, ShareLock, false, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}"
  },
  {
    "function_name": "pg_try_advisory_lock_shared_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "981-995",
    "snippet": "Datum\npg_try_advisory_lock_shared_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockAcquire(&tag, ShareLock, true, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res != LOCKACQUIRE_NOT_AVAIL"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ShareLock",
            "true",
            "true"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT32",
          "args": [
            "tag",
            "key1",
            "key2"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_try_advisory_lock_shared_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockAcquire(&tag, ShareLock, true, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}"
  },
  {
    "function_name": "pg_try_advisory_xact_lock_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "960-974",
    "snippet": "Datum\npg_try_advisory_xact_lock_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockAcquire(&tag, ExclusiveLock, false, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res != LOCKACQUIRE_NOT_AVAIL"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ExclusiveLock",
            "false",
            "true"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT32",
          "args": [
            "tag",
            "key1",
            "key2"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_try_advisory_xact_lock_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockAcquire(&tag, ExclusiveLock, false, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}"
  },
  {
    "function_name": "pg_try_advisory_lock_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "938-952",
    "snippet": "Datum\npg_try_advisory_lock_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockAcquire(&tag, ExclusiveLock, true, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res != LOCKACQUIRE_NOT_AVAIL"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ExclusiveLock",
            "true",
            "true"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT32",
          "args": [
            "tag",
            "key1",
            "key2"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_try_advisory_lock_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\tres = LockAcquire(&tag, ExclusiveLock, true, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}"
  },
  {
    "function_name": "pg_advisory_xact_lock_shared_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "918-931",
    "snippet": "Datum\npg_advisory_xact_lock_shared_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\t(void) LockAcquire(&tag, ShareLock, false, false);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ShareLock",
            "false",
            "false"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT32",
          "args": [
            "tag",
            "key1",
            "key2"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_xact_lock_shared_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\t(void) LockAcquire(&tag, ShareLock, false, false);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "pg_advisory_lock_shared_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "899-912",
    "snippet": "Datum\npg_advisory_lock_shared_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\t(void) LockAcquire(&tag, ShareLock, true, false);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ShareLock",
            "true",
            "false"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT32",
          "args": [
            "tag",
            "key1",
            "key2"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_lock_shared_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\t(void) LockAcquire(&tag, ShareLock, true, false);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "pg_advisory_xact_lock_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "881-894",
    "snippet": "Datum\npg_advisory_xact_lock_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\t(void) LockAcquire(&tag, ExclusiveLock, false, false);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ExclusiveLock",
            "false",
            "false"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT32",
          "args": [
            "tag",
            "key1",
            "key2"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_xact_lock_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\t(void) LockAcquire(&tag, ExclusiveLock, false, false);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "pg_advisory_lock_int4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "862-875",
    "snippet": "Datum\npg_advisory_lock_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\t(void) LockAcquire(&tag, ExclusiveLock, true, false);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ExclusiveLock",
            "true",
            "false"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT32",
          "args": [
            "tag",
            "key1",
            "key2"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_lock_int4(PG_FUNCTION_ARGS)\n{\n\tint32\t\tkey1 = PG_GETARG_INT32(0);\n\tint32\t\tkey2 = PG_GETARG_INT32(1);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT32(tag, key1, key2);\n\n\t(void) LockAcquire(&tag, ExclusiveLock, true, false);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "pg_advisory_unlock_shared_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "844-857",
    "snippet": "Datum\npg_advisory_unlock_shared_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tbool\t\tres;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockRelease(&tag, ShareLock, true);\n\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockRelease",
          "args": [
            "&tag",
            "ShareLock",
            "true"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT64",
          "args": [
            "tag",
            "key"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_unlock_shared_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tbool\t\tres;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockRelease(&tag, ShareLock, true);\n\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "pg_advisory_unlock_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "824-837",
    "snippet": "Datum\npg_advisory_unlock_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tbool\t\tres;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockRelease(&tag, ExclusiveLock, true);\n\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockRelease",
          "args": [
            "&tag",
            "ExclusiveLock",
            "true"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT64",
          "args": [
            "tag",
            "key"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_unlock_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tbool\t\tres;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockRelease(&tag, ExclusiveLock, true);\n\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "pg_try_advisory_xact_lock_shared_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "804-817",
    "snippet": "Datum\npg_try_advisory_xact_lock_shared_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockAcquire(&tag, ShareLock, false, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res != LOCKACQUIRE_NOT_AVAIL"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ShareLock",
            "false",
            "true"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT64",
          "args": [
            "tag",
            "key"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_try_advisory_xact_lock_shared_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockAcquire(&tag, ShareLock, false, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}"
  },
  {
    "function_name": "pg_try_advisory_lock_shared_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "783-796",
    "snippet": "Datum\npg_try_advisory_lock_shared_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockAcquire(&tag, ShareLock, true, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res != LOCKACQUIRE_NOT_AVAIL"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ShareLock",
            "true",
            "true"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT64",
          "args": [
            "tag",
            "key"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_try_advisory_lock_shared_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockAcquire(&tag, ShareLock, true, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}"
  },
  {
    "function_name": "pg_try_advisory_xact_lock_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "763-776",
    "snippet": "Datum\npg_try_advisory_xact_lock_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockAcquire(&tag, ExclusiveLock, false, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res != LOCKACQUIRE_NOT_AVAIL"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ExclusiveLock",
            "false",
            "true"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT64",
          "args": [
            "tag",
            "key"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_try_advisory_xact_lock_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockAcquire(&tag, ExclusiveLock, false, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}"
  },
  {
    "function_name": "pg_try_advisory_lock_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "742-755",
    "snippet": "Datum\npg_try_advisory_lock_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockAcquire(&tag, ExclusiveLock, true, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res != LOCKACQUIRE_NOT_AVAIL"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ExclusiveLock",
            "true",
            "true"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT64",
          "args": [
            "tag",
            "key"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_try_advisory_lock_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\tLockAcquireResult res;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\tres = LockAcquire(&tag, ExclusiveLock, true, true);\n\n\tPG_RETURN_BOOL(res != LOCKACQUIRE_NOT_AVAIL);\n}"
  },
  {
    "function_name": "pg_advisory_xact_lock_shared_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "723-735",
    "snippet": "Datum\npg_advisory_xact_lock_shared_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\t(void) LockAcquire(&tag, ShareLock, false, false);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ShareLock",
            "false",
            "false"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT64",
          "args": [
            "tag",
            "key"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_xact_lock_shared_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\t(void) LockAcquire(&tag, ShareLock, false, false);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "pg_advisory_lock_shared_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "705-717",
    "snippet": "Datum\npg_advisory_lock_shared_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\t(void) LockAcquire(&tag, ShareLock, true, false);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ShareLock",
            "true",
            "false"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT64",
          "args": [
            "tag",
            "key"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_lock_shared_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\t(void) LockAcquire(&tag, ShareLock, true, false);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "pg_advisory_xact_lock_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "688-700",
    "snippet": "Datum\npg_advisory_xact_lock_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\t(void) LockAcquire(&tag, ExclusiveLock, false, false);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ExclusiveLock",
            "false",
            "false"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT64",
          "args": [
            "tag",
            "key"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_xact_lock_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\t(void) LockAcquire(&tag, ExclusiveLock, false, false);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "pg_advisory_lock_int8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "670-682",
    "snippet": "Datum\npg_advisory_lock_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\t(void) LockAcquire(&tag, ExclusiveLock, true, false);\n\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockAcquire",
          "args": [
            "&tag",
            "ExclusiveLock",
            "true",
            "false"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_LOCKTAG_INT64",
          "args": [
            "tag",
            "key"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PreventAdvisoryLocksInParallelMode",
          "args": [],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "PreventAdvisoryLocksInParallelMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "658-665",
          "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "0"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_advisory_lock_int8(PG_FUNCTION_ARGS)\n{\n\tint64\t\tkey = PG_GETARG_INT64(0);\n\tLOCKTAG\t\ttag;\n\n\tPreventAdvisoryLocksInParallelMode();\n\tSET_LOCKTAG_INT64(tag, key);\n\n\t(void) LockAcquire(&tag, ExclusiveLock, true, false);\n\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "PreventAdvisoryLocksInParallelMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "658-665",
    "snippet": "static void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\"))"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot use advisory locks during a parallel operation\""
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TRANSACTION_STATE"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInParallelMode",
          "args": [],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\nPreventAdvisoryLocksInParallelMode(void)\n{\n\tif (IsInParallelMode())\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TRANSACTION_STATE),\n\t\t\t\t errmsg(\"cannot use advisory locks during a parallel operation\")));\n}"
  },
  {
    "function_name": "pg_isolation_test_session_is_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "572-636",
    "snippet": "Datum\npg_isolation_test_session_is_blocked(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tblocked_pid = PG_GETARG_INT32(0);\n\tArrayType  *interesting_pids_a = PG_GETARG_ARRAYTYPE_P(1);\n\tArrayType  *blocking_pids_a;\n\tint32\t   *interesting_pids;\n\tint32\t   *blocking_pids;\n\tint\t\t\tnum_interesting_pids;\n\tint\t\t\tnum_blocking_pids;\n\tint\t\t\tdummy;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\t/* Validate the passed-in array */\n\tAssert(ARR_ELEMTYPE(interesting_pids_a) == INT4OID);\n\tif (array_contains_nulls(interesting_pids_a))\n\t\telog(ERROR, \"array must not contain nulls\");\n\tinteresting_pids = (int32 *) ARR_DATA_PTR(interesting_pids_a);\n\tnum_interesting_pids = ArrayGetNItems(ARR_NDIM(interesting_pids_a),\n\t\t\t\t\t\t\t\t\t\t  ARR_DIMS(interesting_pids_a));\n\n\t/*\n\t * Get the PIDs of all sessions blocking the given session's attempt to\n\t * acquire heavyweight locks.\n\t */\n\tblocking_pids_a =\n\t\tDatumGetArrayTypeP(DirectFunctionCall1(pg_blocking_pids, blocked_pid));\n\n\tAssert(ARR_ELEMTYPE(blocking_pids_a) == INT4OID);\n\tAssert(!array_contains_nulls(blocking_pids_a));\n\tblocking_pids = (int32 *) ARR_DATA_PTR(blocking_pids_a);\n\tnum_blocking_pids = ArrayGetNItems(ARR_NDIM(blocking_pids_a),\n\t\t\t\t\t\t\t\t\t   ARR_DIMS(blocking_pids_a));\n\n\t/*\n\t * Check if any of these are in the list of interesting PIDs, that being\n\t * the sessions that the isolation tester is running.  We don't use\n\t * \"arrayoverlaps\" here, because it would lead to cache lookups and one of\n\t * our goals is to run quickly under CLOBBER_CACHE_ALWAYS.  We expect\n\t * blocking_pids to be usually empty and otherwise a very small number in\n\t * isolation tester cases, so make that the outer loop of a naive search\n\t * for a match.\n\t */\n\tfor (i = 0; i < num_blocking_pids; i++)\n\t\tfor (j = 0; j < num_interesting_pids; j++)\n\t\t{\n\t\t\tif (blocking_pids[i] == interesting_pids[j])\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t}\n\n\t/*\n\t * Check if blocked_pid is waiting for a safe snapshot.  We could in\n\t * theory check the resulting array of blocker PIDs against the\n\t * interesting PIDs whitelist, but since there is no danger of autovacuum\n\t * blocking GetSafeSnapshot there seems to be no point in expending cycles\n\t * on allocating a buffer and searching for overlap; so it's presently\n\t * sufficient for the isolation tester's purposes to use a single element\n\t * buffer and check if the number of safe snapshot blockers is non-zero.\n\t */\n\tif (GetSafeSnapshotBlockingPids(blocked_pid, &dummy, 1) > 0)\n\t\tPG_RETURN_BOOL(true);\n\n\tPG_RETURN_BOOL(false);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSafeSnapshotBlockingPids",
          "args": [
            "blocked_pid",
            "&dummy",
            "1"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ARR_NDIM(blocking_pids_a)",
            "ARR_DIMS(blocking_pids_a)"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "blocking_pids_a"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "blocking_pids_a"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "blocking_pids_a"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!array_contains_nulls(blocking_pids_a)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contains_nulls",
          "args": [
            "blocking_pids_a"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3527-3562",
          "snippet": "bool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ARR_ELEMTYPE(blocking_pids_a) == INT4OID"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "blocking_pids_a"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "DirectFunctionCall1(pg_blocking_pids, blocked_pid)"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "pg_blocking_pids",
            "blocked_pid"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "interesting_pids_a"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "interesting_pids_a"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "interesting_pids_a"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"array must not contain nulls\""
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ARR_ELEMTYPE(interesting_pids_a) == INT4OID"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "interesting_pids_a"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_isolation_test_session_is_blocked(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tblocked_pid = PG_GETARG_INT32(0);\n\tArrayType  *interesting_pids_a = PG_GETARG_ARRAYTYPE_P(1);\n\tArrayType  *blocking_pids_a;\n\tint32\t   *interesting_pids;\n\tint32\t   *blocking_pids;\n\tint\t\t\tnum_interesting_pids;\n\tint\t\t\tnum_blocking_pids;\n\tint\t\t\tdummy;\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\t/* Validate the passed-in array */\n\tAssert(ARR_ELEMTYPE(interesting_pids_a) == INT4OID);\n\tif (array_contains_nulls(interesting_pids_a))\n\t\telog(ERROR, \"array must not contain nulls\");\n\tinteresting_pids = (int32 *) ARR_DATA_PTR(interesting_pids_a);\n\tnum_interesting_pids = ArrayGetNItems(ARR_NDIM(interesting_pids_a),\n\t\t\t\t\t\t\t\t\t\t  ARR_DIMS(interesting_pids_a));\n\n\t/*\n\t * Get the PIDs of all sessions blocking the given session's attempt to\n\t * acquire heavyweight locks.\n\t */\n\tblocking_pids_a =\n\t\tDatumGetArrayTypeP(DirectFunctionCall1(pg_blocking_pids, blocked_pid));\n\n\tAssert(ARR_ELEMTYPE(blocking_pids_a) == INT4OID);\n\tAssert(!array_contains_nulls(blocking_pids_a));\n\tblocking_pids = (int32 *) ARR_DATA_PTR(blocking_pids_a);\n\tnum_blocking_pids = ArrayGetNItems(ARR_NDIM(blocking_pids_a),\n\t\t\t\t\t\t\t\t\t   ARR_DIMS(blocking_pids_a));\n\n\t/*\n\t * Check if any of these are in the list of interesting PIDs, that being\n\t * the sessions that the isolation tester is running.  We don't use\n\t * \"arrayoverlaps\" here, because it would lead to cache lookups and one of\n\t * our goals is to run quickly under CLOBBER_CACHE_ALWAYS.  We expect\n\t * blocking_pids to be usually empty and otherwise a very small number in\n\t * isolation tester cases, so make that the outer loop of a naive search\n\t * for a match.\n\t */\n\tfor (i = 0; i < num_blocking_pids; i++)\n\t\tfor (j = 0; j < num_interesting_pids; j++)\n\t\t{\n\t\t\tif (blocking_pids[i] == interesting_pids[j])\n\t\t\t\tPG_RETURN_BOOL(true);\n\t\t}\n\n\t/*\n\t * Check if blocked_pid is waiting for a safe snapshot.  We could in\n\t * theory check the resulting array of blocker PIDs against the\n\t * interesting PIDs whitelist, but since there is no danger of autovacuum\n\t * blocking GetSafeSnapshot there seems to be no point in expending cycles\n\t * on allocating a buffer and searching for overlap; so it's presently\n\t * sufficient for the isolation tester's purposes to use a single element\n\t * buffer and check if the number of safe snapshot blockers is non-zero.\n\t */\n\tif (GetSafeSnapshotBlockingPids(blocked_pid, &dummy, 1) > 0)\n\t\tPG_RETURN_BOOL(true);\n\n\tPG_RETURN_BOOL(false);\n}"
  },
  {
    "function_name": "pg_safe_snapshot_blocking_pids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "527-558",
    "snippet": "Datum\npg_safe_snapshot_blocking_pids(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tblocked_pid = PG_GETARG_INT32(0);\n\tint\t\t   *blockers;\n\tint\t\t\tnum_blockers;\n\tDatum\t   *blocker_datums;\n\n\t/* A buffer big enough for any possible blocker list without truncation */\n\tblockers = (int *) palloc(MaxBackends * sizeof(int));\n\n\t/* Collect a snapshot of processes waited for by GetSafeSnapshot */\n\tnum_blockers =\n\t\tGetSafeSnapshotBlockingPids(blocked_pid, blockers, MaxBackends);\n\n\t/* Convert int array to Datum array */\n\tif (num_blockers > 0)\n\t{\n\t\tint\t\t\ti;\n\n\t\tblocker_datums = (Datum *) palloc(num_blockers * sizeof(Datum));\n\t\tfor (i = 0; i < num_blockers; ++i)\n\t\t\tblocker_datums[i] = Int32GetDatum(blockers[i]);\n\t}\n\telse\n\t\tblocker_datums = NULL;\n\n\t/* Construct array, using hardwired knowledge about int4 type */\n\tPG_RETURN_ARRAYTYPE_P(construct_array(blocker_datums, num_blockers,\n\t\t\t\t\t\t\t\t\t\t  INT4OID,\n\t\t\t\t\t\t\t\t\t\t  sizeof(int32), true, 'i'));\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "construct_array(blocker_datums, num_blockers,\n\t\t\t\t\t\t\t\t\t\t  INT4OID,\n\t\t\t\t\t\t\t\t\t\t  sizeof(int32), true, 'i')"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "blocker_datums",
            "num_blockers",
            "INT4OID",
            "sizeof(int32)",
            "true",
            "'i'"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "blockers[i]"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "num_blockers * sizeof(Datum)"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetSafeSnapshotBlockingPids",
          "args": [
            "blocked_pid",
            "blockers",
            "MaxBackends"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_safe_snapshot_blocking_pids(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tblocked_pid = PG_GETARG_INT32(0);\n\tint\t\t   *blockers;\n\tint\t\t\tnum_blockers;\n\tDatum\t   *blocker_datums;\n\n\t/* A buffer big enough for any possible blocker list without truncation */\n\tblockers = (int *) palloc(MaxBackends * sizeof(int));\n\n\t/* Collect a snapshot of processes waited for by GetSafeSnapshot */\n\tnum_blockers =\n\t\tGetSafeSnapshotBlockingPids(blocked_pid, blockers, MaxBackends);\n\n\t/* Convert int array to Datum array */\n\tif (num_blockers > 0)\n\t{\n\t\tint\t\t\ti;\n\n\t\tblocker_datums = (Datum *) palloc(num_blockers * sizeof(Datum));\n\t\tfor (i = 0; i < num_blockers; ++i)\n\t\t\tblocker_datums[i] = Int32GetDatum(blockers[i]);\n\t}\n\telse\n\t\tblocker_datums = NULL;\n\n\t/* Construct array, using hardwired knowledge about int4 type */\n\tPG_RETURN_ARRAYTYPE_P(construct_array(blocker_datums, num_blockers,\n\t\t\t\t\t\t\t\t\t\t  INT4OID,\n\t\t\t\t\t\t\t\t\t\t  sizeof(int32), true, 'i'));\n}"
  },
  {
    "function_name": "pg_blocking_pids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "417-517",
    "snippet": "Datum\npg_blocking_pids(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tblocked_pid = PG_GETARG_INT32(0);\n\tDatum\t   *arrayelems;\n\tint\t\t\tnarrayelems;\n\tBlockedProcsData *lockData; /* state data from lmgr */\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\t/* Collect a snapshot of lock manager state */\n\tlockData = GetBlockerStatusData(blocked_pid);\n\n\t/* We can't need more output entries than there are reported PROCLOCKs */\n\tarrayelems = (Datum *) palloc(lockData->nlocks * sizeof(Datum));\n\tnarrayelems = 0;\n\n\t/* For each blocked proc in the lock group ... */\n\tfor (i = 0; i < lockData->nprocs; i++)\n\t{\n\t\tBlockedProcData *bproc = &lockData->procs[i];\n\t\tLockInstanceData *instances = &lockData->locks[bproc->first_lock];\n\t\tint\t\t   *preceding_waiters = &lockData->waiter_pids[bproc->first_waiter];\n\t\tLockInstanceData *blocked_instance;\n\t\tLockMethod\tlockMethodTable;\n\t\tint\t\t\tconflictMask;\n\n\t\t/*\n\t\t * Locate the blocked proc's own entry in the LockInstanceData array.\n\t\t * There should be exactly one matching entry.\n\t\t */\n\t\tblocked_instance = NULL;\n\t\tfor (j = 0; j < bproc->num_locks; j++)\n\t\t{\n\t\t\tLockInstanceData *instance = &(instances[j]);\n\n\t\t\tif (instance->pid == bproc->pid)\n\t\t\t{\n\t\t\t\tAssert(blocked_instance == NULL);\n\t\t\t\tblocked_instance = instance;\n\t\t\t}\n\t\t}\n\t\tAssert(blocked_instance != NULL);\n\n\t\tlockMethodTable = GetLockTagsMethodTable(&(blocked_instance->locktag));\n\t\tconflictMask = lockMethodTable->conflictTab[blocked_instance->waitLockMode];\n\n\t\t/* Now scan the PROCLOCK data for conflicting procs */\n\t\tfor (j = 0; j < bproc->num_locks; j++)\n\t\t{\n\t\t\tLockInstanceData *instance = &(instances[j]);\n\n\t\t\t/* A proc never blocks itself, so ignore that entry */\n\t\t\tif (instance == blocked_instance)\n\t\t\t\tcontinue;\n\t\t\t/* Members of same lock group never block each other, either */\n\t\t\tif (instance->leaderPid == blocked_instance->leaderPid)\n\t\t\t\tcontinue;\n\n\t\t\tif (conflictMask & instance->holdMask)\n\t\t\t{\n\t\t\t\t/* hard block: blocked by lock already held by this entry */\n\t\t\t}\n\t\t\telse if (instance->waitLockMode != NoLock &&\n\t\t\t\t\t (conflictMask & LOCKBIT_ON(instance->waitLockMode)))\n\t\t\t{\n\t\t\t\t/* conflict in lock requests; who's in front in wait queue? */\n\t\t\t\tbool\t\tahead = false;\n\t\t\t\tint\t\t\tk;\n\n\t\t\t\tfor (k = 0; k < bproc->num_waiters; k++)\n\t\t\t\t{\n\t\t\t\t\tif (preceding_waiters[k] == instance->pid)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* soft block: this entry is ahead of blocked proc */\n\t\t\t\t\t\tahead = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!ahead)\n\t\t\t\t\tcontinue;\t/* not blocked by this entry */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not blocked by this entry */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* blocked by this entry, so emit a record */\n\t\t\tarrayelems[narrayelems++] = Int32GetDatum(instance->leaderPid);\n\t\t}\n\t}\n\n\t/* Assert we didn't overrun arrayelems[] */\n\tAssert(narrayelems <= lockData->nlocks);\n\n\t/* Construct array, using hardwired knowledge about int4 type */\n\tPG_RETURN_ARRAYTYPE_P(construct_array(arrayelems, narrayelems,\n\t\t\t\t\t\t\t\t\t\t  INT4OID,\n\t\t\t\t\t\t\t\t\t\t  sizeof(int32), true, 'i'));\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "construct_array(arrayelems, narrayelems,\n\t\t\t\t\t\t\t\t\t\t  INT4OID,\n\t\t\t\t\t\t\t\t\t\t  sizeof(int32), true, 'i')"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "arrayelems",
            "narrayelems",
            "INT4OID",
            "sizeof(int32)",
            "true",
            "'i'"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "narrayelems <= lockData->nlocks"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "instance->leaderPid"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCKBIT_ON",
          "args": [
            "instance->waitLockMode"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLockTagsMethodTable",
          "args": [
            "&(blocked_instance->locktag)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "blocked_instance != NULL"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "blocked_instance == NULL"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "lockData->nlocks * sizeof(Datum)"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBlockerStatusData",
          "args": [
            "blocked_pid"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\npg_blocking_pids(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tblocked_pid = PG_GETARG_INT32(0);\n\tDatum\t   *arrayelems;\n\tint\t\t\tnarrayelems;\n\tBlockedProcsData *lockData; /* state data from lmgr */\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\t/* Collect a snapshot of lock manager state */\n\tlockData = GetBlockerStatusData(blocked_pid);\n\n\t/* We can't need more output entries than there are reported PROCLOCKs */\n\tarrayelems = (Datum *) palloc(lockData->nlocks * sizeof(Datum));\n\tnarrayelems = 0;\n\n\t/* For each blocked proc in the lock group ... */\n\tfor (i = 0; i < lockData->nprocs; i++)\n\t{\n\t\tBlockedProcData *bproc = &lockData->procs[i];\n\t\tLockInstanceData *instances = &lockData->locks[bproc->first_lock];\n\t\tint\t\t   *preceding_waiters = &lockData->waiter_pids[bproc->first_waiter];\n\t\tLockInstanceData *blocked_instance;\n\t\tLockMethod\tlockMethodTable;\n\t\tint\t\t\tconflictMask;\n\n\t\t/*\n\t\t * Locate the blocked proc's own entry in the LockInstanceData array.\n\t\t * There should be exactly one matching entry.\n\t\t */\n\t\tblocked_instance = NULL;\n\t\tfor (j = 0; j < bproc->num_locks; j++)\n\t\t{\n\t\t\tLockInstanceData *instance = &(instances[j]);\n\n\t\t\tif (instance->pid == bproc->pid)\n\t\t\t{\n\t\t\t\tAssert(blocked_instance == NULL);\n\t\t\t\tblocked_instance = instance;\n\t\t\t}\n\t\t}\n\t\tAssert(blocked_instance != NULL);\n\n\t\tlockMethodTable = GetLockTagsMethodTable(&(blocked_instance->locktag));\n\t\tconflictMask = lockMethodTable->conflictTab[blocked_instance->waitLockMode];\n\n\t\t/* Now scan the PROCLOCK data for conflicting procs */\n\t\tfor (j = 0; j < bproc->num_locks; j++)\n\t\t{\n\t\t\tLockInstanceData *instance = &(instances[j]);\n\n\t\t\t/* A proc never blocks itself, so ignore that entry */\n\t\t\tif (instance == blocked_instance)\n\t\t\t\tcontinue;\n\t\t\t/* Members of same lock group never block each other, either */\n\t\t\tif (instance->leaderPid == blocked_instance->leaderPid)\n\t\t\t\tcontinue;\n\n\t\t\tif (conflictMask & instance->holdMask)\n\t\t\t{\n\t\t\t\t/* hard block: blocked by lock already held by this entry */\n\t\t\t}\n\t\t\telse if (instance->waitLockMode != NoLock &&\n\t\t\t\t\t (conflictMask & LOCKBIT_ON(instance->waitLockMode)))\n\t\t\t{\n\t\t\t\t/* conflict in lock requests; who's in front in wait queue? */\n\t\t\t\tbool\t\tahead = false;\n\t\t\t\tint\t\t\tk;\n\n\t\t\t\tfor (k = 0; k < bproc->num_waiters; k++)\n\t\t\t\t{\n\t\t\t\t\tif (preceding_waiters[k] == instance->pid)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* soft block: this entry is ahead of blocked proc */\n\t\t\t\t\t\tahead = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!ahead)\n\t\t\t\t\tcontinue;\t/* not blocked by this entry */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* not blocked by this entry */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* blocked by this entry, so emit a record */\n\t\t\tarrayelems[narrayelems++] = Int32GetDatum(instance->leaderPid);\n\t\t}\n\t}\n\n\t/* Assert we didn't overrun arrayelems[] */\n\tAssert(narrayelems <= lockData->nlocks);\n\n\t/* Construct array, using hardwired knowledge about int4 type */\n\tPG_RETURN_ARRAYTYPE_P(construct_array(arrayelems, narrayelems,\n\t\t\t\t\t\t\t\t\t\t  INT4OID,\n\t\t\t\t\t\t\t\t\t\t  sizeof(int32), true, 'i'));\n}"
  },
  {
    "function_name": "pg_lock_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "81-395",
    "snippet": "Datum\npg_lock_status(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tPG_Lock_Status *mystatus;\n\tLockData   *lockData;\n\tPredicateLockData *predLockData;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\t\tMemoryContext oldcontext;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* build tupdesc for result tuples */\n\t\t/* this had better match function's declaration in pg_proc.h */\n\t\ttupdesc = CreateTemplateTupleDesc(NUM_LOCK_STATUS_COLUMNS, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"locktype\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"database\",\n\t\t\t\t\t\t   OIDOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"relation\",\n\t\t\t\t\t\t   OIDOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"page\",\n\t\t\t\t\t\t   INT4OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 5, \"tuple\",\n\t\t\t\t\t\t   INT2OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 6, \"virtualxid\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 7, \"transactionid\",\n\t\t\t\t\t\t   XIDOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 8, \"classid\",\n\t\t\t\t\t\t   OIDOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 9, \"objid\",\n\t\t\t\t\t\t   OIDOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 10, \"objsubid\",\n\t\t\t\t\t\t   INT2OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 11, \"virtualtransaction\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 12, \"pid\",\n\t\t\t\t\t\t   INT4OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 13, \"mode\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 14, \"granted\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 15, \"fastpath\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\n\t\t/*\n\t\t * Collect all the locking information that we will format and send\n\t\t * out as a result set.\n\t\t */\n\t\tmystatus = (PG_Lock_Status *) palloc(sizeof(PG_Lock_Status));\n\t\tfuncctx->user_fctx = (void *) mystatus;\n\n\t\tmystatus->lockData = GetLockStatusData();\n\t\tmystatus->currIdx = 0;\n\t\tmystatus->predLockData = GetPredicateLockStatusData();\n\t\tmystatus->predLockIdx = 0;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tmystatus = (PG_Lock_Status *) funcctx->user_fctx;\n\tlockData = mystatus->lockData;\n\n\twhile (mystatus->currIdx < lockData->nelements)\n\t{\n\t\tbool\t\tgranted;\n\t\tLOCKMODE\tmode = 0;\n\t\tconst char *locktypename;\n\t\tchar\t\ttnbuf[32];\n\t\tDatum\t\tvalues[NUM_LOCK_STATUS_COLUMNS];\n\t\tbool\t\tnulls[NUM_LOCK_STATUS_COLUMNS];\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\tresult;\n\t\tLockInstanceData *instance;\n\n\t\tinstance = &(lockData->locks[mystatus->currIdx]);\n\n\t\t/*\n\t\t * Look to see if there are any held lock modes in this PROCLOCK. If\n\t\t * so, report, and destructively modify lockData so we don't report\n\t\t * again.\n\t\t */\n\t\tgranted = false;\n\t\tif (instance->holdMask)\n\t\t{\n\t\t\tfor (mode = 0; mode < MAX_LOCKMODES; mode++)\n\t\t\t{\n\t\t\t\tif (instance->holdMask & LOCKBIT_ON(mode))\n\t\t\t\t{\n\t\t\t\t\tgranted = true;\n\t\t\t\t\tinstance->holdMask &= LOCKBIT_OFF(mode);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If no (more) held modes to report, see if PROC is waiting for a\n\t\t * lock on this lock.\n\t\t */\n\t\tif (!granted)\n\t\t{\n\t\t\tif (instance->waitLockMode != NoLock)\n\t\t\t{\n\t\t\t\t/* Yes, so report it with proper mode */\n\t\t\t\tmode = instance->waitLockMode;\n\n\t\t\t\t/*\n\t\t\t\t * We are now done with this PROCLOCK, so advance pointer to\n\t\t\t\t * continue with next one on next call.\n\t\t\t\t */\n\t\t\t\tmystatus->currIdx++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Okay, we've displayed all the locks associated with this\n\t\t\t\t * PROCLOCK, proceed to the next one.\n\t\t\t\t */\n\t\t\t\tmystatus->currIdx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Form tuple with appropriate data.\n\t\t */\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\n\t\tif (instance->locktag.locktag_type <= LOCKTAG_LAST_TYPE)\n\t\t\tlocktypename = LockTagTypeNames[instance->locktag.locktag_type];\n\t\telse\n\t\t{\n\t\t\tsnprintf(tnbuf, sizeof(tnbuf), \"unknown %d\",\n\t\t\t\t\t (int) instance->locktag.locktag_type);\n\t\t\tlocktypename = tnbuf;\n\t\t}\n\t\tvalues[0] = CStringGetTextDatum(locktypename);\n\n\t\tswitch ((LockTagType) instance->locktag.locktag_type)\n\t\t{\n\t\t\tcase LOCKTAG_RELATION:\n\t\t\tcase LOCKTAG_RELATION_EXTEND:\n\t\t\t\tvalues[1] = ObjectIdGetDatum(instance->locktag.locktag_field1);\n\t\t\t\tvalues[2] = ObjectIdGetDatum(instance->locktag.locktag_field2);\n\t\t\t\tnulls[3] = true;\n\t\t\t\tnulls[4] = true;\n\t\t\t\tnulls[5] = true;\n\t\t\t\tnulls[6] = true;\n\t\t\t\tnulls[7] = true;\n\t\t\t\tnulls[8] = true;\n\t\t\t\tnulls[9] = true;\n\t\t\t\tbreak;\n\t\t\tcase LOCKTAG_PAGE:\n\t\t\t\tvalues[1] = ObjectIdGetDatum(instance->locktag.locktag_field1);\n\t\t\t\tvalues[2] = ObjectIdGetDatum(instance->locktag.locktag_field2);\n\t\t\t\tvalues[3] = UInt32GetDatum(instance->locktag.locktag_field3);\n\t\t\t\tnulls[4] = true;\n\t\t\t\tnulls[5] = true;\n\t\t\t\tnulls[6] = true;\n\t\t\t\tnulls[7] = true;\n\t\t\t\tnulls[8] = true;\n\t\t\t\tnulls[9] = true;\n\t\t\t\tbreak;\n\t\t\tcase LOCKTAG_TUPLE:\n\t\t\t\tvalues[1] = ObjectIdGetDatum(instance->locktag.locktag_field1);\n\t\t\t\tvalues[2] = ObjectIdGetDatum(instance->locktag.locktag_field2);\n\t\t\t\tvalues[3] = UInt32GetDatum(instance->locktag.locktag_field3);\n\t\t\t\tvalues[4] = UInt16GetDatum(instance->locktag.locktag_field4);\n\t\t\t\tnulls[5] = true;\n\t\t\t\tnulls[6] = true;\n\t\t\t\tnulls[7] = true;\n\t\t\t\tnulls[8] = true;\n\t\t\t\tnulls[9] = true;\n\t\t\t\tbreak;\n\t\t\tcase LOCKTAG_TRANSACTION:\n\t\t\t\tvalues[6] =\n\t\t\t\t\tTransactionIdGetDatum(instance->locktag.locktag_field1);\n\t\t\t\tnulls[1] = true;\n\t\t\t\tnulls[2] = true;\n\t\t\t\tnulls[3] = true;\n\t\t\t\tnulls[4] = true;\n\t\t\t\tnulls[5] = true;\n\t\t\t\tnulls[7] = true;\n\t\t\t\tnulls[8] = true;\n\t\t\t\tnulls[9] = true;\n\t\t\t\tbreak;\n\t\t\tcase LOCKTAG_VIRTUALTRANSACTION:\n\t\t\t\tvalues[5] = VXIDGetDatum(instance->locktag.locktag_field1,\n\t\t\t\t\t\t\t\t\t\t instance->locktag.locktag_field2);\n\t\t\t\tnulls[1] = true;\n\t\t\t\tnulls[2] = true;\n\t\t\t\tnulls[3] = true;\n\t\t\t\tnulls[4] = true;\n\t\t\t\tnulls[6] = true;\n\t\t\t\tnulls[7] = true;\n\t\t\t\tnulls[8] = true;\n\t\t\t\tnulls[9] = true;\n\t\t\t\tbreak;\n\t\t\tcase LOCKTAG_OBJECT:\n\t\t\tcase LOCKTAG_USERLOCK:\n\t\t\tcase LOCKTAG_ADVISORY:\n\t\t\tdefault:\t\t\t/* treat unknown locktags like OBJECT */\n\t\t\t\tvalues[1] = ObjectIdGetDatum(instance->locktag.locktag_field1);\n\t\t\t\tvalues[7] = ObjectIdGetDatum(instance->locktag.locktag_field2);\n\t\t\t\tvalues[8] = ObjectIdGetDatum(instance->locktag.locktag_field3);\n\t\t\t\tvalues[9] = Int16GetDatum(instance->locktag.locktag_field4);\n\t\t\t\tnulls[2] = true;\n\t\t\t\tnulls[3] = true;\n\t\t\t\tnulls[4] = true;\n\t\t\t\tnulls[5] = true;\n\t\t\t\tnulls[6] = true;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvalues[10] = VXIDGetDatum(instance->backend, instance->lxid);\n\t\tif (instance->pid != 0)\n\t\t\tvalues[11] = Int32GetDatum(instance->pid);\n\t\telse\n\t\t\tnulls[11] = true;\n\t\tvalues[12] = CStringGetTextDatum(GetLockmodeName(instance->locktag.locktag_lockmethodid, mode));\n\t\tvalues[13] = BoolGetDatum(granted);\n\t\tvalues[14] = BoolGetDatum(instance->fastpath);\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tresult = HeapTupleGetDatum(tuple);\n\t\tSRF_RETURN_NEXT(funcctx, result);\n\t}\n\n\t/*\n\t * Have returned all regular locks. Now start on the SIREAD predicate\n\t * locks.\n\t */\n\tpredLockData = mystatus->predLockData;\n\tif (mystatus->predLockIdx < predLockData->nelements)\n\t{\n\t\tPredicateLockTargetType lockType;\n\n\t\tPREDICATELOCKTARGETTAG *predTag = &(predLockData->locktags[mystatus->predLockIdx]);\n\t\tSERIALIZABLEXACT *xact = &(predLockData->xacts[mystatus->predLockIdx]);\n\t\tDatum\t\tvalues[NUM_LOCK_STATUS_COLUMNS];\n\t\tbool\t\tnulls[NUM_LOCK_STATUS_COLUMNS];\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\tresult;\n\n\t\tmystatus->predLockIdx++;\n\n\t\t/*\n\t\t * Form tuple with appropriate data.\n\t\t */\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\n\t\t/* lock type */\n\t\tlockType = GET_PREDICATELOCKTARGETTAG_TYPE(*predTag);\n\n\t\tvalues[0] = CStringGetTextDatum(PredicateLockTagTypeNames[lockType]);\n\n\t\t/* lock target */\n\t\tvalues[1] = GET_PREDICATELOCKTARGETTAG_DB(*predTag);\n\t\tvalues[2] = GET_PREDICATELOCKTARGETTAG_RELATION(*predTag);\n\t\tif (lockType == PREDLOCKTAG_TUPLE)\n\t\t\tvalues[4] = GET_PREDICATELOCKTARGETTAG_OFFSET(*predTag);\n\t\telse\n\t\t\tnulls[4] = true;\n\t\tif ((lockType == PREDLOCKTAG_TUPLE) ||\n\t\t\t(lockType == PREDLOCKTAG_PAGE))\n\t\t\tvalues[3] = GET_PREDICATELOCKTARGETTAG_PAGE(*predTag);\n\t\telse\n\t\t\tnulls[3] = true;\n\n\t\t/* these fields are targets for other types of locks */\n\t\tnulls[5] = true;\t\t/* virtualxid */\n\t\tnulls[6] = true;\t\t/* transactionid */\n\t\tnulls[7] = true;\t\t/* classid */\n\t\tnulls[8] = true;\t\t/* objid */\n\t\tnulls[9] = true;\t\t/* objsubid */\n\n\t\t/* lock holder */\n\t\tvalues[10] = VXIDGetDatum(xact->vxid.backendId,\n\t\t\t\t\t\t\t\t  xact->vxid.localTransactionId);\n\t\tif (xact->pid != 0)\n\t\t\tvalues[11] = Int32GetDatum(xact->pid);\n\t\telse\n\t\t\tnulls[11] = true;\n\n\t\t/*\n\t\t * Lock mode. Currently all predicate locks are SIReadLocks, which are\n\t\t * always held (never waiting) and have no fast path\n\t\t */\n\t\tvalues[12] = CStringGetTextDatum(\"SIReadLock\");\n\t\tvalues[13] = BoolGetDatum(true);\n\t\tvalues[14] = BoolGetDatum(false);\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tresult = HeapTupleGetDatum(tuple);\n\t\tSRF_RETURN_NEXT(funcctx, result);\n\t}\n\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_LOCK_STATUS_COLUMNS\t\t15"
    ],
    "globals_used": [
      "const char *const LockTagTypeNames[] = {\n\t\"relation\",\n\t\"extend\",\n\t\"page\",\n\t\"tuple\",\n\t\"transactionid\",\n\t\"virtualxid\",\n\t\"speculative token\",\n\t\"object\",\n\t\"userlock\",\n\t\"advisory\"\n};",
      "static const char *const PredicateLockTagTypeNames[] = {\n\t\"relation\",\n\t\"page\",\n\t\"tuple\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "result"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetDatum",
          "args": [
            "tuple"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "funcctx->tuple_desc",
            "values",
            "nulls"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "false"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "true"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "\"SIReadLock\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "xact->pid"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXIDGetDatum",
          "args": [
            "xact->vxid.backendId",
            "xact->vxid.localTransactionId"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "VXIDGetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
          "lines": "63-75",
          "snippet": "static Datum\nVXIDGetDatum(BackendId bid, LocalTransactionId lxid)\n{\n\t/*\n\t * The representation is \"<bid>/<lxid>\", decimal and unsigned decimal\n\t * respectively.  Note that elog.c also knows how to format a vxid.\n\t */\n\tchar\t\tvxidstr[32];\n\n\tsnprintf(vxidstr, sizeof(vxidstr), \"%d/%u\", bid, lxid);\n\n\treturn CStringGetTextDatum(vxidstr);\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/predicate_internals.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic Datum\nVXIDGetDatum(BackendId bid, LocalTransactionId lxid)\n{\n\t/*\n\t * The representation is \"<bid>/<lxid>\", decimal and unsigned decimal\n\t * respectively.  Note that elog.c also knows how to format a vxid.\n\t */\n\tchar\t\tvxidstr[32];\n\n\tsnprintf(vxidstr, sizeof(vxidstr), \"%d/%u\", bid, lxid);\n\n\treturn CStringGetTextDatum(vxidstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_PREDICATELOCKTARGETTAG_PAGE",
          "args": [
            "*predTag"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_PREDICATELOCKTARGETTAG_OFFSET",
          "args": [
            "*predTag"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_PREDICATELOCKTARGETTAG_RELATION",
          "args": [
            "*predTag"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_PREDICATELOCKTARGETTAG_DB",
          "args": [
            "*predTag"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "PredicateLockTagTypeNames[lockType]"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_PREDICATELOCKTARGETTAG_TYPE",
          "args": [
            "*predTag"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "nulls",
            "false",
            "sizeof(nulls)"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "values",
            "0",
            "sizeof(values)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "result"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetDatum",
          "args": [
            "tuple"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "funcctx->tuple_desc",
            "values",
            "nulls"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "instance->fastpath"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "granted"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "GetLockmodeName(instance->locktag.locktag_lockmethodid, mode)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLockmodeName",
          "args": [
            "instance->locktag.locktag_lockmethodid",
            "mode"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "instance->pid"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "instance->locktag.locktag_field4"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "instance->locktag.locktag_field3"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "instance->locktag.locktag_field2"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "instance->locktag.locktag_field1"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdGetDatum",
          "args": [
            "instance->locktag.locktag_field1"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UInt16GetDatum",
          "args": [
            "instance->locktag.locktag_field4"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UInt32GetDatum",
          "args": [
            "instance->locktag.locktag_field3"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "instance->locktag.locktag_field2"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "instance->locktag.locktag_field1"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UInt32GetDatum",
          "args": [
            "instance->locktag.locktag_field3"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "instance->locktag.locktag_field2"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "instance->locktag.locktag_field1"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "instance->locktag.locktag_field2"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "instance->locktag.locktag_field1"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "locktypename"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tnbuf",
            "sizeof(tnbuf)",
            "\"unknown %d\"",
            "(int) instance->locktag.locktag_type"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "nulls",
            "false",
            "sizeof(nulls)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "values",
            "0",
            "sizeof(values)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCKBIT_OFF",
          "args": [
            "mode"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCKBIT_ON",
          "args": [
            "mode"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPredicateLockStatusData",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLockStatusData",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(PG_Lock_Status)"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 15",
            "\"fastpath\"",
            "BOOLOID",
            "-1",
            "0"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 14",
            "\"granted\"",
            "BOOLOID",
            "-1",
            "0"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 13",
            "\"mode\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 12",
            "\"pid\"",
            "INT4OID",
            "-1",
            "0"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 11",
            "\"virtualtransaction\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 10",
            "\"objsubid\"",
            "INT2OID",
            "-1",
            "0"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 9",
            "\"objid\"",
            "OIDOID",
            "-1",
            "0"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 8",
            "\"classid\"",
            "OIDOID",
            "-1",
            "0"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 7",
            "\"transactionid\"",
            "XIDOID",
            "-1",
            "0"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 6",
            "\"virtualxid\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 5",
            "\"tuple\"",
            "INT2OID",
            "-1",
            "0"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 4",
            "\"page\"",
            "INT4OID",
            "-1",
            "0"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 3",
            "\"relation\"",
            "OIDOID",
            "-1",
            "0"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 2",
            "\"database\"",
            "OIDOID",
            "-1",
            "0"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 1",
            "\"locktype\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "NUM_LOCK_STATUS_COLUMNS",
            "false"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\n#define NUM_LOCK_STATUS_COLUMNS\t\t15\n\nconst char *const LockTagTypeNames[] = {\n\t\"relation\",\n\t\"extend\",\n\t\"page\",\n\t\"tuple\",\n\t\"transactionid\",\n\t\"virtualxid\",\n\t\"speculative token\",\n\t\"object\",\n\t\"userlock\",\n\t\"advisory\"\n};\nstatic const char *const PredicateLockTagTypeNames[] = {\n\t\"relation\",\n\t\"page\",\n\t\"tuple\"\n};\n\nDatum\npg_lock_status(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tPG_Lock_Status *mystatus;\n\tLockData   *lockData;\n\tPredicateLockData *predLockData;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\t\tMemoryContext oldcontext;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* build tupdesc for result tuples */\n\t\t/* this had better match function's declaration in pg_proc.h */\n\t\ttupdesc = CreateTemplateTupleDesc(NUM_LOCK_STATUS_COLUMNS, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"locktype\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"database\",\n\t\t\t\t\t\t   OIDOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"relation\",\n\t\t\t\t\t\t   OIDOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"page\",\n\t\t\t\t\t\t   INT4OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 5, \"tuple\",\n\t\t\t\t\t\t   INT2OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 6, \"virtualxid\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 7, \"transactionid\",\n\t\t\t\t\t\t   XIDOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 8, \"classid\",\n\t\t\t\t\t\t   OIDOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 9, \"objid\",\n\t\t\t\t\t\t   OIDOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 10, \"objsubid\",\n\t\t\t\t\t\t   INT2OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 11, \"virtualtransaction\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 12, \"pid\",\n\t\t\t\t\t\t   INT4OID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 13, \"mode\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 14, \"granted\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 15, \"fastpath\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\n\t\t/*\n\t\t * Collect all the locking information that we will format and send\n\t\t * out as a result set.\n\t\t */\n\t\tmystatus = (PG_Lock_Status *) palloc(sizeof(PG_Lock_Status));\n\t\tfuncctx->user_fctx = (void *) mystatus;\n\n\t\tmystatus->lockData = GetLockStatusData();\n\t\tmystatus->currIdx = 0;\n\t\tmystatus->predLockData = GetPredicateLockStatusData();\n\t\tmystatus->predLockIdx = 0;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tmystatus = (PG_Lock_Status *) funcctx->user_fctx;\n\tlockData = mystatus->lockData;\n\n\twhile (mystatus->currIdx < lockData->nelements)\n\t{\n\t\tbool\t\tgranted;\n\t\tLOCKMODE\tmode = 0;\n\t\tconst char *locktypename;\n\t\tchar\t\ttnbuf[32];\n\t\tDatum\t\tvalues[NUM_LOCK_STATUS_COLUMNS];\n\t\tbool\t\tnulls[NUM_LOCK_STATUS_COLUMNS];\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\tresult;\n\t\tLockInstanceData *instance;\n\n\t\tinstance = &(lockData->locks[mystatus->currIdx]);\n\n\t\t/*\n\t\t * Look to see if there are any held lock modes in this PROCLOCK. If\n\t\t * so, report, and destructively modify lockData so we don't report\n\t\t * again.\n\t\t */\n\t\tgranted = false;\n\t\tif (instance->holdMask)\n\t\t{\n\t\t\tfor (mode = 0; mode < MAX_LOCKMODES; mode++)\n\t\t\t{\n\t\t\t\tif (instance->holdMask & LOCKBIT_ON(mode))\n\t\t\t\t{\n\t\t\t\t\tgranted = true;\n\t\t\t\t\tinstance->holdMask &= LOCKBIT_OFF(mode);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If no (more) held modes to report, see if PROC is waiting for a\n\t\t * lock on this lock.\n\t\t */\n\t\tif (!granted)\n\t\t{\n\t\t\tif (instance->waitLockMode != NoLock)\n\t\t\t{\n\t\t\t\t/* Yes, so report it with proper mode */\n\t\t\t\tmode = instance->waitLockMode;\n\n\t\t\t\t/*\n\t\t\t\t * We are now done with this PROCLOCK, so advance pointer to\n\t\t\t\t * continue with next one on next call.\n\t\t\t\t */\n\t\t\t\tmystatus->currIdx++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Okay, we've displayed all the locks associated with this\n\t\t\t\t * PROCLOCK, proceed to the next one.\n\t\t\t\t */\n\t\t\t\tmystatus->currIdx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Form tuple with appropriate data.\n\t\t */\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\n\t\tif (instance->locktag.locktag_type <= LOCKTAG_LAST_TYPE)\n\t\t\tlocktypename = LockTagTypeNames[instance->locktag.locktag_type];\n\t\telse\n\t\t{\n\t\t\tsnprintf(tnbuf, sizeof(tnbuf), \"unknown %d\",\n\t\t\t\t\t (int) instance->locktag.locktag_type);\n\t\t\tlocktypename = tnbuf;\n\t\t}\n\t\tvalues[0] = CStringGetTextDatum(locktypename);\n\n\t\tswitch ((LockTagType) instance->locktag.locktag_type)\n\t\t{\n\t\t\tcase LOCKTAG_RELATION:\n\t\t\tcase LOCKTAG_RELATION_EXTEND:\n\t\t\t\tvalues[1] = ObjectIdGetDatum(instance->locktag.locktag_field1);\n\t\t\t\tvalues[2] = ObjectIdGetDatum(instance->locktag.locktag_field2);\n\t\t\t\tnulls[3] = true;\n\t\t\t\tnulls[4] = true;\n\t\t\t\tnulls[5] = true;\n\t\t\t\tnulls[6] = true;\n\t\t\t\tnulls[7] = true;\n\t\t\t\tnulls[8] = true;\n\t\t\t\tnulls[9] = true;\n\t\t\t\tbreak;\n\t\t\tcase LOCKTAG_PAGE:\n\t\t\t\tvalues[1] = ObjectIdGetDatum(instance->locktag.locktag_field1);\n\t\t\t\tvalues[2] = ObjectIdGetDatum(instance->locktag.locktag_field2);\n\t\t\t\tvalues[3] = UInt32GetDatum(instance->locktag.locktag_field3);\n\t\t\t\tnulls[4] = true;\n\t\t\t\tnulls[5] = true;\n\t\t\t\tnulls[6] = true;\n\t\t\t\tnulls[7] = true;\n\t\t\t\tnulls[8] = true;\n\t\t\t\tnulls[9] = true;\n\t\t\t\tbreak;\n\t\t\tcase LOCKTAG_TUPLE:\n\t\t\t\tvalues[1] = ObjectIdGetDatum(instance->locktag.locktag_field1);\n\t\t\t\tvalues[2] = ObjectIdGetDatum(instance->locktag.locktag_field2);\n\t\t\t\tvalues[3] = UInt32GetDatum(instance->locktag.locktag_field3);\n\t\t\t\tvalues[4] = UInt16GetDatum(instance->locktag.locktag_field4);\n\t\t\t\tnulls[5] = true;\n\t\t\t\tnulls[6] = true;\n\t\t\t\tnulls[7] = true;\n\t\t\t\tnulls[8] = true;\n\t\t\t\tnulls[9] = true;\n\t\t\t\tbreak;\n\t\t\tcase LOCKTAG_TRANSACTION:\n\t\t\t\tvalues[6] =\n\t\t\t\t\tTransactionIdGetDatum(instance->locktag.locktag_field1);\n\t\t\t\tnulls[1] = true;\n\t\t\t\tnulls[2] = true;\n\t\t\t\tnulls[3] = true;\n\t\t\t\tnulls[4] = true;\n\t\t\t\tnulls[5] = true;\n\t\t\t\tnulls[7] = true;\n\t\t\t\tnulls[8] = true;\n\t\t\t\tnulls[9] = true;\n\t\t\t\tbreak;\n\t\t\tcase LOCKTAG_VIRTUALTRANSACTION:\n\t\t\t\tvalues[5] = VXIDGetDatum(instance->locktag.locktag_field1,\n\t\t\t\t\t\t\t\t\t\t instance->locktag.locktag_field2);\n\t\t\t\tnulls[1] = true;\n\t\t\t\tnulls[2] = true;\n\t\t\t\tnulls[3] = true;\n\t\t\t\tnulls[4] = true;\n\t\t\t\tnulls[6] = true;\n\t\t\t\tnulls[7] = true;\n\t\t\t\tnulls[8] = true;\n\t\t\t\tnulls[9] = true;\n\t\t\t\tbreak;\n\t\t\tcase LOCKTAG_OBJECT:\n\t\t\tcase LOCKTAG_USERLOCK:\n\t\t\tcase LOCKTAG_ADVISORY:\n\t\t\tdefault:\t\t\t/* treat unknown locktags like OBJECT */\n\t\t\t\tvalues[1] = ObjectIdGetDatum(instance->locktag.locktag_field1);\n\t\t\t\tvalues[7] = ObjectIdGetDatum(instance->locktag.locktag_field2);\n\t\t\t\tvalues[8] = ObjectIdGetDatum(instance->locktag.locktag_field3);\n\t\t\t\tvalues[9] = Int16GetDatum(instance->locktag.locktag_field4);\n\t\t\t\tnulls[2] = true;\n\t\t\t\tnulls[3] = true;\n\t\t\t\tnulls[4] = true;\n\t\t\t\tnulls[5] = true;\n\t\t\t\tnulls[6] = true;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvalues[10] = VXIDGetDatum(instance->backend, instance->lxid);\n\t\tif (instance->pid != 0)\n\t\t\tvalues[11] = Int32GetDatum(instance->pid);\n\t\telse\n\t\t\tnulls[11] = true;\n\t\tvalues[12] = CStringGetTextDatum(GetLockmodeName(instance->locktag.locktag_lockmethodid, mode));\n\t\tvalues[13] = BoolGetDatum(granted);\n\t\tvalues[14] = BoolGetDatum(instance->fastpath);\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tresult = HeapTupleGetDatum(tuple);\n\t\tSRF_RETURN_NEXT(funcctx, result);\n\t}\n\n\t/*\n\t * Have returned all regular locks. Now start on the SIREAD predicate\n\t * locks.\n\t */\n\tpredLockData = mystatus->predLockData;\n\tif (mystatus->predLockIdx < predLockData->nelements)\n\t{\n\t\tPredicateLockTargetType lockType;\n\n\t\tPREDICATELOCKTARGETTAG *predTag = &(predLockData->locktags[mystatus->predLockIdx]);\n\t\tSERIALIZABLEXACT *xact = &(predLockData->xacts[mystatus->predLockIdx]);\n\t\tDatum\t\tvalues[NUM_LOCK_STATUS_COLUMNS];\n\t\tbool\t\tnulls[NUM_LOCK_STATUS_COLUMNS];\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\tresult;\n\n\t\tmystatus->predLockIdx++;\n\n\t\t/*\n\t\t * Form tuple with appropriate data.\n\t\t */\n\t\tMemSet(values, 0, sizeof(values));\n\t\tMemSet(nulls, false, sizeof(nulls));\n\n\t\t/* lock type */\n\t\tlockType = GET_PREDICATELOCKTARGETTAG_TYPE(*predTag);\n\n\t\tvalues[0] = CStringGetTextDatum(PredicateLockTagTypeNames[lockType]);\n\n\t\t/* lock target */\n\t\tvalues[1] = GET_PREDICATELOCKTARGETTAG_DB(*predTag);\n\t\tvalues[2] = GET_PREDICATELOCKTARGETTAG_RELATION(*predTag);\n\t\tif (lockType == PREDLOCKTAG_TUPLE)\n\t\t\tvalues[4] = GET_PREDICATELOCKTARGETTAG_OFFSET(*predTag);\n\t\telse\n\t\t\tnulls[4] = true;\n\t\tif ((lockType == PREDLOCKTAG_TUPLE) ||\n\t\t\t(lockType == PREDLOCKTAG_PAGE))\n\t\t\tvalues[3] = GET_PREDICATELOCKTARGETTAG_PAGE(*predTag);\n\t\telse\n\t\t\tnulls[3] = true;\n\n\t\t/* these fields are targets for other types of locks */\n\t\tnulls[5] = true;\t\t/* virtualxid */\n\t\tnulls[6] = true;\t\t/* transactionid */\n\t\tnulls[7] = true;\t\t/* classid */\n\t\tnulls[8] = true;\t\t/* objid */\n\t\tnulls[9] = true;\t\t/* objsubid */\n\n\t\t/* lock holder */\n\t\tvalues[10] = VXIDGetDatum(xact->vxid.backendId,\n\t\t\t\t\t\t\t\t  xact->vxid.localTransactionId);\n\t\tif (xact->pid != 0)\n\t\t\tvalues[11] = Int32GetDatum(xact->pid);\n\t\telse\n\t\t\tnulls[11] = true;\n\n\t\t/*\n\t\t * Lock mode. Currently all predicate locks are SIReadLocks, which are\n\t\t * always held (never waiting) and have no fast path\n\t\t */\n\t\tvalues[12] = CStringGetTextDatum(\"SIReadLock\");\n\t\tvalues[13] = BoolGetDatum(true);\n\t\tvalues[14] = BoolGetDatum(false);\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tresult = HeapTupleGetDatum(tuple);\n\t\tSRF_RETURN_NEXT(funcctx, result);\n\t}\n\n\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "VXIDGetDatum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/lockfuncs.c",
    "lines": "63-75",
    "snippet": "static Datum\nVXIDGetDatum(BackendId bid, LocalTransactionId lxid)\n{\n\t/*\n\t * The representation is \"<bid>/<lxid>\", decimal and unsigned decimal\n\t * respectively.  Note that elog.c also knows how to format a vxid.\n\t */\n\tchar\t\tvxidstr[32];\n\n\tsnprintf(vxidstr, sizeof(vxidstr), \"%d/%u\", bid, lxid);\n\n\treturn CStringGetTextDatum(vxidstr);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/predicate_internals.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CStringGetTextDatum",
          "args": [
            "vxidstr"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "vxidstr",
            "sizeof(vxidstr)",
            "\"%d/%u\"",
            "bid",
            "lxid"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/predicate_internals.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic Datum\nVXIDGetDatum(BackendId bid, LocalTransactionId lxid)\n{\n\t/*\n\t * The representation is \"<bid>/<lxid>\", decimal and unsigned decimal\n\t * respectively.  Note that elog.c also knows how to format a vxid.\n\t */\n\tchar\t\tvxidstr[32];\n\n\tsnprintf(vxidstr, sizeof(vxidstr), \"%d/%u\", bid, lxid);\n\n\treturn CStringGetTextDatum(vxidstr);\n}"
  }
]