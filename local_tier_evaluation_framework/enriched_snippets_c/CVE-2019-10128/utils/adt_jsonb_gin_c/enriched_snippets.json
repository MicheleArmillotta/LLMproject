[
  {
    "function_name": "make_scalar_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "566-612",
    "snippet": "static Datum\nmake_scalar_key(const JsonbValue *scalarVal, bool is_key)\n{\n\tDatum\t\titem;\n\tchar\t   *cstr;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\tAssert(!is_key);\n\t\t\titem = make_text_key(JGINFLAG_NULL, \"\", 0);\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tAssert(!is_key);\n\t\t\titem = make_text_key(JGINFLAG_BOOL,\n\t\t\t\t\t\t\t\t scalarVal->val.boolean ? \"t\" : \"f\", 1);\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\tAssert(!is_key);\n\n\t\t\t/*\n\t\t\t * A normalized textual representation, free of trailing zeroes,\n\t\t\t * is required so that numerically equal values will produce equal\n\t\t\t * strings.\n\t\t\t *\n\t\t\t * It isn't ideal that numerics are stored in a relatively bulky\n\t\t\t * textual format.  However, it's a notationally convenient way of\n\t\t\t * storing a \"union\" type in the GIN B-Tree, and indexing Jsonb\n\t\t\t * strings takes precedence.\n\t\t\t */\n\t\t\tcstr = numeric_normalize(scalarVal->val.numeric);\n\t\t\titem = make_text_key(JGINFLAG_NUM, cstr, strlen(cstr));\n\t\t\tpfree(cstr);\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\titem = make_text_key(is_key ? JGINFLAG_KEY : JGINFLAG_STR,\n\t\t\t\t\t\t\t\t scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t scalarVal->val.string.len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb scalar type: %d\", scalarVal->type);\n\t\t\titem = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn item;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum make_text_key(char flag, const char *str, int len);",
      "static Datum make_scalar_key(const JsonbValue *scalarVal, bool is_key);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized jsonb scalar type: %d\"",
            "scalarVal->type"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_text_key",
          "args": [
            "is_key ? JGINFLAG_KEY : JGINFLAG_STR",
            "scalarVal->val.string.val",
            "scalarVal->val.string.len"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "make_text_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
          "lines": "528-558",
          "snippet": "static Datum\nmake_text_key(char flag, const char *str, int len)\n{\n\ttext\t   *item;\n\tchar\t\thashbuf[10];\n\n\tif (len > JGIN_MAXLENGTH)\n\t{\n\t\tuint32\t\thashval;\n\n\t\thashval = DatumGetUInt32(hash_any((const unsigned char *) str, len));\n\t\tsnprintf(hashbuf, sizeof(hashbuf), \"%08x\", hashval);\n\t\tstr = hashbuf;\n\t\tlen = 8;\n\t\tflag |= JGINFLAG_HASHED;\n\t}\n\n\t/*\n\t * Now build the text Datum.  For simplicity we build a 4-byte-header\n\t * varlena text Datum here, but we expect it will get converted to short\n\t * header format when stored in the index.\n\t */\n\titem = (text *) palloc(VARHDRSZ + len + 1);\n\tSET_VARSIZE(item, VARHDRSZ + len + 1);\n\n\t*VARDATA(item) = flag;\n\n\tmemcpy(VARDATA(item) + 1, str, len);\n\n\treturn PointerGetDatum(item);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/gin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum make_text_key(char flag, const char *str, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic Datum make_text_key(char flag, const char *str, int len);\n\nstatic Datum\nmake_text_key(char flag, const char *str, int len)\n{\n\ttext\t   *item;\n\tchar\t\thashbuf[10];\n\n\tif (len > JGIN_MAXLENGTH)\n\t{\n\t\tuint32\t\thashval;\n\n\t\thashval = DatumGetUInt32(hash_any((const unsigned char *) str, len));\n\t\tsnprintf(hashbuf, sizeof(hashbuf), \"%08x\", hashval);\n\t\tstr = hashbuf;\n\t\tlen = 8;\n\t\tflag |= JGINFLAG_HASHED;\n\t}\n\n\t/*\n\t * Now build the text Datum.  For simplicity we build a 4-byte-header\n\t * varlena text Datum here, but we expect it will get converted to short\n\t * header format when stored in the index.\n\t */\n\titem = (text *) palloc(VARHDRSZ + len + 1);\n\tSET_VARSIZE(item, VARHDRSZ + len + 1);\n\n\t*VARDATA(item) = flag;\n\n\tmemcpy(VARDATA(item) + 1, str, len);\n\n\treturn PointerGetDatum(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "cstr"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cstr"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "numeric_normalize",
          "args": [
            "scalarVal->val.numeric"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "numeric_normalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/numeric.c",
          "lines": "756-793",
          "snippet": "char *\nnumeric_normalize(Numeric num)\n{\n\tNumericVar\tx;\n\tchar\t   *str;\n\tint\t\t\tlast;\n\n\t/*\n\t * Handle NaN\n\t */\n\tif (NUMERIC_IS_NAN(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tinit_var_from_num(num, &x);\n\n\tstr = get_str_from_var(&x);\n\n\t/* If there's no decimal point, there's certainly nothing to remove. */\n\tif (strchr(str, '.') != NULL)\n\t{\n\t\t/*\n\t\t * Back up over trailing fractional zeroes.  Since there is a decimal\n\t\t * point, this loop will terminate safely.\n\t\t */\n\t\tlast = strlen(str) - 1;\n\t\twhile (str[last] == '0')\n\t\t\tlast--;\n\n\t\t/* We want to get rid of the decimal point too, if it's now last. */\n\t\tif (str[last] == '.')\n\t\t\tlast--;\n\n\t\t/* Delete whatever we backed up over. */\n\t\tstr[last + 1] = '\\0';\n\t}\n\n\treturn str;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double numeric_to_double_no_overflow(Numeric num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"funcapi.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic double numeric_to_double_no_overflow(Numeric num);\n\nchar *\nnumeric_normalize(Numeric num)\n{\n\tNumericVar\tx;\n\tchar\t   *str;\n\tint\t\t\tlast;\n\n\t/*\n\t * Handle NaN\n\t */\n\tif (NUMERIC_IS_NAN(num))\n\t\treturn pstrdup(\"NaN\");\n\n\tinit_var_from_num(num, &x);\n\n\tstr = get_str_from_var(&x);\n\n\t/* If there's no decimal point, there's certainly nothing to remove. */\n\tif (strchr(str, '.') != NULL)\n\t{\n\t\t/*\n\t\t * Back up over trailing fractional zeroes.  Since there is a decimal\n\t\t * point, this loop will terminate safely.\n\t\t */\n\t\tlast = strlen(str) - 1;\n\t\twhile (str[last] == '0')\n\t\t\tlast--;\n\n\t\t/* We want to get rid of the decimal point too, if it's now last. */\n\t\tif (str[last] == '.')\n\t\t\tlast--;\n\n\t\t/* Delete whatever we backed up over. */\n\t\tstr[last + 1] = '\\0';\n\t}\n\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!is_key"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!is_key"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!is_key"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic Datum make_text_key(char flag, const char *str, int len);\nstatic Datum make_scalar_key(const JsonbValue *scalarVal, bool is_key);\n\nstatic Datum\nmake_scalar_key(const JsonbValue *scalarVal, bool is_key)\n{\n\tDatum\t\titem;\n\tchar\t   *cstr;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\tAssert(!is_key);\n\t\t\titem = make_text_key(JGINFLAG_NULL, \"\", 0);\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tAssert(!is_key);\n\t\t\titem = make_text_key(JGINFLAG_BOOL,\n\t\t\t\t\t\t\t\t scalarVal->val.boolean ? \"t\" : \"f\", 1);\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\tAssert(!is_key);\n\n\t\t\t/*\n\t\t\t * A normalized textual representation, free of trailing zeroes,\n\t\t\t * is required so that numerically equal values will produce equal\n\t\t\t * strings.\n\t\t\t *\n\t\t\t * It isn't ideal that numerics are stored in a relatively bulky\n\t\t\t * textual format.  However, it's a notationally convenient way of\n\t\t\t * storing a \"union\" type in the GIN B-Tree, and indexing Jsonb\n\t\t\t * strings takes precedence.\n\t\t\t */\n\t\t\tcstr = numeric_normalize(scalarVal->val.numeric);\n\t\t\titem = make_text_key(JGINFLAG_NUM, cstr, strlen(cstr));\n\t\t\tpfree(cstr);\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\titem = make_text_key(is_key ? JGINFLAG_KEY : JGINFLAG_STR,\n\t\t\t\t\t\t\t\t scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t scalarVal->val.string.len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb scalar type: %d\", scalarVal->type);\n\t\t\titem = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn item;\n}"
  },
  {
    "function_name": "make_text_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "528-558",
    "snippet": "static Datum\nmake_text_key(char flag, const char *str, int len)\n{\n\ttext\t   *item;\n\tchar\t\thashbuf[10];\n\n\tif (len > JGIN_MAXLENGTH)\n\t{\n\t\tuint32\t\thashval;\n\n\t\thashval = DatumGetUInt32(hash_any((const unsigned char *) str, len));\n\t\tsnprintf(hashbuf, sizeof(hashbuf), \"%08x\", hashval);\n\t\tstr = hashbuf;\n\t\tlen = 8;\n\t\tflag |= JGINFLAG_HASHED;\n\t}\n\n\t/*\n\t * Now build the text Datum.  For simplicity we build a 4-byte-header\n\t * varlena text Datum here, but we expect it will get converted to short\n\t * header format when stored in the index.\n\t */\n\titem = (text *) palloc(VARHDRSZ + len + 1);\n\tSET_VARSIZE(item, VARHDRSZ + len + 1);\n\n\t*VARDATA(item) = flag;\n\n\tmemcpy(VARDATA(item) + 1, str, len);\n\n\treturn PointerGetDatum(item);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum make_text_key(char flag, const char *str, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "item"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(item) + 1",
            "str",
            "len"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "item"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "item"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "item",
            "VARHDRSZ + len + 1"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + len + 1"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "hashbuf",
            "sizeof(hashbuf)",
            "\"%08x\"",
            "hashval"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "hash_any((const unsigned char *) str, len)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_any",
          "args": [
            "(const unsigned char *) str",
            "len"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic Datum make_text_key(char flag, const char *str, int len);\n\nstatic Datum\nmake_text_key(char flag, const char *str, int len)\n{\n\ttext\t   *item;\n\tchar\t\thashbuf[10];\n\n\tif (len > JGIN_MAXLENGTH)\n\t{\n\t\tuint32\t\thashval;\n\n\t\thashval = DatumGetUInt32(hash_any((const unsigned char *) str, len));\n\t\tsnprintf(hashbuf, sizeof(hashbuf), \"%08x\", hashval);\n\t\tstr = hashbuf;\n\t\tlen = 8;\n\t\tflag |= JGINFLAG_HASHED;\n\t}\n\n\t/*\n\t * Now build the text Datum.  For simplicity we build a 4-byte-header\n\t * varlena text Datum here, but we expect it will get converted to short\n\t * header format when stored in the index.\n\t */\n\titem = (text *) palloc(VARHDRSZ + len + 1);\n\tSET_VARSIZE(item, VARHDRSZ + len + 1);\n\n\t*VARDATA(item) = flag;\n\n\tmemcpy(VARDATA(item) + 1, str, len);\n\n\treturn PointerGetDatum(item);\n}"
  },
  {
    "function_name": "gin_triconsistent_jsonb_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "489-520",
    "snippet": "Datum\ngin_triconsistent_jsonb_path(PG_FUNCTION_ARGS)\n{\n\tGinTernaryValue *check = (GinTernaryValue *) PG_GETARG_POINTER(0);\n\tStrategyNumber strategy = PG_GETARG_UINT16(1);\n\n\t/* Jsonb\t   *query = PG_GETARG_JSONB_P(2); */\n\tint32\t\tnkeys = PG_GETARG_INT32(3);\n\n\t/* Pointer\t   *extra_data = (Pointer *) PG_GETARG_POINTER(4); */\n\tGinTernaryValue res = GIN_MAYBE;\n\tint32\t\ti;\n\n\tif (strategy != JsonbContainsStrategyNumber)\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\n\t/*\n\t * Note that we never return GIN_TRUE, only GIN_MAYBE or GIN_FALSE; this\n\t * corresponds to always forcing recheck in the regular consistent\n\t * function, for the reasons listed there.\n\t */\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tif (check[i] == GIN_FALSE)\n\t\t{\n\t\t\tres = GIN_FALSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tPG_RETURN_GIN_TERNARY_VALUE(res);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_GIN_TERNARY_VALUE",
          "args": [
            "res"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized strategy number: %d\"",
            "strategy"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_UINT16",
          "args": [
            "1"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_triconsistent_jsonb_path(PG_FUNCTION_ARGS)\n{\n\tGinTernaryValue *check = (GinTernaryValue *) PG_GETARG_POINTER(0);\n\tStrategyNumber strategy = PG_GETARG_UINT16(1);\n\n\t/* Jsonb\t   *query = PG_GETARG_JSONB_P(2); */\n\tint32\t\tnkeys = PG_GETARG_INT32(3);\n\n\t/* Pointer\t   *extra_data = (Pointer *) PG_GETARG_POINTER(4); */\n\tGinTernaryValue res = GIN_MAYBE;\n\tint32\t\ti;\n\n\tif (strategy != JsonbContainsStrategyNumber)\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\n\t/*\n\t * Note that we never return GIN_TRUE, only GIN_MAYBE or GIN_FALSE; this\n\t * corresponds to always forcing recheck in the regular consistent\n\t * function, for the reasons listed there.\n\t */\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tif (check[i] == GIN_FALSE)\n\t\t{\n\t\t\tres = GIN_FALSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tPG_RETURN_GIN_TERNARY_VALUE(res);\n}"
  },
  {
    "function_name": "gin_consistent_jsonb_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "451-487",
    "snippet": "Datum\ngin_consistent_jsonb_path(PG_FUNCTION_ARGS)\n{\n\tbool\t   *check = (bool *) PG_GETARG_POINTER(0);\n\tStrategyNumber strategy = PG_GETARG_UINT16(1);\n\n\t/* Jsonb\t   *query = PG_GETARG_JSONB_P(2); */\n\tint32\t\tnkeys = PG_GETARG_INT32(3);\n\n\t/* Pointer\t   *extra_data = (Pointer *) PG_GETARG_POINTER(4); */\n\tbool\t   *recheck = (bool *) PG_GETARG_POINTER(5);\n\tbool\t\tres = true;\n\tint32\t\ti;\n\n\tif (strategy != JsonbContainsStrategyNumber)\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\n\t/*\n\t * jsonb_path_ops is necessarily lossy, not only because of hash\n\t * collisions but also because it doesn't preserve complete information\n\t * about the structure of the JSON object.  Besides, there are some\n\t * special rules around the containment of raw scalars in arrays that are\n\t * not handled here.  So we must always recheck a match.  However, if not\n\t * all of the keys are present, the tuple certainly doesn't match.\n\t */\n\t*recheck = true;\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tif (!check[i])\n\t\t{\n\t\t\tres = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized strategy number: %d\"",
            "strategy"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "5"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_UINT16",
          "args": [
            "1"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_consistent_jsonb_path(PG_FUNCTION_ARGS)\n{\n\tbool\t   *check = (bool *) PG_GETARG_POINTER(0);\n\tStrategyNumber strategy = PG_GETARG_UINT16(1);\n\n\t/* Jsonb\t   *query = PG_GETARG_JSONB_P(2); */\n\tint32\t\tnkeys = PG_GETARG_INT32(3);\n\n\t/* Pointer\t   *extra_data = (Pointer *) PG_GETARG_POINTER(4); */\n\tbool\t   *recheck = (bool *) PG_GETARG_POINTER(5);\n\tbool\t\tres = true;\n\tint32\t\ti;\n\n\tif (strategy != JsonbContainsStrategyNumber)\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\n\t/*\n\t * jsonb_path_ops is necessarily lossy, not only because of hash\n\t * collisions but also because it doesn't preserve complete information\n\t * about the structure of the JSON object.  Besides, there are some\n\t * special rules around the containment of raw scalars in arrays that are\n\t * not handled here.  So we must always recheck a match.  However, if not\n\t * all of the keys are present, the tuple certainly doesn't match.\n\t */\n\t*recheck = true;\n\tfor (i = 0; i < nkeys; i++)\n\t{\n\t\tif (!check[i])\n\t\t{\n\t\t\tres = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "gin_extract_jsonb_query_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "427-449",
    "snippet": "Datum\ngin_extract_jsonb_query_path(PG_FUNCTION_ARGS)\n{\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\tStrategyNumber strategy = PG_GETARG_UINT16(2);\n\tint32\t   *searchMode = (int32 *) PG_GETARG_POINTER(6);\n\tDatum\t   *entries;\n\n\tif (strategy != JsonbContainsStrategyNumber)\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\n\t/* Query is a jsonb, so just apply gin_extract_jsonb_path ... */\n\tentries = (Datum *)\n\t\tDatumGetPointer(DirectFunctionCall2(gin_extract_jsonb_path,\n\t\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(nentries)));\n\n\t/* ... although \"contains {}\" requires a full index scan */\n\tif (*nentries == 0)\n\t\t*searchMode = GIN_SEARCH_MODE_ALL;\n\n\tPG_RETURN_POINTER(entries);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "entries"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "DirectFunctionCall2(gin_extract_jsonb_path,\n\t\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(nentries))"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "gin_extract_jsonb_path",
            "PG_GETARG_DATUM(0)",
            "PointerGetDatum(nentries)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "nentries"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized strategy number: %d\"",
            "strategy"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "6"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_UINT16",
          "args": [
            "2"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_extract_jsonb_query_path(PG_FUNCTION_ARGS)\n{\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\tStrategyNumber strategy = PG_GETARG_UINT16(2);\n\tint32\t   *searchMode = (int32 *) PG_GETARG_POINTER(6);\n\tDatum\t   *entries;\n\n\tif (strategy != JsonbContainsStrategyNumber)\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\n\t/* Query is a jsonb, so just apply gin_extract_jsonb_path ... */\n\tentries = (Datum *)\n\t\tDatumGetPointer(DirectFunctionCall2(gin_extract_jsonb_path,\n\t\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(nentries)));\n\n\t/* ... although \"contains {}\" requires a full index scan */\n\tif (*nentries == 0)\n\t\t*searchMode = GIN_SEARCH_MODE_ALL;\n\n\tPG_RETURN_POINTER(entries);\n}"
  },
  {
    "function_name": "gin_extract_jsonb_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "329-425",
    "snippet": "Datum\ngin_extract_jsonb_path(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\tint\t\t\ttotal = 2 * JB_ROOT_COUNT(jb);\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tPathHashStack tail;\n\tPathHashStack *stack;\n\tint\t\t\ti = 0;\n\tDatum\t   *entries;\n\n\t/* If the root level is empty, we certainly have no keys */\n\tif (total == 0)\n\t{\n\t\t*nentries = 0;\n\t\tPG_RETURN_POINTER(NULL);\n\t}\n\n\t/* Otherwise, use 2 * root count as initial estimate of result size */\n\tentries = (Datum *) palloc(sizeof(Datum) * total);\n\n\t/* We keep a stack of partial hashes corresponding to parent key levels */\n\ttail.parent = NULL;\n\ttail.hash = 0;\n\tstack = &tail;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tPathHashStack *parent;\n\n\t\t/* Since we recurse into the object, we might need more space */\n\t\tif (i >= total)\n\t\t{\n\t\t\ttotal *= 2;\n\t\t\tentries = (Datum *) repalloc(entries, sizeof(Datum) * total);\n\t\t}\n\n\t\tswitch (r)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\t/* Push a stack level for this object */\n\t\t\t\tparent = stack;\n\t\t\t\tstack = (PathHashStack *) palloc(sizeof(PathHashStack));\n\n\t\t\t\t/*\n\t\t\t\t * We pass forward hashes from outer nesting levels so that\n\t\t\t\t * the hashes for nested values will include outer keys as\n\t\t\t\t * well as their own keys.\n\t\t\t\t *\n\t\t\t\t * Nesting an array within another array will not alter\n\t\t\t\t * innermost scalar element hash values, but that seems\n\t\t\t\t * inconsequential.\n\t\t\t\t */\n\t\t\t\tstack->hash = parent->hash;\n\t\t\t\tstack->parent = parent;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\t\t/* mix this key into the current outer hash */\n\t\t\t\tJsonbHashScalarValue(&v, &stack->hash);\n\t\t\t\t/* hash is now ready to incorporate the value */\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\tcase WJB_VALUE:\n\t\t\t\t/* mix the element or value's hash into the prepared hash */\n\t\t\t\tJsonbHashScalarValue(&v, &stack->hash);\n\t\t\t\t/* and emit an index entry */\n\t\t\t\tentries[i++] = UInt32GetDatum(stack->hash);\n\t\t\t\t/* reset hash for next key, value, or sub-object */\n\t\t\t\tstack->hash = stack->parent->hash;\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\t/* Pop the stack */\n\t\t\t\tparent = stack->parent;\n\t\t\t\tpfree(stack);\n\t\t\t\tstack = parent;\n\t\t\t\t/* reset hash for next key, value, or sub-object */\n\t\t\t\tif (stack->parent)\n\t\t\t\t\tstack->hash = stack->parent->hash;\n\t\t\t\telse\n\t\t\t\t\tstack->hash = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid JsonbIteratorNext rc: %d\", (int) r);\n\t\t}\n\t}\n\n\t*nentries = i;\n\n\tPG_RETURN_POINTER(entries);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "entries"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid JsonbIteratorNext rc: %d\"",
            "(int) r"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "stack"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UInt32GetDatum",
          "args": [
            "stack->hash"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbHashScalarValue",
          "args": [
            "&v",
            "&stack->hash"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbHashScalarValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1213-1250",
          "snippet": "void\nJsonbHashScalarValue(const JsonbValue *scalarVal, uint32 *hash)\n{\n\tuint32\t\ttmp;\n\n\t/* Compute hash value for scalarVal */\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\ttmp = 0x01;\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\ttmp = DatumGetUInt32(hash_any((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t  scalarVal->val.string.len));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\t/* Must hash equal numerics to equal hash codes */\n\t\t\ttmp = DatumGetUInt32(DirectFunctionCall1(hash_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric)));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\ttmp = scalarVal->val.boolean ? 0x02 : 0x04;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t\ttmp = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Combine hash values of successive keys, values and elements by rotating\n\t * the previous value left 1 bit, then XOR'ing in the new\n\t * key/value/element's hash value.\n\t */\n\t*hash = (*hash << 1) | (*hash >> 31);\n\t*hash ^= tmp;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nvoid\nJsonbHashScalarValue(const JsonbValue *scalarVal, uint32 *hash)\n{\n\tuint32\t\ttmp;\n\n\t/* Compute hash value for scalarVal */\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\ttmp = 0x01;\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\ttmp = DatumGetUInt32(hash_any((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t  scalarVal->val.string.len));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\t/* Must hash equal numerics to equal hash codes */\n\t\t\ttmp = DatumGetUInt32(DirectFunctionCall1(hash_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric)));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\ttmp = scalarVal->val.boolean ? 0x02 : 0x04;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t\ttmp = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Combine hash values of successive keys, values and elements by rotating\n\t * the previous value left 1 bit, then XOR'ing in the new\n\t * key/value/element's hash value.\n\t */\n\t*hash = (*hash << 1) | (*hash >> 31);\n\t*hash ^= tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(PathHashStack)"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "entries",
            "sizeof(Datum) * total"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "NULL"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "jb"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_extract_jsonb_path(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\tint\t\t\ttotal = 2 * JB_ROOT_COUNT(jb);\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tPathHashStack tail;\n\tPathHashStack *stack;\n\tint\t\t\ti = 0;\n\tDatum\t   *entries;\n\n\t/* If the root level is empty, we certainly have no keys */\n\tif (total == 0)\n\t{\n\t\t*nentries = 0;\n\t\tPG_RETURN_POINTER(NULL);\n\t}\n\n\t/* Otherwise, use 2 * root count as initial estimate of result size */\n\tentries = (Datum *) palloc(sizeof(Datum) * total);\n\n\t/* We keep a stack of partial hashes corresponding to parent key levels */\n\ttail.parent = NULL;\n\ttail.hash = 0;\n\tstack = &tail;\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tPathHashStack *parent;\n\n\t\t/* Since we recurse into the object, we might need more space */\n\t\tif (i >= total)\n\t\t{\n\t\t\ttotal *= 2;\n\t\t\tentries = (Datum *) repalloc(entries, sizeof(Datum) * total);\n\t\t}\n\n\t\tswitch (r)\n\t\t{\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\t/* Push a stack level for this object */\n\t\t\t\tparent = stack;\n\t\t\t\tstack = (PathHashStack *) palloc(sizeof(PathHashStack));\n\n\t\t\t\t/*\n\t\t\t\t * We pass forward hashes from outer nesting levels so that\n\t\t\t\t * the hashes for nested values will include outer keys as\n\t\t\t\t * well as their own keys.\n\t\t\t\t *\n\t\t\t\t * Nesting an array within another array will not alter\n\t\t\t\t * innermost scalar element hash values, but that seems\n\t\t\t\t * inconsequential.\n\t\t\t\t */\n\t\t\t\tstack->hash = parent->hash;\n\t\t\t\tstack->parent = parent;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\t\t/* mix this key into the current outer hash */\n\t\t\t\tJsonbHashScalarValue(&v, &stack->hash);\n\t\t\t\t/* hash is now ready to incorporate the value */\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\tcase WJB_VALUE:\n\t\t\t\t/* mix the element or value's hash into the prepared hash */\n\t\t\t\tJsonbHashScalarValue(&v, &stack->hash);\n\t\t\t\t/* and emit an index entry */\n\t\t\t\tentries[i++] = UInt32GetDatum(stack->hash);\n\t\t\t\t/* reset hash for next key, value, or sub-object */\n\t\t\t\tstack->hash = stack->parent->hash;\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\t/* Pop the stack */\n\t\t\t\tparent = stack->parent;\n\t\t\t\tpfree(stack);\n\t\t\t\tstack = parent;\n\t\t\t\t/* reset hash for next key, value, or sub-object */\n\t\t\t\tif (stack->parent)\n\t\t\t\t\tstack->hash = stack->parent->hash;\n\t\t\t\telse\n\t\t\t\t\tstack->hash = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid JsonbIteratorNext rc: %d\", (int) r);\n\t\t}\n\t}\n\n\t*nentries = i;\n\n\tPG_RETURN_POINTER(entries);\n}"
  },
  {
    "function_name": "gin_triconsistent_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "265-315",
    "snippet": "Datum\ngin_triconsistent_jsonb(PG_FUNCTION_ARGS)\n{\n\tGinTernaryValue *check = (GinTernaryValue *) PG_GETARG_POINTER(0);\n\tStrategyNumber strategy = PG_GETARG_UINT16(1);\n\n\t/* Jsonb\t   *query = PG_GETARG_JSONB_P(2); */\n\tint32\t\tnkeys = PG_GETARG_INT32(3);\n\n\t/* Pointer\t   *extra_data = (Pointer *) PG_GETARG_POINTER(4); */\n\tGinTernaryValue res = GIN_MAYBE;\n\tint32\t\ti;\n\n\t/*\n\t * Note that we never return GIN_TRUE, only GIN_MAYBE or GIN_FALSE; this\n\t * corresponds to always forcing recheck in the regular consistent\n\t * function, for the reasons listed there.\n\t */\n\tif (strategy == JsonbContainsStrategyNumber ||\n\t\tstrategy == JsonbExistsAllStrategyNumber)\n\t{\n\t\t/* All extracted keys must be present */\n\t\tfor (i = 0; i < nkeys; i++)\n\t\t{\n\t\t\tif (check[i] == GIN_FALSE)\n\t\t\t{\n\t\t\t\tres = GIN_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse if (strategy == JsonbExistsStrategyNumber ||\n\t\t\t strategy == JsonbExistsAnyStrategyNumber)\n\t{\n\t\t/* At least one extracted key must be present */\n\t\tres = GIN_FALSE;\n\t\tfor (i = 0; i < nkeys; i++)\n\t\t{\n\t\t\tif (check[i] == GIN_TRUE ||\n\t\t\t\tcheck[i] == GIN_MAYBE)\n\t\t\t{\n\t\t\t\tres = GIN_MAYBE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\n\tPG_RETURN_GIN_TERNARY_VALUE(res);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_GIN_TERNARY_VALUE",
          "args": [
            "res"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized strategy number: %d\"",
            "strategy"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_UINT16",
          "args": [
            "1"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_triconsistent_jsonb(PG_FUNCTION_ARGS)\n{\n\tGinTernaryValue *check = (GinTernaryValue *) PG_GETARG_POINTER(0);\n\tStrategyNumber strategy = PG_GETARG_UINT16(1);\n\n\t/* Jsonb\t   *query = PG_GETARG_JSONB_P(2); */\n\tint32\t\tnkeys = PG_GETARG_INT32(3);\n\n\t/* Pointer\t   *extra_data = (Pointer *) PG_GETARG_POINTER(4); */\n\tGinTernaryValue res = GIN_MAYBE;\n\tint32\t\ti;\n\n\t/*\n\t * Note that we never return GIN_TRUE, only GIN_MAYBE or GIN_FALSE; this\n\t * corresponds to always forcing recheck in the regular consistent\n\t * function, for the reasons listed there.\n\t */\n\tif (strategy == JsonbContainsStrategyNumber ||\n\t\tstrategy == JsonbExistsAllStrategyNumber)\n\t{\n\t\t/* All extracted keys must be present */\n\t\tfor (i = 0; i < nkeys; i++)\n\t\t{\n\t\t\tif (check[i] == GIN_FALSE)\n\t\t\t{\n\t\t\t\tres = GIN_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse if (strategy == JsonbExistsStrategyNumber ||\n\t\t\t strategy == JsonbExistsAnyStrategyNumber)\n\t{\n\t\t/* At least one extracted key must be present */\n\t\tres = GIN_FALSE;\n\t\tfor (i = 0; i < nkeys; i++)\n\t\t{\n\t\t\tif (check[i] == GIN_TRUE ||\n\t\t\t\tcheck[i] == GIN_MAYBE)\n\t\t\t{\n\t\t\t\tres = GIN_MAYBE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\n\tPG_RETURN_GIN_TERNARY_VALUE(res);\n}"
  },
  {
    "function_name": "gin_consistent_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "193-263",
    "snippet": "Datum\ngin_consistent_jsonb(PG_FUNCTION_ARGS)\n{\n\tbool\t   *check = (bool *) PG_GETARG_POINTER(0);\n\tStrategyNumber strategy = PG_GETARG_UINT16(1);\n\n\t/* Jsonb\t   *query = PG_GETARG_JSONB_P(2); */\n\tint32\t\tnkeys = PG_GETARG_INT32(3);\n\n\t/* Pointer\t   *extra_data = (Pointer *) PG_GETARG_POINTER(4); */\n\tbool\t   *recheck = (bool *) PG_GETARG_POINTER(5);\n\tbool\t\tres = true;\n\tint32\t\ti;\n\n\tif (strategy == JsonbContainsStrategyNumber)\n\t{\n\t\t/*\n\t\t * We must always recheck, since we can't tell from the index whether\n\t\t * the positions of the matched items match the structure of the query\n\t\t * object.  (Even if we could, we'd also have to worry about hashed\n\t\t * keys and the index's failure to distinguish keys from string array\n\t\t * elements.)  However, the tuple certainly doesn't match unless it\n\t\t * contains all the query keys.\n\t\t */\n\t\t*recheck = true;\n\t\tfor (i = 0; i < nkeys; i++)\n\t\t{\n\t\t\tif (!check[i])\n\t\t\t{\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse if (strategy == JsonbExistsStrategyNumber)\n\t{\n\t\t/*\n\t\t * Although the key is certainly present in the index, we must recheck\n\t\t * because (1) the key might be hashed, and (2) the index match might\n\t\t * be for a key that's not at top level of the JSON object.  For (1),\n\t\t * we could look at the query key to see if it's hashed and not\n\t\t * recheck if not, but the index lacks enough info to tell about (2).\n\t\t */\n\t\t*recheck = true;\n\t\tres = true;\n\t}\n\telse if (strategy == JsonbExistsAnyStrategyNumber)\n\t{\n\t\t/* As for plain exists, we must recheck */\n\t\t*recheck = true;\n\t\tres = true;\n\t}\n\telse if (strategy == JsonbExistsAllStrategyNumber)\n\t{\n\t\t/* As for plain exists, we must recheck */\n\t\t*recheck = true;\n\t\t/* ... but unless all the keys are present, we can say \"false\" */\n\t\tfor (i = 0; i < nkeys; i++)\n\t\t{\n\t\t\tif (!check[i])\n\t\t\t{\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized strategy number: %d\"",
            "strategy"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "5"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_UINT16",
          "args": [
            "1"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_consistent_jsonb(PG_FUNCTION_ARGS)\n{\n\tbool\t   *check = (bool *) PG_GETARG_POINTER(0);\n\tStrategyNumber strategy = PG_GETARG_UINT16(1);\n\n\t/* Jsonb\t   *query = PG_GETARG_JSONB_P(2); */\n\tint32\t\tnkeys = PG_GETARG_INT32(3);\n\n\t/* Pointer\t   *extra_data = (Pointer *) PG_GETARG_POINTER(4); */\n\tbool\t   *recheck = (bool *) PG_GETARG_POINTER(5);\n\tbool\t\tres = true;\n\tint32\t\ti;\n\n\tif (strategy == JsonbContainsStrategyNumber)\n\t{\n\t\t/*\n\t\t * We must always recheck, since we can't tell from the index whether\n\t\t * the positions of the matched items match the structure of the query\n\t\t * object.  (Even if we could, we'd also have to worry about hashed\n\t\t * keys and the index's failure to distinguish keys from string array\n\t\t * elements.)  However, the tuple certainly doesn't match unless it\n\t\t * contains all the query keys.\n\t\t */\n\t\t*recheck = true;\n\t\tfor (i = 0; i < nkeys; i++)\n\t\t{\n\t\t\tif (!check[i])\n\t\t\t{\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse if (strategy == JsonbExistsStrategyNumber)\n\t{\n\t\t/*\n\t\t * Although the key is certainly present in the index, we must recheck\n\t\t * because (1) the key might be hashed, and (2) the index match might\n\t\t * be for a key that's not at top level of the JSON object.  For (1),\n\t\t * we could look at the query key to see if it's hashed and not\n\t\t * recheck if not, but the index lacks enough info to tell about (2).\n\t\t */\n\t\t*recheck = true;\n\t\tres = true;\n\t}\n\telse if (strategy == JsonbExistsAnyStrategyNumber)\n\t{\n\t\t/* As for plain exists, we must recheck */\n\t\t*recheck = true;\n\t\tres = true;\n\t}\n\telse if (strategy == JsonbExistsAllStrategyNumber)\n\t{\n\t\t/* As for plain exists, we must recheck */\n\t\t*recheck = true;\n\t\t/* ... but unless all the keys are present, we can say \"false\" */\n\t\tfor (i = 0; i < nkeys; i++)\n\t\t{\n\t\t\tif (!check[i])\n\t\t\t{\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "gin_extract_jsonb_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "122-191",
    "snippet": "Datum\ngin_extract_jsonb_query(PG_FUNCTION_ARGS)\n{\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\tStrategyNumber strategy = PG_GETARG_UINT16(2);\n\tint32\t   *searchMode = (int32 *) PG_GETARG_POINTER(6);\n\tDatum\t   *entries;\n\n\tif (strategy == JsonbContainsStrategyNumber)\n\t{\n\t\t/* Query is a jsonb, so just apply gin_extract_jsonb... */\n\t\tentries = (Datum *)\n\t\t\tDatumGetPointer(DirectFunctionCall2(gin_extract_jsonb,\n\t\t\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(nentries)));\n\t\t/* ...although \"contains {}\" requires a full index scan */\n\t\tif (*nentries == 0)\n\t\t\t*searchMode = GIN_SEARCH_MODE_ALL;\n\t}\n\telse if (strategy == JsonbExistsStrategyNumber)\n\t{\n\t\t/* Query is a text string, which we treat as a key */\n\t\ttext\t   *query = PG_GETARG_TEXT_PP(0);\n\n\t\t*nentries = 1;\n\t\tentries = (Datum *) palloc(sizeof(Datum));\n\t\tentries[0] = make_text_key(JGINFLAG_KEY,\n\t\t\t\t\t\t\t\t   VARDATA_ANY(query),\n\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(query));\n\t}\n\telse if (strategy == JsonbExistsAnyStrategyNumber ||\n\t\t\t strategy == JsonbExistsAllStrategyNumber)\n\t{\n\t\t/* Query is a text array; each element is treated as a key */\n\t\tArrayType  *query = PG_GETARG_ARRAYTYPE_P(0);\n\t\tDatum\t   *key_datums;\n\t\tbool\t   *key_nulls;\n\t\tint\t\t\tkey_count;\n\t\tint\t\t\ti,\n\t\t\t\t\tj;\n\n\t\tdeconstruct_array(query,\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\n\t\tentries = (Datum *) palloc(sizeof(Datum) * key_count);\n\n\t\tfor (i = 0, j = 0; i < key_count; i++)\n\t\t{\n\t\t\t/* Nulls in the array are ignored */\n\t\t\tif (key_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tentries[j++] = make_text_key(JGINFLAG_KEY,\n\t\t\t\t\t\t\t\t\t\t VARDATA(key_datums[i]),\n\t\t\t\t\t\t\t\t\t\t VARSIZE(key_datums[i]) - VARHDRSZ);\n\t\t}\n\n\t\t*nentries = j;\n\t\t/* ExistsAll with no keys should match everything */\n\t\tif (j == 0 && strategy == JsonbExistsAllStrategyNumber)\n\t\t\t*searchMode = GIN_SEARCH_MODE_ALL;\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\t\tentries = NULL;\t\t\t/* keep compiler quiet */\n\t}\n\n\tPG_RETURN_POINTER(entries);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "entries"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized strategy number: %d\"",
            "strategy"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_text_key",
          "args": [
            "JGINFLAG_KEY",
            "VARDATA(key_datums[i])",
            "VARSIZE(key_datums[i]) - VARHDRSZ"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "make_text_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
          "lines": "528-558",
          "snippet": "static Datum\nmake_text_key(char flag, const char *str, int len)\n{\n\ttext\t   *item;\n\tchar\t\thashbuf[10];\n\n\tif (len > JGIN_MAXLENGTH)\n\t{\n\t\tuint32\t\thashval;\n\n\t\thashval = DatumGetUInt32(hash_any((const unsigned char *) str, len));\n\t\tsnprintf(hashbuf, sizeof(hashbuf), \"%08x\", hashval);\n\t\tstr = hashbuf;\n\t\tlen = 8;\n\t\tflag |= JGINFLAG_HASHED;\n\t}\n\n\t/*\n\t * Now build the text Datum.  For simplicity we build a 4-byte-header\n\t * varlena text Datum here, but we expect it will get converted to short\n\t * header format when stored in the index.\n\t */\n\titem = (text *) palloc(VARHDRSZ + len + 1);\n\tSET_VARSIZE(item, VARHDRSZ + len + 1);\n\n\t*VARDATA(item) = flag;\n\n\tmemcpy(VARDATA(item) + 1, str, len);\n\n\treturn PointerGetDatum(item);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/gin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum make_text_key(char flag, const char *str, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic Datum make_text_key(char flag, const char *str, int len);\n\nstatic Datum\nmake_text_key(char flag, const char *str, int len)\n{\n\ttext\t   *item;\n\tchar\t\thashbuf[10];\n\n\tif (len > JGIN_MAXLENGTH)\n\t{\n\t\tuint32\t\thashval;\n\n\t\thashval = DatumGetUInt32(hash_any((const unsigned char *) str, len));\n\t\tsnprintf(hashbuf, sizeof(hashbuf), \"%08x\", hashval);\n\t\tstr = hashbuf;\n\t\tlen = 8;\n\t\tflag |= JGINFLAG_HASHED;\n\t}\n\n\t/*\n\t * Now build the text Datum.  For simplicity we build a 4-byte-header\n\t * varlena text Datum here, but we expect it will get converted to short\n\t * header format when stored in the index.\n\t */\n\titem = (text *) palloc(VARHDRSZ + len + 1);\n\tSET_VARSIZE(item, VARHDRSZ + len + 1);\n\n\t*VARDATA(item) = flag;\n\n\tmemcpy(VARDATA(item) + 1, str, len);\n\n\treturn PointerGetDatum(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "key_datums[i]"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "key_datums[i]"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Datum) * key_count"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "query",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&key_datums",
            "&key_nulls",
            "&key_count"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "query"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "query"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "DirectFunctionCall2(gin_extract_jsonb,\n\t\t\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(nentries))"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "gin_extract_jsonb",
            "PG_GETARG_DATUM(0)",
            "PointerGetDatum(nentries)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "nentries"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "6"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_UINT16",
          "args": [
            "2"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_extract_jsonb_query(PG_FUNCTION_ARGS)\n{\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\tStrategyNumber strategy = PG_GETARG_UINT16(2);\n\tint32\t   *searchMode = (int32 *) PG_GETARG_POINTER(6);\n\tDatum\t   *entries;\n\n\tif (strategy == JsonbContainsStrategyNumber)\n\t{\n\t\t/* Query is a jsonb, so just apply gin_extract_jsonb... */\n\t\tentries = (Datum *)\n\t\t\tDatumGetPointer(DirectFunctionCall2(gin_extract_jsonb,\n\t\t\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(nentries)));\n\t\t/* ...although \"contains {}\" requires a full index scan */\n\t\tif (*nentries == 0)\n\t\t\t*searchMode = GIN_SEARCH_MODE_ALL;\n\t}\n\telse if (strategy == JsonbExistsStrategyNumber)\n\t{\n\t\t/* Query is a text string, which we treat as a key */\n\t\ttext\t   *query = PG_GETARG_TEXT_PP(0);\n\n\t\t*nentries = 1;\n\t\tentries = (Datum *) palloc(sizeof(Datum));\n\t\tentries[0] = make_text_key(JGINFLAG_KEY,\n\t\t\t\t\t\t\t\t   VARDATA_ANY(query),\n\t\t\t\t\t\t\t\t   VARSIZE_ANY_EXHDR(query));\n\t}\n\telse if (strategy == JsonbExistsAnyStrategyNumber ||\n\t\t\t strategy == JsonbExistsAllStrategyNumber)\n\t{\n\t\t/* Query is a text array; each element is treated as a key */\n\t\tArrayType  *query = PG_GETARG_ARRAYTYPE_P(0);\n\t\tDatum\t   *key_datums;\n\t\tbool\t   *key_nulls;\n\t\tint\t\t\tkey_count;\n\t\tint\t\t\ti,\n\t\t\t\t\tj;\n\n\t\tdeconstruct_array(query,\n\t\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\n\t\tentries = (Datum *) palloc(sizeof(Datum) * key_count);\n\n\t\tfor (i = 0, j = 0; i < key_count; i++)\n\t\t{\n\t\t\t/* Nulls in the array are ignored */\n\t\t\tif (key_nulls[i])\n\t\t\t\tcontinue;\n\t\t\tentries[j++] = make_text_key(JGINFLAG_KEY,\n\t\t\t\t\t\t\t\t\t\t VARDATA(key_datums[i]),\n\t\t\t\t\t\t\t\t\t\t VARSIZE(key_datums[i]) - VARHDRSZ);\n\t\t}\n\n\t\t*nentries = j;\n\t\t/* ExistsAll with no keys should match everything */\n\t\tif (j == 0 && strategy == JsonbExistsAllStrategyNumber)\n\t\t\t*searchMode = GIN_SEARCH_MODE_ALL;\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized strategy number: %d\", strategy);\n\t\tentries = NULL;\t\t\t/* keep compiler quiet */\n\t}\n\n\tPG_RETURN_POINTER(entries);\n}"
  },
  {
    "function_name": "gin_extract_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "66-120",
    "snippet": "Datum\ngin_extract_jsonb(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = (Jsonb *) PG_GETARG_JSONB_P(0);\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\tint\t\t\ttotal = 2 * JB_ROOT_COUNT(jb);\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tint\t\t\ti = 0;\n\tDatum\t   *entries;\n\n\t/* If the root level is empty, we certainly have no keys */\n\tif (total == 0)\n\t{\n\t\t*nentries = 0;\n\t\tPG_RETURN_POINTER(NULL);\n\t}\n\n\t/* Otherwise, use 2 * root count as initial estimate of result size */\n\tentries = (Datum *) palloc(sizeof(Datum) * total);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\t/* Since we recurse into the object, we might need more space */\n\t\tif (i >= total)\n\t\t{\n\t\t\ttotal *= 2;\n\t\t\tentries = (Datum *) repalloc(entries, sizeof(Datum) * total);\n\t\t}\n\n\t\tswitch (r)\n\t\t{\n\t\t\tcase WJB_KEY:\n\t\t\t\tentries[i++] = make_scalar_key(&v, true);\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\t\t/* Pretend string array elements are keys, see jsonb.h */\n\t\t\t\tentries[i++] = make_scalar_key(&v, (v.type == jbvString));\n\t\t\t\tbreak;\n\t\t\tcase WJB_VALUE:\n\t\t\t\tentries[i++] = make_scalar_key(&v, false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* we can ignore structural items */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t*nentries = i;\n\n\tPG_RETURN_POINTER(entries);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "entries"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_scalar_key",
          "args": [
            "&v",
            "false"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "make_scalar_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
          "lines": "566-612",
          "snippet": "static Datum\nmake_scalar_key(const JsonbValue *scalarVal, bool is_key)\n{\n\tDatum\t\titem;\n\tchar\t   *cstr;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\tAssert(!is_key);\n\t\t\titem = make_text_key(JGINFLAG_NULL, \"\", 0);\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tAssert(!is_key);\n\t\t\titem = make_text_key(JGINFLAG_BOOL,\n\t\t\t\t\t\t\t\t scalarVal->val.boolean ? \"t\" : \"f\", 1);\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\tAssert(!is_key);\n\n\t\t\t/*\n\t\t\t * A normalized textual representation, free of trailing zeroes,\n\t\t\t * is required so that numerically equal values will produce equal\n\t\t\t * strings.\n\t\t\t *\n\t\t\t * It isn't ideal that numerics are stored in a relatively bulky\n\t\t\t * textual format.  However, it's a notationally convenient way of\n\t\t\t * storing a \"union\" type in the GIN B-Tree, and indexing Jsonb\n\t\t\t * strings takes precedence.\n\t\t\t */\n\t\t\tcstr = numeric_normalize(scalarVal->val.numeric);\n\t\t\titem = make_text_key(JGINFLAG_NUM, cstr, strlen(cstr));\n\t\t\tpfree(cstr);\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\titem = make_text_key(is_key ? JGINFLAG_KEY : JGINFLAG_STR,\n\t\t\t\t\t\t\t\t scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t scalarVal->val.string.len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb scalar type: %d\", scalarVal->type);\n\t\t\titem = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn item;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/stratnum.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/gin.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum make_text_key(char flag, const char *str, int len);",
            "static Datum make_scalar_key(const JsonbValue *scalarVal, bool is_key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nstatic Datum make_text_key(char flag, const char *str, int len);\nstatic Datum make_scalar_key(const JsonbValue *scalarVal, bool is_key);\n\nstatic Datum\nmake_scalar_key(const JsonbValue *scalarVal, bool is_key)\n{\n\tDatum\t\titem;\n\tchar\t   *cstr;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\tAssert(!is_key);\n\t\t\titem = make_text_key(JGINFLAG_NULL, \"\", 0);\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tAssert(!is_key);\n\t\t\titem = make_text_key(JGINFLAG_BOOL,\n\t\t\t\t\t\t\t\t scalarVal->val.boolean ? \"t\" : \"f\", 1);\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\tAssert(!is_key);\n\n\t\t\t/*\n\t\t\t * A normalized textual representation, free of trailing zeroes,\n\t\t\t * is required so that numerically equal values will produce equal\n\t\t\t * strings.\n\t\t\t *\n\t\t\t * It isn't ideal that numerics are stored in a relatively bulky\n\t\t\t * textual format.  However, it's a notationally convenient way of\n\t\t\t * storing a \"union\" type in the GIN B-Tree, and indexing Jsonb\n\t\t\t * strings takes precedence.\n\t\t\t */\n\t\t\tcstr = numeric_normalize(scalarVal->val.numeric);\n\t\t\titem = make_text_key(JGINFLAG_NUM, cstr, strlen(cstr));\n\t\t\tpfree(cstr);\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\titem = make_text_key(is_key ? JGINFLAG_KEY : JGINFLAG_STR,\n\t\t\t\t\t\t\t\t scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t scalarVal->val.string.len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized jsonb scalar type: %d\", scalarVal->type);\n\t\t\titem = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "entries",
            "sizeof(Datum) * total"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Datum) * total"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "NULL"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "jb"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "1"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_extract_jsonb(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = (Jsonb *) PG_GETARG_JSONB_P(0);\n\tint32\t   *nentries = (int32 *) PG_GETARG_POINTER(1);\n\tint\t\t\ttotal = 2 * JB_ROOT_COUNT(jb);\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tint\t\t\ti = 0;\n\tDatum\t   *entries;\n\n\t/* If the root level is empty, we certainly have no keys */\n\tif (total == 0)\n\t{\n\t\t*nentries = 0;\n\t\tPG_RETURN_POINTER(NULL);\n\t}\n\n\t/* Otherwise, use 2 * root count as initial estimate of result size */\n\tentries = (Datum *) palloc(sizeof(Datum) * total);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\t/* Since we recurse into the object, we might need more space */\n\t\tif (i >= total)\n\t\t{\n\t\t\ttotal *= 2;\n\t\t\tentries = (Datum *) repalloc(entries, sizeof(Datum) * total);\n\t\t}\n\n\t\tswitch (r)\n\t\t{\n\t\t\tcase WJB_KEY:\n\t\t\t\tentries[i++] = make_scalar_key(&v, true);\n\t\t\t\tbreak;\n\t\t\tcase WJB_ELEM:\n\t\t\t\t/* Pretend string array elements are keys, see jsonb.h */\n\t\t\t\tentries[i++] = make_scalar_key(&v, (v.type == jbvString));\n\t\t\t\tbreak;\n\t\t\tcase WJB_VALUE:\n\t\t\t\tentries[i++] = make_scalar_key(&v, false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* we can ignore structural items */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t*nentries = i;\n\n\tPG_RETURN_POINTER(entries);\n}"
  },
  {
    "function_name": "gin_compare_jsonb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_gin.c",
    "lines": "40-64",
    "snippet": "Datum\ngin_compare_jsonb(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint32\t\tresult;\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\t/* Compare text as bttextcmp does, but always using C collation */\n\tresult = varstr_cmp(a1p, len1, a2p, len2, C_COLLATION_OID);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_collation.h\"",
      "#include \"access/stratnum.h\"",
      "#include \"access/hash.h\"",
      "#include \"access/gin.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg2",
            "1"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "arg1",
            "0"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "varstr_cmp",
          "args": [
            "a1p",
            "len1",
            "a2p",
            "len2",
            "C_COLLATION_OID"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "varstr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "1380-1609",
          "snippet": "int\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TEXTBUFLEN\t\t1024"
          ],
          "globals_used": [
            "static int\ttext_cmp(text *arg1, text *arg2, Oid collid);",
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define TEXTBUFLEN\t\t1024\n\nstatic int\ttext_cmp(text *arg1, text *arg2, Oid collid);\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nint\nvarstr_cmp(const char *arg1, int len1, const char *arg2, int len2, Oid collid)\n{\n\tint\t\t\tresult;\n\n\t/*\n\t * Unfortunately, there is no strncoll(), so in the non-C locale case we\n\t * have to do some memory copying.  This turns out to be significantly\n\t * slower, so we optimize the case where LC_COLLATE is C.  We also try to\n\t * optimize relatively-short strings by avoiding palloc/pfree overhead.\n\t */\n\tif (lc_collate_is_c(collid))\n\t{\n\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\tif ((result == 0) && (len1 != len2))\n\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t}\n\telse\n\t{\n\t\tchar\t\ta1buf[TEXTBUFLEN];\n\t\tchar\t\ta2buf[TEXTBUFLEN];\n\t\tchar\t   *a1p,\n\t\t\t\t   *a2p;\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for string comparison\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n\t\t/*\n\t\t * memcmp() can't tell us which of two unequal strings sorts first,\n\t\t * but it's a cheap way to tell if they're equal.  Testing shows that\n\t\t * memcmp() followed by strcoll() is only trivially slower than\n\t\t * strcoll() by itself, so we don't lose much if this doesn't work out\n\t\t * very often, and if it does - for example, because there are many\n\t\t * equal strings in the input - then we win big by avoiding expensive\n\t\t * collation-aware comparisons.\n\t\t */\n\t\tif (len1 == len2 && memcmp(arg1, arg2, len1) == 0)\n\t\t\treturn 0;\n\n#ifdef WIN32\n\t\t/* Win32 does not have UTF-8, so we need to map to UTF-16 */\n\t\tif (GetDatabaseEncoding() == PG_UTF8\n\t\t\t&& (!mylocale || mylocale->provider == COLLPROVIDER_LIBC))\n\t\t{\n\t\t\tint\t\t\ta1len;\n\t\t\tint\t\t\ta2len;\n\t\t\tint\t\t\tr;\n\n\t\t\tif (len1 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta1len = len1 * 2 + 2;\n\t\t\t\ta1p = palloc(a1len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta1len = TEXTBUFLEN;\n\t\t\t\ta1p = a1buf;\n\t\t\t}\n\t\t\tif (len2 >= TEXTBUFLEN / 2)\n\t\t\t{\n\t\t\t\ta2len = len2 * 2 + 2;\n\t\t\t\ta2p = palloc(a2len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta2len = TEXTBUFLEN;\n\t\t\t\ta2p = a2buf;\n\t\t\t}\n\n\t\t\t/* stupid Microsloth API does not work for zero-length input */\n\t\t\tif (len1 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg1, len1,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a1p, a1len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a1p)[r] = 0;\n\n\t\t\tif (len2 == 0)\n\t\t\t\tr = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tr = MultiByteToWideChar(CP_UTF8, 0, arg2, len2,\n\t\t\t\t\t\t\t\t\t\t(LPWSTR) a2p, a2len / 2);\n\t\t\t\tif (!r)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errmsg(\"could not convert string to UTF-16: error code %lu\",\n\t\t\t\t\t\t\t\t\tGetLastError())));\n\t\t\t}\n\t\t\t((LPWSTR) a2p)[r] = 0;\n\n\t\t\terrno = 0;\n#ifdef HAVE_LOCALE_T\n\t\t\tif (mylocale)\n\t\t\t\tresult = wcscoll_l((LPWSTR) a1p, (LPWSTR) a2p, mylocale->info.lt);\n\t\t\telse\n#endif\n\t\t\t\tresult = wcscoll((LPWSTR) a1p, (LPWSTR) a2p);\n\t\t\tif (result == 2147483647)\t/* _NLSCMPERROR; missing from mingw\n\t\t\t\t\t\t\t\t\t\t * headers */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errmsg(\"could not compare Unicode strings: %m\")));\n\n\t\t\t/*\n\t\t\t * In some locales wcscoll() can claim that nonidentical strings\n\t\t\t * are equal.  Believing that would be bad news for a number of\n\t\t\t * reasons, so we follow Perl's lead and sort \"equal\" strings\n\t\t\t * according to strcmp (on the UTF-8 representation).\n\t\t\t */\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tresult = memcmp(arg1, arg2, Min(len1, len2));\n\t\t\t\tif ((result == 0) && (len1 != len2))\n\t\t\t\t\tresult = (len1 < len2) ? -1 : 1;\n\t\t\t}\n\n\t\t\tif (a1p != a1buf)\n\t\t\t\tpfree(a1p);\n\t\t\tif (a2p != a2buf)\n\t\t\t\tpfree(a2p);\n\n\t\t\treturn result;\n\t\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t\tif (len1 >= TEXTBUFLEN)\n\t\t\ta1p = (char *) palloc(len1 + 1);\n\t\telse\n\t\t\ta1p = a1buf;\n\t\tif (len2 >= TEXTBUFLEN)\n\t\t\ta2p = (char *) palloc(len2 + 1);\n\t\telse\n\t\t\ta2p = a2buf;\n\n\t\tmemcpy(a1p, arg1, len1);\n\t\ta1p[len1] = '\\0';\n\t\tmemcpy(a2p, arg2, len2);\n\t\ta2p[len2] = '\\0';\n\n\t\tif (mylocale)\n\t\t{\n\t\t\tif (mylocale->provider == COLLPROVIDER_ICU)\n\t\t\t{\n#ifdef USE_ICU\n#ifdef HAVE_UCOL_STRCOLLUTF8\n\t\t\t\tif (GetDatabaseEncoding() == PG_UTF8)\n\t\t\t\t{\n\t\t\t\t\tUErrorCode\tstatus;\n\n\t\t\t\t\tstatus = U_ZERO_ERROR;\n\t\t\t\t\tresult = ucol_strcollUTF8(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t\t  arg1, len1,\n\t\t\t\t\t\t\t\t\t\t\t  arg2, len2,\n\t\t\t\t\t\t\t\t\t\t\t  &status);\n\t\t\t\t\tif (U_FAILURE(status))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errmsg(\"collation failed: %s\", u_errorName(status))));\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t{\n\t\t\t\t\tint32_t\t\tulen1,\n\t\t\t\t\t\t\t\tulen2;\n\t\t\t\t\tUChar\t   *uchar1,\n\t\t\t\t\t\t\t   *uchar2;\n\n\t\t\t\t\tulen1 = icu_to_uchar(&uchar1, arg1, len1);\n\t\t\t\t\tulen2 = icu_to_uchar(&uchar2, arg2, len2);\n\n\t\t\t\t\tresult = ucol_strcoll(mylocale->info.icu.ucol,\n\t\t\t\t\t\t\t\t\t\t  uchar1, ulen1,\n\t\t\t\t\t\t\t\t\t\t  uchar2, ulen2);\n\n\t\t\t\t\tpfree(uchar1);\n\t\t\t\t\tpfree(uchar2);\n\t\t\t\t}\n#else\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\t\t\t\t\t\t\t/* not USE_ICU */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\tresult = strcoll_l(a1p, a2p, mylocale->info.lt);\n#else\n\t\t\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"unsupported collprovider: %c\", mylocale->provider);\n#endif\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tresult = strcoll(a1p, a2p);\n\n\t\t/*\n\t\t * In some locales strcoll() can claim that nonidentical strings are\n\t\t * equal.  Believing that would be bad news for a number of reasons,\n\t\t * so we follow Perl's lead and sort \"equal\" strings according to\n\t\t * strcmp().\n\t\t */\n\t\tif (result == 0)\n\t\t\tresult = strcmp(a1p, a2p);\n\n\t\tif (a1p != a1buf)\n\t\t\tpfree(a1p);\n\t\tif (a2p != a2buf)\n\t\t\tpfree(a2p);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg2"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "arg1"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg2"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "arg1"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/stratnum.h\"\n#include \"access/hash.h\"\n#include \"access/gin.h\"\n#include \"postgres.h\"\n\nDatum\ngin_compare_jsonb(PG_FUNCTION_ARGS)\n{\n\ttext\t   *arg1 = PG_GETARG_TEXT_PP(0);\n\ttext\t   *arg2 = PG_GETARG_TEXT_PP(1);\n\tint32\t\tresult;\n\tchar\t   *a1p,\n\t\t\t   *a2p;\n\tint\t\t\tlen1,\n\t\t\t\tlen2;\n\n\ta1p = VARDATA_ANY(arg1);\n\ta2p = VARDATA_ANY(arg2);\n\n\tlen1 = VARSIZE_ANY_EXHDR(arg1);\n\tlen2 = VARSIZE_ANY_EXHDR(arg2);\n\n\t/* Compare text as bttextcmp does, but always using C collation */\n\tresult = varstr_cmp(a1p, len1, a2p, len2, C_COLLATION_OID);\n\n\tPG_FREE_IF_COPY(arg1, 0);\n\tPG_FREE_IF_COPY(arg2, 1);\n\n\tPG_RETURN_INT32(result);\n}"
  }
]