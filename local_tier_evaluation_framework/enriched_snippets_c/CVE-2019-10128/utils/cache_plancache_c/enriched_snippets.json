[
  {
    "function_name": "ResetPlanCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1862-1908",
    "snippet": "void\nResetPlanCache(void)\n{\n\tCachedPlanSource *plansource;\n\n\tfor (plansource = first_saved_plan; plansource; plansource = plansource->next_saved)\n\t{\n\t\tListCell   *lc;\n\n\t\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\n\t\t/* No work if it's already invalidated */\n\t\tif (!plansource->is_valid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We *must not* mark transaction control statements as invalid,\n\t\t * particularly not ROLLBACK, because they may need to be executed in\n\t\t * aborted transactions when we can't revalidate them (cf bug #5269).\n\t\t */\n\t\tif (IsTransactionStmtPlan(plansource))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * In general there is no point in invalidating utility statements\n\t\t * since they have no plans anyway.  So invalidate it only if it\n\t\t * contains at least one non-utility statement, or contains a utility\n\t\t * statement that contains a pre-analyzed query (which could have\n\t\t * dependencies.)\n\t\t */\n\t\tforeach(lc, plansource->query_list)\n\t\t{\n\t\t\tQuery\t   *query = lfirst_node(Query, lc);\n\n\t\t\tif (query->commandType != CMD_UTILITY ||\n\t\t\t\tUtilityContainsQuery(query->utilityStmt))\n\t\t\t{\n\t\t\t\t/* non-utility statement, so invalidate */\n\t\t\t\tplansource->is_valid = false;\n\t\t\t\tif (plansource->gplan)\n\t\t\t\t\tplansource->gplan->is_valid = false;\n\t\t\t\t/* no need to look further */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CachedPlanSource *first_saved_plan = NULL;",
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UtilityContainsQuery",
          "args": [
            "query->utilityStmt"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "Query",
            "lc"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "plansource->query_list"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsTransactionStmtPlan",
          "args": [
            "plansource"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic CachedPlanSource *first_saved_plan = NULL;\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nvoid\nResetPlanCache(void)\n{\n\tCachedPlanSource *plansource;\n\n\tfor (plansource = first_saved_plan; plansource; plansource = plansource->next_saved)\n\t{\n\t\tListCell   *lc;\n\n\t\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\n\t\t/* No work if it's already invalidated */\n\t\tif (!plansource->is_valid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We *must not* mark transaction control statements as invalid,\n\t\t * particularly not ROLLBACK, because they may need to be executed in\n\t\t * aborted transactions when we can't revalidate them (cf bug #5269).\n\t\t */\n\t\tif (IsTransactionStmtPlan(plansource))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * In general there is no point in invalidating utility statements\n\t\t * since they have no plans anyway.  So invalidate it only if it\n\t\t * contains at least one non-utility statement, or contains a utility\n\t\t * statement that contains a pre-analyzed query (which could have\n\t\t * dependencies.)\n\t\t */\n\t\tforeach(lc, plansource->query_list)\n\t\t{\n\t\t\tQuery\t   *query = lfirst_node(Query, lc);\n\n\t\t\tif (query->commandType != CMD_UTILITY ||\n\t\t\t\tUtilityContainsQuery(query->utilityStmt))\n\t\t\t{\n\t\t\t\t/* non-utility statement, so invalidate */\n\t\t\t\tplansource->is_valid = false;\n\t\t\t\tif (plansource->gplan)\n\t\t\t\t\tplansource->gplan->is_valid = false;\n\t\t\t\t/* no need to look further */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "PlanCacheSysCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1853-1857",
    "snippet": "static void\nPlanCacheSysCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tResetPlanCache();\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PlanCacheFuncCallback(Datum arg, int cacheid, uint32 hashvalue);",
      "static void PlanCacheSysCallback(Datum arg, int cacheid, uint32 hashvalue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResetPlanCache",
          "args": [],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "ResetPlanCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1862-1908",
          "snippet": "void\nResetPlanCache(void)\n{\n\tCachedPlanSource *plansource;\n\n\tfor (plansource = first_saved_plan; plansource; plansource = plansource->next_saved)\n\t{\n\t\tListCell   *lc;\n\n\t\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\n\t\t/* No work if it's already invalidated */\n\t\tif (!plansource->is_valid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We *must not* mark transaction control statements as invalid,\n\t\t * particularly not ROLLBACK, because they may need to be executed in\n\t\t * aborted transactions when we can't revalidate them (cf bug #5269).\n\t\t */\n\t\tif (IsTransactionStmtPlan(plansource))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * In general there is no point in invalidating utility statements\n\t\t * since they have no plans anyway.  So invalidate it only if it\n\t\t * contains at least one non-utility statement, or contains a utility\n\t\t * statement that contains a pre-analyzed query (which could have\n\t\t * dependencies.)\n\t\t */\n\t\tforeach(lc, plansource->query_list)\n\t\t{\n\t\t\tQuery\t   *query = lfirst_node(Query, lc);\n\n\t\t\tif (query->commandType != CMD_UTILITY ||\n\t\t\t\tUtilityContainsQuery(query->utilityStmt))\n\t\t\t{\n\t\t\t\t/* non-utility statement, so invalidate */\n\t\t\t\tplansource->is_valid = false;\n\t\t\t\tif (plansource->gplan)\n\t\t\t\t\tplansource->gplan->is_valid = false;\n\t\t\t\t/* no need to look further */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CachedPlanSource *first_saved_plan = NULL;",
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic CachedPlanSource *first_saved_plan = NULL;\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nvoid\nResetPlanCache(void)\n{\n\tCachedPlanSource *plansource;\n\n\tfor (plansource = first_saved_plan; plansource; plansource = plansource->next_saved)\n\t{\n\t\tListCell   *lc;\n\n\t\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\n\t\t/* No work if it's already invalidated */\n\t\tif (!plansource->is_valid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We *must not* mark transaction control statements as invalid,\n\t\t * particularly not ROLLBACK, because they may need to be executed in\n\t\t * aborted transactions when we can't revalidate them (cf bug #5269).\n\t\t */\n\t\tif (IsTransactionStmtPlan(plansource))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * In general there is no point in invalidating utility statements\n\t\t * since they have no plans anyway.  So invalidate it only if it\n\t\t * contains at least one non-utility statement, or contains a utility\n\t\t * statement that contains a pre-analyzed query (which could have\n\t\t * dependencies.)\n\t\t */\n\t\tforeach(lc, plansource->query_list)\n\t\t{\n\t\t\tQuery\t   *query = lfirst_node(Query, lc);\n\n\t\t\tif (query->commandType != CMD_UTILITY ||\n\t\t\t\tUtilityContainsQuery(query->utilityStmt))\n\t\t\t{\n\t\t\t\t/* non-utility statement, so invalidate */\n\t\t\t\tplansource->is_valid = false;\n\t\t\t\tif (plansource->gplan)\n\t\t\t\t\tplansource->gplan->is_valid = false;\n\t\t\t\t/* no need to look further */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void PlanCacheFuncCallback(Datum arg, int cacheid, uint32 hashvalue);\nstatic void PlanCacheSysCallback(Datum arg, int cacheid, uint32 hashvalue);\n\nstatic void\nPlanCacheSysCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tResetPlanCache();\n}"
  },
  {
    "function_name": "PlanCacheFuncCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1774-1845",
    "snippet": "static void\nPlanCacheFuncCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tCachedPlanSource *plansource;\n\n\tfor (plansource = first_saved_plan; plansource; plansource = plansource->next_saved)\n\t{\n\t\tListCell   *lc;\n\n\t\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\n\t\t/* No work if it's already invalidated */\n\t\tif (!plansource->is_valid)\n\t\t\tcontinue;\n\n\t\t/* Never invalidate transaction control commands */\n\t\tif (IsTransactionStmtPlan(plansource))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check the dependency list for the rewritten querytree.\n\t\t */\n\t\tforeach(lc, plansource->invalItems)\n\t\t{\n\t\t\tPlanInvalItem *item = (PlanInvalItem *) lfirst(lc);\n\n\t\t\tif (item->cacheId != cacheid)\n\t\t\t\tcontinue;\n\t\t\tif (hashvalue == 0 ||\n\t\t\t\titem->hashValue == hashvalue)\n\t\t\t{\n\t\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\t\tplansource->is_valid = false;\n\t\t\t\tif (plansource->gplan)\n\t\t\t\t\tplansource->gplan->is_valid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * The generic plan, if any, could have more dependencies than the\n\t\t * querytree does, so we have to check it too.\n\t\t */\n\t\tif (plansource->gplan && plansource->gplan->is_valid)\n\t\t{\n\t\t\tforeach(lc, plansource->gplan->stmt_list)\n\t\t\t{\n\t\t\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\t\t\t\tListCell   *lc3;\n\n\t\t\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\t\t\tcontinue;\t/* Ignore utility statements */\n\t\t\t\tforeach(lc3, plannedstmt->invalItems)\n\t\t\t\t{\n\t\t\t\t\tPlanInvalItem *item = (PlanInvalItem *) lfirst(lc3);\n\n\t\t\t\t\tif (item->cacheId != cacheid)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (hashvalue == 0 ||\n\t\t\t\t\t\titem->hashValue == hashvalue)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Invalidate the generic plan only */\n\t\t\t\t\t\tplansource->gplan->is_valid = false;\n\t\t\t\t\t\tbreak;\t/* out of invalItems scan */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!plansource->gplan->is_valid)\n\t\t\t\t\tbreak;\t\t/* out of stmt_list scan */\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CachedPlanSource *first_saved_plan = NULL;",
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);",
      "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);",
      "static void PlanCacheFuncCallback(Datum arg, int cacheid, uint32 hashvalue);",
      "static void PlanCacheSysCallback(Datum arg, int cacheid, uint32 hashvalue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc3"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc3",
            "plannedstmt->invalItems"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "PlannedStmt",
            "lc"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "plansource->gplan->stmt_list"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "plansource->invalItems"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsTransactionStmtPlan",
          "args": [
            "plansource"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic CachedPlanSource *first_saved_plan = NULL;\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\nstatic void PlanCacheFuncCallback(Datum arg, int cacheid, uint32 hashvalue);\nstatic void PlanCacheSysCallback(Datum arg, int cacheid, uint32 hashvalue);\n\nstatic void\nPlanCacheFuncCallback(Datum arg, int cacheid, uint32 hashvalue)\n{\n\tCachedPlanSource *plansource;\n\n\tfor (plansource = first_saved_plan; plansource; plansource = plansource->next_saved)\n\t{\n\t\tListCell   *lc;\n\n\t\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\n\t\t/* No work if it's already invalidated */\n\t\tif (!plansource->is_valid)\n\t\t\tcontinue;\n\n\t\t/* Never invalidate transaction control commands */\n\t\tif (IsTransactionStmtPlan(plansource))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check the dependency list for the rewritten querytree.\n\t\t */\n\t\tforeach(lc, plansource->invalItems)\n\t\t{\n\t\t\tPlanInvalItem *item = (PlanInvalItem *) lfirst(lc);\n\n\t\t\tif (item->cacheId != cacheid)\n\t\t\t\tcontinue;\n\t\t\tif (hashvalue == 0 ||\n\t\t\t\titem->hashValue == hashvalue)\n\t\t\t{\n\t\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\t\tplansource->is_valid = false;\n\t\t\t\tif (plansource->gplan)\n\t\t\t\t\tplansource->gplan->is_valid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * The generic plan, if any, could have more dependencies than the\n\t\t * querytree does, so we have to check it too.\n\t\t */\n\t\tif (plansource->gplan && plansource->gplan->is_valid)\n\t\t{\n\t\t\tforeach(lc, plansource->gplan->stmt_list)\n\t\t\t{\n\t\t\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\t\t\t\tListCell   *lc3;\n\n\t\t\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\t\t\tcontinue;\t/* Ignore utility statements */\n\t\t\t\tforeach(lc3, plannedstmt->invalItems)\n\t\t\t\t{\n\t\t\t\t\tPlanInvalItem *item = (PlanInvalItem *) lfirst(lc3);\n\n\t\t\t\t\tif (item->cacheId != cacheid)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (hashvalue == 0 ||\n\t\t\t\t\t\titem->hashValue == hashvalue)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Invalidate the generic plan only */\n\t\t\t\t\t\tplansource->gplan->is_valid = false;\n\t\t\t\t\t\tbreak;\t/* out of invalItems scan */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!plansource->gplan->is_valid)\n\t\t\t\t\tbreak;\t\t/* out of stmt_list scan */\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "PlanCacheRelCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1709-1762",
    "snippet": "static void\nPlanCacheRelCallback(Datum arg, Oid relid)\n{\n\tCachedPlanSource *plansource;\n\n\tfor (plansource = first_saved_plan; plansource; plansource = plansource->next_saved)\n\t{\n\t\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\n\t\t/* No work if it's already invalidated */\n\t\tif (!plansource->is_valid)\n\t\t\tcontinue;\n\n\t\t/* Never invalidate transaction control commands */\n\t\tif (IsTransactionStmtPlan(plansource))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check the dependency list for the rewritten querytree.\n\t\t */\n\t\tif ((relid == InvalidOid) ? plansource->relationOids != NIL :\n\t\t\tlist_member_oid(plansource->relationOids, relid))\n\t\t{\n\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\tplansource->is_valid = false;\n\t\t\tif (plansource->gplan)\n\t\t\t\tplansource->gplan->is_valid = false;\n\t\t}\n\n\t\t/*\n\t\t * The generic plan, if any, could have more dependencies than the\n\t\t * querytree does, so we have to check it too.\n\t\t */\n\t\tif (plansource->gplan && plansource->gplan->is_valid)\n\t\t{\n\t\t\tListCell   *lc;\n\n\t\t\tforeach(lc, plansource->gplan->stmt_list)\n\t\t\t{\n\t\t\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\n\t\t\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\t\t\tcontinue;\t/* Ignore utility statements */\n\t\t\t\tif ((relid == InvalidOid) ? plannedstmt->relationOids != NIL :\n\t\t\t\t\tlist_member_oid(plannedstmt->relationOids, relid))\n\t\t\t\t{\n\t\t\t\t\t/* Invalidate the generic plan only */\n\t\t\t\t\tplansource->gplan->is_valid = false;\n\t\t\t\t\tbreak;\t\t/* out of stmt_list scan */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CachedPlanSource *first_saved_plan = NULL;",
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);",
      "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);",
      "static void PlanCacheRelCallback(Datum arg, Oid relid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_member_oid",
          "args": [
            "plannedstmt->relationOids",
            "relid"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "PlannedStmt",
            "lc"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "plansource->gplan->stmt_list"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_member_oid",
          "args": [
            "plansource->relationOids",
            "relid"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsTransactionStmtPlan",
          "args": [
            "plansource"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic CachedPlanSource *first_saved_plan = NULL;\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\nstatic void PlanCacheRelCallback(Datum arg, Oid relid);\n\nstatic void\nPlanCacheRelCallback(Datum arg, Oid relid)\n{\n\tCachedPlanSource *plansource;\n\n\tfor (plansource = first_saved_plan; plansource; plansource = plansource->next_saved)\n\t{\n\t\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\n\t\t/* No work if it's already invalidated */\n\t\tif (!plansource->is_valid)\n\t\t\tcontinue;\n\n\t\t/* Never invalidate transaction control commands */\n\t\tif (IsTransactionStmtPlan(plansource))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Check the dependency list for the rewritten querytree.\n\t\t */\n\t\tif ((relid == InvalidOid) ? plansource->relationOids != NIL :\n\t\t\tlist_member_oid(plansource->relationOids, relid))\n\t\t{\n\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\tplansource->is_valid = false;\n\t\t\tif (plansource->gplan)\n\t\t\t\tplansource->gplan->is_valid = false;\n\t\t}\n\n\t\t/*\n\t\t * The generic plan, if any, could have more dependencies than the\n\t\t * querytree does, so we have to check it too.\n\t\t */\n\t\tif (plansource->gplan && plansource->gplan->is_valid)\n\t\t{\n\t\t\tListCell   *lc;\n\n\t\t\tforeach(lc, plansource->gplan->stmt_list)\n\t\t\t{\n\t\t\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\n\t\t\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\t\t\tcontinue;\t/* Ignore utility statements */\n\t\t\t\tif ((relid == InvalidOid) ? plannedstmt->relationOids != NIL :\n\t\t\t\t\tlist_member_oid(plannedstmt->relationOids, relid))\n\t\t\t\t{\n\t\t\t\t\t/* Invalidate the generic plan only */\n\t\t\t\t\tplansource->gplan->is_valid = false;\n\t\t\t\t\tbreak;\t\t/* out of stmt_list scan */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "PlanCacheComputeResultDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1673-1700",
    "snippet": "static TupleDesc\nPlanCacheComputeResultDesc(List *stmt_list)\n{\n\tQuery\t   *query;\n\n\tswitch (ChoosePortalStrategy(stmt_list))\n\t{\n\t\tcase PORTAL_ONE_SELECT:\n\t\tcase PORTAL_ONE_MOD_WITH:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\treturn ExecCleanTypeFromTL(query->targetList, false);\n\n\t\tcase PORTAL_ONE_RETURNING:\n\t\t\tquery = QueryListGetPrimaryStmt(stmt_list);\n\t\t\tAssert(query->returningList);\n\t\t\treturn ExecCleanTypeFromTL(query->returningList, false);\n\n\t\tcase PORTAL_UTIL_SELECT:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\tAssert(query->utilityStmt);\n\t\t\treturn UtilityTupleDescriptor(query->utilityStmt);\n\n\t\tcase PORTAL_MULTI_QUERY:\n\t\t\t/* will not return tuples */\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UtilityTupleDescriptor",
          "args": [
            "query->utilityStmt"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "query->utilityStmt"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial_node",
          "args": [
            "Query",
            "stmt_list"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecCleanTypeFromTL",
          "args": [
            "query->returningList",
            "false"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "query->returningList"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QueryListGetPrimaryStmt",
          "args": [
            "stmt_list"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "QueryListGetPrimaryStmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1461-1474",
          "snippet": "static Query *\nQueryListGetPrimaryStmt(List *stmts)\n{\n\tListCell   *lc;\n\n\tforeach(lc, stmts)\n\t{\n\t\tQuery\t   *stmt = lfirst_node(Query, lc);\n\n\t\tif (stmt->canSetTag)\n\t\t\treturn stmt;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Query *QueryListGetPrimaryStmt(List *stmts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Query *QueryListGetPrimaryStmt(List *stmts);\n\nstatic Query *\nQueryListGetPrimaryStmt(List *stmts)\n{\n\tListCell   *lc;\n\n\tforeach(lc, stmts)\n\t{\n\t\tQuery\t   *stmt = lfirst_node(Query, lc);\n\n\t\tif (stmt->canSetTag)\n\t\t\treturn stmt;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExecCleanTypeFromTL",
          "args": [
            "query->targetList",
            "false"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial_node",
          "args": [
            "Query",
            "stmt_list"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ChoosePortalStrategy",
          "args": [
            "stmt_list"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic TupleDesc\nPlanCacheComputeResultDesc(List *stmt_list)\n{\n\tQuery\t   *query;\n\n\tswitch (ChoosePortalStrategy(stmt_list))\n\t{\n\t\tcase PORTAL_ONE_SELECT:\n\t\tcase PORTAL_ONE_MOD_WITH:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\treturn ExecCleanTypeFromTL(query->targetList, false);\n\n\t\tcase PORTAL_ONE_RETURNING:\n\t\t\tquery = QueryListGetPrimaryStmt(stmt_list);\n\t\t\tAssert(query->returningList);\n\t\t\treturn ExecCleanTypeFromTL(query->returningList, false);\n\n\t\tcase PORTAL_UTIL_SELECT:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\tAssert(query->utilityStmt);\n\t\t\treturn UtilityTupleDescriptor(query->utilityStmt);\n\n\t\tcase PORTAL_MULTI_QUERY:\n\t\t\t/* will not return tuples */\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ScanQueryWalker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1644-1664",
    "snippet": "static bool\nScanQueryWalker(Node *node, bool *acquire)\n{\n\tif (node == NULL)\n\t\treturn false;\n\tif (IsA(node, SubLink))\n\t{\n\t\tSubLink    *sub = (SubLink *) node;\n\n\t\t/* Do what we came for */\n\t\tScanQueryForLocks(castNode(Query, sub->subselect), *acquire);\n\t\t/* Fall through to process lefthand args of SubLink */\n\t}\n\n\t/*\n\t * Do NOT recurse into Query nodes, because ScanQueryForLocks already\n\t * processed subselects of subselects for us.\n\t */\n\treturn expression_tree_walker(node, ScanQueryWalker,\n\t\t\t\t\t\t\t\t  (void *) acquire);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
      "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
      "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
      "static bool ScanQueryWalker(Node *node, bool *acquire);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "expression_tree_walker",
          "args": [
            "node",
            "ScanQueryWalker",
            "(void *) acquire"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanQueryForLocks",
          "args": [
            "castNode(Query, sub->subselect)",
            "*acquire"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "ScanQueryForLocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1575-1639",
          "snippet": "static void\nScanQueryForLocks(Query *parsetree, bool acquire)\n{\n\tListCell   *lc;\n\tint\t\t\trt_index;\n\n\t/* Shouldn't get called on utility commands */\n\tAssert(parsetree->commandType != CMD_UTILITY);\n\n\t/*\n\t * First, process RTEs of the current query level.\n\t */\n\trt_index = 0;\n\tforeach(lc, parsetree->rtable)\n\t{\n\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);\n\t\tLOCKMODE\tlockmode;\n\n\t\trt_index++;\n\t\tswitch (rte->rtekind)\n\t\t{\n\t\t\tcase RTE_RELATION:\n\t\t\t\t/* Acquire or release the appropriate type of lock */\n\t\t\t\tif (rt_index == parsetree->resultRelation)\n\t\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\t\telse if (get_parse_rowmark(parsetree, rt_index) != NULL)\n\t\t\t\t\tlockmode = RowShareLock;\n\t\t\t\telse\n\t\t\t\t\tlockmode = AccessShareLock;\n\t\t\t\tif (acquire)\n\t\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\t\telse\n\t\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t\t\tbreak;\n\n\t\t\tcase RTE_SUBQUERY:\n\t\t\t\t/* Recurse into subquery-in-FROM */\n\t\t\t\tScanQueryForLocks(rte->subquery, acquire);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* ignore other types of RTEs */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Recurse into subquery-in-WITH */\n\tforeach(lc, parsetree->cteList)\n\t{\n\t\tCommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);\n\n\t\tScanQueryForLocks(castNode(Query, cte->ctequery), acquire);\n\t}\n\n\t/*\n\t * Recurse into sublink subqueries, too.  But we already did the ones in\n\t * the rtable and cteList.\n\t */\n\tif (parsetree->hasSubLinks)\n\t{\n\t\tquery_tree_walker(parsetree, ScanQueryWalker,\n\t\t\t\t\t\t  (void *) &acquire,\n\t\t\t\t\t\t  QTW_IGNORE_RC_SUBQUERIES);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
            "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
            "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
            "static bool ScanQueryWalker(Node *node, bool *acquire);",
            "static void PlanCacheRelCallback(Datum arg, Oid relid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\nstatic void PlanCacheRelCallback(Datum arg, Oid relid);\n\nstatic void\nScanQueryForLocks(Query *parsetree, bool acquire)\n{\n\tListCell   *lc;\n\tint\t\t\trt_index;\n\n\t/* Shouldn't get called on utility commands */\n\tAssert(parsetree->commandType != CMD_UTILITY);\n\n\t/*\n\t * First, process RTEs of the current query level.\n\t */\n\trt_index = 0;\n\tforeach(lc, parsetree->rtable)\n\t{\n\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);\n\t\tLOCKMODE\tlockmode;\n\n\t\trt_index++;\n\t\tswitch (rte->rtekind)\n\t\t{\n\t\t\tcase RTE_RELATION:\n\t\t\t\t/* Acquire or release the appropriate type of lock */\n\t\t\t\tif (rt_index == parsetree->resultRelation)\n\t\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\t\telse if (get_parse_rowmark(parsetree, rt_index) != NULL)\n\t\t\t\t\tlockmode = RowShareLock;\n\t\t\t\telse\n\t\t\t\t\tlockmode = AccessShareLock;\n\t\t\t\tif (acquire)\n\t\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\t\telse\n\t\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t\t\tbreak;\n\n\t\t\tcase RTE_SUBQUERY:\n\t\t\t\t/* Recurse into subquery-in-FROM */\n\t\t\t\tScanQueryForLocks(rte->subquery, acquire);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* ignore other types of RTEs */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Recurse into subquery-in-WITH */\n\tforeach(lc, parsetree->cteList)\n\t{\n\t\tCommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);\n\n\t\tScanQueryForLocks(castNode(Query, cte->ctequery), acquire);\n\t}\n\n\t/*\n\t * Recurse into sublink subqueries, too.  But we already did the ones in\n\t * the rtable and cteList.\n\t */\n\tif (parsetree->hasSubLinks)\n\t{\n\t\tquery_tree_walker(parsetree, ScanQueryWalker,\n\t\t\t\t\t\t  (void *) &acquire,\n\t\t\t\t\t\t  QTW_IGNORE_RC_SUBQUERIES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "Query",
            "sub->subselect"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "node",
            "SubLink"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\n\nstatic bool\nScanQueryWalker(Node *node, bool *acquire)\n{\n\tif (node == NULL)\n\t\treturn false;\n\tif (IsA(node, SubLink))\n\t{\n\t\tSubLink    *sub = (SubLink *) node;\n\n\t\t/* Do what we came for */\n\t\tScanQueryForLocks(castNode(Query, sub->subselect), *acquire);\n\t\t/* Fall through to process lefthand args of SubLink */\n\t}\n\n\t/*\n\t * Do NOT recurse into Query nodes, because ScanQueryForLocks already\n\t * processed subselects of subselects for us.\n\t */\n\treturn expression_tree_walker(node, ScanQueryWalker,\n\t\t\t\t\t\t\t\t  (void *) acquire);\n}"
  },
  {
    "function_name": "ScanQueryForLocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1575-1639",
    "snippet": "static void\nScanQueryForLocks(Query *parsetree, bool acquire)\n{\n\tListCell   *lc;\n\tint\t\t\trt_index;\n\n\t/* Shouldn't get called on utility commands */\n\tAssert(parsetree->commandType != CMD_UTILITY);\n\n\t/*\n\t * First, process RTEs of the current query level.\n\t */\n\trt_index = 0;\n\tforeach(lc, parsetree->rtable)\n\t{\n\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);\n\t\tLOCKMODE\tlockmode;\n\n\t\trt_index++;\n\t\tswitch (rte->rtekind)\n\t\t{\n\t\t\tcase RTE_RELATION:\n\t\t\t\t/* Acquire or release the appropriate type of lock */\n\t\t\t\tif (rt_index == parsetree->resultRelation)\n\t\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\t\telse if (get_parse_rowmark(parsetree, rt_index) != NULL)\n\t\t\t\t\tlockmode = RowShareLock;\n\t\t\t\telse\n\t\t\t\t\tlockmode = AccessShareLock;\n\t\t\t\tif (acquire)\n\t\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\t\telse\n\t\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t\t\tbreak;\n\n\t\t\tcase RTE_SUBQUERY:\n\t\t\t\t/* Recurse into subquery-in-FROM */\n\t\t\t\tScanQueryForLocks(rte->subquery, acquire);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* ignore other types of RTEs */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Recurse into subquery-in-WITH */\n\tforeach(lc, parsetree->cteList)\n\t{\n\t\tCommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);\n\n\t\tScanQueryForLocks(castNode(Query, cte->ctequery), acquire);\n\t}\n\n\t/*\n\t * Recurse into sublink subqueries, too.  But we already did the ones in\n\t * the rtable and cteList.\n\t */\n\tif (parsetree->hasSubLinks)\n\t{\n\t\tquery_tree_walker(parsetree, ScanQueryWalker,\n\t\t\t\t\t\t  (void *) &acquire,\n\t\t\t\t\t\t  QTW_IGNORE_RC_SUBQUERIES);\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
      "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
      "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
      "static bool ScanQueryWalker(Node *node, bool *acquire);",
      "static void PlanCacheRelCallback(Datum arg, Oid relid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "query_tree_walker",
          "args": [
            "parsetree",
            "ScanQueryWalker",
            "(void *) &acquire",
            "QTW_IGNORE_RC_SUBQUERIES"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanQueryForLocks",
          "args": [
            "castNode(Query, cte->ctequery)",
            "acquire"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "ScanQueryForLocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1575-1639",
          "snippet": "static void\nScanQueryForLocks(Query *parsetree, bool acquire)\n{\n\tListCell   *lc;\n\tint\t\t\trt_index;\n\n\t/* Shouldn't get called on utility commands */\n\tAssert(parsetree->commandType != CMD_UTILITY);\n\n\t/*\n\t * First, process RTEs of the current query level.\n\t */\n\trt_index = 0;\n\tforeach(lc, parsetree->rtable)\n\t{\n\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);\n\t\tLOCKMODE\tlockmode;\n\n\t\trt_index++;\n\t\tswitch (rte->rtekind)\n\t\t{\n\t\t\tcase RTE_RELATION:\n\t\t\t\t/* Acquire or release the appropriate type of lock */\n\t\t\t\tif (rt_index == parsetree->resultRelation)\n\t\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\t\telse if (get_parse_rowmark(parsetree, rt_index) != NULL)\n\t\t\t\t\tlockmode = RowShareLock;\n\t\t\t\telse\n\t\t\t\t\tlockmode = AccessShareLock;\n\t\t\t\tif (acquire)\n\t\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\t\telse\n\t\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t\t\tbreak;\n\n\t\t\tcase RTE_SUBQUERY:\n\t\t\t\t/* Recurse into subquery-in-FROM */\n\t\t\t\tScanQueryForLocks(rte->subquery, acquire);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* ignore other types of RTEs */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Recurse into subquery-in-WITH */\n\tforeach(lc, parsetree->cteList)\n\t{\n\t\tCommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);\n\n\t\tScanQueryForLocks(castNode(Query, cte->ctequery), acquire);\n\t}\n\n\t/*\n\t * Recurse into sublink subqueries, too.  But we already did the ones in\n\t * the rtable and cteList.\n\t */\n\tif (parsetree->hasSubLinks)\n\t{\n\t\tquery_tree_walker(parsetree, ScanQueryWalker,\n\t\t\t\t\t\t  (void *) &acquire,\n\t\t\t\t\t\t  QTW_IGNORE_RC_SUBQUERIES);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "castNode",
          "args": [
            "Query",
            "cte->ctequery"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "CommonTableExpr",
            "lc"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "parsetree->cteList"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnlockRelationOid",
          "args": [
            "rte->relid",
            "lockmode"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockRelationOid",
          "args": [
            "rte->relid",
            "lockmode"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_parse_rowmark",
          "args": [
            "parsetree",
            "rt_index"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "parsetree->rtable"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "parsetree->commandType != CMD_UTILITY"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\nstatic void PlanCacheRelCallback(Datum arg, Oid relid);\n\nstatic void\nScanQueryForLocks(Query *parsetree, bool acquire)\n{\n\tListCell   *lc;\n\tint\t\t\trt_index;\n\n\t/* Shouldn't get called on utility commands */\n\tAssert(parsetree->commandType != CMD_UTILITY);\n\n\t/*\n\t * First, process RTEs of the current query level.\n\t */\n\trt_index = 0;\n\tforeach(lc, parsetree->rtable)\n\t{\n\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);\n\t\tLOCKMODE\tlockmode;\n\n\t\trt_index++;\n\t\tswitch (rte->rtekind)\n\t\t{\n\t\t\tcase RTE_RELATION:\n\t\t\t\t/* Acquire or release the appropriate type of lock */\n\t\t\t\tif (rt_index == parsetree->resultRelation)\n\t\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\t\telse if (get_parse_rowmark(parsetree, rt_index) != NULL)\n\t\t\t\t\tlockmode = RowShareLock;\n\t\t\t\telse\n\t\t\t\t\tlockmode = AccessShareLock;\n\t\t\t\tif (acquire)\n\t\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\t\telse\n\t\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t\t\tbreak;\n\n\t\t\tcase RTE_SUBQUERY:\n\t\t\t\t/* Recurse into subquery-in-FROM */\n\t\t\t\tScanQueryForLocks(rte->subquery, acquire);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* ignore other types of RTEs */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Recurse into subquery-in-WITH */\n\tforeach(lc, parsetree->cteList)\n\t{\n\t\tCommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);\n\n\t\tScanQueryForLocks(castNode(Query, cte->ctequery), acquire);\n\t}\n\n\t/*\n\t * Recurse into sublink subqueries, too.  But we already did the ones in\n\t * the rtable and cteList.\n\t */\n\tif (parsetree->hasSubLinks)\n\t{\n\t\tquery_tree_walker(parsetree, ScanQueryWalker,\n\t\t\t\t\t\t  (void *) &acquire,\n\t\t\t\t\t\t  QTW_IGNORE_RC_SUBQUERIES);\n\t}\n}"
  },
  {
    "function_name": "AcquirePlannerLocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1550-1570",
    "snippet": "static void\nAcquirePlannerLocks(List *stmt_list, bool acquire)\n{\n\tListCell   *lc;\n\n\tforeach(lc, stmt_list)\n\t{\n\t\tQuery\t   *query = lfirst_node(Query, lc);\n\n\t\tif (query->commandType == CMD_UTILITY)\n\t\t{\n\t\t\t/* Ignore utility statements, unless they contain a Query */\n\t\t\tquery = UtilityContainsQuery(query->utilityStmt);\n\t\t\tif (query)\n\t\t\t\tScanQueryForLocks(query, acquire);\n\t\t\tcontinue;\n\t\t}\n\n\t\tScanQueryForLocks(query, acquire);\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
      "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
      "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
      "static bool ScanQueryWalker(Node *node, bool *acquire);",
      "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ScanQueryForLocks",
          "args": [
            "query",
            "acquire"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "ScanQueryForLocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1575-1639",
          "snippet": "static void\nScanQueryForLocks(Query *parsetree, bool acquire)\n{\n\tListCell   *lc;\n\tint\t\t\trt_index;\n\n\t/* Shouldn't get called on utility commands */\n\tAssert(parsetree->commandType != CMD_UTILITY);\n\n\t/*\n\t * First, process RTEs of the current query level.\n\t */\n\trt_index = 0;\n\tforeach(lc, parsetree->rtable)\n\t{\n\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);\n\t\tLOCKMODE\tlockmode;\n\n\t\trt_index++;\n\t\tswitch (rte->rtekind)\n\t\t{\n\t\t\tcase RTE_RELATION:\n\t\t\t\t/* Acquire or release the appropriate type of lock */\n\t\t\t\tif (rt_index == parsetree->resultRelation)\n\t\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\t\telse if (get_parse_rowmark(parsetree, rt_index) != NULL)\n\t\t\t\t\tlockmode = RowShareLock;\n\t\t\t\telse\n\t\t\t\t\tlockmode = AccessShareLock;\n\t\t\t\tif (acquire)\n\t\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\t\telse\n\t\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t\t\tbreak;\n\n\t\t\tcase RTE_SUBQUERY:\n\t\t\t\t/* Recurse into subquery-in-FROM */\n\t\t\t\tScanQueryForLocks(rte->subquery, acquire);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* ignore other types of RTEs */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Recurse into subquery-in-WITH */\n\tforeach(lc, parsetree->cteList)\n\t{\n\t\tCommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);\n\n\t\tScanQueryForLocks(castNode(Query, cte->ctequery), acquire);\n\t}\n\n\t/*\n\t * Recurse into sublink subqueries, too.  But we already did the ones in\n\t * the rtable and cteList.\n\t */\n\tif (parsetree->hasSubLinks)\n\t{\n\t\tquery_tree_walker(parsetree, ScanQueryWalker,\n\t\t\t\t\t\t  (void *) &acquire,\n\t\t\t\t\t\t  QTW_IGNORE_RC_SUBQUERIES);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
            "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
            "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
            "static bool ScanQueryWalker(Node *node, bool *acquire);",
            "static void PlanCacheRelCallback(Datum arg, Oid relid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\nstatic void PlanCacheRelCallback(Datum arg, Oid relid);\n\nstatic void\nScanQueryForLocks(Query *parsetree, bool acquire)\n{\n\tListCell   *lc;\n\tint\t\t\trt_index;\n\n\t/* Shouldn't get called on utility commands */\n\tAssert(parsetree->commandType != CMD_UTILITY);\n\n\t/*\n\t * First, process RTEs of the current query level.\n\t */\n\trt_index = 0;\n\tforeach(lc, parsetree->rtable)\n\t{\n\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);\n\t\tLOCKMODE\tlockmode;\n\n\t\trt_index++;\n\t\tswitch (rte->rtekind)\n\t\t{\n\t\t\tcase RTE_RELATION:\n\t\t\t\t/* Acquire or release the appropriate type of lock */\n\t\t\t\tif (rt_index == parsetree->resultRelation)\n\t\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\t\telse if (get_parse_rowmark(parsetree, rt_index) != NULL)\n\t\t\t\t\tlockmode = RowShareLock;\n\t\t\t\telse\n\t\t\t\t\tlockmode = AccessShareLock;\n\t\t\t\tif (acquire)\n\t\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\t\telse\n\t\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t\t\tbreak;\n\n\t\t\tcase RTE_SUBQUERY:\n\t\t\t\t/* Recurse into subquery-in-FROM */\n\t\t\t\tScanQueryForLocks(rte->subquery, acquire);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* ignore other types of RTEs */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Recurse into subquery-in-WITH */\n\tforeach(lc, parsetree->cteList)\n\t{\n\t\tCommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);\n\n\t\tScanQueryForLocks(castNode(Query, cte->ctequery), acquire);\n\t}\n\n\t/*\n\t * Recurse into sublink subqueries, too.  But we already did the ones in\n\t * the rtable and cteList.\n\t */\n\tif (parsetree->hasSubLinks)\n\t{\n\t\tquery_tree_walker(parsetree, ScanQueryWalker,\n\t\t\t\t\t\t  (void *) &acquire,\n\t\t\t\t\t\t  QTW_IGNORE_RC_SUBQUERIES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UtilityContainsQuery",
          "args": [
            "query->utilityStmt"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "Query",
            "lc"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "stmt_list"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic void\nAcquirePlannerLocks(List *stmt_list, bool acquire)\n{\n\tListCell   *lc;\n\n\tforeach(lc, stmt_list)\n\t{\n\t\tQuery\t   *query = lfirst_node(Query, lc);\n\n\t\tif (query->commandType == CMD_UTILITY)\n\t\t{\n\t\t\t/* Ignore utility statements, unless they contain a Query */\n\t\t\tquery = UtilityContainsQuery(query->utilityStmt);\n\t\t\tif (query)\n\t\t\t\tScanQueryForLocks(query, acquire);\n\t\t\tcontinue;\n\t\t}\n\n\t\tScanQueryForLocks(query, acquire);\n\t}\n}"
  },
  {
    "function_name": "AcquireExecutorLocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1480-1540",
    "snippet": "static void\nAcquireExecutorLocks(List *stmt_list, bool acquire)\n{\n\tListCell   *lc1;\n\n\tforeach(lc1, stmt_list)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc1);\n\t\tint\t\t\trt_index;\n\t\tListCell   *lc2;\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t{\n\t\t\t/*\n\t\t\t * Ignore utility statements, except those (such as EXPLAIN) that\n\t\t\t * contain a parsed-but-not-planned query.  Note: it's okay to use\n\t\t\t * ScanQueryForLocks, even though the query hasn't been through\n\t\t\t * rule rewriting, because rewriting doesn't change the query\n\t\t\t * representation.\n\t\t\t */\n\t\t\tQuery\t   *query = UtilityContainsQuery(plannedstmt->utilityStmt);\n\n\t\t\tif (query)\n\t\t\t\tScanQueryForLocks(query, acquire);\n\t\t\tcontinue;\n\t\t}\n\n\t\trt_index = 0;\n\t\tforeach(lc2, plannedstmt->rtable)\n\t\t{\n\t\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc2);\n\t\t\tLOCKMODE\tlockmode;\n\t\t\tPlanRowMark *rc;\n\n\t\t\trt_index++;\n\n\t\t\tif (rte->rtekind != RTE_RELATION)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Acquire the appropriate type of lock on each relation OID. Note\n\t\t\t * that we don't actually try to open the rel, and hence will not\n\t\t\t * fail if it's been dropped entirely --- we'll just transiently\n\t\t\t * acquire a non-conflicting lock.\n\t\t\t */\n\t\t\tif (list_member_int(plannedstmt->resultRelations, rt_index) ||\n\t\t\t\tlist_member_int(plannedstmt->nonleafResultRelations, rt_index))\n\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\telse if ((rc = get_plan_rowmark(plannedstmt->rowMarks, rt_index)) != NULL &&\n\t\t\t\t\t RowMarkRequiresRowShareLock(rc->markType))\n\t\t\t\tlockmode = RowShareLock;\n\t\t\telse\n\t\t\t\tlockmode = AccessShareLock;\n\n\t\t\tif (acquire)\n\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\telse\n\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
      "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
      "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
      "static bool ScanQueryWalker(Node *node, bool *acquire);",
      "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);",
      "static void PlanCacheRelCallback(Datum arg, Oid relid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UnlockRelationOid",
          "args": [
            "rte->relid",
            "lockmode"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockRelationOid",
          "args": [
            "rte->relid",
            "lockmode"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RowMarkRequiresRowShareLock",
          "args": [
            "rc->markType"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_plan_rowmark",
          "args": [
            "plannedstmt->rowMarks",
            "rt_index"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_member_int",
          "args": [
            "plannedstmt->nonleafResultRelations",
            "rt_index"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_member_int",
          "args": [
            "plannedstmt->resultRelations",
            "rt_index"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc2"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc2",
            "plannedstmt->rtable"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanQueryForLocks",
          "args": [
            "query",
            "acquire"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "ScanQueryForLocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1575-1639",
          "snippet": "static void\nScanQueryForLocks(Query *parsetree, bool acquire)\n{\n\tListCell   *lc;\n\tint\t\t\trt_index;\n\n\t/* Shouldn't get called on utility commands */\n\tAssert(parsetree->commandType != CMD_UTILITY);\n\n\t/*\n\t * First, process RTEs of the current query level.\n\t */\n\trt_index = 0;\n\tforeach(lc, parsetree->rtable)\n\t{\n\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);\n\t\tLOCKMODE\tlockmode;\n\n\t\trt_index++;\n\t\tswitch (rte->rtekind)\n\t\t{\n\t\t\tcase RTE_RELATION:\n\t\t\t\t/* Acquire or release the appropriate type of lock */\n\t\t\t\tif (rt_index == parsetree->resultRelation)\n\t\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\t\telse if (get_parse_rowmark(parsetree, rt_index) != NULL)\n\t\t\t\t\tlockmode = RowShareLock;\n\t\t\t\telse\n\t\t\t\t\tlockmode = AccessShareLock;\n\t\t\t\tif (acquire)\n\t\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\t\telse\n\t\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t\t\tbreak;\n\n\t\t\tcase RTE_SUBQUERY:\n\t\t\t\t/* Recurse into subquery-in-FROM */\n\t\t\t\tScanQueryForLocks(rte->subquery, acquire);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* ignore other types of RTEs */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Recurse into subquery-in-WITH */\n\tforeach(lc, parsetree->cteList)\n\t{\n\t\tCommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);\n\n\t\tScanQueryForLocks(castNode(Query, cte->ctequery), acquire);\n\t}\n\n\t/*\n\t * Recurse into sublink subqueries, too.  But we already did the ones in\n\t * the rtable and cteList.\n\t */\n\tif (parsetree->hasSubLinks)\n\t{\n\t\tquery_tree_walker(parsetree, ScanQueryWalker,\n\t\t\t\t\t\t  (void *) &acquire,\n\t\t\t\t\t\t  QTW_IGNORE_RC_SUBQUERIES);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
            "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
            "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
            "static bool ScanQueryWalker(Node *node, bool *acquire);",
            "static void PlanCacheRelCallback(Datum arg, Oid relid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\nstatic void PlanCacheRelCallback(Datum arg, Oid relid);\n\nstatic void\nScanQueryForLocks(Query *parsetree, bool acquire)\n{\n\tListCell   *lc;\n\tint\t\t\trt_index;\n\n\t/* Shouldn't get called on utility commands */\n\tAssert(parsetree->commandType != CMD_UTILITY);\n\n\t/*\n\t * First, process RTEs of the current query level.\n\t */\n\trt_index = 0;\n\tforeach(lc, parsetree->rtable)\n\t{\n\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);\n\t\tLOCKMODE\tlockmode;\n\n\t\trt_index++;\n\t\tswitch (rte->rtekind)\n\t\t{\n\t\t\tcase RTE_RELATION:\n\t\t\t\t/* Acquire or release the appropriate type of lock */\n\t\t\t\tif (rt_index == parsetree->resultRelation)\n\t\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\t\telse if (get_parse_rowmark(parsetree, rt_index) != NULL)\n\t\t\t\t\tlockmode = RowShareLock;\n\t\t\t\telse\n\t\t\t\t\tlockmode = AccessShareLock;\n\t\t\t\tif (acquire)\n\t\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\t\telse\n\t\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t\t\tbreak;\n\n\t\t\tcase RTE_SUBQUERY:\n\t\t\t\t/* Recurse into subquery-in-FROM */\n\t\t\t\tScanQueryForLocks(rte->subquery, acquire);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/* ignore other types of RTEs */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Recurse into subquery-in-WITH */\n\tforeach(lc, parsetree->cteList)\n\t{\n\t\tCommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);\n\n\t\tScanQueryForLocks(castNode(Query, cte->ctequery), acquire);\n\t}\n\n\t/*\n\t * Recurse into sublink subqueries, too.  But we already did the ones in\n\t * the rtable and cteList.\n\t */\n\tif (parsetree->hasSubLinks)\n\t{\n\t\tquery_tree_walker(parsetree, ScanQueryWalker,\n\t\t\t\t\t\t  (void *) &acquire,\n\t\t\t\t\t\t  QTW_IGNORE_RC_SUBQUERIES);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UtilityContainsQuery",
          "args": [
            "plannedstmt->utilityStmt"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "PlannedStmt",
            "lc1"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc1",
            "stmt_list"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\nstatic void PlanCacheRelCallback(Datum arg, Oid relid);\n\nstatic void\nAcquireExecutorLocks(List *stmt_list, bool acquire)\n{\n\tListCell   *lc1;\n\n\tforeach(lc1, stmt_list)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc1);\n\t\tint\t\t\trt_index;\n\t\tListCell   *lc2;\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t{\n\t\t\t/*\n\t\t\t * Ignore utility statements, except those (such as EXPLAIN) that\n\t\t\t * contain a parsed-but-not-planned query.  Note: it's okay to use\n\t\t\t * ScanQueryForLocks, even though the query hasn't been through\n\t\t\t * rule rewriting, because rewriting doesn't change the query\n\t\t\t * representation.\n\t\t\t */\n\t\t\tQuery\t   *query = UtilityContainsQuery(plannedstmt->utilityStmt);\n\n\t\t\tif (query)\n\t\t\t\tScanQueryForLocks(query, acquire);\n\t\t\tcontinue;\n\t\t}\n\n\t\trt_index = 0;\n\t\tforeach(lc2, plannedstmt->rtable)\n\t\t{\n\t\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc2);\n\t\t\tLOCKMODE\tlockmode;\n\t\t\tPlanRowMark *rc;\n\n\t\t\trt_index++;\n\n\t\t\tif (rte->rtekind != RTE_RELATION)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Acquire the appropriate type of lock on each relation OID. Note\n\t\t\t * that we don't actually try to open the rel, and hence will not\n\t\t\t * fail if it's been dropped entirely --- we'll just transiently\n\t\t\t * acquire a non-conflicting lock.\n\t\t\t */\n\t\t\tif (list_member_int(plannedstmt->resultRelations, rt_index) ||\n\t\t\t\tlist_member_int(plannedstmt->nonleafResultRelations, rt_index))\n\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\telse if ((rc = get_plan_rowmark(plannedstmt->rowMarks, rt_index)) != NULL &&\n\t\t\t\t\t RowMarkRequiresRowShareLock(rc->markType))\n\t\t\t\tlockmode = RowShareLock;\n\t\t\telse\n\t\t\t\tlockmode = AccessShareLock;\n\n\t\t\tif (acquire)\n\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\telse\n\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "QueryListGetPrimaryStmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1461-1474",
    "snippet": "static Query *\nQueryListGetPrimaryStmt(List *stmts)\n{\n\tListCell   *lc;\n\n\tforeach(lc, stmts)\n\t{\n\t\tQuery\t   *stmt = lfirst_node(Query, lc);\n\n\t\tif (stmt->canSetTag)\n\t\t\treturn stmt;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Query *QueryListGetPrimaryStmt(List *stmts);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "Query",
            "lc"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "stmts"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Query *QueryListGetPrimaryStmt(List *stmts);\n\nstatic Query *\nQueryListGetPrimaryStmt(List *stmts)\n{\n\tListCell   *lc;\n\n\tforeach(lc, stmts)\n\t{\n\t\tQuery\t   *stmt = lfirst_node(Query, lc);\n\n\t\tif (stmt->canSetTag)\n\t\t\treturn stmt;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "CachedPlanGetTargetList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1427-1451",
    "snippet": "List *\nCachedPlanGetTargetList(CachedPlanSource *plansource,\n\t\t\t\t\t\tQueryEnvironment *queryEnv)\n{\n\tQuery\t   *pstmt;\n\n\t/* Assert caller is doing things in a sane order */\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * No work needed if statement doesn't return tuples (we assume this\n\t * feature cannot be changed by an invalidation)\n\t */\n\tif (plansource->resultDesc == NULL)\n\t\treturn NIL;\n\n\t/* Make sure the querytree list is valid and we have parse-time locks */\n\tRevalidateCachedQuery(plansource, queryEnv);\n\n\t/* Get the primary statement and find out what it returns */\n\tpstmt = QueryListGetPrimaryStmt(plansource->query_list);\n\n\treturn FetchStatementTargetList((Node *) pstmt);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);",
      "static CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FetchStatementTargetList",
          "args": [
            "(Node *) pstmt"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QueryListGetPrimaryStmt",
          "args": [
            "plansource->query_list"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "QueryListGetPrimaryStmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1461-1474",
          "snippet": "static Query *\nQueryListGetPrimaryStmt(List *stmts)\n{\n\tListCell   *lc;\n\n\tforeach(lc, stmts)\n\t{\n\t\tQuery\t   *stmt = lfirst_node(Query, lc);\n\n\t\tif (stmt->canSetTag)\n\t\t\treturn stmt;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Query *QueryListGetPrimaryStmt(List *stmts);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Query *QueryListGetPrimaryStmt(List *stmts);\n\nstatic Query *\nQueryListGetPrimaryStmt(List *stmts)\n{\n\tListCell   *lc;\n\n\tforeach(lc, stmts)\n\t{\n\t\tQuery\t   *stmt = lfirst_node(Query, lc);\n\n\t\tif (stmt->canSetTag)\n\t\t\treturn stmt;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RevalidateCachedQuery",
          "args": [
            "plansource",
            "queryEnv"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "RevalidateCachedQuery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "557-786",
          "snippet": "static List *\nRevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv)\n{\n\tbool\t\tsnapshot_set;\n\tRawStmt    *rawtree;\n\tList\t   *tlist;\t\t\t/* transient query-tree list */\n\tList\t   *qlist;\t\t\t/* permanent query-tree list */\n\tTupleDesc\tresultDesc;\n\tMemoryContext querytree_context;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * For one-shot plans, we do not support revalidation checking; it's\n\t * assumed the query is parsed, planned, and executed in one transaction,\n\t * so that no lock re-acquisition is necessary.  Also, there is never any\n\t * need to revalidate plans for transaction control commands (and we\n\t * mustn't risk any catalog accesses when handling those).\n\t */\n\tif (plansource->is_oneshot || IsTransactionStmtPlan(plansource))\n\t{\n\t\tAssert(plansource->is_valid);\n\t\treturn NIL;\n\t}\n\n\t/*\n\t * If the query is currently valid, we should have a saved search_path ---\n\t * check to see if that matches the current environment.  If not, we want\n\t * to force replan.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAssert(plansource->search_path != NULL);\n\t\tif (!OverrideSearchPathMatchesCurrent(plansource->search_path))\n\t\t{\n\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\tplansource->is_valid = false;\n\t\t\tif (plansource->gplan)\n\t\t\t\tplansource->gplan->is_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * If the query rewrite phase had a possible RLS dependency, we must redo\n\t * it if either the role or the row_security setting has changed.\n\t */\n\tif (plansource->is_valid && plansource->dependsOnRLS &&\n\t\t(plansource->rewriteRoleId != GetUserId() ||\n\t\t plansource->rewriteRowSecurity != row_security))\n\t\tplansource->is_valid = false;\n\n\t/*\n\t * If the query is currently valid, acquire locks on the referenced\n\t * objects; then check again.  We need to do it this way to cover the race\n\t * condition that an invalidation message arrives before we get the locks.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAcquirePlannerLocks(plansource->query_list, true);\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the query invalid.\n\t\t */\n\t\tif (plansource->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn NIL;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquirePlannerLocks(plansource->query_list, false);\n\t}\n\n\t/*\n\t * Discard the no-longer-useful query tree.  (Note: we don't want to do\n\t * this any earlier, else we'd not have been able to release locks\n\t * correctly in the race condition case.)\n\t */\n\tplansource->is_valid = false;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\n\t/*\n\t * Free the query_context.  We don't really expect MemoryContextDelete to\n\t * fail, but just in case, make sure the CachedPlanSource is left in a\n\t * reasonably sane state.  (The generic plan won't get unlinked yet, but\n\t * that's acceptable.)\n\t */\n\tif (plansource->query_context)\n\t{\n\t\tMemoryContext qcxt = plansource->query_context;\n\n\t\tplansource->query_context = NULL;\n\t\tMemoryContextDelete(qcxt);\n\t}\n\n\t/* Drop the generic plan reference if any */\n\tReleaseGenericPlan(plansource);\n\n\t/*\n\t * Now re-do parse analysis and rewrite.  This not incidentally acquires\n\t * the locks we need to do planning safely.\n\t */\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for parsing/planning.  But if it isn't, install one.  Note: no point in\n\t * checking whether parse analysis requires a snapshot; utility commands\n\t * don't have invalidatable plans, so we'd not get here for such a\n\t * command.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet())\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Run parse analysis and rule rewriting.  The parser tends to scribble on\n\t * its input, so we must copy the raw parse tree to prevent corruption of\n\t * the cache.\n\t */\n\trawtree = copyObject(plansource->raw_parse_tree);\n\tif (rawtree == NULL)\n\t\ttlist = NIL;\n\telse if (plansource->parserSetup != NULL)\n\t\ttlist = pg_analyze_and_rewrite_params(rawtree,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->query_string,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetup,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetupArg,\n\t\t\t\t\t\t\t\t\t\t\t  queryEnv);\n\telse\n\t\ttlist = pg_analyze_and_rewrite(rawtree,\n\t\t\t\t\t\t\t\t\t   plansource->query_string,\n\t\t\t\t\t\t\t\t\t   plansource->param_types,\n\t\t\t\t\t\t\t\t\t   plansource->num_params,\n\t\t\t\t\t\t\t\t\t   queryEnv);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Check or update the result tupdesc.  XXX should we use a weaker\n\t * condition than equalTupleDescs() here?\n\t *\n\t * We assume the parameter types didn't change from the first time, so no\n\t * need to update that.\n\t */\n\tresultDesc = PlanCacheComputeResultDesc(tlist);\n\tif (resultDesc == NULL && plansource->resultDesc == NULL)\n\t{\n\t\t/* OK, doesn't return tuples */\n\t}\n\telse if (resultDesc == NULL || plansource->resultDesc == NULL ||\n\t\t\t !equalTupleDescs(resultDesc, plansource->resultDesc))\n\t{\n\t\t/* can we give a better error message? */\n\t\tif (plansource->fixed_result)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cached plan must not change result type\")));\n\t\toldcxt = MemoryContextSwitchTo(plansource->context);\n\t\tif (resultDesc)\n\t\t\tresultDesc = CreateTupleDescCopy(resultDesc);\n\t\tif (plansource->resultDesc)\n\t\t\tFreeTupleDesc(plansource->resultDesc);\n\t\tplansource->resultDesc = resultDesc;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Allocate new query_context and copy the completed querytree into it.\n\t * It's transient until we complete the copying and dependency extraction.\n\t */\n\tquerytree_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\toldcxt = MemoryContextSwitchTo(querytree_context);\n\n\tqlist = copyObject(tlist);\n\n\t/*\n\t * Use the planner machinery to extract dependencies.  Data is saved in\n\t * query_context.  (We assume that not a lot of extra cruft is created by\n\t * this call.)\n\t */\n\textract_query_dependencies((Node *) qlist,\n\t\t\t\t\t\t\t   &plansource->relationOids,\n\t\t\t\t\t\t\t   &plansource->invalItems,\n\t\t\t\t\t\t\t   &plansource->dependsOnRLS);\n\n\t/* Update RLS info as well. */\n\tplansource->rewriteRoleId = GetUserId();\n\tplansource->rewriteRowSecurity = row_security;\n\n\t/*\n\t * Also save the current search_path in the query_context.  (This should\n\t * not generate much extra cruft either, since almost certainly the path\n\t * is already valid.)\n\t */\n\tplansource->search_path = GetOverrideSearchPath(querytree_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Now reparent the finished query_context and save the links */\n\tMemoryContextSetParent(querytree_context, plansource->context);\n\n\tplansource->query_context = querytree_context;\n\tplansource->query_list = qlist;\n\n\t/*\n\t * Note: we do not reset generic_cost or total_custom_cost, although we\n\t * could choose to do so.  If the DDL or statistics change that prompted\n\t * the invalidation meant a significant change in the cost estimates, it\n\t * would be better to reset those variables and start fresh; but often it\n\t * doesn't, and we're better retaining our hard-won knowledge about the\n\t * relative costs.\n\t */\n\n\tplansource->is_valid = true;\n\n\t/* Return transient copy of querytrees for possible use in planning */\n\treturn tlist;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);",
            "static CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);",
            "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
            "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
            "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
            "static bool ScanQueryWalker(Node *node, bool *acquire);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\n\nstatic List *\nRevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv)\n{\n\tbool\t\tsnapshot_set;\n\tRawStmt    *rawtree;\n\tList\t   *tlist;\t\t\t/* transient query-tree list */\n\tList\t   *qlist;\t\t\t/* permanent query-tree list */\n\tTupleDesc\tresultDesc;\n\tMemoryContext querytree_context;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * For one-shot plans, we do not support revalidation checking; it's\n\t * assumed the query is parsed, planned, and executed in one transaction,\n\t * so that no lock re-acquisition is necessary.  Also, there is never any\n\t * need to revalidate plans for transaction control commands (and we\n\t * mustn't risk any catalog accesses when handling those).\n\t */\n\tif (plansource->is_oneshot || IsTransactionStmtPlan(plansource))\n\t{\n\t\tAssert(plansource->is_valid);\n\t\treturn NIL;\n\t}\n\n\t/*\n\t * If the query is currently valid, we should have a saved search_path ---\n\t * check to see if that matches the current environment.  If not, we want\n\t * to force replan.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAssert(plansource->search_path != NULL);\n\t\tif (!OverrideSearchPathMatchesCurrent(plansource->search_path))\n\t\t{\n\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\tplansource->is_valid = false;\n\t\t\tif (plansource->gplan)\n\t\t\t\tplansource->gplan->is_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * If the query rewrite phase had a possible RLS dependency, we must redo\n\t * it if either the role or the row_security setting has changed.\n\t */\n\tif (plansource->is_valid && plansource->dependsOnRLS &&\n\t\t(plansource->rewriteRoleId != GetUserId() ||\n\t\t plansource->rewriteRowSecurity != row_security))\n\t\tplansource->is_valid = false;\n\n\t/*\n\t * If the query is currently valid, acquire locks on the referenced\n\t * objects; then check again.  We need to do it this way to cover the race\n\t * condition that an invalidation message arrives before we get the locks.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAcquirePlannerLocks(plansource->query_list, true);\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the query invalid.\n\t\t */\n\t\tif (plansource->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn NIL;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquirePlannerLocks(plansource->query_list, false);\n\t}\n\n\t/*\n\t * Discard the no-longer-useful query tree.  (Note: we don't want to do\n\t * this any earlier, else we'd not have been able to release locks\n\t * correctly in the race condition case.)\n\t */\n\tplansource->is_valid = false;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\n\t/*\n\t * Free the query_context.  We don't really expect MemoryContextDelete to\n\t * fail, but just in case, make sure the CachedPlanSource is left in a\n\t * reasonably sane state.  (The generic plan won't get unlinked yet, but\n\t * that's acceptable.)\n\t */\n\tif (plansource->query_context)\n\t{\n\t\tMemoryContext qcxt = plansource->query_context;\n\n\t\tplansource->query_context = NULL;\n\t\tMemoryContextDelete(qcxt);\n\t}\n\n\t/* Drop the generic plan reference if any */\n\tReleaseGenericPlan(plansource);\n\n\t/*\n\t * Now re-do parse analysis and rewrite.  This not incidentally acquires\n\t * the locks we need to do planning safely.\n\t */\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for parsing/planning.  But if it isn't, install one.  Note: no point in\n\t * checking whether parse analysis requires a snapshot; utility commands\n\t * don't have invalidatable plans, so we'd not get here for such a\n\t * command.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet())\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Run parse analysis and rule rewriting.  The parser tends to scribble on\n\t * its input, so we must copy the raw parse tree to prevent corruption of\n\t * the cache.\n\t */\n\trawtree = copyObject(plansource->raw_parse_tree);\n\tif (rawtree == NULL)\n\t\ttlist = NIL;\n\telse if (plansource->parserSetup != NULL)\n\t\ttlist = pg_analyze_and_rewrite_params(rawtree,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->query_string,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetup,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetupArg,\n\t\t\t\t\t\t\t\t\t\t\t  queryEnv);\n\telse\n\t\ttlist = pg_analyze_and_rewrite(rawtree,\n\t\t\t\t\t\t\t\t\t   plansource->query_string,\n\t\t\t\t\t\t\t\t\t   plansource->param_types,\n\t\t\t\t\t\t\t\t\t   plansource->num_params,\n\t\t\t\t\t\t\t\t\t   queryEnv);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Check or update the result tupdesc.  XXX should we use a weaker\n\t * condition than equalTupleDescs() here?\n\t *\n\t * We assume the parameter types didn't change from the first time, so no\n\t * need to update that.\n\t */\n\tresultDesc = PlanCacheComputeResultDesc(tlist);\n\tif (resultDesc == NULL && plansource->resultDesc == NULL)\n\t{\n\t\t/* OK, doesn't return tuples */\n\t}\n\telse if (resultDesc == NULL || plansource->resultDesc == NULL ||\n\t\t\t !equalTupleDescs(resultDesc, plansource->resultDesc))\n\t{\n\t\t/* can we give a better error message? */\n\t\tif (plansource->fixed_result)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cached plan must not change result type\")));\n\t\toldcxt = MemoryContextSwitchTo(plansource->context);\n\t\tif (resultDesc)\n\t\t\tresultDesc = CreateTupleDescCopy(resultDesc);\n\t\tif (plansource->resultDesc)\n\t\t\tFreeTupleDesc(plansource->resultDesc);\n\t\tplansource->resultDesc = resultDesc;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Allocate new query_context and copy the completed querytree into it.\n\t * It's transient until we complete the copying and dependency extraction.\n\t */\n\tquerytree_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\toldcxt = MemoryContextSwitchTo(querytree_context);\n\n\tqlist = copyObject(tlist);\n\n\t/*\n\t * Use the planner machinery to extract dependencies.  Data is saved in\n\t * query_context.  (We assume that not a lot of extra cruft is created by\n\t * this call.)\n\t */\n\textract_query_dependencies((Node *) qlist,\n\t\t\t\t\t\t\t   &plansource->relationOids,\n\t\t\t\t\t\t\t   &plansource->invalItems,\n\t\t\t\t\t\t\t   &plansource->dependsOnRLS);\n\n\t/* Update RLS info as well. */\n\tplansource->rewriteRoleId = GetUserId();\n\tplansource->rewriteRowSecurity = row_security;\n\n\t/*\n\t * Also save the current search_path in the query_context.  (This should\n\t * not generate much extra cruft either, since almost certainly the path\n\t * is already valid.)\n\t */\n\tplansource->search_path = GetOverrideSearchPath(querytree_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Now reparent the finished query_context and save the links */\n\tMemoryContextSetParent(querytree_context, plansource->context);\n\n\tplansource->query_context = querytree_context;\n\tplansource->query_list = qlist;\n\n\t/*\n\t * Note: we do not reset generic_cost or total_custom_cost, although we\n\t * could choose to do so.  If the DDL or statistics change that prompted\n\t * the invalidation meant a significant change in the cost estimates, it\n\t * would be better to reset those variables and start fresh; but often it\n\t * doesn't, and we're better retaining our hard-won knowledge about the\n\t * relative costs.\n\t */\n\n\tplansource->is_valid = true;\n\n\t/* Return transient copy of querytrees for possible use in planning */\n\treturn tlist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->is_complete"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);\n\nList *\nCachedPlanGetTargetList(CachedPlanSource *plansource,\n\t\t\t\t\t\tQueryEnvironment *queryEnv)\n{\n\tQuery\t   *pstmt;\n\n\t/* Assert caller is doing things in a sane order */\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * No work needed if statement doesn't return tuples (we assume this\n\t * feature cannot be changed by an invalidation)\n\t */\n\tif (plansource->resultDesc == NULL)\n\t\treturn NIL;\n\n\t/* Make sure the querytree list is valid and we have parse-time locks */\n\tRevalidateCachedQuery(plansource, queryEnv);\n\n\t/* Get the primary statement and find out what it returns */\n\tpstmt = QueryListGetPrimaryStmt(plansource->query_list);\n\n\treturn FetchStatementTargetList((Node *) pstmt);\n}"
  },
  {
    "function_name": "CachedPlanIsValid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1414-1419",
    "snippet": "bool\nCachedPlanIsValid(CachedPlanSource *plansource)\n{\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\treturn plansource->is_valid;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nbool\nCachedPlanIsValid(CachedPlanSource *plansource)\n{\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\treturn plansource->is_valid;\n}"
  },
  {
    "function_name": "CopyCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1323-1404",
    "snippet": "CachedPlanSource *\nCopyCachedPlan(CachedPlanSource *plansource)\n{\n\tCachedPlanSource *newsource;\n\tMemoryContext source_context;\n\tMemoryContext querytree_context;\n\tMemoryContext oldcxt;\n\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * One-shot plans can't be copied, because we haven't taken care that\n\t * parsing/planning didn't scribble on the raw parse tree or querytrees.\n\t */\n\tif (plansource->is_oneshot)\n\t\telog(ERROR, \"cannot copy a one-shot cached plan\");\n\n\tsource_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"CachedPlanSource\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\toldcxt = MemoryContextSwitchTo(source_context);\n\n\tnewsource = (CachedPlanSource *) palloc0(sizeof(CachedPlanSource));\n\tnewsource->magic = CACHEDPLANSOURCE_MAGIC;\n\tnewsource->raw_parse_tree = copyObject(plansource->raw_parse_tree);\n\tnewsource->query_string = pstrdup(plansource->query_string);\n\tMemoryContextSetIdentifier(source_context, newsource->query_string);\n\tnewsource->commandTag = plansource->commandTag;\n\tif (plansource->num_params > 0)\n\t{\n\t\tnewsource->param_types = (Oid *)\n\t\t\tpalloc(plansource->num_params * sizeof(Oid));\n\t\tmemcpy(newsource->param_types, plansource->param_types,\n\t\t\t   plansource->num_params * sizeof(Oid));\n\t}\n\telse\n\t\tnewsource->param_types = NULL;\n\tnewsource->num_params = plansource->num_params;\n\tnewsource->parserSetup = plansource->parserSetup;\n\tnewsource->parserSetupArg = plansource->parserSetupArg;\n\tnewsource->cursor_options = plansource->cursor_options;\n\tnewsource->fixed_result = plansource->fixed_result;\n\tif (plansource->resultDesc)\n\t\tnewsource->resultDesc = CreateTupleDescCopy(plansource->resultDesc);\n\telse\n\t\tnewsource->resultDesc = NULL;\n\tnewsource->context = source_context;\n\n\tquerytree_context = AllocSetContextCreate(source_context,\n\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\tMemoryContextSwitchTo(querytree_context);\n\tnewsource->query_list = copyObject(plansource->query_list);\n\tnewsource->relationOids = copyObject(plansource->relationOids);\n\tnewsource->invalItems = copyObject(plansource->invalItems);\n\tif (plansource->search_path)\n\t\tnewsource->search_path = CopyOverrideSearchPath(plansource->search_path);\n\tnewsource->query_context = querytree_context;\n\tnewsource->rewriteRoleId = plansource->rewriteRoleId;\n\tnewsource->rewriteRowSecurity = plansource->rewriteRowSecurity;\n\tnewsource->dependsOnRLS = plansource->dependsOnRLS;\n\n\tnewsource->gplan = NULL;\n\n\tnewsource->is_oneshot = false;\n\tnewsource->is_complete = true;\n\tnewsource->is_saved = false;\n\tnewsource->is_valid = plansource->is_valid;\n\tnewsource->generation = plansource->generation;\n\tnewsource->next_saved = NULL;\n\n\t/* We may as well copy any acquired cost knowledge */\n\tnewsource->generic_cost = plansource->generic_cost;\n\tnewsource->total_custom_cost = plansource->total_custom_cost;\n\tnewsource->num_custom_plans = plansource->num_custom_plans;\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn newsource;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CopyOverrideSearchPath",
          "args": [
            "plansource->search_path"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "plansource->invalItems"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "plansource->relationOids"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "plansource->query_list"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "querytree_context"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "source_context",
            "\"CachedPlanQuery\"",
            "ALLOCSET_START_SMALL_SIZES"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "plansource->resultDesc"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newsource->param_types",
            "plansource->param_types",
            "plansource->num_params * sizeof(Oid)"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "plansource->num_params * sizeof(Oid)"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSetIdentifier",
          "args": [
            "source_context",
            "newsource->query_string"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextSetIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "328-333",
          "snippet": "void\nMemoryContextSetIdentifier(MemoryContext context, const char *id)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tcontext->ident = id;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextSetIdentifier(MemoryContext context, const char *id)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tcontext->ident = id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "plansource->query_string"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "plansource->raw_parse_tree"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "source_context"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"CachedPlanSource\"",
            "ALLOCSET_START_SMALL_SIZES"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot copy a one-shot cached plan\""
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->is_complete"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nCachedPlanSource *\nCopyCachedPlan(CachedPlanSource *plansource)\n{\n\tCachedPlanSource *newsource;\n\tMemoryContext source_context;\n\tMemoryContext querytree_context;\n\tMemoryContext oldcxt;\n\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * One-shot plans can't be copied, because we haven't taken care that\n\t * parsing/planning didn't scribble on the raw parse tree or querytrees.\n\t */\n\tif (plansource->is_oneshot)\n\t\telog(ERROR, \"cannot copy a one-shot cached plan\");\n\n\tsource_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"CachedPlanSource\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\toldcxt = MemoryContextSwitchTo(source_context);\n\n\tnewsource = (CachedPlanSource *) palloc0(sizeof(CachedPlanSource));\n\tnewsource->magic = CACHEDPLANSOURCE_MAGIC;\n\tnewsource->raw_parse_tree = copyObject(plansource->raw_parse_tree);\n\tnewsource->query_string = pstrdup(plansource->query_string);\n\tMemoryContextSetIdentifier(source_context, newsource->query_string);\n\tnewsource->commandTag = plansource->commandTag;\n\tif (plansource->num_params > 0)\n\t{\n\t\tnewsource->param_types = (Oid *)\n\t\t\tpalloc(plansource->num_params * sizeof(Oid));\n\t\tmemcpy(newsource->param_types, plansource->param_types,\n\t\t\t   plansource->num_params * sizeof(Oid));\n\t}\n\telse\n\t\tnewsource->param_types = NULL;\n\tnewsource->num_params = plansource->num_params;\n\tnewsource->parserSetup = plansource->parserSetup;\n\tnewsource->parserSetupArg = plansource->parserSetupArg;\n\tnewsource->cursor_options = plansource->cursor_options;\n\tnewsource->fixed_result = plansource->fixed_result;\n\tif (plansource->resultDesc)\n\t\tnewsource->resultDesc = CreateTupleDescCopy(plansource->resultDesc);\n\telse\n\t\tnewsource->resultDesc = NULL;\n\tnewsource->context = source_context;\n\n\tquerytree_context = AllocSetContextCreate(source_context,\n\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\tMemoryContextSwitchTo(querytree_context);\n\tnewsource->query_list = copyObject(plansource->query_list);\n\tnewsource->relationOids = copyObject(plansource->relationOids);\n\tnewsource->invalItems = copyObject(plansource->invalItems);\n\tif (plansource->search_path)\n\t\tnewsource->search_path = CopyOverrideSearchPath(plansource->search_path);\n\tnewsource->query_context = querytree_context;\n\tnewsource->rewriteRoleId = plansource->rewriteRoleId;\n\tnewsource->rewriteRowSecurity = plansource->rewriteRowSecurity;\n\tnewsource->dependsOnRLS = plansource->dependsOnRLS;\n\n\tnewsource->gplan = NULL;\n\n\tnewsource->is_oneshot = false;\n\tnewsource->is_complete = true;\n\tnewsource->is_saved = false;\n\tnewsource->is_valid = plansource->is_valid;\n\tnewsource->generation = plansource->generation;\n\tnewsource->next_saved = NULL;\n\n\t/* We may as well copy any acquired cost knowledge */\n\tnewsource->generic_cost = plansource->generic_cost;\n\tnewsource->total_custom_cost = plansource->total_custom_cost;\n\tnewsource->num_custom_plans = plansource->num_custom_plans;\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn newsource;\n}"
  },
  {
    "function_name": "CachedPlanSetParentContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1285-1312",
    "snippet": "void\nCachedPlanSetParentContext(CachedPlanSource *plansource,\n\t\t\t\t\t\t   MemoryContext newcontext)\n{\n\t/* Assert caller is doing things in a sane order */\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(plansource->is_complete);\n\n\t/* These seem worth real tests, though */\n\tif (plansource->is_saved)\n\t\telog(ERROR, \"cannot move a saved cached plan to another context\");\n\tif (plansource->is_oneshot)\n\t\telog(ERROR, \"cannot move a one-shot cached plan to another context\");\n\n\t/* OK, let the caller keep the plan where he wishes */\n\tMemoryContextSetParent(plansource->context, newcontext);\n\n\t/*\n\t * The query_context needs no special handling, since it's a child of\n\t * plansource->context.  But if there's a generic plan, it should be\n\t * maintained as a sibling of plansource->context.\n\t */\n\tif (plansource->gplan)\n\t{\n\t\tAssert(plansource->gplan->magic == CACHEDPLAN_MAGIC);\n\t\tMemoryContextSetParent(plansource->gplan->context, newcontext);\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSetParent",
          "args": [
            "plansource->gplan->context",
            "newcontext"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextSetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "353-397",
          "snippet": "void\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->gplan->magic == CACHEDPLAN_MAGIC"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot move a one-shot cached plan to another context\""
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->is_complete"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nvoid\nCachedPlanSetParentContext(CachedPlanSource *plansource,\n\t\t\t\t\t\t   MemoryContext newcontext)\n{\n\t/* Assert caller is doing things in a sane order */\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(plansource->is_complete);\n\n\t/* These seem worth real tests, though */\n\tif (plansource->is_saved)\n\t\telog(ERROR, \"cannot move a saved cached plan to another context\");\n\tif (plansource->is_oneshot)\n\t\telog(ERROR, \"cannot move a one-shot cached plan to another context\");\n\n\t/* OK, let the caller keep the plan where he wishes */\n\tMemoryContextSetParent(plansource->context, newcontext);\n\n\t/*\n\t * The query_context needs no special handling, since it's a child of\n\t * plansource->context.  But if there's a generic plan, it should be\n\t * maintained as a sibling of plansource->context.\n\t */\n\tif (plansource->gplan)\n\t{\n\t\tAssert(plansource->gplan->magic == CACHEDPLAN_MAGIC);\n\t\tMemoryContextSetParent(plansource->gplan->context, newcontext);\n\t}\n}"
  },
  {
    "function_name": "ReleaseCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1257-1277",
    "snippet": "void\nReleaseCachedPlan(CachedPlan *plan, bool useResOwner)\n{\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\tif (useResOwner)\n\t{\n\t\tAssert(plan->is_saved);\n\t\tResourceOwnerForgetPlanCacheRef(CurrentResourceOwner, plan);\n\t}\n\tAssert(plan->refcount > 0);\n\tplan->refcount--;\n\tif (plan->refcount == 0)\n\t{\n\t\t/* Mark it no longer valid */\n\t\tplan->magic = 0;\n\n\t\t/* One-shot plans do not own their context, so we can't free them */\n\t\tif (!plan->is_oneshot)\n\t\t\tMemoryContextDelete(plan->context);\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "plan->context"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plan->refcount > 0"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerForgetPlanCacheRef",
          "args": [
            "CurrentResourceOwner",
            "plan"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerForgetPlanCacheRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1071-1077",
          "snippet": "void\nResourceOwnerForgetPlanCacheRef(ResourceOwner owner, CachedPlan *plan)\n{\n\tif (!ResourceArrayRemove(&(owner->planrefarr), PointerGetDatum(plan)))\n\t\telog(ERROR, \"plancache reference %p is not owned by resource owner %s\",\n\t\t\t plan, owner->name);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintPlanCacheLeakWarning(CachedPlan *plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintPlanCacheLeakWarning(CachedPlan *plan);\n\nvoid\nResourceOwnerForgetPlanCacheRef(ResourceOwner owner, CachedPlan *plan)\n{\n\tif (!ResourceArrayRemove(&(owner->planrefarr), PointerGetDatum(plan)))\n\t\telog(ERROR, \"plancache reference %p is not owned by resource owner %s\",\n\t\t\t plan, owner->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plan->is_saved"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plan->magic == CACHEDPLAN_MAGIC"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nReleaseCachedPlan(CachedPlan *plan, bool useResOwner)\n{\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\tif (useResOwner)\n\t{\n\t\tAssert(plan->is_saved);\n\t\tResourceOwnerForgetPlanCacheRef(CurrentResourceOwner, plan);\n\t}\n\tAssert(plan->refcount > 0);\n\tplan->refcount--;\n\tif (plan->refcount == 0)\n\t{\n\t\t/* Mark it no longer valid */\n\t\tplan->magic = 0;\n\n\t\t/* One-shot plans do not own their context, so we can't free them */\n\t\tif (!plan->is_oneshot)\n\t\t\tMemoryContextDelete(plan->context);\n\t}\n}"
  },
  {
    "function_name": "GetCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1136-1244",
    "snippet": "CachedPlan *\nGetCachedPlan(CachedPlanSource *plansource, ParamListInfo boundParams,\n\t\t\t  bool useResOwner, QueryEnvironment *queryEnv)\n{\n\tCachedPlan *plan = NULL;\n\tList\t   *qlist;\n\tbool\t\tcustomplan;\n\n\t/* Assert caller is doing things in a sane order */\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(plansource->is_complete);\n\t/* This seems worth a real test, though */\n\tif (useResOwner && !plansource->is_saved)\n\t\telog(ERROR, \"cannot apply ResourceOwner to non-saved cached plan\");\n\n\t/* Make sure the querytree list is valid and we have parse-time locks */\n\tqlist = RevalidateCachedQuery(plansource, queryEnv);\n\n\t/* Decide whether to use a custom plan */\n\tcustomplan = choose_custom_plan(plansource, boundParams);\n\n\tif (!customplan)\n\t{\n\t\tif (CheckCachedPlan(plansource))\n\t\t{\n\t\t\t/* We want a generic plan, and we already have a valid one */\n\t\t\tplan = plansource->gplan;\n\t\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Build a new generic plan */\n\t\t\tplan = BuildCachedPlan(plansource, qlist, NULL, queryEnv);\n\t\t\t/* Just make real sure plansource->gplan is clear */\n\t\t\tReleaseGenericPlan(plansource);\n\t\t\t/* Link the new generic plan into the plansource */\n\t\t\tplansource->gplan = plan;\n\t\t\tplan->refcount++;\n\t\t\t/* Immediately reparent into appropriate context */\n\t\t\tif (plansource->is_saved)\n\t\t\t{\n\t\t\t\t/* saved plans all live under CacheMemoryContext */\n\t\t\t\tMemoryContextSetParent(plan->context, CacheMemoryContext);\n\t\t\t\tplan->is_saved = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* otherwise, it should be a sibling of the plansource */\n\t\t\t\tMemoryContextSetParent(plan->context,\n\t\t\t\t\t\t\t\t\t   MemoryContextGetParent(plansource->context));\n\t\t\t}\n\t\t\t/* Update generic_cost whenever we make a new generic plan */\n\t\t\tplansource->generic_cost = cached_plan_cost(plan, false);\n\n\t\t\t/*\n\t\t\t * If, based on the now-known value of generic_cost, we'd not have\n\t\t\t * chosen to use a generic plan, then forget it and make a custom\n\t\t\t * plan.  This is a bit of a wart but is necessary to avoid a\n\t\t\t * glitch in behavior when the custom plans are consistently big\n\t\t\t * winners; at some point we'll experiment with a generic plan and\n\t\t\t * find it's a loser, but we don't want to actually execute that\n\t\t\t * plan.\n\t\t\t */\n\t\t\tcustomplan = choose_custom_plan(plansource, boundParams);\n\n\t\t\t/*\n\t\t\t * If we choose to plan again, we need to re-copy the query_list,\n\t\t\t * since the planner probably scribbled on it.  We can force\n\t\t\t * BuildCachedPlan to do that by passing NIL.\n\t\t\t */\n\t\t\tqlist = NIL;\n\t\t}\n\t}\n\n\tif (customplan)\n\t{\n\t\t/* Build a custom plan */\n\t\tplan = BuildCachedPlan(plansource, qlist, boundParams, queryEnv);\n\t\t/* Accumulate total costs of custom plans, but 'ware overflow */\n\t\tif (plansource->num_custom_plans < INT_MAX)\n\t\t{\n\t\t\tplansource->total_custom_cost += cached_plan_cost(plan, true);\n\t\t\tplansource->num_custom_plans++;\n\t\t}\n\t}\n\n\tAssert(plan != NULL);\n\n\t/* Flag the plan as in use by caller */\n\tif (useResOwner)\n\t\tResourceOwnerEnlargePlanCacheRefs(CurrentResourceOwner);\n\tplan->refcount++;\n\tif (useResOwner)\n\t\tResourceOwnerRememberPlanCacheRef(CurrentResourceOwner, plan);\n\n\t/*\n\t * Saved plans should be under CacheMemoryContext so they will not go away\n\t * until their reference count goes to zero.  In the generic-plan cases we\n\t * already took care of that, but for a custom plan, do it as soon as we\n\t * have created a reference-counted link.\n\t */\n\tif (customplan && plansource->is_saved)\n\t{\n\t\tMemoryContextSetParent(plan->context, CacheMemoryContext);\n\t\tplan->is_saved = true;\n\t}\n\n\treturn plan;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);",
      "static CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);",
      "static bool choose_custom_plan(CachedPlanSource *plansource,\n\t\t\t\t   ParamListInfo boundParams);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSetParent",
          "args": [
            "plan->context",
            "CacheMemoryContext"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextSetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "353-397",
          "snippet": "void\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerRememberPlanCacheRef",
          "args": [
            "CurrentResourceOwner",
            "plan"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerRememberPlanCacheRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1062-1066",
          "snippet": "void\nResourceOwnerRememberPlanCacheRef(ResourceOwner owner, CachedPlan *plan)\n{\n\tResourceArrayAdd(&(owner->planrefarr), PointerGetDatum(plan));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintPlanCacheLeakWarning(CachedPlan *plan);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintPlanCacheLeakWarning(CachedPlan *plan);\n\nvoid\nResourceOwnerRememberPlanCacheRef(ResourceOwner owner, CachedPlan *plan)\n{\n\tResourceArrayAdd(&(owner->planrefarr), PointerGetDatum(plan));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResourceOwnerEnlargePlanCacheRefs",
          "args": [
            "CurrentResourceOwner"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerEnlargePlanCacheRefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1051-1055",
          "snippet": "void\nResourceOwnerEnlargePlanCacheRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->planrefarr));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargePlanCacheRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->planrefarr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plan != NULL"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cached_plan_cost",
          "args": [
            "plan",
            "true"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "cached_plan_cost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1071-1116",
          "snippet": "static double\ncached_plan_cost(CachedPlan *plan, bool include_planner)\n{\n\tdouble\t\tresult = 0;\n\tListCell   *lc;\n\n\tforeach(lc, plan->stmt_list)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\tcontinue;\t\t\t/* Ignore utility statements */\n\n\t\tresult += plannedstmt->planTree->total_cost;\n\n\t\tif (include_planner)\n\t\t{\n\t\t\t/*\n\t\t\t * Currently we use a very crude estimate of planning effort based\n\t\t\t * on the number of relations in the finished plan's rangetable.\n\t\t\t * Join planning effort actually scales much worse than linearly\n\t\t\t * in the number of relations --- but only until the join collapse\n\t\t\t * limits kick in.  Also, while inheritance child relations surely\n\t\t\t * add to planning effort, they don't make the join situation\n\t\t\t * worse.  So the actual shape of the planning cost curve versus\n\t\t\t * number of relations isn't all that obvious.  It will take\n\t\t\t * considerable work to arrive at a less crude estimate, and for\n\t\t\t * now it's not clear that's worth doing.\n\t\t\t *\n\t\t\t * The other big difficulty here is that we don't have any very\n\t\t\t * good model of how planning cost compares to execution costs.\n\t\t\t * The current multiplier of 1000 * cpu_operator_cost is probably\n\t\t\t * on the low side, but we'll try this for awhile before making a\n\t\t\t * more aggressive correction.\n\t\t\t *\n\t\t\t * If we ever do write a more complicated estimator, it should\n\t\t\t * probably live in src/backend/optimizer/ not here.\n\t\t\t */\n\t\t\tint\t\t\tnrelations = list_length(plannedstmt->rtable);\n\n\t\t\tresult += 1000.0 * cpu_operator_cost * (nrelations + 1);\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double cached_plan_cost(CachedPlan *plan, bool include_planner);",
            "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic double cached_plan_cost(CachedPlan *plan, bool include_planner);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic double\ncached_plan_cost(CachedPlan *plan, bool include_planner)\n{\n\tdouble\t\tresult = 0;\n\tListCell   *lc;\n\n\tforeach(lc, plan->stmt_list)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\tcontinue;\t\t\t/* Ignore utility statements */\n\n\t\tresult += plannedstmt->planTree->total_cost;\n\n\t\tif (include_planner)\n\t\t{\n\t\t\t/*\n\t\t\t * Currently we use a very crude estimate of planning effort based\n\t\t\t * on the number of relations in the finished plan's rangetable.\n\t\t\t * Join planning effort actually scales much worse than linearly\n\t\t\t * in the number of relations --- but only until the join collapse\n\t\t\t * limits kick in.  Also, while inheritance child relations surely\n\t\t\t * add to planning effort, they don't make the join situation\n\t\t\t * worse.  So the actual shape of the planning cost curve versus\n\t\t\t * number of relations isn't all that obvious.  It will take\n\t\t\t * considerable work to arrive at a less crude estimate, and for\n\t\t\t * now it's not clear that's worth doing.\n\t\t\t *\n\t\t\t * The other big difficulty here is that we don't have any very\n\t\t\t * good model of how planning cost compares to execution costs.\n\t\t\t * The current multiplier of 1000 * cpu_operator_cost is probably\n\t\t\t * on the low side, but we'll try this for awhile before making a\n\t\t\t * more aggressive correction.\n\t\t\t *\n\t\t\t * If we ever do write a more complicated estimator, it should\n\t\t\t * probably live in src/backend/optimizer/ not here.\n\t\t\t */\n\t\t\tint\t\t\tnrelations = list_length(plannedstmt->rtable);\n\n\t\t\tresult += 1000.0 * cpu_operator_cost * (nrelations + 1);\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BuildCachedPlan",
          "args": [
            "plansource",
            "qlist",
            "boundParams",
            "queryEnv"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "BuildCachedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "881-1013",
          "snippet": "static CachedPlan *\nBuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv)\n{\n\tCachedPlan *plan;\n\tList\t   *plist;\n\tbool\t\tsnapshot_set;\n\tbool\t\tis_transient;\n\tMemoryContext plan_context;\n\tMemoryContext oldcxt = CurrentMemoryContext;\n\tListCell   *lc;\n\n\t/*\n\t * Normally the querytree should be valid already, but if it's not,\n\t * rebuild it.\n\t *\n\t * NOTE: GetCachedPlan should have called RevalidateCachedQuery first, so\n\t * we ought to be holding sufficient locks to prevent any invalidation.\n\t * However, if we're building a custom plan after having built and\n\t * rejected a generic plan, it's possible to reach here with is_valid\n\t * false due to an invalidation while making the generic plan.  In theory\n\t * the invalidation must be a false positive, perhaps a consequence of an\n\t * sinval reset event or the CLOBBER_CACHE_ALWAYS debug code.  But for\n\t * safety, let's treat it as real and redo the RevalidateCachedQuery call.\n\t */\n\tif (!plansource->is_valid)\n\t\tqlist = RevalidateCachedQuery(plansource, queryEnv);\n\n\t/*\n\t * If we don't already have a copy of the querytree list that can be\n\t * scribbled on by the planner, make one.  For a one-shot plan, we assume\n\t * it's okay to scribble on the original query_list.\n\t */\n\tif (qlist == NIL)\n\t{\n\t\tif (!plansource->is_oneshot)\n\t\t\tqlist = copyObject(plansource->query_list);\n\t\telse\n\t\t\tqlist = plansource->query_list;\n\t}\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for planning.  But if it isn't, and we need one, install one.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet() &&\n\t\tplansource->raw_parse_tree &&\n\t\tanalyze_requires_snapshot(plansource->raw_parse_tree))\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Generate the plan.\n\t */\n\tplist = pg_plan_queries(qlist, plansource->cursor_options, boundParams);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Normally we make a dedicated memory context for the CachedPlan and its\n\t * subsidiary data.  (It's probably not going to be large, but just in\n\t * case, allow it to grow large.  It's transient for the moment.)  But for\n\t * a one-shot plan, we just leave it in the caller's memory context.\n\t */\n\tif (!plansource->is_oneshot)\n\t{\n\t\tplan_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"CachedPlan\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_START_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(plan_context, plansource->query_string);\n\n\t\t/*\n\t\t * Copy plan into the new context.\n\t\t */\n\t\tMemoryContextSwitchTo(plan_context);\n\n\t\tplist = copyObject(plist);\n\t}\n\telse\n\t\tplan_context = CurrentMemoryContext;\n\n\t/*\n\t * Create and fill the CachedPlan struct within the new context.\n\t */\n\tplan = (CachedPlan *) palloc(sizeof(CachedPlan));\n\tplan->magic = CACHEDPLAN_MAGIC;\n\tplan->stmt_list = plist;\n\n\t/*\n\t * CachedPlan is dependent on role either if RLS affected the rewrite\n\t * phase or if a role dependency was injected during planning.  And it's\n\t * transient if any plan is marked so.\n\t */\n\tplan->planRoleId = GetUserId();\n\tplan->dependsOnRole = plansource->dependsOnRLS;\n\tis_transient = false;\n\tforeach(lc, plist)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\tcontinue;\t\t\t/* Ignore utility statements */\n\n\t\tif (plannedstmt->transientPlan)\n\t\t\tis_transient = true;\n\t\tif (plannedstmt->dependsOnRole)\n\t\t\tplan->dependsOnRole = true;\n\t}\n\tif (is_transient)\n\t{\n\t\tAssert(TransactionIdIsNormal(TransactionXmin));\n\t\tplan->saved_xmin = TransactionXmin;\n\t}\n\telse\n\t\tplan->saved_xmin = InvalidTransactionId;\n\tplan->refcount = 0;\n\tplan->context = plan_context;\n\tplan->is_oneshot = plansource->is_oneshot;\n\tplan->is_saved = false;\n\tplan->is_valid = true;\n\n\t/* assign generation number to new plan */\n\tplan->generation = ++(plansource->generation);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn plan;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);",
            "static CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);",
            "static bool choose_custom_plan(CachedPlanSource *plansource,\n\t\t\t\t   ParamListInfo boundParams);",
            "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);\nstatic bool choose_custom_plan(CachedPlanSource *plansource,\n\t\t\t\t   ParamListInfo boundParams);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic CachedPlan *\nBuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv)\n{\n\tCachedPlan *plan;\n\tList\t   *plist;\n\tbool\t\tsnapshot_set;\n\tbool\t\tis_transient;\n\tMemoryContext plan_context;\n\tMemoryContext oldcxt = CurrentMemoryContext;\n\tListCell   *lc;\n\n\t/*\n\t * Normally the querytree should be valid already, but if it's not,\n\t * rebuild it.\n\t *\n\t * NOTE: GetCachedPlan should have called RevalidateCachedQuery first, so\n\t * we ought to be holding sufficient locks to prevent any invalidation.\n\t * However, if we're building a custom plan after having built and\n\t * rejected a generic plan, it's possible to reach here with is_valid\n\t * false due to an invalidation while making the generic plan.  In theory\n\t * the invalidation must be a false positive, perhaps a consequence of an\n\t * sinval reset event or the CLOBBER_CACHE_ALWAYS debug code.  But for\n\t * safety, let's treat it as real and redo the RevalidateCachedQuery call.\n\t */\n\tif (!plansource->is_valid)\n\t\tqlist = RevalidateCachedQuery(plansource, queryEnv);\n\n\t/*\n\t * If we don't already have a copy of the querytree list that can be\n\t * scribbled on by the planner, make one.  For a one-shot plan, we assume\n\t * it's okay to scribble on the original query_list.\n\t */\n\tif (qlist == NIL)\n\t{\n\t\tif (!plansource->is_oneshot)\n\t\t\tqlist = copyObject(plansource->query_list);\n\t\telse\n\t\t\tqlist = plansource->query_list;\n\t}\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for planning.  But if it isn't, and we need one, install one.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet() &&\n\t\tplansource->raw_parse_tree &&\n\t\tanalyze_requires_snapshot(plansource->raw_parse_tree))\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Generate the plan.\n\t */\n\tplist = pg_plan_queries(qlist, plansource->cursor_options, boundParams);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Normally we make a dedicated memory context for the CachedPlan and its\n\t * subsidiary data.  (It's probably not going to be large, but just in\n\t * case, allow it to grow large.  It's transient for the moment.)  But for\n\t * a one-shot plan, we just leave it in the caller's memory context.\n\t */\n\tif (!plansource->is_oneshot)\n\t{\n\t\tplan_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"CachedPlan\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_START_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(plan_context, plansource->query_string);\n\n\t\t/*\n\t\t * Copy plan into the new context.\n\t\t */\n\t\tMemoryContextSwitchTo(plan_context);\n\n\t\tplist = copyObject(plist);\n\t}\n\telse\n\t\tplan_context = CurrentMemoryContext;\n\n\t/*\n\t * Create and fill the CachedPlan struct within the new context.\n\t */\n\tplan = (CachedPlan *) palloc(sizeof(CachedPlan));\n\tplan->magic = CACHEDPLAN_MAGIC;\n\tplan->stmt_list = plist;\n\n\t/*\n\t * CachedPlan is dependent on role either if RLS affected the rewrite\n\t * phase or if a role dependency was injected during planning.  And it's\n\t * transient if any plan is marked so.\n\t */\n\tplan->planRoleId = GetUserId();\n\tplan->dependsOnRole = plansource->dependsOnRLS;\n\tis_transient = false;\n\tforeach(lc, plist)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\tcontinue;\t\t\t/* Ignore utility statements */\n\n\t\tif (plannedstmt->transientPlan)\n\t\t\tis_transient = true;\n\t\tif (plannedstmt->dependsOnRole)\n\t\t\tplan->dependsOnRole = true;\n\t}\n\tif (is_transient)\n\t{\n\t\tAssert(TransactionIdIsNormal(TransactionXmin));\n\t\tplan->saved_xmin = TransactionXmin;\n\t}\n\telse\n\t\tplan->saved_xmin = InvalidTransactionId;\n\tplan->refcount = 0;\n\tplan->context = plan_context;\n\tplan->is_oneshot = plansource->is_oneshot;\n\tplan->is_saved = false;\n\tplan->is_valid = true;\n\n\t/* assign generation number to new plan */\n\tplan->generation = ++(plansource->generation);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn plan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "choose_custom_plan",
          "args": [
            "plansource",
            "boundParams"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "choose_custom_plan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1020-1062",
          "snippet": "static bool\nchoose_custom_plan(CachedPlanSource *plansource, ParamListInfo boundParams)\n{\n\tdouble\t\tavg_custom_cost;\n\n\t/* One-shot plans will always be considered custom */\n\tif (plansource->is_oneshot)\n\t\treturn true;\n\n\t/* Otherwise, never any point in a custom plan if there's no parameters */\n\tif (boundParams == NULL)\n\t\treturn false;\n\t/* ... nor for transaction control statements */\n\tif (IsTransactionStmtPlan(plansource))\n\t\treturn false;\n\n\t/* See if caller wants to force the decision */\n\tif (plansource->cursor_options & CURSOR_OPT_GENERIC_PLAN)\n\t\treturn false;\n\tif (plansource->cursor_options & CURSOR_OPT_CUSTOM_PLAN)\n\t\treturn true;\n\n\t/* Generate custom plans until we have done at least 5 (arbitrary) */\n\tif (plansource->num_custom_plans < 5)\n\t\treturn true;\n\n\tavg_custom_cost = plansource->total_custom_cost / plansource->num_custom_plans;\n\n\t/*\n\t * Prefer generic plan if it's less expensive than the average custom\n\t * plan.  (Because we include a charge for cost of planning in the\n\t * custom-plan costs, this means the generic plan only has to be less\n\t * expensive than the execution cost plus replan cost of the custom\n\t * plans.)\n\t *\n\t * Note that if generic_cost is -1 (indicating we've not yet determined\n\t * the generic plan cost), we'll always prefer generic at this point.\n\t */\n\tif (plansource->generic_cost < avg_custom_cost)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);",
            "static bool choose_custom_plan(CachedPlanSource *plansource,\n\t\t\t\t   ParamListInfo boundParams);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic bool choose_custom_plan(CachedPlanSource *plansource,\n\t\t\t\t   ParamListInfo boundParams);\n\nstatic bool\nchoose_custom_plan(CachedPlanSource *plansource, ParamListInfo boundParams)\n{\n\tdouble\t\tavg_custom_cost;\n\n\t/* One-shot plans will always be considered custom */\n\tif (plansource->is_oneshot)\n\t\treturn true;\n\n\t/* Otherwise, never any point in a custom plan if there's no parameters */\n\tif (boundParams == NULL)\n\t\treturn false;\n\t/* ... nor for transaction control statements */\n\tif (IsTransactionStmtPlan(plansource))\n\t\treturn false;\n\n\t/* See if caller wants to force the decision */\n\tif (plansource->cursor_options & CURSOR_OPT_GENERIC_PLAN)\n\t\treturn false;\n\tif (plansource->cursor_options & CURSOR_OPT_CUSTOM_PLAN)\n\t\treturn true;\n\n\t/* Generate custom plans until we have done at least 5 (arbitrary) */\n\tif (plansource->num_custom_plans < 5)\n\t\treturn true;\n\n\tavg_custom_cost = plansource->total_custom_cost / plansource->num_custom_plans;\n\n\t/*\n\t * Prefer generic plan if it's less expensive than the average custom\n\t * plan.  (Because we include a charge for cost of planning in the\n\t * custom-plan costs, this means the generic plan only has to be less\n\t * expensive than the execution cost plus replan cost of the custom\n\t * plans.)\n\t *\n\t * Note that if generic_cost is -1 (indicating we've not yet determined\n\t * the generic plan cost), we'll always prefer generic at this point.\n\t */\n\tif (plansource->generic_cost < avg_custom_cost)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextGetParent",
          "args": [
            "plansource->context"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextGetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "438-444",
          "snippet": "MemoryContext\nMemoryContextGetParent(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\treturn context->parent;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nMemoryContext\nMemoryContextGetParent(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\treturn context->parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseGenericPlan",
          "args": [
            "plansource"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseGenericPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "529-541",
          "snippet": "static void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nstatic void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plan->magic == CACHEDPLAN_MAGIC"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckCachedPlan",
          "args": [
            "plansource"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "CheckCachedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "797-863",
          "snippet": "static bool\nCheckCachedPlan(CachedPlanSource *plansource)\n{\n\tCachedPlan *plan = plansource->gplan;\n\n\t/* Assert that caller checked the querytree */\n\tAssert(plansource->is_valid);\n\n\t/* If there's no generic plan, just say \"false\" */\n\tif (!plan)\n\t\treturn false;\n\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t/* Generic plans are never one-shot */\n\tAssert(!plan->is_oneshot);\n\n\t/*\n\t * If plan isn't valid for current role, we can't use it.\n\t */\n\tif (plan->is_valid && plan->dependsOnRole &&\n\t\tplan->planRoleId != GetUserId())\n\t\tplan->is_valid = false;\n\n\t/*\n\t * If it appears valid, acquire locks and recheck; this is much the same\n\t * logic as in RevalidateCachedQuery, but for a plan.\n\t */\n\tif (plan->is_valid)\n\t{\n\t\t/*\n\t\t * Plan must have positive refcount because it is referenced by\n\t\t * plansource; so no need to fear it disappears under us here.\n\t\t */\n\t\tAssert(plan->refcount > 0);\n\n\t\tAcquireExecutorLocks(plan->stmt_list, true);\n\n\t\t/*\n\t\t * If plan was transient, check to see if TransactionXmin has\n\t\t * advanced, and if so invalidate it.\n\t\t */\n\t\tif (plan->is_valid &&\n\t\t\tTransactionIdIsValid(plan->saved_xmin) &&\n\t\t\t!TransactionIdEquals(plan->saved_xmin, TransactionXmin))\n\t\t\tplan->is_valid = false;\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the plan invalid.\n\t\t */\n\t\tif (plan->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn true;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquireExecutorLocks(plan->stmt_list, false);\n\t}\n\n\t/*\n\t * Plan has been invalidated, so unlink it from the parent and release it.\n\t */\n\tReleaseGenericPlan(plansource);\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);",
            "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
            "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
            "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
            "static bool ScanQueryWalker(Node *node, bool *acquire);",
            "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic bool\nCheckCachedPlan(CachedPlanSource *plansource)\n{\n\tCachedPlan *plan = plansource->gplan;\n\n\t/* Assert that caller checked the querytree */\n\tAssert(plansource->is_valid);\n\n\t/* If there's no generic plan, just say \"false\" */\n\tif (!plan)\n\t\treturn false;\n\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t/* Generic plans are never one-shot */\n\tAssert(!plan->is_oneshot);\n\n\t/*\n\t * If plan isn't valid for current role, we can't use it.\n\t */\n\tif (plan->is_valid && plan->dependsOnRole &&\n\t\tplan->planRoleId != GetUserId())\n\t\tplan->is_valid = false;\n\n\t/*\n\t * If it appears valid, acquire locks and recheck; this is much the same\n\t * logic as in RevalidateCachedQuery, but for a plan.\n\t */\n\tif (plan->is_valid)\n\t{\n\t\t/*\n\t\t * Plan must have positive refcount because it is referenced by\n\t\t * plansource; so no need to fear it disappears under us here.\n\t\t */\n\t\tAssert(plan->refcount > 0);\n\n\t\tAcquireExecutorLocks(plan->stmt_list, true);\n\n\t\t/*\n\t\t * If plan was transient, check to see if TransactionXmin has\n\t\t * advanced, and if so invalidate it.\n\t\t */\n\t\tif (plan->is_valid &&\n\t\t\tTransactionIdIsValid(plan->saved_xmin) &&\n\t\t\t!TransactionIdEquals(plan->saved_xmin, TransactionXmin))\n\t\t\tplan->is_valid = false;\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the plan invalid.\n\t\t */\n\t\tif (plan->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn true;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquireExecutorLocks(plan->stmt_list, false);\n\t}\n\n\t/*\n\t * Plan has been invalidated, so unlink it from the parent and release it.\n\t */\n\tReleaseGenericPlan(plansource);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RevalidateCachedQuery",
          "args": [
            "plansource",
            "queryEnv"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "RevalidateCachedQuery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "557-786",
          "snippet": "static List *\nRevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv)\n{\n\tbool\t\tsnapshot_set;\n\tRawStmt    *rawtree;\n\tList\t   *tlist;\t\t\t/* transient query-tree list */\n\tList\t   *qlist;\t\t\t/* permanent query-tree list */\n\tTupleDesc\tresultDesc;\n\tMemoryContext querytree_context;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * For one-shot plans, we do not support revalidation checking; it's\n\t * assumed the query is parsed, planned, and executed in one transaction,\n\t * so that no lock re-acquisition is necessary.  Also, there is never any\n\t * need to revalidate plans for transaction control commands (and we\n\t * mustn't risk any catalog accesses when handling those).\n\t */\n\tif (plansource->is_oneshot || IsTransactionStmtPlan(plansource))\n\t{\n\t\tAssert(plansource->is_valid);\n\t\treturn NIL;\n\t}\n\n\t/*\n\t * If the query is currently valid, we should have a saved search_path ---\n\t * check to see if that matches the current environment.  If not, we want\n\t * to force replan.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAssert(plansource->search_path != NULL);\n\t\tif (!OverrideSearchPathMatchesCurrent(plansource->search_path))\n\t\t{\n\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\tplansource->is_valid = false;\n\t\t\tif (plansource->gplan)\n\t\t\t\tplansource->gplan->is_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * If the query rewrite phase had a possible RLS dependency, we must redo\n\t * it if either the role or the row_security setting has changed.\n\t */\n\tif (plansource->is_valid && plansource->dependsOnRLS &&\n\t\t(plansource->rewriteRoleId != GetUserId() ||\n\t\t plansource->rewriteRowSecurity != row_security))\n\t\tplansource->is_valid = false;\n\n\t/*\n\t * If the query is currently valid, acquire locks on the referenced\n\t * objects; then check again.  We need to do it this way to cover the race\n\t * condition that an invalidation message arrives before we get the locks.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAcquirePlannerLocks(plansource->query_list, true);\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the query invalid.\n\t\t */\n\t\tif (plansource->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn NIL;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquirePlannerLocks(plansource->query_list, false);\n\t}\n\n\t/*\n\t * Discard the no-longer-useful query tree.  (Note: we don't want to do\n\t * this any earlier, else we'd not have been able to release locks\n\t * correctly in the race condition case.)\n\t */\n\tplansource->is_valid = false;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\n\t/*\n\t * Free the query_context.  We don't really expect MemoryContextDelete to\n\t * fail, but just in case, make sure the CachedPlanSource is left in a\n\t * reasonably sane state.  (The generic plan won't get unlinked yet, but\n\t * that's acceptable.)\n\t */\n\tif (plansource->query_context)\n\t{\n\t\tMemoryContext qcxt = plansource->query_context;\n\n\t\tplansource->query_context = NULL;\n\t\tMemoryContextDelete(qcxt);\n\t}\n\n\t/* Drop the generic plan reference if any */\n\tReleaseGenericPlan(plansource);\n\n\t/*\n\t * Now re-do parse analysis and rewrite.  This not incidentally acquires\n\t * the locks we need to do planning safely.\n\t */\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for parsing/planning.  But if it isn't, install one.  Note: no point in\n\t * checking whether parse analysis requires a snapshot; utility commands\n\t * don't have invalidatable plans, so we'd not get here for such a\n\t * command.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet())\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Run parse analysis and rule rewriting.  The parser tends to scribble on\n\t * its input, so we must copy the raw parse tree to prevent corruption of\n\t * the cache.\n\t */\n\trawtree = copyObject(plansource->raw_parse_tree);\n\tif (rawtree == NULL)\n\t\ttlist = NIL;\n\telse if (plansource->parserSetup != NULL)\n\t\ttlist = pg_analyze_and_rewrite_params(rawtree,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->query_string,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetup,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetupArg,\n\t\t\t\t\t\t\t\t\t\t\t  queryEnv);\n\telse\n\t\ttlist = pg_analyze_and_rewrite(rawtree,\n\t\t\t\t\t\t\t\t\t   plansource->query_string,\n\t\t\t\t\t\t\t\t\t   plansource->param_types,\n\t\t\t\t\t\t\t\t\t   plansource->num_params,\n\t\t\t\t\t\t\t\t\t   queryEnv);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Check or update the result tupdesc.  XXX should we use a weaker\n\t * condition than equalTupleDescs() here?\n\t *\n\t * We assume the parameter types didn't change from the first time, so no\n\t * need to update that.\n\t */\n\tresultDesc = PlanCacheComputeResultDesc(tlist);\n\tif (resultDesc == NULL && plansource->resultDesc == NULL)\n\t{\n\t\t/* OK, doesn't return tuples */\n\t}\n\telse if (resultDesc == NULL || plansource->resultDesc == NULL ||\n\t\t\t !equalTupleDescs(resultDesc, plansource->resultDesc))\n\t{\n\t\t/* can we give a better error message? */\n\t\tif (plansource->fixed_result)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cached plan must not change result type\")));\n\t\toldcxt = MemoryContextSwitchTo(plansource->context);\n\t\tif (resultDesc)\n\t\t\tresultDesc = CreateTupleDescCopy(resultDesc);\n\t\tif (plansource->resultDesc)\n\t\t\tFreeTupleDesc(plansource->resultDesc);\n\t\tplansource->resultDesc = resultDesc;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Allocate new query_context and copy the completed querytree into it.\n\t * It's transient until we complete the copying and dependency extraction.\n\t */\n\tquerytree_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\toldcxt = MemoryContextSwitchTo(querytree_context);\n\n\tqlist = copyObject(tlist);\n\n\t/*\n\t * Use the planner machinery to extract dependencies.  Data is saved in\n\t * query_context.  (We assume that not a lot of extra cruft is created by\n\t * this call.)\n\t */\n\textract_query_dependencies((Node *) qlist,\n\t\t\t\t\t\t\t   &plansource->relationOids,\n\t\t\t\t\t\t\t   &plansource->invalItems,\n\t\t\t\t\t\t\t   &plansource->dependsOnRLS);\n\n\t/* Update RLS info as well. */\n\tplansource->rewriteRoleId = GetUserId();\n\tplansource->rewriteRowSecurity = row_security;\n\n\t/*\n\t * Also save the current search_path in the query_context.  (This should\n\t * not generate much extra cruft either, since almost certainly the path\n\t * is already valid.)\n\t */\n\tplansource->search_path = GetOverrideSearchPath(querytree_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Now reparent the finished query_context and save the links */\n\tMemoryContextSetParent(querytree_context, plansource->context);\n\n\tplansource->query_context = querytree_context;\n\tplansource->query_list = qlist;\n\n\t/*\n\t * Note: we do not reset generic_cost or total_custom_cost, although we\n\t * could choose to do so.  If the DDL or statistics change that prompted\n\t * the invalidation meant a significant change in the cost estimates, it\n\t * would be better to reset those variables and start fresh; but often it\n\t * doesn't, and we're better retaining our hard-won knowledge about the\n\t * relative costs.\n\t */\n\n\tplansource->is_valid = true;\n\n\t/* Return transient copy of querytrees for possible use in planning */\n\treturn tlist;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);",
            "static CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);",
            "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
            "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
            "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
            "static bool ScanQueryWalker(Node *node, bool *acquire);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\n\nstatic List *\nRevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv)\n{\n\tbool\t\tsnapshot_set;\n\tRawStmt    *rawtree;\n\tList\t   *tlist;\t\t\t/* transient query-tree list */\n\tList\t   *qlist;\t\t\t/* permanent query-tree list */\n\tTupleDesc\tresultDesc;\n\tMemoryContext querytree_context;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * For one-shot plans, we do not support revalidation checking; it's\n\t * assumed the query is parsed, planned, and executed in one transaction,\n\t * so that no lock re-acquisition is necessary.  Also, there is never any\n\t * need to revalidate plans for transaction control commands (and we\n\t * mustn't risk any catalog accesses when handling those).\n\t */\n\tif (plansource->is_oneshot || IsTransactionStmtPlan(plansource))\n\t{\n\t\tAssert(plansource->is_valid);\n\t\treturn NIL;\n\t}\n\n\t/*\n\t * If the query is currently valid, we should have a saved search_path ---\n\t * check to see if that matches the current environment.  If not, we want\n\t * to force replan.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAssert(plansource->search_path != NULL);\n\t\tif (!OverrideSearchPathMatchesCurrent(plansource->search_path))\n\t\t{\n\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\tplansource->is_valid = false;\n\t\t\tif (plansource->gplan)\n\t\t\t\tplansource->gplan->is_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * If the query rewrite phase had a possible RLS dependency, we must redo\n\t * it if either the role or the row_security setting has changed.\n\t */\n\tif (plansource->is_valid && plansource->dependsOnRLS &&\n\t\t(plansource->rewriteRoleId != GetUserId() ||\n\t\t plansource->rewriteRowSecurity != row_security))\n\t\tplansource->is_valid = false;\n\n\t/*\n\t * If the query is currently valid, acquire locks on the referenced\n\t * objects; then check again.  We need to do it this way to cover the race\n\t * condition that an invalidation message arrives before we get the locks.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAcquirePlannerLocks(plansource->query_list, true);\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the query invalid.\n\t\t */\n\t\tif (plansource->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn NIL;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquirePlannerLocks(plansource->query_list, false);\n\t}\n\n\t/*\n\t * Discard the no-longer-useful query tree.  (Note: we don't want to do\n\t * this any earlier, else we'd not have been able to release locks\n\t * correctly in the race condition case.)\n\t */\n\tplansource->is_valid = false;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\n\t/*\n\t * Free the query_context.  We don't really expect MemoryContextDelete to\n\t * fail, but just in case, make sure the CachedPlanSource is left in a\n\t * reasonably sane state.  (The generic plan won't get unlinked yet, but\n\t * that's acceptable.)\n\t */\n\tif (plansource->query_context)\n\t{\n\t\tMemoryContext qcxt = plansource->query_context;\n\n\t\tplansource->query_context = NULL;\n\t\tMemoryContextDelete(qcxt);\n\t}\n\n\t/* Drop the generic plan reference if any */\n\tReleaseGenericPlan(plansource);\n\n\t/*\n\t * Now re-do parse analysis and rewrite.  This not incidentally acquires\n\t * the locks we need to do planning safely.\n\t */\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for parsing/planning.  But if it isn't, install one.  Note: no point in\n\t * checking whether parse analysis requires a snapshot; utility commands\n\t * don't have invalidatable plans, so we'd not get here for such a\n\t * command.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet())\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Run parse analysis and rule rewriting.  The parser tends to scribble on\n\t * its input, so we must copy the raw parse tree to prevent corruption of\n\t * the cache.\n\t */\n\trawtree = copyObject(plansource->raw_parse_tree);\n\tif (rawtree == NULL)\n\t\ttlist = NIL;\n\telse if (plansource->parserSetup != NULL)\n\t\ttlist = pg_analyze_and_rewrite_params(rawtree,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->query_string,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetup,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetupArg,\n\t\t\t\t\t\t\t\t\t\t\t  queryEnv);\n\telse\n\t\ttlist = pg_analyze_and_rewrite(rawtree,\n\t\t\t\t\t\t\t\t\t   plansource->query_string,\n\t\t\t\t\t\t\t\t\t   plansource->param_types,\n\t\t\t\t\t\t\t\t\t   plansource->num_params,\n\t\t\t\t\t\t\t\t\t   queryEnv);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Check or update the result tupdesc.  XXX should we use a weaker\n\t * condition than equalTupleDescs() here?\n\t *\n\t * We assume the parameter types didn't change from the first time, so no\n\t * need to update that.\n\t */\n\tresultDesc = PlanCacheComputeResultDesc(tlist);\n\tif (resultDesc == NULL && plansource->resultDesc == NULL)\n\t{\n\t\t/* OK, doesn't return tuples */\n\t}\n\telse if (resultDesc == NULL || plansource->resultDesc == NULL ||\n\t\t\t !equalTupleDescs(resultDesc, plansource->resultDesc))\n\t{\n\t\t/* can we give a better error message? */\n\t\tif (plansource->fixed_result)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cached plan must not change result type\")));\n\t\toldcxt = MemoryContextSwitchTo(plansource->context);\n\t\tif (resultDesc)\n\t\t\tresultDesc = CreateTupleDescCopy(resultDesc);\n\t\tif (plansource->resultDesc)\n\t\t\tFreeTupleDesc(plansource->resultDesc);\n\t\tplansource->resultDesc = resultDesc;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Allocate new query_context and copy the completed querytree into it.\n\t * It's transient until we complete the copying and dependency extraction.\n\t */\n\tquerytree_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\toldcxt = MemoryContextSwitchTo(querytree_context);\n\n\tqlist = copyObject(tlist);\n\n\t/*\n\t * Use the planner machinery to extract dependencies.  Data is saved in\n\t * query_context.  (We assume that not a lot of extra cruft is created by\n\t * this call.)\n\t */\n\textract_query_dependencies((Node *) qlist,\n\t\t\t\t\t\t\t   &plansource->relationOids,\n\t\t\t\t\t\t\t   &plansource->invalItems,\n\t\t\t\t\t\t\t   &plansource->dependsOnRLS);\n\n\t/* Update RLS info as well. */\n\tplansource->rewriteRoleId = GetUserId();\n\tplansource->rewriteRowSecurity = row_security;\n\n\t/*\n\t * Also save the current search_path in the query_context.  (This should\n\t * not generate much extra cruft either, since almost certainly the path\n\t * is already valid.)\n\t */\n\tplansource->search_path = GetOverrideSearchPath(querytree_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Now reparent the finished query_context and save the links */\n\tMemoryContextSetParent(querytree_context, plansource->context);\n\n\tplansource->query_context = querytree_context;\n\tplansource->query_list = qlist;\n\n\t/*\n\t * Note: we do not reset generic_cost or total_custom_cost, although we\n\t * could choose to do so.  If the DDL or statistics change that prompted\n\t * the invalidation meant a significant change in the cost estimates, it\n\t * would be better to reset those variables and start fresh; but often it\n\t * doesn't, and we're better retaining our hard-won knowledge about the\n\t * relative costs.\n\t */\n\n\tplansource->is_valid = true;\n\n\t/* Return transient copy of querytrees for possible use in planning */\n\treturn tlist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot apply ResourceOwner to non-saved cached plan\""
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->is_complete"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);\nstatic bool choose_custom_plan(CachedPlanSource *plansource,\n\t\t\t\t   ParamListInfo boundParams);\n\nCachedPlan *\nGetCachedPlan(CachedPlanSource *plansource, ParamListInfo boundParams,\n\t\t\t  bool useResOwner, QueryEnvironment *queryEnv)\n{\n\tCachedPlan *plan = NULL;\n\tList\t   *qlist;\n\tbool\t\tcustomplan;\n\n\t/* Assert caller is doing things in a sane order */\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(plansource->is_complete);\n\t/* This seems worth a real test, though */\n\tif (useResOwner && !plansource->is_saved)\n\t\telog(ERROR, \"cannot apply ResourceOwner to non-saved cached plan\");\n\n\t/* Make sure the querytree list is valid and we have parse-time locks */\n\tqlist = RevalidateCachedQuery(plansource, queryEnv);\n\n\t/* Decide whether to use a custom plan */\n\tcustomplan = choose_custom_plan(plansource, boundParams);\n\n\tif (!customplan)\n\t{\n\t\tif (CheckCachedPlan(plansource))\n\t\t{\n\t\t\t/* We want a generic plan, and we already have a valid one */\n\t\t\tplan = plansource->gplan;\n\t\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Build a new generic plan */\n\t\t\tplan = BuildCachedPlan(plansource, qlist, NULL, queryEnv);\n\t\t\t/* Just make real sure plansource->gplan is clear */\n\t\t\tReleaseGenericPlan(plansource);\n\t\t\t/* Link the new generic plan into the plansource */\n\t\t\tplansource->gplan = plan;\n\t\t\tplan->refcount++;\n\t\t\t/* Immediately reparent into appropriate context */\n\t\t\tif (plansource->is_saved)\n\t\t\t{\n\t\t\t\t/* saved plans all live under CacheMemoryContext */\n\t\t\t\tMemoryContextSetParent(plan->context, CacheMemoryContext);\n\t\t\t\tplan->is_saved = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* otherwise, it should be a sibling of the plansource */\n\t\t\t\tMemoryContextSetParent(plan->context,\n\t\t\t\t\t\t\t\t\t   MemoryContextGetParent(plansource->context));\n\t\t\t}\n\t\t\t/* Update generic_cost whenever we make a new generic plan */\n\t\t\tplansource->generic_cost = cached_plan_cost(plan, false);\n\n\t\t\t/*\n\t\t\t * If, based on the now-known value of generic_cost, we'd not have\n\t\t\t * chosen to use a generic plan, then forget it and make a custom\n\t\t\t * plan.  This is a bit of a wart but is necessary to avoid a\n\t\t\t * glitch in behavior when the custom plans are consistently big\n\t\t\t * winners; at some point we'll experiment with a generic plan and\n\t\t\t * find it's a loser, but we don't want to actually execute that\n\t\t\t * plan.\n\t\t\t */\n\t\t\tcustomplan = choose_custom_plan(plansource, boundParams);\n\n\t\t\t/*\n\t\t\t * If we choose to plan again, we need to re-copy the query_list,\n\t\t\t * since the planner probably scribbled on it.  We can force\n\t\t\t * BuildCachedPlan to do that by passing NIL.\n\t\t\t */\n\t\t\tqlist = NIL;\n\t\t}\n\t}\n\n\tif (customplan)\n\t{\n\t\t/* Build a custom plan */\n\t\tplan = BuildCachedPlan(plansource, qlist, boundParams, queryEnv);\n\t\t/* Accumulate total costs of custom plans, but 'ware overflow */\n\t\tif (plansource->num_custom_plans < INT_MAX)\n\t\t{\n\t\t\tplansource->total_custom_cost += cached_plan_cost(plan, true);\n\t\t\tplansource->num_custom_plans++;\n\t\t}\n\t}\n\n\tAssert(plan != NULL);\n\n\t/* Flag the plan as in use by caller */\n\tif (useResOwner)\n\t\tResourceOwnerEnlargePlanCacheRefs(CurrentResourceOwner);\n\tplan->refcount++;\n\tif (useResOwner)\n\t\tResourceOwnerRememberPlanCacheRef(CurrentResourceOwner, plan);\n\n\t/*\n\t * Saved plans should be under CacheMemoryContext so they will not go away\n\t * until their reference count goes to zero.  In the generic-plan cases we\n\t * already took care of that, but for a custom plan, do it as soon as we\n\t * have created a reference-counted link.\n\t */\n\tif (customplan && plansource->is_saved)\n\t{\n\t\tMemoryContextSetParent(plan->context, CacheMemoryContext);\n\t\tplan->is_saved = true;\n\t}\n\n\treturn plan;\n}"
  },
  {
    "function_name": "cached_plan_cost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1071-1116",
    "snippet": "static double\ncached_plan_cost(CachedPlan *plan, bool include_planner)\n{\n\tdouble\t\tresult = 0;\n\tListCell   *lc;\n\n\tforeach(lc, plan->stmt_list)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\tcontinue;\t\t\t/* Ignore utility statements */\n\n\t\tresult += plannedstmt->planTree->total_cost;\n\n\t\tif (include_planner)\n\t\t{\n\t\t\t/*\n\t\t\t * Currently we use a very crude estimate of planning effort based\n\t\t\t * on the number of relations in the finished plan's rangetable.\n\t\t\t * Join planning effort actually scales much worse than linearly\n\t\t\t * in the number of relations --- but only until the join collapse\n\t\t\t * limits kick in.  Also, while inheritance child relations surely\n\t\t\t * add to planning effort, they don't make the join situation\n\t\t\t * worse.  So the actual shape of the planning cost curve versus\n\t\t\t * number of relations isn't all that obvious.  It will take\n\t\t\t * considerable work to arrive at a less crude estimate, and for\n\t\t\t * now it's not clear that's worth doing.\n\t\t\t *\n\t\t\t * The other big difficulty here is that we don't have any very\n\t\t\t * good model of how planning cost compares to execution costs.\n\t\t\t * The current multiplier of 1000 * cpu_operator_cost is probably\n\t\t\t * on the low side, but we'll try this for awhile before making a\n\t\t\t * more aggressive correction.\n\t\t\t *\n\t\t\t * If we ever do write a more complicated estimator, it should\n\t\t\t * probably live in src/backend/optimizer/ not here.\n\t\t\t */\n\t\t\tint\t\t\tnrelations = list_length(plannedstmt->rtable);\n\n\t\t\tresult += 1000.0 * cpu_operator_cost * (nrelations + 1);\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double cached_plan_cost(CachedPlan *plan, bool include_planner);",
      "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "plannedstmt->rtable"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "PlannedStmt",
            "lc"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "plan->stmt_list"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic double cached_plan_cost(CachedPlan *plan, bool include_planner);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic double\ncached_plan_cost(CachedPlan *plan, bool include_planner)\n{\n\tdouble\t\tresult = 0;\n\tListCell   *lc;\n\n\tforeach(lc, plan->stmt_list)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\tcontinue;\t\t\t/* Ignore utility statements */\n\n\t\tresult += plannedstmt->planTree->total_cost;\n\n\t\tif (include_planner)\n\t\t{\n\t\t\t/*\n\t\t\t * Currently we use a very crude estimate of planning effort based\n\t\t\t * on the number of relations in the finished plan's rangetable.\n\t\t\t * Join planning effort actually scales much worse than linearly\n\t\t\t * in the number of relations --- but only until the join collapse\n\t\t\t * limits kick in.  Also, while inheritance child relations surely\n\t\t\t * add to planning effort, they don't make the join situation\n\t\t\t * worse.  So the actual shape of the planning cost curve versus\n\t\t\t * number of relations isn't all that obvious.  It will take\n\t\t\t * considerable work to arrive at a less crude estimate, and for\n\t\t\t * now it's not clear that's worth doing.\n\t\t\t *\n\t\t\t * The other big difficulty here is that we don't have any very\n\t\t\t * good model of how planning cost compares to execution costs.\n\t\t\t * The current multiplier of 1000 * cpu_operator_cost is probably\n\t\t\t * on the low side, but we'll try this for awhile before making a\n\t\t\t * more aggressive correction.\n\t\t\t *\n\t\t\t * If we ever do write a more complicated estimator, it should\n\t\t\t * probably live in src/backend/optimizer/ not here.\n\t\t\t */\n\t\t\tint\t\t\tnrelations = list_length(plannedstmt->rtable);\n\n\t\t\tresult += 1000.0 * cpu_operator_cost * (nrelations + 1);\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "choose_custom_plan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "1020-1062",
    "snippet": "static bool\nchoose_custom_plan(CachedPlanSource *plansource, ParamListInfo boundParams)\n{\n\tdouble\t\tavg_custom_cost;\n\n\t/* One-shot plans will always be considered custom */\n\tif (plansource->is_oneshot)\n\t\treturn true;\n\n\t/* Otherwise, never any point in a custom plan if there's no parameters */\n\tif (boundParams == NULL)\n\t\treturn false;\n\t/* ... nor for transaction control statements */\n\tif (IsTransactionStmtPlan(plansource))\n\t\treturn false;\n\n\t/* See if caller wants to force the decision */\n\tif (plansource->cursor_options & CURSOR_OPT_GENERIC_PLAN)\n\t\treturn false;\n\tif (plansource->cursor_options & CURSOR_OPT_CUSTOM_PLAN)\n\t\treturn true;\n\n\t/* Generate custom plans until we have done at least 5 (arbitrary) */\n\tif (plansource->num_custom_plans < 5)\n\t\treturn true;\n\n\tavg_custom_cost = plansource->total_custom_cost / plansource->num_custom_plans;\n\n\t/*\n\t * Prefer generic plan if it's less expensive than the average custom\n\t * plan.  (Because we include a charge for cost of planning in the\n\t * custom-plan costs, this means the generic plan only has to be less\n\t * expensive than the execution cost plus replan cost of the custom\n\t * plans.)\n\t *\n\t * Note that if generic_cost is -1 (indicating we've not yet determined\n\t * the generic plan cost), we'll always prefer generic at this point.\n\t */\n\tif (plansource->generic_cost < avg_custom_cost)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);",
      "static bool choose_custom_plan(CachedPlanSource *plansource,\n\t\t\t\t   ParamListInfo boundParams);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsTransactionStmtPlan",
          "args": [
            "plansource"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic bool choose_custom_plan(CachedPlanSource *plansource,\n\t\t\t\t   ParamListInfo boundParams);\n\nstatic bool\nchoose_custom_plan(CachedPlanSource *plansource, ParamListInfo boundParams)\n{\n\tdouble\t\tavg_custom_cost;\n\n\t/* One-shot plans will always be considered custom */\n\tif (plansource->is_oneshot)\n\t\treturn true;\n\n\t/* Otherwise, never any point in a custom plan if there's no parameters */\n\tif (boundParams == NULL)\n\t\treturn false;\n\t/* ... nor for transaction control statements */\n\tif (IsTransactionStmtPlan(plansource))\n\t\treturn false;\n\n\t/* See if caller wants to force the decision */\n\tif (plansource->cursor_options & CURSOR_OPT_GENERIC_PLAN)\n\t\treturn false;\n\tif (plansource->cursor_options & CURSOR_OPT_CUSTOM_PLAN)\n\t\treturn true;\n\n\t/* Generate custom plans until we have done at least 5 (arbitrary) */\n\tif (plansource->num_custom_plans < 5)\n\t\treturn true;\n\n\tavg_custom_cost = plansource->total_custom_cost / plansource->num_custom_plans;\n\n\t/*\n\t * Prefer generic plan if it's less expensive than the average custom\n\t * plan.  (Because we include a charge for cost of planning in the\n\t * custom-plan costs, this means the generic plan only has to be less\n\t * expensive than the execution cost plus replan cost of the custom\n\t * plans.)\n\t *\n\t * Note that if generic_cost is -1 (indicating we've not yet determined\n\t * the generic plan cost), we'll always prefer generic at this point.\n\t */\n\tif (plansource->generic_cost < avg_custom_cost)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "BuildCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "881-1013",
    "snippet": "static CachedPlan *\nBuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv)\n{\n\tCachedPlan *plan;\n\tList\t   *plist;\n\tbool\t\tsnapshot_set;\n\tbool\t\tis_transient;\n\tMemoryContext plan_context;\n\tMemoryContext oldcxt = CurrentMemoryContext;\n\tListCell   *lc;\n\n\t/*\n\t * Normally the querytree should be valid already, but if it's not,\n\t * rebuild it.\n\t *\n\t * NOTE: GetCachedPlan should have called RevalidateCachedQuery first, so\n\t * we ought to be holding sufficient locks to prevent any invalidation.\n\t * However, if we're building a custom plan after having built and\n\t * rejected a generic plan, it's possible to reach here with is_valid\n\t * false due to an invalidation while making the generic plan.  In theory\n\t * the invalidation must be a false positive, perhaps a consequence of an\n\t * sinval reset event or the CLOBBER_CACHE_ALWAYS debug code.  But for\n\t * safety, let's treat it as real and redo the RevalidateCachedQuery call.\n\t */\n\tif (!plansource->is_valid)\n\t\tqlist = RevalidateCachedQuery(plansource, queryEnv);\n\n\t/*\n\t * If we don't already have a copy of the querytree list that can be\n\t * scribbled on by the planner, make one.  For a one-shot plan, we assume\n\t * it's okay to scribble on the original query_list.\n\t */\n\tif (qlist == NIL)\n\t{\n\t\tif (!plansource->is_oneshot)\n\t\t\tqlist = copyObject(plansource->query_list);\n\t\telse\n\t\t\tqlist = plansource->query_list;\n\t}\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for planning.  But if it isn't, and we need one, install one.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet() &&\n\t\tplansource->raw_parse_tree &&\n\t\tanalyze_requires_snapshot(plansource->raw_parse_tree))\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Generate the plan.\n\t */\n\tplist = pg_plan_queries(qlist, plansource->cursor_options, boundParams);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Normally we make a dedicated memory context for the CachedPlan and its\n\t * subsidiary data.  (It's probably not going to be large, but just in\n\t * case, allow it to grow large.  It's transient for the moment.)  But for\n\t * a one-shot plan, we just leave it in the caller's memory context.\n\t */\n\tif (!plansource->is_oneshot)\n\t{\n\t\tplan_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"CachedPlan\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_START_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(plan_context, plansource->query_string);\n\n\t\t/*\n\t\t * Copy plan into the new context.\n\t\t */\n\t\tMemoryContextSwitchTo(plan_context);\n\n\t\tplist = copyObject(plist);\n\t}\n\telse\n\t\tplan_context = CurrentMemoryContext;\n\n\t/*\n\t * Create and fill the CachedPlan struct within the new context.\n\t */\n\tplan = (CachedPlan *) palloc(sizeof(CachedPlan));\n\tplan->magic = CACHEDPLAN_MAGIC;\n\tplan->stmt_list = plist;\n\n\t/*\n\t * CachedPlan is dependent on role either if RLS affected the rewrite\n\t * phase or if a role dependency was injected during planning.  And it's\n\t * transient if any plan is marked so.\n\t */\n\tplan->planRoleId = GetUserId();\n\tplan->dependsOnRole = plansource->dependsOnRLS;\n\tis_transient = false;\n\tforeach(lc, plist)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\tcontinue;\t\t\t/* Ignore utility statements */\n\n\t\tif (plannedstmt->transientPlan)\n\t\t\tis_transient = true;\n\t\tif (plannedstmt->dependsOnRole)\n\t\t\tplan->dependsOnRole = true;\n\t}\n\tif (is_transient)\n\t{\n\t\tAssert(TransactionIdIsNormal(TransactionXmin));\n\t\tplan->saved_xmin = TransactionXmin;\n\t}\n\telse\n\t\tplan->saved_xmin = InvalidTransactionId;\n\tplan->refcount = 0;\n\tplan->context = plan_context;\n\tplan->is_oneshot = plansource->is_oneshot;\n\tplan->is_saved = false;\n\tplan->is_valid = true;\n\n\t/* assign generation number to new plan */\n\tplan->generation = ++(plansource->generation);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn plan;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);",
      "static CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);",
      "static bool choose_custom_plan(CachedPlanSource *plansource,\n\t\t\t\t   ParamListInfo boundParams);",
      "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsNormal(TransactionXmin)"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsNormal",
          "args": [
            "TransactionXmin"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_node",
          "args": [
            "PlannedStmt",
            "lc"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "plist"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(CachedPlan)"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "plist"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "plan_context"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextCopyAndSetIdentifier",
          "args": [
            "plan_context",
            "plansource->query_string"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"CachedPlan\"",
            "ALLOCSET_START_SMALL_SIZES"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PopActiveSnapshot",
          "args": [],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "PopActiveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "811-832",
          "snippet": "void\nPopActiveSnapshot(void)\n{\n\tActiveSnapshotElt *newstack;\n\n\tnewstack = ActiveSnapshot->as_next;\n\n\tAssert(ActiveSnapshot->as_snap->active_count > 0);\n\n\tActiveSnapshot->as_snap->active_count--;\n\n\tif (ActiveSnapshot->as_snap->active_count == 0 &&\n\t\tActiveSnapshot->as_snap->regd_count == 0)\n\t\tFreeSnapshot(ActiveSnapshot->as_snap);\n\n\tpfree(ActiveSnapshot);\n\tActiveSnapshot = newstack;\n\tif (ActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = NULL;\n\n\tSnapshotResetXmin();\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static ActiveSnapshotElt *OldestActiveSnapshot = NULL;",
            "static void SnapshotResetXmin(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\nstatic void SnapshotResetXmin(void);\n\nvoid\nPopActiveSnapshot(void)\n{\n\tActiveSnapshotElt *newstack;\n\n\tnewstack = ActiveSnapshot->as_next;\n\n\tAssert(ActiveSnapshot->as_snap->active_count > 0);\n\n\tActiveSnapshot->as_snap->active_count--;\n\n\tif (ActiveSnapshot->as_snap->active_count == 0 &&\n\t\tActiveSnapshot->as_snap->regd_count == 0)\n\t\tFreeSnapshot(ActiveSnapshot->as_snap);\n\n\tpfree(ActiveSnapshot);\n\tActiveSnapshot = newstack;\n\tif (ActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = NULL;\n\n\tSnapshotResetXmin();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_plan_queries",
          "args": [
            "qlist",
            "plansource->cursor_options",
            "boundParams"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PushActiveSnapshot",
          "args": [
            "GetTransactionSnapshot()"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "PushActiveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "732-758",
          "snippet": "void\nPushActiveSnapshot(Snapshot snap)\n{\n\tActiveSnapshotElt *newactive;\n\n\tAssert(snap != InvalidSnapshot);\n\n\tnewactive = MemoryContextAlloc(TopTransactionContext, sizeof(ActiveSnapshotElt));\n\n\t/*\n\t * Checking SecondarySnapshot is probably useless here, but it seems\n\t * better to be sure.\n\t */\n\tif (snap == CurrentSnapshot || snap == SecondarySnapshot || !snap->copied)\n\t\tnewactive->as_snap = CopySnapshot(snap);\n\telse\n\t\tnewactive->as_snap = snap;\n\n\tnewactive->as_next = ActiveSnapshot;\n\tnewactive->as_level = GetCurrentTransactionNestLevel();\n\n\tnewactive->as_snap->active_count++;\n\n\tActiveSnapshot = newactive;\n\tif (OldestActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = ActiveSnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CurrentSnapshot = NULL;",
            "static Snapshot SecondarySnapshot = NULL;",
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static ActiveSnapshotElt *OldestActiveSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot SecondarySnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\n\nvoid\nPushActiveSnapshot(Snapshot snap)\n{\n\tActiveSnapshotElt *newactive;\n\n\tAssert(snap != InvalidSnapshot);\n\n\tnewactive = MemoryContextAlloc(TopTransactionContext, sizeof(ActiveSnapshotElt));\n\n\t/*\n\t * Checking SecondarySnapshot is probably useless here, but it seems\n\t * better to be sure.\n\t */\n\tif (snap == CurrentSnapshot || snap == SecondarySnapshot || !snap->copied)\n\t\tnewactive->as_snap = CopySnapshot(snap);\n\telse\n\t\tnewactive->as_snap = snap;\n\n\tnewactive->as_next = ActiveSnapshot;\n\tnewactive->as_level = GetCurrentTransactionNestLevel();\n\n\tnewactive->as_snap->active_count++;\n\n\tActiveSnapshot = newactive;\n\tif (OldestActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = ActiveSnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTransactionSnapshot",
          "args": [],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransactionSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "303-371",
          "snippet": "Snapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot CurrentSnapshot = NULL;",
            "static Snapshot HistoricSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "bool\t\tFirstSnapshotSet = false;",
            "static Snapshot FirstXactSnapshot = NULL;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot HistoricSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot FirstXactSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "analyze_requires_snapshot",
          "args": [
            "plansource->raw_parse_tree"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ActiveSnapshotSet",
          "args": [],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "ActiveSnapshotSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "850-854",
          "snippet": "bool\nActiveSnapshotSet(void)\n{\n\treturn ActiveSnapshot != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\n\nbool\nActiveSnapshotSet(void)\n{\n\treturn ActiveSnapshot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "plansource->query_list"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RevalidateCachedQuery",
          "args": [
            "plansource",
            "queryEnv"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "RevalidateCachedQuery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "557-786",
          "snippet": "static List *\nRevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv)\n{\n\tbool\t\tsnapshot_set;\n\tRawStmt    *rawtree;\n\tList\t   *tlist;\t\t\t/* transient query-tree list */\n\tList\t   *qlist;\t\t\t/* permanent query-tree list */\n\tTupleDesc\tresultDesc;\n\tMemoryContext querytree_context;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * For one-shot plans, we do not support revalidation checking; it's\n\t * assumed the query is parsed, planned, and executed in one transaction,\n\t * so that no lock re-acquisition is necessary.  Also, there is never any\n\t * need to revalidate plans for transaction control commands (and we\n\t * mustn't risk any catalog accesses when handling those).\n\t */\n\tif (plansource->is_oneshot || IsTransactionStmtPlan(plansource))\n\t{\n\t\tAssert(plansource->is_valid);\n\t\treturn NIL;\n\t}\n\n\t/*\n\t * If the query is currently valid, we should have a saved search_path ---\n\t * check to see if that matches the current environment.  If not, we want\n\t * to force replan.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAssert(plansource->search_path != NULL);\n\t\tif (!OverrideSearchPathMatchesCurrent(plansource->search_path))\n\t\t{\n\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\tplansource->is_valid = false;\n\t\t\tif (plansource->gplan)\n\t\t\t\tplansource->gplan->is_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * If the query rewrite phase had a possible RLS dependency, we must redo\n\t * it if either the role or the row_security setting has changed.\n\t */\n\tif (plansource->is_valid && plansource->dependsOnRLS &&\n\t\t(plansource->rewriteRoleId != GetUserId() ||\n\t\t plansource->rewriteRowSecurity != row_security))\n\t\tplansource->is_valid = false;\n\n\t/*\n\t * If the query is currently valid, acquire locks on the referenced\n\t * objects; then check again.  We need to do it this way to cover the race\n\t * condition that an invalidation message arrives before we get the locks.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAcquirePlannerLocks(plansource->query_list, true);\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the query invalid.\n\t\t */\n\t\tif (plansource->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn NIL;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquirePlannerLocks(plansource->query_list, false);\n\t}\n\n\t/*\n\t * Discard the no-longer-useful query tree.  (Note: we don't want to do\n\t * this any earlier, else we'd not have been able to release locks\n\t * correctly in the race condition case.)\n\t */\n\tplansource->is_valid = false;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\n\t/*\n\t * Free the query_context.  We don't really expect MemoryContextDelete to\n\t * fail, but just in case, make sure the CachedPlanSource is left in a\n\t * reasonably sane state.  (The generic plan won't get unlinked yet, but\n\t * that's acceptable.)\n\t */\n\tif (plansource->query_context)\n\t{\n\t\tMemoryContext qcxt = plansource->query_context;\n\n\t\tplansource->query_context = NULL;\n\t\tMemoryContextDelete(qcxt);\n\t}\n\n\t/* Drop the generic plan reference if any */\n\tReleaseGenericPlan(plansource);\n\n\t/*\n\t * Now re-do parse analysis and rewrite.  This not incidentally acquires\n\t * the locks we need to do planning safely.\n\t */\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for parsing/planning.  But if it isn't, install one.  Note: no point in\n\t * checking whether parse analysis requires a snapshot; utility commands\n\t * don't have invalidatable plans, so we'd not get here for such a\n\t * command.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet())\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Run parse analysis and rule rewriting.  The parser tends to scribble on\n\t * its input, so we must copy the raw parse tree to prevent corruption of\n\t * the cache.\n\t */\n\trawtree = copyObject(plansource->raw_parse_tree);\n\tif (rawtree == NULL)\n\t\ttlist = NIL;\n\telse if (plansource->parserSetup != NULL)\n\t\ttlist = pg_analyze_and_rewrite_params(rawtree,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->query_string,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetup,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetupArg,\n\t\t\t\t\t\t\t\t\t\t\t  queryEnv);\n\telse\n\t\ttlist = pg_analyze_and_rewrite(rawtree,\n\t\t\t\t\t\t\t\t\t   plansource->query_string,\n\t\t\t\t\t\t\t\t\t   plansource->param_types,\n\t\t\t\t\t\t\t\t\t   plansource->num_params,\n\t\t\t\t\t\t\t\t\t   queryEnv);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Check or update the result tupdesc.  XXX should we use a weaker\n\t * condition than equalTupleDescs() here?\n\t *\n\t * We assume the parameter types didn't change from the first time, so no\n\t * need to update that.\n\t */\n\tresultDesc = PlanCacheComputeResultDesc(tlist);\n\tif (resultDesc == NULL && plansource->resultDesc == NULL)\n\t{\n\t\t/* OK, doesn't return tuples */\n\t}\n\telse if (resultDesc == NULL || plansource->resultDesc == NULL ||\n\t\t\t !equalTupleDescs(resultDesc, plansource->resultDesc))\n\t{\n\t\t/* can we give a better error message? */\n\t\tif (plansource->fixed_result)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cached plan must not change result type\")));\n\t\toldcxt = MemoryContextSwitchTo(plansource->context);\n\t\tif (resultDesc)\n\t\t\tresultDesc = CreateTupleDescCopy(resultDesc);\n\t\tif (plansource->resultDesc)\n\t\t\tFreeTupleDesc(plansource->resultDesc);\n\t\tplansource->resultDesc = resultDesc;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Allocate new query_context and copy the completed querytree into it.\n\t * It's transient until we complete the copying and dependency extraction.\n\t */\n\tquerytree_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\toldcxt = MemoryContextSwitchTo(querytree_context);\n\n\tqlist = copyObject(tlist);\n\n\t/*\n\t * Use the planner machinery to extract dependencies.  Data is saved in\n\t * query_context.  (We assume that not a lot of extra cruft is created by\n\t * this call.)\n\t */\n\textract_query_dependencies((Node *) qlist,\n\t\t\t\t\t\t\t   &plansource->relationOids,\n\t\t\t\t\t\t\t   &plansource->invalItems,\n\t\t\t\t\t\t\t   &plansource->dependsOnRLS);\n\n\t/* Update RLS info as well. */\n\tplansource->rewriteRoleId = GetUserId();\n\tplansource->rewriteRowSecurity = row_security;\n\n\t/*\n\t * Also save the current search_path in the query_context.  (This should\n\t * not generate much extra cruft either, since almost certainly the path\n\t * is already valid.)\n\t */\n\tplansource->search_path = GetOverrideSearchPath(querytree_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Now reparent the finished query_context and save the links */\n\tMemoryContextSetParent(querytree_context, plansource->context);\n\n\tplansource->query_context = querytree_context;\n\tplansource->query_list = qlist;\n\n\t/*\n\t * Note: we do not reset generic_cost or total_custom_cost, although we\n\t * could choose to do so.  If the DDL or statistics change that prompted\n\t * the invalidation meant a significant change in the cost estimates, it\n\t * would be better to reset those variables and start fresh; but often it\n\t * doesn't, and we're better retaining our hard-won knowledge about the\n\t * relative costs.\n\t */\n\n\tplansource->is_valid = true;\n\n\t/* Return transient copy of querytrees for possible use in planning */\n\treturn tlist;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);",
            "static CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);",
            "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
            "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
            "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
            "static bool ScanQueryWalker(Node *node, bool *acquire);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\n\nstatic List *\nRevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv)\n{\n\tbool\t\tsnapshot_set;\n\tRawStmt    *rawtree;\n\tList\t   *tlist;\t\t\t/* transient query-tree list */\n\tList\t   *qlist;\t\t\t/* permanent query-tree list */\n\tTupleDesc\tresultDesc;\n\tMemoryContext querytree_context;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * For one-shot plans, we do not support revalidation checking; it's\n\t * assumed the query is parsed, planned, and executed in one transaction,\n\t * so that no lock re-acquisition is necessary.  Also, there is never any\n\t * need to revalidate plans for transaction control commands (and we\n\t * mustn't risk any catalog accesses when handling those).\n\t */\n\tif (plansource->is_oneshot || IsTransactionStmtPlan(plansource))\n\t{\n\t\tAssert(plansource->is_valid);\n\t\treturn NIL;\n\t}\n\n\t/*\n\t * If the query is currently valid, we should have a saved search_path ---\n\t * check to see if that matches the current environment.  If not, we want\n\t * to force replan.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAssert(plansource->search_path != NULL);\n\t\tif (!OverrideSearchPathMatchesCurrent(plansource->search_path))\n\t\t{\n\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\tplansource->is_valid = false;\n\t\t\tif (plansource->gplan)\n\t\t\t\tplansource->gplan->is_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * If the query rewrite phase had a possible RLS dependency, we must redo\n\t * it if either the role or the row_security setting has changed.\n\t */\n\tif (plansource->is_valid && plansource->dependsOnRLS &&\n\t\t(plansource->rewriteRoleId != GetUserId() ||\n\t\t plansource->rewriteRowSecurity != row_security))\n\t\tplansource->is_valid = false;\n\n\t/*\n\t * If the query is currently valid, acquire locks on the referenced\n\t * objects; then check again.  We need to do it this way to cover the race\n\t * condition that an invalidation message arrives before we get the locks.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAcquirePlannerLocks(plansource->query_list, true);\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the query invalid.\n\t\t */\n\t\tif (plansource->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn NIL;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquirePlannerLocks(plansource->query_list, false);\n\t}\n\n\t/*\n\t * Discard the no-longer-useful query tree.  (Note: we don't want to do\n\t * this any earlier, else we'd not have been able to release locks\n\t * correctly in the race condition case.)\n\t */\n\tplansource->is_valid = false;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\n\t/*\n\t * Free the query_context.  We don't really expect MemoryContextDelete to\n\t * fail, but just in case, make sure the CachedPlanSource is left in a\n\t * reasonably sane state.  (The generic plan won't get unlinked yet, but\n\t * that's acceptable.)\n\t */\n\tif (plansource->query_context)\n\t{\n\t\tMemoryContext qcxt = plansource->query_context;\n\n\t\tplansource->query_context = NULL;\n\t\tMemoryContextDelete(qcxt);\n\t}\n\n\t/* Drop the generic plan reference if any */\n\tReleaseGenericPlan(plansource);\n\n\t/*\n\t * Now re-do parse analysis and rewrite.  This not incidentally acquires\n\t * the locks we need to do planning safely.\n\t */\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for parsing/planning.  But if it isn't, install one.  Note: no point in\n\t * checking whether parse analysis requires a snapshot; utility commands\n\t * don't have invalidatable plans, so we'd not get here for such a\n\t * command.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet())\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Run parse analysis and rule rewriting.  The parser tends to scribble on\n\t * its input, so we must copy the raw parse tree to prevent corruption of\n\t * the cache.\n\t */\n\trawtree = copyObject(plansource->raw_parse_tree);\n\tif (rawtree == NULL)\n\t\ttlist = NIL;\n\telse if (plansource->parserSetup != NULL)\n\t\ttlist = pg_analyze_and_rewrite_params(rawtree,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->query_string,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetup,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetupArg,\n\t\t\t\t\t\t\t\t\t\t\t  queryEnv);\n\telse\n\t\ttlist = pg_analyze_and_rewrite(rawtree,\n\t\t\t\t\t\t\t\t\t   plansource->query_string,\n\t\t\t\t\t\t\t\t\t   plansource->param_types,\n\t\t\t\t\t\t\t\t\t   plansource->num_params,\n\t\t\t\t\t\t\t\t\t   queryEnv);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Check or update the result tupdesc.  XXX should we use a weaker\n\t * condition than equalTupleDescs() here?\n\t *\n\t * We assume the parameter types didn't change from the first time, so no\n\t * need to update that.\n\t */\n\tresultDesc = PlanCacheComputeResultDesc(tlist);\n\tif (resultDesc == NULL && plansource->resultDesc == NULL)\n\t{\n\t\t/* OK, doesn't return tuples */\n\t}\n\telse if (resultDesc == NULL || plansource->resultDesc == NULL ||\n\t\t\t !equalTupleDescs(resultDesc, plansource->resultDesc))\n\t{\n\t\t/* can we give a better error message? */\n\t\tif (plansource->fixed_result)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cached plan must not change result type\")));\n\t\toldcxt = MemoryContextSwitchTo(plansource->context);\n\t\tif (resultDesc)\n\t\t\tresultDesc = CreateTupleDescCopy(resultDesc);\n\t\tif (plansource->resultDesc)\n\t\t\tFreeTupleDesc(plansource->resultDesc);\n\t\tplansource->resultDesc = resultDesc;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Allocate new query_context and copy the completed querytree into it.\n\t * It's transient until we complete the copying and dependency extraction.\n\t */\n\tquerytree_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\toldcxt = MemoryContextSwitchTo(querytree_context);\n\n\tqlist = copyObject(tlist);\n\n\t/*\n\t * Use the planner machinery to extract dependencies.  Data is saved in\n\t * query_context.  (We assume that not a lot of extra cruft is created by\n\t * this call.)\n\t */\n\textract_query_dependencies((Node *) qlist,\n\t\t\t\t\t\t\t   &plansource->relationOids,\n\t\t\t\t\t\t\t   &plansource->invalItems,\n\t\t\t\t\t\t\t   &plansource->dependsOnRLS);\n\n\t/* Update RLS info as well. */\n\tplansource->rewriteRoleId = GetUserId();\n\tplansource->rewriteRowSecurity = row_security;\n\n\t/*\n\t * Also save the current search_path in the query_context.  (This should\n\t * not generate much extra cruft either, since almost certainly the path\n\t * is already valid.)\n\t */\n\tplansource->search_path = GetOverrideSearchPath(querytree_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Now reparent the finished query_context and save the links */\n\tMemoryContextSetParent(querytree_context, plansource->context);\n\n\tplansource->query_context = querytree_context;\n\tplansource->query_list = qlist;\n\n\t/*\n\t * Note: we do not reset generic_cost or total_custom_cost, although we\n\t * could choose to do so.  If the DDL or statistics change that prompted\n\t * the invalidation meant a significant change in the cost estimates, it\n\t * would be better to reset those variables and start fresh; but often it\n\t * doesn't, and we're better retaining our hard-won knowledge about the\n\t * relative costs.\n\t */\n\n\tplansource->is_valid = true;\n\n\t/* Return transient copy of querytrees for possible use in planning */\n\treturn tlist;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);\nstatic bool choose_custom_plan(CachedPlanSource *plansource,\n\t\t\t\t   ParamListInfo boundParams);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic CachedPlan *\nBuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv)\n{\n\tCachedPlan *plan;\n\tList\t   *plist;\n\tbool\t\tsnapshot_set;\n\tbool\t\tis_transient;\n\tMemoryContext plan_context;\n\tMemoryContext oldcxt = CurrentMemoryContext;\n\tListCell   *lc;\n\n\t/*\n\t * Normally the querytree should be valid already, but if it's not,\n\t * rebuild it.\n\t *\n\t * NOTE: GetCachedPlan should have called RevalidateCachedQuery first, so\n\t * we ought to be holding sufficient locks to prevent any invalidation.\n\t * However, if we're building a custom plan after having built and\n\t * rejected a generic plan, it's possible to reach here with is_valid\n\t * false due to an invalidation while making the generic plan.  In theory\n\t * the invalidation must be a false positive, perhaps a consequence of an\n\t * sinval reset event or the CLOBBER_CACHE_ALWAYS debug code.  But for\n\t * safety, let's treat it as real and redo the RevalidateCachedQuery call.\n\t */\n\tif (!plansource->is_valid)\n\t\tqlist = RevalidateCachedQuery(plansource, queryEnv);\n\n\t/*\n\t * If we don't already have a copy of the querytree list that can be\n\t * scribbled on by the planner, make one.  For a one-shot plan, we assume\n\t * it's okay to scribble on the original query_list.\n\t */\n\tif (qlist == NIL)\n\t{\n\t\tif (!plansource->is_oneshot)\n\t\t\tqlist = copyObject(plansource->query_list);\n\t\telse\n\t\t\tqlist = plansource->query_list;\n\t}\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for planning.  But if it isn't, and we need one, install one.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet() &&\n\t\tplansource->raw_parse_tree &&\n\t\tanalyze_requires_snapshot(plansource->raw_parse_tree))\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Generate the plan.\n\t */\n\tplist = pg_plan_queries(qlist, plansource->cursor_options, boundParams);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Normally we make a dedicated memory context for the CachedPlan and its\n\t * subsidiary data.  (It's probably not going to be large, but just in\n\t * case, allow it to grow large.  It's transient for the moment.)  But for\n\t * a one-shot plan, we just leave it in the caller's memory context.\n\t */\n\tif (!plansource->is_oneshot)\n\t{\n\t\tplan_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"CachedPlan\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_START_SMALL_SIZES);\n\t\tMemoryContextCopyAndSetIdentifier(plan_context, plansource->query_string);\n\n\t\t/*\n\t\t * Copy plan into the new context.\n\t\t */\n\t\tMemoryContextSwitchTo(plan_context);\n\n\t\tplist = copyObject(plist);\n\t}\n\telse\n\t\tplan_context = CurrentMemoryContext;\n\n\t/*\n\t * Create and fill the CachedPlan struct within the new context.\n\t */\n\tplan = (CachedPlan *) palloc(sizeof(CachedPlan));\n\tplan->magic = CACHEDPLAN_MAGIC;\n\tplan->stmt_list = plist;\n\n\t/*\n\t * CachedPlan is dependent on role either if RLS affected the rewrite\n\t * phase or if a role dependency was injected during planning.  And it's\n\t * transient if any plan is marked so.\n\t */\n\tplan->planRoleId = GetUserId();\n\tplan->dependsOnRole = plansource->dependsOnRLS;\n\tis_transient = false;\n\tforeach(lc, plist)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc);\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t\tcontinue;\t\t\t/* Ignore utility statements */\n\n\t\tif (plannedstmt->transientPlan)\n\t\t\tis_transient = true;\n\t\tif (plannedstmt->dependsOnRole)\n\t\t\tplan->dependsOnRole = true;\n\t}\n\tif (is_transient)\n\t{\n\t\tAssert(TransactionIdIsNormal(TransactionXmin));\n\t\tplan->saved_xmin = TransactionXmin;\n\t}\n\telse\n\t\tplan->saved_xmin = InvalidTransactionId;\n\tplan->refcount = 0;\n\tplan->context = plan_context;\n\tplan->is_oneshot = plansource->is_oneshot;\n\tplan->is_saved = false;\n\tplan->is_valid = true;\n\n\t/* assign generation number to new plan */\n\tplan->generation = ++(plansource->generation);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn plan;\n}"
  },
  {
    "function_name": "CheckCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "797-863",
    "snippet": "static bool\nCheckCachedPlan(CachedPlanSource *plansource)\n{\n\tCachedPlan *plan = plansource->gplan;\n\n\t/* Assert that caller checked the querytree */\n\tAssert(plansource->is_valid);\n\n\t/* If there's no generic plan, just say \"false\" */\n\tif (!plan)\n\t\treturn false;\n\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t/* Generic plans are never one-shot */\n\tAssert(!plan->is_oneshot);\n\n\t/*\n\t * If plan isn't valid for current role, we can't use it.\n\t */\n\tif (plan->is_valid && plan->dependsOnRole &&\n\t\tplan->planRoleId != GetUserId())\n\t\tplan->is_valid = false;\n\n\t/*\n\t * If it appears valid, acquire locks and recheck; this is much the same\n\t * logic as in RevalidateCachedQuery, but for a plan.\n\t */\n\tif (plan->is_valid)\n\t{\n\t\t/*\n\t\t * Plan must have positive refcount because it is referenced by\n\t\t * plansource; so no need to fear it disappears under us here.\n\t\t */\n\t\tAssert(plan->refcount > 0);\n\n\t\tAcquireExecutorLocks(plan->stmt_list, true);\n\n\t\t/*\n\t\t * If plan was transient, check to see if TransactionXmin has\n\t\t * advanced, and if so invalidate it.\n\t\t */\n\t\tif (plan->is_valid &&\n\t\t\tTransactionIdIsValid(plan->saved_xmin) &&\n\t\t\t!TransactionIdEquals(plan->saved_xmin, TransactionXmin))\n\t\t\tplan->is_valid = false;\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the plan invalid.\n\t\t */\n\t\tif (plan->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn true;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquireExecutorLocks(plan->stmt_list, false);\n\t}\n\n\t/*\n\t * Plan has been invalidated, so unlink it from the parent and release it.\n\t */\n\tReleaseGenericPlan(plansource);\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);",
      "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
      "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
      "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
      "static bool ScanQueryWalker(Node *node, bool *acquire);",
      "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseGenericPlan",
          "args": [
            "plansource"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseGenericPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "529-541",
          "snippet": "static void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nstatic void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AcquireExecutorLocks",
          "args": [
            "plan->stmt_list",
            "false"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "AcquireExecutorLocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1480-1540",
          "snippet": "static void\nAcquireExecutorLocks(List *stmt_list, bool acquire)\n{\n\tListCell   *lc1;\n\n\tforeach(lc1, stmt_list)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc1);\n\t\tint\t\t\trt_index;\n\t\tListCell   *lc2;\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t{\n\t\t\t/*\n\t\t\t * Ignore utility statements, except those (such as EXPLAIN) that\n\t\t\t * contain a parsed-but-not-planned query.  Note: it's okay to use\n\t\t\t * ScanQueryForLocks, even though the query hasn't been through\n\t\t\t * rule rewriting, because rewriting doesn't change the query\n\t\t\t * representation.\n\t\t\t */\n\t\t\tQuery\t   *query = UtilityContainsQuery(plannedstmt->utilityStmt);\n\n\t\t\tif (query)\n\t\t\t\tScanQueryForLocks(query, acquire);\n\t\t\tcontinue;\n\t\t}\n\n\t\trt_index = 0;\n\t\tforeach(lc2, plannedstmt->rtable)\n\t\t{\n\t\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc2);\n\t\t\tLOCKMODE\tlockmode;\n\t\t\tPlanRowMark *rc;\n\n\t\t\trt_index++;\n\n\t\t\tif (rte->rtekind != RTE_RELATION)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Acquire the appropriate type of lock on each relation OID. Note\n\t\t\t * that we don't actually try to open the rel, and hence will not\n\t\t\t * fail if it's been dropped entirely --- we'll just transiently\n\t\t\t * acquire a non-conflicting lock.\n\t\t\t */\n\t\t\tif (list_member_int(plannedstmt->resultRelations, rt_index) ||\n\t\t\t\tlist_member_int(plannedstmt->nonleafResultRelations, rt_index))\n\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\telse if ((rc = get_plan_rowmark(plannedstmt->rowMarks, rt_index)) != NULL &&\n\t\t\t\t\t RowMarkRequiresRowShareLock(rc->markType))\n\t\t\t\tlockmode = RowShareLock;\n\t\t\telse\n\t\t\t\tlockmode = AccessShareLock;\n\n\t\t\tif (acquire)\n\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\telse\n\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
            "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
            "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
            "static bool ScanQueryWalker(Node *node, bool *acquire);",
            "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);",
            "static void PlanCacheRelCallback(Datum arg, Oid relid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\nstatic void PlanCacheRelCallback(Datum arg, Oid relid);\n\nstatic void\nAcquireExecutorLocks(List *stmt_list, bool acquire)\n{\n\tListCell   *lc1;\n\n\tforeach(lc1, stmt_list)\n\t{\n\t\tPlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc1);\n\t\tint\t\t\trt_index;\n\t\tListCell   *lc2;\n\n\t\tif (plannedstmt->commandType == CMD_UTILITY)\n\t\t{\n\t\t\t/*\n\t\t\t * Ignore utility statements, except those (such as EXPLAIN) that\n\t\t\t * contain a parsed-but-not-planned query.  Note: it's okay to use\n\t\t\t * ScanQueryForLocks, even though the query hasn't been through\n\t\t\t * rule rewriting, because rewriting doesn't change the query\n\t\t\t * representation.\n\t\t\t */\n\t\t\tQuery\t   *query = UtilityContainsQuery(plannedstmt->utilityStmt);\n\n\t\t\tif (query)\n\t\t\t\tScanQueryForLocks(query, acquire);\n\t\t\tcontinue;\n\t\t}\n\n\t\trt_index = 0;\n\t\tforeach(lc2, plannedstmt->rtable)\n\t\t{\n\t\t\tRangeTblEntry *rte = (RangeTblEntry *) lfirst(lc2);\n\t\t\tLOCKMODE\tlockmode;\n\t\t\tPlanRowMark *rc;\n\n\t\t\trt_index++;\n\n\t\t\tif (rte->rtekind != RTE_RELATION)\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Acquire the appropriate type of lock on each relation OID. Note\n\t\t\t * that we don't actually try to open the rel, and hence will not\n\t\t\t * fail if it's been dropped entirely --- we'll just transiently\n\t\t\t * acquire a non-conflicting lock.\n\t\t\t */\n\t\t\tif (list_member_int(plannedstmt->resultRelations, rt_index) ||\n\t\t\t\tlist_member_int(plannedstmt->nonleafResultRelations, rt_index))\n\t\t\t\tlockmode = RowExclusiveLock;\n\t\t\telse if ((rc = get_plan_rowmark(plannedstmt->rowMarks, rt_index)) != NULL &&\n\t\t\t\t\t RowMarkRequiresRowShareLock(rc->markType))\n\t\t\t\tlockmode = RowShareLock;\n\t\t\telse\n\t\t\t\tlockmode = AccessShareLock;\n\n\t\t\tif (acquire)\n\t\t\t\tLockRelationOid(rte->relid, lockmode);\n\t\t\telse\n\t\t\t\tUnlockRelationOid(rte->relid, lockmode);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransactionIdEquals",
          "args": [
            "plan->saved_xmin",
            "TransactionXmin"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsValid",
          "args": [
            "plan->saved_xmin"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plan->refcount > 0"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!plan->is_oneshot"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plan->magic == CACHEDPLAN_MAGIC"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->is_valid"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic bool\nCheckCachedPlan(CachedPlanSource *plansource)\n{\n\tCachedPlan *plan = plansource->gplan;\n\n\t/* Assert that caller checked the querytree */\n\tAssert(plansource->is_valid);\n\n\t/* If there's no generic plan, just say \"false\" */\n\tif (!plan)\n\t\treturn false;\n\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t/* Generic plans are never one-shot */\n\tAssert(!plan->is_oneshot);\n\n\t/*\n\t * If plan isn't valid for current role, we can't use it.\n\t */\n\tif (plan->is_valid && plan->dependsOnRole &&\n\t\tplan->planRoleId != GetUserId())\n\t\tplan->is_valid = false;\n\n\t/*\n\t * If it appears valid, acquire locks and recheck; this is much the same\n\t * logic as in RevalidateCachedQuery, but for a plan.\n\t */\n\tif (plan->is_valid)\n\t{\n\t\t/*\n\t\t * Plan must have positive refcount because it is referenced by\n\t\t * plansource; so no need to fear it disappears under us here.\n\t\t */\n\t\tAssert(plan->refcount > 0);\n\n\t\tAcquireExecutorLocks(plan->stmt_list, true);\n\n\t\t/*\n\t\t * If plan was transient, check to see if TransactionXmin has\n\t\t * advanced, and if so invalidate it.\n\t\t */\n\t\tif (plan->is_valid &&\n\t\t\tTransactionIdIsValid(plan->saved_xmin) &&\n\t\t\t!TransactionIdEquals(plan->saved_xmin, TransactionXmin))\n\t\t\tplan->is_valid = false;\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the plan invalid.\n\t\t */\n\t\tif (plan->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn true;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquireExecutorLocks(plan->stmt_list, false);\n\t}\n\n\t/*\n\t * Plan has been invalidated, so unlink it from the parent and release it.\n\t */\n\tReleaseGenericPlan(plansource);\n\n\treturn false;\n}"
  },
  {
    "function_name": "RevalidateCachedQuery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "557-786",
    "snippet": "static List *\nRevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv)\n{\n\tbool\t\tsnapshot_set;\n\tRawStmt    *rawtree;\n\tList\t   *tlist;\t\t\t/* transient query-tree list */\n\tList\t   *qlist;\t\t\t/* permanent query-tree list */\n\tTupleDesc\tresultDesc;\n\tMemoryContext querytree_context;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * For one-shot plans, we do not support revalidation checking; it's\n\t * assumed the query is parsed, planned, and executed in one transaction,\n\t * so that no lock re-acquisition is necessary.  Also, there is never any\n\t * need to revalidate plans for transaction control commands (and we\n\t * mustn't risk any catalog accesses when handling those).\n\t */\n\tif (plansource->is_oneshot || IsTransactionStmtPlan(plansource))\n\t{\n\t\tAssert(plansource->is_valid);\n\t\treturn NIL;\n\t}\n\n\t/*\n\t * If the query is currently valid, we should have a saved search_path ---\n\t * check to see if that matches the current environment.  If not, we want\n\t * to force replan.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAssert(plansource->search_path != NULL);\n\t\tif (!OverrideSearchPathMatchesCurrent(plansource->search_path))\n\t\t{\n\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\tplansource->is_valid = false;\n\t\t\tif (plansource->gplan)\n\t\t\t\tplansource->gplan->is_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * If the query rewrite phase had a possible RLS dependency, we must redo\n\t * it if either the role or the row_security setting has changed.\n\t */\n\tif (plansource->is_valid && plansource->dependsOnRLS &&\n\t\t(plansource->rewriteRoleId != GetUserId() ||\n\t\t plansource->rewriteRowSecurity != row_security))\n\t\tplansource->is_valid = false;\n\n\t/*\n\t * If the query is currently valid, acquire locks on the referenced\n\t * objects; then check again.  We need to do it this way to cover the race\n\t * condition that an invalidation message arrives before we get the locks.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAcquirePlannerLocks(plansource->query_list, true);\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the query invalid.\n\t\t */\n\t\tif (plansource->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn NIL;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquirePlannerLocks(plansource->query_list, false);\n\t}\n\n\t/*\n\t * Discard the no-longer-useful query tree.  (Note: we don't want to do\n\t * this any earlier, else we'd not have been able to release locks\n\t * correctly in the race condition case.)\n\t */\n\tplansource->is_valid = false;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\n\t/*\n\t * Free the query_context.  We don't really expect MemoryContextDelete to\n\t * fail, but just in case, make sure the CachedPlanSource is left in a\n\t * reasonably sane state.  (The generic plan won't get unlinked yet, but\n\t * that's acceptable.)\n\t */\n\tif (plansource->query_context)\n\t{\n\t\tMemoryContext qcxt = plansource->query_context;\n\n\t\tplansource->query_context = NULL;\n\t\tMemoryContextDelete(qcxt);\n\t}\n\n\t/* Drop the generic plan reference if any */\n\tReleaseGenericPlan(plansource);\n\n\t/*\n\t * Now re-do parse analysis and rewrite.  This not incidentally acquires\n\t * the locks we need to do planning safely.\n\t */\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for parsing/planning.  But if it isn't, install one.  Note: no point in\n\t * checking whether parse analysis requires a snapshot; utility commands\n\t * don't have invalidatable plans, so we'd not get here for such a\n\t * command.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet())\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Run parse analysis and rule rewriting.  The parser tends to scribble on\n\t * its input, so we must copy the raw parse tree to prevent corruption of\n\t * the cache.\n\t */\n\trawtree = copyObject(plansource->raw_parse_tree);\n\tif (rawtree == NULL)\n\t\ttlist = NIL;\n\telse if (plansource->parserSetup != NULL)\n\t\ttlist = pg_analyze_and_rewrite_params(rawtree,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->query_string,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetup,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetupArg,\n\t\t\t\t\t\t\t\t\t\t\t  queryEnv);\n\telse\n\t\ttlist = pg_analyze_and_rewrite(rawtree,\n\t\t\t\t\t\t\t\t\t   plansource->query_string,\n\t\t\t\t\t\t\t\t\t   plansource->param_types,\n\t\t\t\t\t\t\t\t\t   plansource->num_params,\n\t\t\t\t\t\t\t\t\t   queryEnv);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Check or update the result tupdesc.  XXX should we use a weaker\n\t * condition than equalTupleDescs() here?\n\t *\n\t * We assume the parameter types didn't change from the first time, so no\n\t * need to update that.\n\t */\n\tresultDesc = PlanCacheComputeResultDesc(tlist);\n\tif (resultDesc == NULL && plansource->resultDesc == NULL)\n\t{\n\t\t/* OK, doesn't return tuples */\n\t}\n\telse if (resultDesc == NULL || plansource->resultDesc == NULL ||\n\t\t\t !equalTupleDescs(resultDesc, plansource->resultDesc))\n\t{\n\t\t/* can we give a better error message? */\n\t\tif (plansource->fixed_result)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cached plan must not change result type\")));\n\t\toldcxt = MemoryContextSwitchTo(plansource->context);\n\t\tif (resultDesc)\n\t\t\tresultDesc = CreateTupleDescCopy(resultDesc);\n\t\tif (plansource->resultDesc)\n\t\t\tFreeTupleDesc(plansource->resultDesc);\n\t\tplansource->resultDesc = resultDesc;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Allocate new query_context and copy the completed querytree into it.\n\t * It's transient until we complete the copying and dependency extraction.\n\t */\n\tquerytree_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\toldcxt = MemoryContextSwitchTo(querytree_context);\n\n\tqlist = copyObject(tlist);\n\n\t/*\n\t * Use the planner machinery to extract dependencies.  Data is saved in\n\t * query_context.  (We assume that not a lot of extra cruft is created by\n\t * this call.)\n\t */\n\textract_query_dependencies((Node *) qlist,\n\t\t\t\t\t\t\t   &plansource->relationOids,\n\t\t\t\t\t\t\t   &plansource->invalItems,\n\t\t\t\t\t\t\t   &plansource->dependsOnRLS);\n\n\t/* Update RLS info as well. */\n\tplansource->rewriteRoleId = GetUserId();\n\tplansource->rewriteRowSecurity = row_security;\n\n\t/*\n\t * Also save the current search_path in the query_context.  (This should\n\t * not generate much extra cruft either, since almost certainly the path\n\t * is already valid.)\n\t */\n\tplansource->search_path = GetOverrideSearchPath(querytree_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Now reparent the finished query_context and save the links */\n\tMemoryContextSetParent(querytree_context, plansource->context);\n\n\tplansource->query_context = querytree_context;\n\tplansource->query_list = qlist;\n\n\t/*\n\t * Note: we do not reset generic_cost or total_custom_cost, although we\n\t * could choose to do so.  If the DDL or statistics change that prompted\n\t * the invalidation meant a significant change in the cost estimates, it\n\t * would be better to reset those variables and start fresh; but often it\n\t * doesn't, and we're better retaining our hard-won knowledge about the\n\t * relative costs.\n\t */\n\n\tplansource->is_valid = true;\n\n\t/* Return transient copy of querytrees for possible use in planning */\n\treturn tlist;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);",
      "static CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);",
      "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
      "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
      "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
      "static bool ScanQueryWalker(Node *node, bool *acquire);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSetParent",
          "args": [
            "querytree_context",
            "plansource->context"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextSetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "353-397",
          "snippet": "void\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetOverrideSearchPath",
          "args": [
            "querytree_context"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_query_dependencies",
          "args": [
            "(Node *) qlist",
            "&plansource->relationOids",
            "&plansource->invalItems",
            "&plansource->dependsOnRLS"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "tlist"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "querytree_context"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"CachedPlanQuery\"",
            "ALLOCSET_START_SMALL_SIZES"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeTupleDesc",
          "args": [
            "plansource->resultDesc"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "RememberToFreeTupleDescAtEOX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2789-2815",
          "snippet": "static void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *EOXactTupleDescArray;",
            "static int\tNextEOXactTupleDescNum = 0;",
            "static int\tEOXactTupleDescArrayLen = 0;",
            "static void RememberToFreeTupleDescAtEOX(TupleDesc td);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *EOXactTupleDescArray;\nstatic int\tNextEOXactTupleDescNum = 0;\nstatic int\tEOXactTupleDescArrayLen = 0;\nstatic void RememberToFreeTupleDescAtEOX(TupleDesc td);\n\nstatic void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "resultDesc"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "plansource->context"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cached plan must not change result type\"))"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cached plan must not change result type\""
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "equalTupleDescs",
          "args": [
            "resultDesc",
            "plansource->resultDesc"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PlanCacheComputeResultDesc",
          "args": [
            "tlist"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "PlanCacheComputeResultDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1673-1700",
          "snippet": "static TupleDesc\nPlanCacheComputeResultDesc(List *stmt_list)\n{\n\tQuery\t   *query;\n\n\tswitch (ChoosePortalStrategy(stmt_list))\n\t{\n\t\tcase PORTAL_ONE_SELECT:\n\t\tcase PORTAL_ONE_MOD_WITH:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\treturn ExecCleanTypeFromTL(query->targetList, false);\n\n\t\tcase PORTAL_ONE_RETURNING:\n\t\t\tquery = QueryListGetPrimaryStmt(stmt_list);\n\t\t\tAssert(query->returningList);\n\t\t\treturn ExecCleanTypeFromTL(query->returningList, false);\n\n\t\tcase PORTAL_UTIL_SELECT:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\tAssert(query->utilityStmt);\n\t\t\treturn UtilityTupleDescriptor(query->utilityStmt);\n\n\t\tcase PORTAL_MULTI_QUERY:\n\t\t\t/* will not return tuples */\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic TupleDesc\nPlanCacheComputeResultDesc(List *stmt_list)\n{\n\tQuery\t   *query;\n\n\tswitch (ChoosePortalStrategy(stmt_list))\n\t{\n\t\tcase PORTAL_ONE_SELECT:\n\t\tcase PORTAL_ONE_MOD_WITH:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\treturn ExecCleanTypeFromTL(query->targetList, false);\n\n\t\tcase PORTAL_ONE_RETURNING:\n\t\t\tquery = QueryListGetPrimaryStmt(stmt_list);\n\t\t\tAssert(query->returningList);\n\t\t\treturn ExecCleanTypeFromTL(query->returningList, false);\n\n\t\tcase PORTAL_UTIL_SELECT:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\tAssert(query->utilityStmt);\n\t\t\treturn UtilityTupleDescriptor(query->utilityStmt);\n\n\t\tcase PORTAL_MULTI_QUERY:\n\t\t\t/* will not return tuples */\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PopActiveSnapshot",
          "args": [],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "PopActiveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "811-832",
          "snippet": "void\nPopActiveSnapshot(void)\n{\n\tActiveSnapshotElt *newstack;\n\n\tnewstack = ActiveSnapshot->as_next;\n\n\tAssert(ActiveSnapshot->as_snap->active_count > 0);\n\n\tActiveSnapshot->as_snap->active_count--;\n\n\tif (ActiveSnapshot->as_snap->active_count == 0 &&\n\t\tActiveSnapshot->as_snap->regd_count == 0)\n\t\tFreeSnapshot(ActiveSnapshot->as_snap);\n\n\tpfree(ActiveSnapshot);\n\tActiveSnapshot = newstack;\n\tif (ActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = NULL;\n\n\tSnapshotResetXmin();\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static ActiveSnapshotElt *OldestActiveSnapshot = NULL;",
            "static void SnapshotResetXmin(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\nstatic void SnapshotResetXmin(void);\n\nvoid\nPopActiveSnapshot(void)\n{\n\tActiveSnapshotElt *newstack;\n\n\tnewstack = ActiveSnapshot->as_next;\n\n\tAssert(ActiveSnapshot->as_snap->active_count > 0);\n\n\tActiveSnapshot->as_snap->active_count--;\n\n\tif (ActiveSnapshot->as_snap->active_count == 0 &&\n\t\tActiveSnapshot->as_snap->regd_count == 0)\n\t\tFreeSnapshot(ActiveSnapshot->as_snap);\n\n\tpfree(ActiveSnapshot);\n\tActiveSnapshot = newstack;\n\tif (ActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = NULL;\n\n\tSnapshotResetXmin();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_analyze_and_rewrite",
          "args": [
            "rawtree",
            "plansource->query_string",
            "plansource->param_types",
            "plansource->num_params",
            "queryEnv"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_analyze_and_rewrite_params",
          "args": [
            "rawtree",
            "plansource->query_string",
            "plansource->parserSetup",
            "plansource->parserSetupArg",
            "queryEnv"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "plansource->raw_parse_tree"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PushActiveSnapshot",
          "args": [
            "GetTransactionSnapshot()"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "PushActiveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "732-758",
          "snippet": "void\nPushActiveSnapshot(Snapshot snap)\n{\n\tActiveSnapshotElt *newactive;\n\n\tAssert(snap != InvalidSnapshot);\n\n\tnewactive = MemoryContextAlloc(TopTransactionContext, sizeof(ActiveSnapshotElt));\n\n\t/*\n\t * Checking SecondarySnapshot is probably useless here, but it seems\n\t * better to be sure.\n\t */\n\tif (snap == CurrentSnapshot || snap == SecondarySnapshot || !snap->copied)\n\t\tnewactive->as_snap = CopySnapshot(snap);\n\telse\n\t\tnewactive->as_snap = snap;\n\n\tnewactive->as_next = ActiveSnapshot;\n\tnewactive->as_level = GetCurrentTransactionNestLevel();\n\n\tnewactive->as_snap->active_count++;\n\n\tActiveSnapshot = newactive;\n\tif (OldestActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = ActiveSnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CurrentSnapshot = NULL;",
            "static Snapshot SecondarySnapshot = NULL;",
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static ActiveSnapshotElt *OldestActiveSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot SecondarySnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\n\nvoid\nPushActiveSnapshot(Snapshot snap)\n{\n\tActiveSnapshotElt *newactive;\n\n\tAssert(snap != InvalidSnapshot);\n\n\tnewactive = MemoryContextAlloc(TopTransactionContext, sizeof(ActiveSnapshotElt));\n\n\t/*\n\t * Checking SecondarySnapshot is probably useless here, but it seems\n\t * better to be sure.\n\t */\n\tif (snap == CurrentSnapshot || snap == SecondarySnapshot || !snap->copied)\n\t\tnewactive->as_snap = CopySnapshot(snap);\n\telse\n\t\tnewactive->as_snap = snap;\n\n\tnewactive->as_next = ActiveSnapshot;\n\tnewactive->as_level = GetCurrentTransactionNestLevel();\n\n\tnewactive->as_snap->active_count++;\n\n\tActiveSnapshot = newactive;\n\tif (OldestActiveSnapshot == NULL)\n\t\tOldestActiveSnapshot = ActiveSnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTransactionSnapshot",
          "args": [],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransactionSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "303-371",
          "snippet": "Snapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot CurrentSnapshot = NULL;",
            "static Snapshot HistoricSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "bool\t\tFirstSnapshotSet = false;",
            "static Snapshot FirstXactSnapshot = NULL;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic SnapshotData CurrentSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CurrentSnapshot = NULL;\nstatic Snapshot HistoricSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nbool\t\tFirstSnapshotSet = false;\nstatic Snapshot FirstXactSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetTransactionSnapshot(void)\n{\n\t/*\n\t * Return historic snapshot if doing logical decoding. We'll never need a\n\t * non-historic transaction snapshot in this (sub-)transaction, so there's\n\t * no need to be careful to set one up for later calls to\n\t * GetTransactionSnapshot().\n\t */\n\tif (HistoricSnapshotActive())\n\t{\n\t\tAssert(!FirstSnapshotSet);\n\t\treturn HistoricSnapshot;\n\t}\n\n\t/* First call in transaction? */\n\tif (!FirstSnapshotSet)\n\t{\n\t\t/*\n\t\t * Don't allow catalog snapshot to be older than xact snapshot.  Must\n\t\t * do this first to allow the empty-heap Assert to succeed.\n\t\t */\n\t\tInvalidateCatalogSnapshot();\n\n\t\tAssert(pairingheap_is_empty(&RegisteredSnapshots));\n\t\tAssert(FirstXactSnapshot == NULL);\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR,\n\t\t\t\t \"cannot take query snapshot during a parallel operation\");\n\n\t\t/*\n\t\t * In transaction-snapshot mode, the first snapshot must live until\n\t\t * end of xact regardless of what the caller does with it, so we must\n\t\t * make a copy of it rather than returning CurrentSnapshotData\n\t\t * directly.  Furthermore, if we're running in serializable mode,\n\t\t * predicate.c needs to wrap the snapshot fetch in its own processing.\n\t\t */\n\t\tif (IsolationUsesXactSnapshot())\n\t\t{\n\t\t\t/* First, create the snapshot in CurrentSnapshotData */\n\t\t\tif (IsolationIsSerializable())\n\t\t\t\tCurrentSnapshot = GetSerializableTransactionSnapshot(&CurrentSnapshotData);\n\t\t\telse\n\t\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\t\t\t/* Make a saved copy */\n\t\t\tCurrentSnapshot = CopySnapshot(CurrentSnapshot);\n\t\t\tFirstXactSnapshot = CurrentSnapshot;\n\t\t\t/* Mark it as \"registered\" in FirstXactSnapshot */\n\t\t\tFirstXactSnapshot->regd_count++;\n\t\t\tpairingheap_add(&RegisteredSnapshots, &FirstXactSnapshot->ph_node);\n\t\t}\n\t\telse\n\t\t\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\t\tFirstSnapshotSet = true;\n\t\treturn CurrentSnapshot;\n\t}\n\n\tif (IsolationUsesXactSnapshot())\n\t\treturn CurrentSnapshot;\n\n\t/* Don't allow catalog snapshot to be older than xact snapshot. */\n\tInvalidateCatalogSnapshot();\n\n\tCurrentSnapshot = GetSnapshotData(&CurrentSnapshotData);\n\n\treturn CurrentSnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ActiveSnapshotSet",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "ActiveSnapshotSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "850-854",
          "snippet": "bool\nActiveSnapshotSet(void)\n{\n\treturn ActiveSnapshot != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\n\nbool\nActiveSnapshotSet(void)\n{\n\treturn ActiveSnapshot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->is_complete"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseGenericPlan",
          "args": [
            "plansource"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseGenericPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "529-541",
          "snippet": "static void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nstatic void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "qcxt"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AcquirePlannerLocks",
          "args": [
            "plansource->query_list",
            "false"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "AcquirePlannerLocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1550-1570",
          "snippet": "static void\nAcquirePlannerLocks(List *stmt_list, bool acquire)\n{\n\tListCell   *lc;\n\n\tforeach(lc, stmt_list)\n\t{\n\t\tQuery\t   *query = lfirst_node(Query, lc);\n\n\t\tif (query->commandType == CMD_UTILITY)\n\t\t{\n\t\t\t/* Ignore utility statements, unless they contain a Query */\n\t\t\tquery = UtilityContainsQuery(query->utilityStmt);\n\t\t\tif (query)\n\t\t\t\tScanQueryForLocks(query, acquire);\n\t\t\tcontinue;\n\t\t}\n\n\t\tScanQueryForLocks(query, acquire);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AcquireExecutorLocks(List *stmt_list, bool acquire);",
            "static void AcquirePlannerLocks(List *stmt_list, bool acquire);",
            "static void ScanQueryForLocks(Query *parsetree, bool acquire);",
            "static bool ScanQueryWalker(Node *node, bool *acquire);",
            "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic void\nAcquirePlannerLocks(List *stmt_list, bool acquire)\n{\n\tListCell   *lc;\n\n\tforeach(lc, stmt_list)\n\t{\n\t\tQuery\t   *query = lfirst_node(Query, lc);\n\n\t\tif (query->commandType == CMD_UTILITY)\n\t\t{\n\t\t\t/* Ignore utility statements, unless they contain a Query */\n\t\t\tquery = UtilityContainsQuery(query->utilityStmt);\n\t\t\tif (query)\n\t\t\t\tScanQueryForLocks(query, acquire);\n\t\t\tcontinue;\n\t\t}\n\n\t\tScanQueryForLocks(query, acquire);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OverrideSearchPathMatchesCurrent",
          "args": [
            "plansource->search_path"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->search_path != NULL"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->is_valid"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsTransactionStmtPlan",
          "args": [
            "plansource"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic List *RevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\nstatic CachedPlan *BuildCachedPlan(CachedPlanSource *plansource, List *qlist,\n\t\t\t\tParamListInfo boundParams, QueryEnvironment *queryEnv);\nstatic void AcquireExecutorLocks(List *stmt_list, bool acquire);\nstatic void AcquirePlannerLocks(List *stmt_list, bool acquire);\nstatic void ScanQueryForLocks(Query *parsetree, bool acquire);\nstatic bool ScanQueryWalker(Node *node, bool *acquire);\n\nstatic List *\nRevalidateCachedQuery(CachedPlanSource *plansource,\n\t\t\t\t\t  QueryEnvironment *queryEnv)\n{\n\tbool\t\tsnapshot_set;\n\tRawStmt    *rawtree;\n\tList\t   *tlist;\t\t\t/* transient query-tree list */\n\tList\t   *qlist;\t\t\t/* permanent query-tree list */\n\tTupleDesc\tresultDesc;\n\tMemoryContext querytree_context;\n\tMemoryContext oldcxt;\n\n\t/*\n\t * For one-shot plans, we do not support revalidation checking; it's\n\t * assumed the query is parsed, planned, and executed in one transaction,\n\t * so that no lock re-acquisition is necessary.  Also, there is never any\n\t * need to revalidate plans for transaction control commands (and we\n\t * mustn't risk any catalog accesses when handling those).\n\t */\n\tif (plansource->is_oneshot || IsTransactionStmtPlan(plansource))\n\t{\n\t\tAssert(plansource->is_valid);\n\t\treturn NIL;\n\t}\n\n\t/*\n\t * If the query is currently valid, we should have a saved search_path ---\n\t * check to see if that matches the current environment.  If not, we want\n\t * to force replan.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAssert(plansource->search_path != NULL);\n\t\tif (!OverrideSearchPathMatchesCurrent(plansource->search_path))\n\t\t{\n\t\t\t/* Invalidate the querytree and generic plan */\n\t\t\tplansource->is_valid = false;\n\t\t\tif (plansource->gplan)\n\t\t\t\tplansource->gplan->is_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * If the query rewrite phase had a possible RLS dependency, we must redo\n\t * it if either the role or the row_security setting has changed.\n\t */\n\tif (plansource->is_valid && plansource->dependsOnRLS &&\n\t\t(plansource->rewriteRoleId != GetUserId() ||\n\t\t plansource->rewriteRowSecurity != row_security))\n\t\tplansource->is_valid = false;\n\n\t/*\n\t * If the query is currently valid, acquire locks on the referenced\n\t * objects; then check again.  We need to do it this way to cover the race\n\t * condition that an invalidation message arrives before we get the locks.\n\t */\n\tif (plansource->is_valid)\n\t{\n\t\tAcquirePlannerLocks(plansource->query_list, true);\n\n\t\t/*\n\t\t * By now, if any invalidation has happened, the inval callback\n\t\t * functions will have marked the query invalid.\n\t\t */\n\t\tif (plansource->is_valid)\n\t\t{\n\t\t\t/* Successfully revalidated and locked the query. */\n\t\t\treturn NIL;\n\t\t}\n\n\t\t/* Oops, the race case happened.  Release useless locks. */\n\t\tAcquirePlannerLocks(plansource->query_list, false);\n\t}\n\n\t/*\n\t * Discard the no-longer-useful query tree.  (Note: we don't want to do\n\t * this any earlier, else we'd not have been able to release locks\n\t * correctly in the race condition case.)\n\t */\n\tplansource->is_valid = false;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\n\t/*\n\t * Free the query_context.  We don't really expect MemoryContextDelete to\n\t * fail, but just in case, make sure the CachedPlanSource is left in a\n\t * reasonably sane state.  (The generic plan won't get unlinked yet, but\n\t * that's acceptable.)\n\t */\n\tif (plansource->query_context)\n\t{\n\t\tMemoryContext qcxt = plansource->query_context;\n\n\t\tplansource->query_context = NULL;\n\t\tMemoryContextDelete(qcxt);\n\t}\n\n\t/* Drop the generic plan reference if any */\n\tReleaseGenericPlan(plansource);\n\n\t/*\n\t * Now re-do parse analysis and rewrite.  This not incidentally acquires\n\t * the locks we need to do planning safely.\n\t */\n\tAssert(plansource->is_complete);\n\n\t/*\n\t * If a snapshot is already set (the normal case), we can just use that\n\t * for parsing/planning.  But if it isn't, install one.  Note: no point in\n\t * checking whether parse analysis requires a snapshot; utility commands\n\t * don't have invalidatable plans, so we'd not get here for such a\n\t * command.\n\t */\n\tsnapshot_set = false;\n\tif (!ActiveSnapshotSet())\n\t{\n\t\tPushActiveSnapshot(GetTransactionSnapshot());\n\t\tsnapshot_set = true;\n\t}\n\n\t/*\n\t * Run parse analysis and rule rewriting.  The parser tends to scribble on\n\t * its input, so we must copy the raw parse tree to prevent corruption of\n\t * the cache.\n\t */\n\trawtree = copyObject(plansource->raw_parse_tree);\n\tif (rawtree == NULL)\n\t\ttlist = NIL;\n\telse if (plansource->parserSetup != NULL)\n\t\ttlist = pg_analyze_and_rewrite_params(rawtree,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->query_string,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetup,\n\t\t\t\t\t\t\t\t\t\t\t  plansource->parserSetupArg,\n\t\t\t\t\t\t\t\t\t\t\t  queryEnv);\n\telse\n\t\ttlist = pg_analyze_and_rewrite(rawtree,\n\t\t\t\t\t\t\t\t\t   plansource->query_string,\n\t\t\t\t\t\t\t\t\t   plansource->param_types,\n\t\t\t\t\t\t\t\t\t   plansource->num_params,\n\t\t\t\t\t\t\t\t\t   queryEnv);\n\n\t/* Release snapshot if we got one */\n\tif (snapshot_set)\n\t\tPopActiveSnapshot();\n\n\t/*\n\t * Check or update the result tupdesc.  XXX should we use a weaker\n\t * condition than equalTupleDescs() here?\n\t *\n\t * We assume the parameter types didn't change from the first time, so no\n\t * need to update that.\n\t */\n\tresultDesc = PlanCacheComputeResultDesc(tlist);\n\tif (resultDesc == NULL && plansource->resultDesc == NULL)\n\t{\n\t\t/* OK, doesn't return tuples */\n\t}\n\telse if (resultDesc == NULL || plansource->resultDesc == NULL ||\n\t\t\t !equalTupleDescs(resultDesc, plansource->resultDesc))\n\t{\n\t\t/* can we give a better error message? */\n\t\tif (plansource->fixed_result)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cached plan must not change result type\")));\n\t\toldcxt = MemoryContextSwitchTo(plansource->context);\n\t\tif (resultDesc)\n\t\t\tresultDesc = CreateTupleDescCopy(resultDesc);\n\t\tif (plansource->resultDesc)\n\t\t\tFreeTupleDesc(plansource->resultDesc);\n\t\tplansource->resultDesc = resultDesc;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/*\n\t * Allocate new query_context and copy the completed querytree into it.\n\t * It's transient until we complete the copying and dependency extraction.\n\t */\n\tquerytree_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\toldcxt = MemoryContextSwitchTo(querytree_context);\n\n\tqlist = copyObject(tlist);\n\n\t/*\n\t * Use the planner machinery to extract dependencies.  Data is saved in\n\t * query_context.  (We assume that not a lot of extra cruft is created by\n\t * this call.)\n\t */\n\textract_query_dependencies((Node *) qlist,\n\t\t\t\t\t\t\t   &plansource->relationOids,\n\t\t\t\t\t\t\t   &plansource->invalItems,\n\t\t\t\t\t\t\t   &plansource->dependsOnRLS);\n\n\t/* Update RLS info as well. */\n\tplansource->rewriteRoleId = GetUserId();\n\tplansource->rewriteRowSecurity = row_security;\n\n\t/*\n\t * Also save the current search_path in the query_context.  (This should\n\t * not generate much extra cruft either, since almost certainly the path\n\t * is already valid.)\n\t */\n\tplansource->search_path = GetOverrideSearchPath(querytree_context);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Now reparent the finished query_context and save the links */\n\tMemoryContextSetParent(querytree_context, plansource->context);\n\n\tplansource->query_context = querytree_context;\n\tplansource->query_list = qlist;\n\n\t/*\n\t * Note: we do not reset generic_cost or total_custom_cost, although we\n\t * could choose to do so.  If the DDL or statistics change that prompted\n\t * the invalidation meant a significant change in the cost estimates, it\n\t * would be better to reset those variables and start fresh; but often it\n\t * doesn't, and we're better retaining our hard-won knowledge about the\n\t * relative costs.\n\t */\n\n\tplansource->is_valid = true;\n\n\t/* Return transient copy of querytrees for possible use in planning */\n\treturn tlist;\n}"
  },
  {
    "function_name": "ReleaseGenericPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "529-541",
    "snippet": "static void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseCachedPlan",
          "args": [
            "plan",
            "false"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseCachedPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1257-1277",
          "snippet": "void\nReleaseCachedPlan(CachedPlan *plan, bool useResOwner)\n{\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\tif (useResOwner)\n\t{\n\t\tAssert(plan->is_saved);\n\t\tResourceOwnerForgetPlanCacheRef(CurrentResourceOwner, plan);\n\t}\n\tAssert(plan->refcount > 0);\n\tplan->refcount--;\n\tif (plan->refcount == 0)\n\t{\n\t\t/* Mark it no longer valid */\n\t\tplan->magic = 0;\n\n\t\t/* One-shot plans do not own their context, so we can't free them */\n\t\tif (!plan->is_oneshot)\n\t\t\tMemoryContextDelete(plan->context);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nReleaseCachedPlan(CachedPlan *plan, bool useResOwner)\n{\n\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\tif (useResOwner)\n\t{\n\t\tAssert(plan->is_saved);\n\t\tResourceOwnerForgetPlanCacheRef(CurrentResourceOwner, plan);\n\t}\n\tAssert(plan->refcount > 0);\n\tplan->refcount--;\n\tif (plan->refcount == 0)\n\t{\n\t\t/* Mark it no longer valid */\n\t\tplan->magic = 0;\n\n\t\t/* One-shot plans do not own their context, so we can't free them */\n\t\tif (!plan->is_oneshot)\n\t\t\tMemoryContextDelete(plan->context);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plan->magic == CACHEDPLAN_MAGIC"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nstatic void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}"
  },
  {
    "function_name": "DropCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "486-524",
    "snippet": "void\nDropCachedPlan(CachedPlanSource *plansource)\n{\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\n\t/* If it's been saved, remove it from the list */\n\tif (plansource->is_saved)\n\t{\n\t\tif (first_saved_plan == plansource)\n\t\t\tfirst_saved_plan = plansource->next_saved;\n\t\telse\n\t\t{\n\t\t\tCachedPlanSource *psrc;\n\n\t\t\tfor (psrc = first_saved_plan; psrc; psrc = psrc->next_saved)\n\t\t\t{\n\t\t\t\tif (psrc->next_saved == plansource)\n\t\t\t\t{\n\t\t\t\t\tpsrc->next_saved = plansource->next_saved;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tplansource->is_saved = false;\n\t}\n\n\t/* Decrement generic CachePlan's refcount and drop if no longer needed */\n\tReleaseGenericPlan(plansource);\n\n\t/* Mark it no longer valid */\n\tplansource->magic = 0;\n\n\t/*\n\t * Remove the CachedPlanSource and all subsidiary data (including the\n\t * query_context if any).  But if it's a one-shot we can't free anything.\n\t */\n\tif (!plansource->is_oneshot)\n\t\tMemoryContextDelete(plansource->context);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CachedPlanSource *first_saved_plan = NULL;",
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "plansource->context"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseGenericPlan",
          "args": [
            "plansource"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseGenericPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "529-541",
          "snippet": "static void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nstatic void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic CachedPlanSource *first_saved_plan = NULL;\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nvoid\nDropCachedPlan(CachedPlanSource *plansource)\n{\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\n\t/* If it's been saved, remove it from the list */\n\tif (plansource->is_saved)\n\t{\n\t\tif (first_saved_plan == plansource)\n\t\t\tfirst_saved_plan = plansource->next_saved;\n\t\telse\n\t\t{\n\t\t\tCachedPlanSource *psrc;\n\n\t\t\tfor (psrc = first_saved_plan; psrc; psrc = psrc->next_saved)\n\t\t\t{\n\t\t\t\tif (psrc->next_saved == plansource)\n\t\t\t\t{\n\t\t\t\t\tpsrc->next_saved = plansource->next_saved;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tplansource->is_saved = false;\n\t}\n\n\t/* Decrement generic CachePlan's refcount and drop if no longer needed */\n\tReleaseGenericPlan(plansource);\n\n\t/* Mark it no longer valid */\n\tplansource->magic = 0;\n\n\t/*\n\t * Remove the CachedPlanSource and all subsidiary data (including the\n\t * query_context if any).  But if it's a one-shot we can't free anything.\n\t */\n\tif (!plansource->is_oneshot)\n\t\tMemoryContextDelete(plansource->context);\n}"
  },
  {
    "function_name": "SaveCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "441-476",
    "snippet": "void\nSaveCachedPlan(CachedPlanSource *plansource)\n{\n\t/* Assert caller is doing things in a sane order */\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(plansource->is_complete);\n\tAssert(!plansource->is_saved);\n\n\t/* This seems worth a real test, though */\n\tif (plansource->is_oneshot)\n\t\telog(ERROR, \"cannot save one-shot cached plan\");\n\n\t/*\n\t * In typical use, this function would be called before generating any\n\t * plans from the CachedPlanSource.  If there is a generic plan, moving it\n\t * into CacheMemoryContext would be pretty risky since it's unclear\n\t * whether the caller has taken suitable care with making references\n\t * long-lived.  Best thing to do seems to be to discard the plan.\n\t */\n\tReleaseGenericPlan(plansource);\n\n\t/*\n\t * Reparent the source memory context under CacheMemoryContext so that it\n\t * will live indefinitely.  The query_context follows along since it's\n\t * already a child of the other one.\n\t */\n\tMemoryContextSetParent(plansource->context, CacheMemoryContext);\n\n\t/*\n\t * Add the entry to the global list of cached plans.\n\t */\n\tplansource->next_saved = first_saved_plan;\n\tfirst_saved_plan = plansource;\n\n\tplansource->is_saved = true;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CachedPlanSource *first_saved_plan = NULL;",
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSetParent",
          "args": [
            "plansource->context",
            "CacheMemoryContext"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextSetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "353-397",
          "snippet": "void\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseGenericPlan",
          "args": [
            "plansource"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseGenericPlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "529-541",
          "snippet": "static void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
            "static bool CheckCachedPlan(CachedPlanSource *plansource);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nstatic void\nReleaseGenericPlan(CachedPlanSource *plansource)\n{\n\t/* Be paranoid about the possibility that ReleaseCachedPlan fails */\n\tif (plansource->gplan)\n\t{\n\t\tCachedPlan *plan = plansource->gplan;\n\n\t\tAssert(plan->magic == CACHEDPLAN_MAGIC);\n\t\tplansource->gplan = NULL;\n\t\tReleaseCachedPlan(plan, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot save one-shot cached plan\""
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!plansource->is_saved"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->is_complete"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic CachedPlanSource *first_saved_plan = NULL;\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nvoid\nSaveCachedPlan(CachedPlanSource *plansource)\n{\n\t/* Assert caller is doing things in a sane order */\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(plansource->is_complete);\n\tAssert(!plansource->is_saved);\n\n\t/* This seems worth a real test, though */\n\tif (plansource->is_oneshot)\n\t\telog(ERROR, \"cannot save one-shot cached plan\");\n\n\t/*\n\t * In typical use, this function would be called before generating any\n\t * plans from the CachedPlanSource.  If there is a generic plan, moving it\n\t * into CacheMemoryContext would be pretty risky since it's unclear\n\t * whether the caller has taken suitable care with making references\n\t * long-lived.  Best thing to do seems to be to discard the plan.\n\t */\n\tReleaseGenericPlan(plansource);\n\n\t/*\n\t * Reparent the source memory context under CacheMemoryContext so that it\n\t * will live indefinitely.  The query_context follows along since it's\n\t * already a child of the other one.\n\t */\n\tMemoryContextSetParent(plansource->context, CacheMemoryContext);\n\n\t/*\n\t * Add the entry to the global list of cached plans.\n\t */\n\tplansource->next_saved = first_saved_plan;\n\tfirst_saved_plan = plansource;\n\n\tplansource->is_saved = true;\n}"
  },
  {
    "function_name": "CompleteCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "325-424",
    "snippet": "void\nCompleteCachedPlan(CachedPlanSource *plansource,\n\t\t\t\t   List *querytree_list,\n\t\t\t\t   MemoryContext querytree_context,\n\t\t\t\t   Oid *param_types,\n\t\t\t\t   int num_params,\n\t\t\t\t   ParserSetupHook parserSetup,\n\t\t\t\t   void *parserSetupArg,\n\t\t\t\t   int cursor_options,\n\t\t\t\t   bool fixed_result)\n{\n\tMemoryContext source_context = plansource->context;\n\tMemoryContext oldcxt = CurrentMemoryContext;\n\n\t/* Assert caller is doing things in a sane order */\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(!plansource->is_complete);\n\n\t/*\n\t * If caller supplied a querytree_context, reparent it underneath the\n\t * CachedPlanSource's context; otherwise, create a suitable context and\n\t * copy the querytree_list into it.  But no data copying should be done\n\t * for one-shot plans; for those, assume the passed querytree_list is\n\t * sufficiently long-lived.\n\t */\n\tif (plansource->is_oneshot)\n\t{\n\t\tquerytree_context = CurrentMemoryContext;\n\t}\n\telse if (querytree_context != NULL)\n\t{\n\t\tMemoryContextSetParent(querytree_context, source_context);\n\t\tMemoryContextSwitchTo(querytree_context);\n\t}\n\telse\n\t{\n\t\t/* Again, it's a good bet the querytree_context can be small */\n\t\tquerytree_context = AllocSetContextCreate(source_context,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\t\tMemoryContextSwitchTo(querytree_context);\n\t\tquerytree_list = copyObject(querytree_list);\n\t}\n\n\tplansource->query_context = querytree_context;\n\tplansource->query_list = querytree_list;\n\n\tif (!plansource->is_oneshot && !IsTransactionStmtPlan(plansource))\n\t{\n\t\t/*\n\t\t * Use the planner machinery to extract dependencies.  Data is saved\n\t\t * in query_context.  (We assume that not a lot of extra cruft is\n\t\t * created by this call.)  We can skip this for one-shot plans, and\n\t\t * transaction control commands have no such dependencies anyway.\n\t\t */\n\t\textract_query_dependencies((Node *) querytree_list,\n\t\t\t\t\t\t\t\t   &plansource->relationOids,\n\t\t\t\t\t\t\t\t   &plansource->invalItems,\n\t\t\t\t\t\t\t\t   &plansource->dependsOnRLS);\n\n\t\t/* Update RLS info as well. */\n\t\tplansource->rewriteRoleId = GetUserId();\n\t\tplansource->rewriteRowSecurity = row_security;\n\n\t\t/*\n\t\t * Also save the current search_path in the query_context.  (This\n\t\t * should not generate much extra cruft either, since almost certainly\n\t\t * the path is already valid.)\tAgain, we don't really need this for\n\t\t * one-shot plans; and we *must* skip this for transaction control\n\t\t * commands, because this could result in catalog accesses.\n\t\t */\n\t\tplansource->search_path = GetOverrideSearchPath(querytree_context);\n\t}\n\n\t/*\n\t * Save the final parameter types (or other parameter specification data)\n\t * into the source_context, as well as our other parameters.  Also save\n\t * the result tuple descriptor.\n\t */\n\tMemoryContextSwitchTo(source_context);\n\n\tif (num_params > 0)\n\t{\n\t\tplansource->param_types = (Oid *) palloc(num_params * sizeof(Oid));\n\t\tmemcpy(plansource->param_types, param_types, num_params * sizeof(Oid));\n\t}\n\telse\n\t\tplansource->param_types = NULL;\n\tplansource->num_params = num_params;\n\tplansource->parserSetup = parserSetup;\n\tplansource->parserSetupArg = parserSetupArg;\n\tplansource->cursor_options = cursor_options;\n\tplansource->fixed_result = fixed_result;\n\tplansource->resultDesc = PlanCacheComputeResultDesc(querytree_list);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\tplansource->is_complete = true;\n\tplansource->is_valid = true;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PlanCacheComputeResultDesc",
          "args": [
            "querytree_list"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "PlanCacheComputeResultDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
          "lines": "1673-1700",
          "snippet": "static TupleDesc\nPlanCacheComputeResultDesc(List *stmt_list)\n{\n\tQuery\t   *query;\n\n\tswitch (ChoosePortalStrategy(stmt_list))\n\t{\n\t\tcase PORTAL_ONE_SELECT:\n\t\tcase PORTAL_ONE_MOD_WITH:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\treturn ExecCleanTypeFromTL(query->targetList, false);\n\n\t\tcase PORTAL_ONE_RETURNING:\n\t\t\tquery = QueryListGetPrimaryStmt(stmt_list);\n\t\t\tAssert(query->returningList);\n\t\t\treturn ExecCleanTypeFromTL(query->returningList, false);\n\n\t\tcase PORTAL_UTIL_SELECT:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\tAssert(query->utilityStmt);\n\t\t\treturn UtilityTupleDescriptor(query->utilityStmt);\n\n\t\tcase PORTAL_MULTI_QUERY:\n\t\t\t/* will not return tuples */\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"tcop/utility.h\"",
            "#include \"tcop/pquery.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/analyze.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/transam.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc PlanCacheComputeResultDesc(List *stmt_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TupleDesc PlanCacheComputeResultDesc(List *stmt_list);\n\nstatic TupleDesc\nPlanCacheComputeResultDesc(List *stmt_list)\n{\n\tQuery\t   *query;\n\n\tswitch (ChoosePortalStrategy(stmt_list))\n\t{\n\t\tcase PORTAL_ONE_SELECT:\n\t\tcase PORTAL_ONE_MOD_WITH:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\treturn ExecCleanTypeFromTL(query->targetList, false);\n\n\t\tcase PORTAL_ONE_RETURNING:\n\t\t\tquery = QueryListGetPrimaryStmt(stmt_list);\n\t\t\tAssert(query->returningList);\n\t\t\treturn ExecCleanTypeFromTL(query->returningList, false);\n\n\t\tcase PORTAL_UTIL_SELECT:\n\t\t\tquery = linitial_node(Query, stmt_list);\n\t\t\tAssert(query->utilityStmt);\n\t\t\treturn UtilityTupleDescriptor(query->utilityStmt);\n\n\t\tcase PORTAL_MULTI_QUERY:\n\t\t\t/* will not return tuples */\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "plansource->param_types",
            "param_types",
            "num_params * sizeof(Oid)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "num_params * sizeof(Oid)"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "source_context"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetOverrideSearchPath",
          "args": [
            "querytree_context"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_query_dependencies",
          "args": [
            "(Node *) querytree_list",
            "&plansource->relationOids",
            "&plansource->invalItems",
            "&plansource->dependsOnRLS"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsTransactionStmtPlan",
          "args": [
            "plansource"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "querytree_list"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "querytree_context"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "source_context",
            "\"CachedPlanQuery\"",
            "ALLOCSET_START_SMALL_SIZES"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "querytree_context"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSetParent",
          "args": [
            "querytree_context",
            "source_context"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextSetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "353-397",
          "snippet": "void\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextSetParent(MemoryContext context, MemoryContext new_parent)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertArg(context != new_parent);\n\n\t/* Fast path if it's got correct parent already */\n\tif (new_parent == context->parent)\n\t\treturn;\n\n\t/* Delink from existing parent, if any */\n\tif (context->parent)\n\t{\n\t\tMemoryContext parent = context->parent;\n\n\t\tif (context->prevchild != NULL)\n\t\t\tcontext->prevchild->nextchild = context->nextchild;\n\t\telse\n\t\t{\n\t\t\tAssert(parent->firstchild == context);\n\t\t\tparent->firstchild = context->nextchild;\n\t\t}\n\n\t\tif (context->nextchild != NULL)\n\t\t\tcontext->nextchild->prevchild = context->prevchild;\n\t}\n\n\t/* And relink */\n\tif (new_parent)\n\t{\n\t\tAssertArg(MemoryContextIsValid(new_parent));\n\t\tcontext->parent = new_parent;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = new_parent->firstchild;\n\t\tif (new_parent->firstchild != NULL)\n\t\t\tnew_parent->firstchild->prevchild = context;\n\t\tnew_parent->firstchild = context;\n\t}\n\telse\n\t{\n\t\tcontext->parent = NULL;\n\t\tcontext->prevchild = NULL;\n\t\tcontext->nextchild = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!plansource->is_complete"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "plansource->magic == CACHEDPLANSOURCE_MAGIC"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nvoid\nCompleteCachedPlan(CachedPlanSource *plansource,\n\t\t\t\t   List *querytree_list,\n\t\t\t\t   MemoryContext querytree_context,\n\t\t\t\t   Oid *param_types,\n\t\t\t\t   int num_params,\n\t\t\t\t   ParserSetupHook parserSetup,\n\t\t\t\t   void *parserSetupArg,\n\t\t\t\t   int cursor_options,\n\t\t\t\t   bool fixed_result)\n{\n\tMemoryContext source_context = plansource->context;\n\tMemoryContext oldcxt = CurrentMemoryContext;\n\n\t/* Assert caller is doing things in a sane order */\n\tAssert(plansource->magic == CACHEDPLANSOURCE_MAGIC);\n\tAssert(!plansource->is_complete);\n\n\t/*\n\t * If caller supplied a querytree_context, reparent it underneath the\n\t * CachedPlanSource's context; otherwise, create a suitable context and\n\t * copy the querytree_list into it.  But no data copying should be done\n\t * for one-shot plans; for those, assume the passed querytree_list is\n\t * sufficiently long-lived.\n\t */\n\tif (plansource->is_oneshot)\n\t{\n\t\tquerytree_context = CurrentMemoryContext;\n\t}\n\telse if (querytree_context != NULL)\n\t{\n\t\tMemoryContextSetParent(querytree_context, source_context);\n\t\tMemoryContextSwitchTo(querytree_context);\n\t}\n\telse\n\t{\n\t\t/* Again, it's a good bet the querytree_context can be small */\n\t\tquerytree_context = AllocSetContextCreate(source_context,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"CachedPlanQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t  ALLOCSET_START_SMALL_SIZES);\n\t\tMemoryContextSwitchTo(querytree_context);\n\t\tquerytree_list = copyObject(querytree_list);\n\t}\n\n\tplansource->query_context = querytree_context;\n\tplansource->query_list = querytree_list;\n\n\tif (!plansource->is_oneshot && !IsTransactionStmtPlan(plansource))\n\t{\n\t\t/*\n\t\t * Use the planner machinery to extract dependencies.  Data is saved\n\t\t * in query_context.  (We assume that not a lot of extra cruft is\n\t\t * created by this call.)  We can skip this for one-shot plans, and\n\t\t * transaction control commands have no such dependencies anyway.\n\t\t */\n\t\textract_query_dependencies((Node *) querytree_list,\n\t\t\t\t\t\t\t\t   &plansource->relationOids,\n\t\t\t\t\t\t\t\t   &plansource->invalItems,\n\t\t\t\t\t\t\t\t   &plansource->dependsOnRLS);\n\n\t\t/* Update RLS info as well. */\n\t\tplansource->rewriteRoleId = GetUserId();\n\t\tplansource->rewriteRowSecurity = row_security;\n\n\t\t/*\n\t\t * Also save the current search_path in the query_context.  (This\n\t\t * should not generate much extra cruft either, since almost certainly\n\t\t * the path is already valid.)\tAgain, we don't really need this for\n\t\t * one-shot plans; and we *must* skip this for transaction control\n\t\t * commands, because this could result in catalog accesses.\n\t\t */\n\t\tplansource->search_path = GetOverrideSearchPath(querytree_context);\n\t}\n\n\t/*\n\t * Save the final parameter types (or other parameter specification data)\n\t * into the source_context, as well as our other parameters.  Also save\n\t * the result tuple descriptor.\n\t */\n\tMemoryContextSwitchTo(source_context);\n\n\tif (num_params > 0)\n\t{\n\t\tplansource->param_types = (Oid *) palloc(num_params * sizeof(Oid));\n\t\tmemcpy(plansource->param_types, param_types, num_params * sizeof(Oid));\n\t}\n\telse\n\t\tplansource->param_types = NULL;\n\tplansource->num_params = num_params;\n\tplansource->parserSetup = parserSetup;\n\tplansource->parserSetupArg = parserSetupArg;\n\tplansource->cursor_options = cursor_options;\n\tplansource->fixed_result = fixed_result;\n\tplansource->resultDesc = PlanCacheComputeResultDesc(querytree_list);\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\tplansource->is_complete = true;\n\tplansource->is_valid = true;\n}"
  },
  {
    "function_name": "CreateOneShotCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "235-281",
    "snippet": "CachedPlanSource *\nCreateOneShotCachedPlan(RawStmt *raw_parse_tree,\n\t\t\t\t\t\tconst char *query_string,\n\t\t\t\t\t\tconst char *commandTag)\n{\n\tCachedPlanSource *plansource;\n\n\tAssert(query_string != NULL);\t/* required as of 8.4 */\n\n\t/*\n\t * Create and fill the CachedPlanSource struct within the caller's memory\n\t * context.  Most fields are just left empty for the moment.\n\t */\n\tplansource = (CachedPlanSource *) palloc0(sizeof(CachedPlanSource));\n\tplansource->magic = CACHEDPLANSOURCE_MAGIC;\n\tplansource->raw_parse_tree = raw_parse_tree;\n\tplansource->query_string = query_string;\n\tplansource->commandTag = commandTag;\n\tplansource->param_types = NULL;\n\tplansource->num_params = 0;\n\tplansource->parserSetup = NULL;\n\tplansource->parserSetupArg = NULL;\n\tplansource->cursor_options = 0;\n\tplansource->fixed_result = false;\n\tplansource->resultDesc = NULL;\n\tplansource->context = CurrentMemoryContext;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\tplansource->query_context = NULL;\n\tplansource->rewriteRoleId = InvalidOid;\n\tplansource->rewriteRowSecurity = false;\n\tplansource->dependsOnRLS = false;\n\tplansource->gplan = NULL;\n\tplansource->is_oneshot = true;\n\tplansource->is_complete = false;\n\tplansource->is_saved = false;\n\tplansource->is_valid = false;\n\tplansource->generation = 0;\n\tplansource->next_saved = NULL;\n\tplansource->generic_cost = -1;\n\tplansource->total_custom_cost = 0;\n\tplansource->num_custom_plans = 0;\n\n\treturn plansource;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(CachedPlanSource)"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "query_string != NULL"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nCachedPlanSource *\nCreateOneShotCachedPlan(RawStmt *raw_parse_tree,\n\t\t\t\t\t\tconst char *query_string,\n\t\t\t\t\t\tconst char *commandTag)\n{\n\tCachedPlanSource *plansource;\n\n\tAssert(query_string != NULL);\t/* required as of 8.4 */\n\n\t/*\n\t * Create and fill the CachedPlanSource struct within the caller's memory\n\t * context.  Most fields are just left empty for the moment.\n\t */\n\tplansource = (CachedPlanSource *) palloc0(sizeof(CachedPlanSource));\n\tplansource->magic = CACHEDPLANSOURCE_MAGIC;\n\tplansource->raw_parse_tree = raw_parse_tree;\n\tplansource->query_string = query_string;\n\tplansource->commandTag = commandTag;\n\tplansource->param_types = NULL;\n\tplansource->num_params = 0;\n\tplansource->parserSetup = NULL;\n\tplansource->parserSetupArg = NULL;\n\tplansource->cursor_options = 0;\n\tplansource->fixed_result = false;\n\tplansource->resultDesc = NULL;\n\tplansource->context = CurrentMemoryContext;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\tplansource->query_context = NULL;\n\tplansource->rewriteRoleId = InvalidOid;\n\tplansource->rewriteRowSecurity = false;\n\tplansource->dependsOnRLS = false;\n\tplansource->gplan = NULL;\n\tplansource->is_oneshot = true;\n\tplansource->is_complete = false;\n\tplansource->is_saved = false;\n\tplansource->is_valid = false;\n\tplansource->generation = 0;\n\tplansource->next_saved = NULL;\n\tplansource->generic_cost = -1;\n\tplansource->total_custom_cost = 0;\n\tplansource->num_custom_plans = 0;\n\n\treturn plansource;\n}"
  },
  {
    "function_name": "CreateCachedPlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "151-215",
    "snippet": "CachedPlanSource *\nCreateCachedPlan(RawStmt *raw_parse_tree,\n\t\t\t\t const char *query_string,\n\t\t\t\t const char *commandTag)\n{\n\tCachedPlanSource *plansource;\n\tMemoryContext source_context;\n\tMemoryContext oldcxt;\n\n\tAssert(query_string != NULL);\t/* required as of 8.4 */\n\n\t/*\n\t * Make a dedicated memory context for the CachedPlanSource and its\n\t * permanent subsidiary data.  It's probably not going to be large, but\n\t * just in case, allow it to grow large.  Initially it's a child of the\n\t * caller's context (which we assume to be transient), so that it will be\n\t * cleaned up on error.\n\t */\n\tsource_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"CachedPlanSource\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\t/*\n\t * Create and fill the CachedPlanSource struct within the new context.\n\t * Most fields are just left empty for the moment.\n\t */\n\toldcxt = MemoryContextSwitchTo(source_context);\n\n\tplansource = (CachedPlanSource *) palloc0(sizeof(CachedPlanSource));\n\tplansource->magic = CACHEDPLANSOURCE_MAGIC;\n\tplansource->raw_parse_tree = copyObject(raw_parse_tree);\n\tplansource->query_string = pstrdup(query_string);\n\tMemoryContextSetIdentifier(source_context, plansource->query_string);\n\tplansource->commandTag = commandTag;\n\tplansource->param_types = NULL;\n\tplansource->num_params = 0;\n\tplansource->parserSetup = NULL;\n\tplansource->parserSetupArg = NULL;\n\tplansource->cursor_options = 0;\n\tplansource->fixed_result = false;\n\tplansource->resultDesc = NULL;\n\tplansource->context = source_context;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\tplansource->query_context = NULL;\n\tplansource->rewriteRoleId = InvalidOid;\n\tplansource->rewriteRowSecurity = false;\n\tplansource->dependsOnRLS = false;\n\tplansource->gplan = NULL;\n\tplansource->is_oneshot = false;\n\tplansource->is_complete = false;\n\tplansource->is_saved = false;\n\tplansource->is_valid = false;\n\tplansource->generation = 0;\n\tplansource->next_saved = NULL;\n\tplansource->generic_cost = -1;\n\tplansource->total_custom_cost = 0;\n\tplansource->num_custom_plans = 0;\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn plansource;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReleaseGenericPlan(CachedPlanSource *plansource);",
      "static bool CheckCachedPlan(CachedPlanSource *plansource);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSetIdentifier",
          "args": [
            "source_context",
            "plansource->query_string"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextSetIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "328-333",
          "snippet": "void\nMemoryContextSetIdentifier(MemoryContext context, const char *id)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tcontext->ident = id;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextSetIdentifier(MemoryContext context, const char *id)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\tcontext->ident = id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "query_string"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "raw_parse_tree"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(CachedPlanSource)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "source_context"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CurrentMemoryContext",
            "\"CachedPlanSource\"",
            "ALLOCSET_START_SMALL_SIZES"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "query_string != NULL"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void ReleaseGenericPlan(CachedPlanSource *plansource);\nstatic bool CheckCachedPlan(CachedPlanSource *plansource);\n\nCachedPlanSource *\nCreateCachedPlan(RawStmt *raw_parse_tree,\n\t\t\t\t const char *query_string,\n\t\t\t\t const char *commandTag)\n{\n\tCachedPlanSource *plansource;\n\tMemoryContext source_context;\n\tMemoryContext oldcxt;\n\n\tAssert(query_string != NULL);\t/* required as of 8.4 */\n\n\t/*\n\t * Make a dedicated memory context for the CachedPlanSource and its\n\t * permanent subsidiary data.  It's probably not going to be large, but\n\t * just in case, allow it to grow large.  Initially it's a child of the\n\t * caller's context (which we assume to be transient), so that it will be\n\t * cleaned up on error.\n\t */\n\tsource_context = AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   \"CachedPlanSource\",\n\t\t\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\t/*\n\t * Create and fill the CachedPlanSource struct within the new context.\n\t * Most fields are just left empty for the moment.\n\t */\n\toldcxt = MemoryContextSwitchTo(source_context);\n\n\tplansource = (CachedPlanSource *) palloc0(sizeof(CachedPlanSource));\n\tplansource->magic = CACHEDPLANSOURCE_MAGIC;\n\tplansource->raw_parse_tree = copyObject(raw_parse_tree);\n\tplansource->query_string = pstrdup(query_string);\n\tMemoryContextSetIdentifier(source_context, plansource->query_string);\n\tplansource->commandTag = commandTag;\n\tplansource->param_types = NULL;\n\tplansource->num_params = 0;\n\tplansource->parserSetup = NULL;\n\tplansource->parserSetupArg = NULL;\n\tplansource->cursor_options = 0;\n\tplansource->fixed_result = false;\n\tplansource->resultDesc = NULL;\n\tplansource->context = source_context;\n\tplansource->query_list = NIL;\n\tplansource->relationOids = NIL;\n\tplansource->invalItems = NIL;\n\tplansource->search_path = NULL;\n\tplansource->query_context = NULL;\n\tplansource->rewriteRoleId = InvalidOid;\n\tplansource->rewriteRowSecurity = false;\n\tplansource->dependsOnRLS = false;\n\tplansource->gplan = NULL;\n\tplansource->is_oneshot = false;\n\tplansource->is_complete = false;\n\tplansource->is_saved = false;\n\tplansource->is_valid = false;\n\tplansource->generation = 0;\n\tplansource->next_saved = NULL;\n\tplansource->generic_cost = -1;\n\tplansource->total_custom_cost = 0;\n\tplansource->num_custom_plans = 0;\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn plansource;\n}"
  },
  {
    "function_name": "InitPlanCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/plancache.c",
    "lines": "115-125",
    "snippet": "void\nInitPlanCache(void)\n{\n\tCacheRegisterRelcacheCallback(PlanCacheRelCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(PROCOID, PlanCacheFuncCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(NAMESPACEOID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(OPEROID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(AMOPOPID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(FOREIGNSERVEROID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(FOREIGNDATAWRAPPEROID, PlanCacheSysCallback, (Datum) 0);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/rls.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/inval.h\"",
      "#include \"tcop/utility.h\"",
      "#include \"tcop/pquery.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"parser/parsetree.h\"",
      "#include \"parser/analyze.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/planmain.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/transam.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CacheRegisterSyscacheCallback",
          "args": [
            "FOREIGNDATAWRAPPEROID",
            "PlanCacheSysCallback",
            "(Datum) 0"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "CacheRegisterSyscacheCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1425-1456",
          "snippet": "void\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_SYSCACHE_CALLBACKS 64"
          ],
          "globals_used": [
            "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
            "static int16 syscache_callback_links[SysCacheSize];",
            "static int\tsyscache_callback_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_SYSCACHE_CALLBACKS 64\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int16 syscache_callback_links[SysCacheSize];\nstatic int\tsyscache_callback_count = 0;\n\nvoid\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CacheRegisterRelcacheCallback",
          "args": [
            "PlanCacheRelCallback",
            "(Datum) 0"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "CacheRegisterRelcacheCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1467-1478",
          "snippet": "void\nCacheRegisterRelcacheCallback(RelcacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (relcache_callback_count >= MAX_RELCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of relcache_callback_list slots\");\n\n\trelcache_callback_list[relcache_callback_count].function = func;\n\trelcache_callback_list[relcache_callback_count].arg = arg;\n\n\t++relcache_callback_count;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_RELCACHE_CALLBACKS 10"
          ],
          "globals_used": [
            "static struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];",
            "static int\trelcache_callback_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_RELCACHE_CALLBACKS 10\n\nstatic struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];\nstatic int\trelcache_callback_count = 0;\n\nvoid\nCacheRegisterRelcacheCallback(RelcacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (relcache_callback_count >= MAX_RELCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of relcache_callback_list slots\");\n\n\trelcache_callback_list[relcache_callback_count].function = func;\n\trelcache_callback_list[relcache_callback_count].arg = arg;\n\n\t++relcache_callback_count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"tcop/utility.h\"\n#include \"tcop/pquery.h\"\n#include \"storage/lmgr.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/analyze.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/cost.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"catalog/namespace.h\"\n#include \"access/transam.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nInitPlanCache(void)\n{\n\tCacheRegisterRelcacheCallback(PlanCacheRelCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(PROCOID, PlanCacheFuncCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(NAMESPACEOID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(OPEROID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(AMOPOPID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(FOREIGNSERVEROID, PlanCacheSysCallback, (Datum) 0);\n\tCacheRegisterSyscacheCallback(FOREIGNDATAWRAPPEROID, PlanCacheSysCallback, (Datum) 0);\n}"
  }
]