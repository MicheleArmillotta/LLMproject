[
  {
    "function_name": "anl_get_next_S",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
    "lines": "283-292",
    "snippet": "double\nanl_get_next_S(double t, int n, double *stateptr)\n{\n\tdouble\t\tresult;\n\n\toldrs.W = *stateptr;\n\tresult = reservoir_get_next_S(&oldrs, t, n);\n\t*stateptr = oldrs.W;\n\treturn result;\n}",
    "includes": [
      "#include \"utils/sampling.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ReservoirStateData oldrs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reservoir_get_next_S",
          "args": [
            "&oldrs",
            "t",
            "n"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "reservoir_get_next_S",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "141-221",
          "snippet": "double\nreservoir_get_next_S(ReservoirState rs, double t, int n)\n{\n\tdouble\t\tS;\n\n\t/* The magic constant here is T from Vitter's paper */\n\tif (t <= (22.0 * n))\n\t{\n\t\t/* Process records using Algorithm X until t is large enough */\n\t\tdouble\t\tV,\n\t\t\t\t\tquot;\n\n\t\tV = sampler_random_fract(rs->randstate);\t/* Generate V */\n\t\tS = 0;\n\t\tt += 1;\n\t\t/* Note: \"num\" in Vitter's code is always equal to t - n */\n\t\tquot = (t - (double) n) / t;\n\t\t/* Find min S satisfying (4.1) */\n\t\twhile (quot > V)\n\t\t{\n\t\t\tS += 1;\n\t\t\tt += 1;\n\t\t\tquot *= (t - (double) n) / t;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Now apply Algorithm Z */\n\t\tdouble\t\tW = rs->W;\n\t\tdouble\t\tterm = t - (double) n + 1;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tdouble\t\tnumer,\n\t\t\t\t\t\tnumer_lim,\n\t\t\t\t\t\tdenom;\n\t\t\tdouble\t\tU,\n\t\t\t\t\t\tX,\n\t\t\t\t\t\tlhs,\n\t\t\t\t\t\trhs,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\ttmp;\n\n\t\t\t/* Generate U and X */\n\t\t\tU = sampler_random_fract(rs->randstate);\n\t\t\tX = t * (W - 1.0);\n\t\t\tS = floor(X);\t\t/* S is tentatively set to floor(X) */\n\t\t\t/* Test if U <= h(S)/cg(X) in the manner of (6.3) */\n\t\t\ttmp = (t + 1) / term;\n\t\t\tlhs = exp(log(((U * tmp * tmp) * (term + S)) / (t + X)) / n);\n\t\t\trhs = (((t + X) / (term + S)) * term) / t;\n\t\t\tif (lhs <= rhs)\n\t\t\t{\n\t\t\t\tW = rhs / lhs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Test if U <= f(S)/cg(X) */\n\t\t\ty = (((U * (t + 1)) / term) * (t + S + 1)) / (t + X);\n\t\t\tif ((double) n < S)\n\t\t\t{\n\t\t\t\tdenom = t;\n\t\t\t\tnumer_lim = term + S;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdenom = t - (double) n + S;\n\t\t\t\tnumer_lim = t + 1;\n\t\t\t}\n\t\t\tfor (numer = t + S; numer >= numer_lim; numer -= 1)\n\t\t\t{\n\t\t\t\ty *= numer / denom;\n\t\t\t\tdenom -= 1;\n\t\t\t}\n\t\t\tW = exp(-log(sampler_random_fract(rs->randstate)) / n); /* Generate W in advance */\n\t\t\tif (exp(log(y) / n) <= (t + X) / t)\n\t\t\t\tbreak;\n\t\t}\n\t\trs->W = W;\n\t}\n\treturn S;\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\ndouble\nreservoir_get_next_S(ReservoirState rs, double t, int n)\n{\n\tdouble\t\tS;\n\n\t/* The magic constant here is T from Vitter's paper */\n\tif (t <= (22.0 * n))\n\t{\n\t\t/* Process records using Algorithm X until t is large enough */\n\t\tdouble\t\tV,\n\t\t\t\t\tquot;\n\n\t\tV = sampler_random_fract(rs->randstate);\t/* Generate V */\n\t\tS = 0;\n\t\tt += 1;\n\t\t/* Note: \"num\" in Vitter's code is always equal to t - n */\n\t\tquot = (t - (double) n) / t;\n\t\t/* Find min S satisfying (4.1) */\n\t\twhile (quot > V)\n\t\t{\n\t\t\tS += 1;\n\t\t\tt += 1;\n\t\t\tquot *= (t - (double) n) / t;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Now apply Algorithm Z */\n\t\tdouble\t\tW = rs->W;\n\t\tdouble\t\tterm = t - (double) n + 1;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tdouble\t\tnumer,\n\t\t\t\t\t\tnumer_lim,\n\t\t\t\t\t\tdenom;\n\t\t\tdouble\t\tU,\n\t\t\t\t\t\tX,\n\t\t\t\t\t\tlhs,\n\t\t\t\t\t\trhs,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\ttmp;\n\n\t\t\t/* Generate U and X */\n\t\t\tU = sampler_random_fract(rs->randstate);\n\t\t\tX = t * (W - 1.0);\n\t\t\tS = floor(X);\t\t/* S is tentatively set to floor(X) */\n\t\t\t/* Test if U <= h(S)/cg(X) in the manner of (6.3) */\n\t\t\ttmp = (t + 1) / term;\n\t\t\tlhs = exp(log(((U * tmp * tmp) * (term + S)) / (t + X)) / n);\n\t\t\trhs = (((t + X) / (term + S)) * term) / t;\n\t\t\tif (lhs <= rhs)\n\t\t\t{\n\t\t\t\tW = rhs / lhs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Test if U <= f(S)/cg(X) */\n\t\t\ty = (((U * (t + 1)) / term) * (t + S + 1)) / (t + X);\n\t\t\tif ((double) n < S)\n\t\t\t{\n\t\t\t\tdenom = t;\n\t\t\t\tnumer_lim = term + S;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdenom = t - (double) n + S;\n\t\t\t\tnumer_lim = t + 1;\n\t\t\t}\n\t\t\tfor (numer = t + S; numer >= numer_lim; numer -= 1)\n\t\t\t{\n\t\t\t\ty *= numer / denom;\n\t\t\t\tdenom -= 1;\n\t\t\t}\n\t\t\tW = exp(-log(sampler_random_fract(rs->randstate)) / n); /* Generate W in advance */\n\t\t\tif (exp(log(y) / n) <= (t + X) / t)\n\t\t\t\tbreak;\n\t\t}\n\t\trs->W = W;\n\t}\n\treturn S;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic ReservoirStateData oldrs;\n\ndouble\nanl_get_next_S(double t, int n, double *stateptr)\n{\n\tdouble\t\tresult;\n\n\toldrs.W = *stateptr;\n\tresult = reservoir_get_next_S(&oldrs, t, n);\n\t*stateptr = oldrs.W;\n\treturn result;\n}"
  },
  {
    "function_name": "anl_init_selection_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
    "lines": "272-281",
    "snippet": "double\nanl_init_selection_state(int n)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* Initial value of W (for use when Algorithm Z is first applied) */\n\treturn exp(-log(sampler_random_fract(oldrs.randstate)) / n);\n}",
    "includes": [
      "#include \"utils/sampling.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ReservoirStateData oldrs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp",
          "args": [
            "-log(sampler_random_fract(oldrs.randstate)) / n"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "pg_get_expr_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "2341-2364",
          "snippet": "Datum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PRETTYFLAG_SCHEMA\t\t0x0004",
            "#define PRETTYFLAG_INDENT\t\t0x0002",
            "#define PRETTYFLAG_PAREN\t\t0x0001"
          ],
          "globals_used": [
            "static char *pg_get_triggerdef_worker(Oid trigid, bool pretty);",
            "static char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);",
            "static text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);",
            "static void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);",
            "static const char *get_simple_binary_op_name(OpExpr *expr);",
            "static bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);",
            "static char *get_relation_name(Oid relid);",
            "static char *generate_qualified_relation_name(Oid relid);",
            "static char *flatten_reloptions(Oid relid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define PRETTYFLAG_SCHEMA\t\t0x0004\n#define PRETTYFLAG_INDENT\t\t0x0002\n#define PRETTYFLAG_PAREN\t\t0x0001\n\nstatic char *pg_get_triggerdef_worker(Oid trigid, bool pretty);\nstatic char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);\nstatic text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);\nstatic void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);\nstatic const char *get_simple_binary_op_name(OpExpr *expr);\nstatic bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);\nstatic char *get_relation_name(Oid relid);\nstatic char *generate_qualified_relation_name(Oid relid);\nstatic char *flatten_reloptions(Oid relid);\n\nDatum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "sampler_random_fract(oldrs.randstate)"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "CacheInvalidateCatalog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1245-1258",
          "snippet": "void\nCacheInvalidateCatalog(Oid catalogId)\n{\n\tOid\t\t\tdatabaseId;\n\n\tPrepareInvalidationState();\n\n\tif (IsSharedRelation(catalogId))\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\n\tRegisterCatalogInvalidation(databaseId, catalogId);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateCatalog(Oid catalogId)\n{\n\tOid\t\t\tdatabaseId;\n\n\tPrepareInvalidationState();\n\n\tif (IsSharedRelation(catalogId))\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\n\tRegisterCatalogInvalidation(databaseId, catalogId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sampler_random_fract",
          "args": [
            "oldrs.randstate"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "sampler_random_fract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "237-248",
          "snippet": "double\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\ndouble\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sampler_random_init_state",
          "args": [
            "random()",
            "oldrs.randstate"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "sampler_random_init_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "228-234",
          "snippet": "void\nsampler_random_init_state(long seed, SamplerRandomState randstate)\n{\n\trandstate[0] = 0x330e;\t\t/* same as pg_erand48, but could be anything */\n\trandstate[1] = (unsigned short) seed;\n\trandstate[2] = (unsigned short) (seed >> 16);\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\nsampler_random_init_state(long seed, SamplerRandomState randstate)\n{\n\trandstate[0] = 0x330e;\t\t/* same as pg_erand48, but could be anything */\n\trandstate[1] = (unsigned short) seed;\n\trandstate[2] = (unsigned short) (seed >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "random",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "anl_random_fract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "261-270",
          "snippet": "double\nanl_random_fract(void)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* and compute a random fraction */\n\treturn sampler_random_fract(oldrs.randstate);\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ReservoirStateData oldrs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic ReservoirStateData oldrs;\n\ndouble\nanl_random_fract(void)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* and compute a random fraction */\n\treturn sampler_random_fract(oldrs.randstate);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic ReservoirStateData oldrs;\n\ndouble\nanl_init_selection_state(int n)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* Initial value of W (for use when Algorithm Z is first applied) */\n\treturn exp(-log(sampler_random_fract(oldrs.randstate)) / n);\n}"
  },
  {
    "function_name": "anl_random_fract",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
    "lines": "261-270",
    "snippet": "double\nanl_random_fract(void)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* and compute a random fraction */\n\treturn sampler_random_fract(oldrs.randstate);\n}",
    "includes": [
      "#include \"utils/sampling.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ReservoirStateData oldrs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sampler_random_fract",
          "args": [
            "oldrs.randstate"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "sampler_random_fract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "237-248",
          "snippet": "double\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\ndouble\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sampler_random_init_state",
          "args": [
            "random()",
            "oldrs.randstate"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "sampler_random_init_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "228-234",
          "snippet": "void\nsampler_random_init_state(long seed, SamplerRandomState randstate)\n{\n\trandstate[0] = 0x330e;\t\t/* same as pg_erand48, but could be anything */\n\trandstate[1] = (unsigned short) seed;\n\trandstate[2] = (unsigned short) (seed >> 16);\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\nsampler_random_init_state(long seed, SamplerRandomState randstate)\n{\n\trandstate[0] = 0x330e;\t\t/* same as pg_erand48, but could be anything */\n\trandstate[1] = (unsigned short) seed;\n\trandstate[2] = (unsigned short) (seed >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "random",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "anl_random_fract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "261-270",
          "snippet": "double\nanl_random_fract(void)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* and compute a random fraction */\n\treturn sampler_random_fract(oldrs.randstate);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic ReservoirStateData oldrs;\n\ndouble\nanl_random_fract(void)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* and compute a random fraction */\n\treturn sampler_random_fract(oldrs.randstate);\n}"
  },
  {
    "function_name": "sampler_random_fract",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
    "lines": "237-248",
    "snippet": "double\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}",
    "includes": [
      "#include \"utils/sampling.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_erand48",
          "args": [
            "randstate"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\ndouble\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}"
  },
  {
    "function_name": "sampler_random_init_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
    "lines": "228-234",
    "snippet": "void\nsampler_random_init_state(long seed, SamplerRandomState randstate)\n{\n\trandstate[0] = 0x330e;\t\t/* same as pg_erand48, but could be anything */\n\trandstate[1] = (unsigned short) seed;\n\trandstate[2] = (unsigned short) (seed >> 16);\n}",
    "includes": [
      "#include \"utils/sampling.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\nsampler_random_init_state(long seed, SamplerRandomState randstate)\n{\n\trandstate[0] = 0x330e;\t\t/* same as pg_erand48, but could be anything */\n\trandstate[1] = (unsigned short) seed;\n\trandstate[2] = (unsigned short) (seed >> 16);\n}"
  },
  {
    "function_name": "reservoir_get_next_S",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
    "lines": "141-221",
    "snippet": "double\nreservoir_get_next_S(ReservoirState rs, double t, int n)\n{\n\tdouble\t\tS;\n\n\t/* The magic constant here is T from Vitter's paper */\n\tif (t <= (22.0 * n))\n\t{\n\t\t/* Process records using Algorithm X until t is large enough */\n\t\tdouble\t\tV,\n\t\t\t\t\tquot;\n\n\t\tV = sampler_random_fract(rs->randstate);\t/* Generate V */\n\t\tS = 0;\n\t\tt += 1;\n\t\t/* Note: \"num\" in Vitter's code is always equal to t - n */\n\t\tquot = (t - (double) n) / t;\n\t\t/* Find min S satisfying (4.1) */\n\t\twhile (quot > V)\n\t\t{\n\t\t\tS += 1;\n\t\t\tt += 1;\n\t\t\tquot *= (t - (double) n) / t;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Now apply Algorithm Z */\n\t\tdouble\t\tW = rs->W;\n\t\tdouble\t\tterm = t - (double) n + 1;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tdouble\t\tnumer,\n\t\t\t\t\t\tnumer_lim,\n\t\t\t\t\t\tdenom;\n\t\t\tdouble\t\tU,\n\t\t\t\t\t\tX,\n\t\t\t\t\t\tlhs,\n\t\t\t\t\t\trhs,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\ttmp;\n\n\t\t\t/* Generate U and X */\n\t\t\tU = sampler_random_fract(rs->randstate);\n\t\t\tX = t * (W - 1.0);\n\t\t\tS = floor(X);\t\t/* S is tentatively set to floor(X) */\n\t\t\t/* Test if U <= h(S)/cg(X) in the manner of (6.3) */\n\t\t\ttmp = (t + 1) / term;\n\t\t\tlhs = exp(log(((U * tmp * tmp) * (term + S)) / (t + X)) / n);\n\t\t\trhs = (((t + X) / (term + S)) * term) / t;\n\t\t\tif (lhs <= rhs)\n\t\t\t{\n\t\t\t\tW = rhs / lhs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Test if U <= f(S)/cg(X) */\n\t\t\ty = (((U * (t + 1)) / term) * (t + S + 1)) / (t + X);\n\t\t\tif ((double) n < S)\n\t\t\t{\n\t\t\t\tdenom = t;\n\t\t\t\tnumer_lim = term + S;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdenom = t - (double) n + S;\n\t\t\t\tnumer_lim = t + 1;\n\t\t\t}\n\t\t\tfor (numer = t + S; numer >= numer_lim; numer -= 1)\n\t\t\t{\n\t\t\t\ty *= numer / denom;\n\t\t\t\tdenom -= 1;\n\t\t\t}\n\t\t\tW = exp(-log(sampler_random_fract(rs->randstate)) / n); /* Generate W in advance */\n\t\t\tif (exp(log(y) / n) <= (t + X) / t)\n\t\t\t\tbreak;\n\t\t}\n\t\trs->W = W;\n\t}\n\treturn S;\n}",
    "includes": [
      "#include \"utils/sampling.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp",
          "args": [
            "log(y) / n"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "pg_get_expr_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "2341-2364",
          "snippet": "Datum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PRETTYFLAG_SCHEMA\t\t0x0004",
            "#define PRETTYFLAG_INDENT\t\t0x0002",
            "#define PRETTYFLAG_PAREN\t\t0x0001"
          ],
          "globals_used": [
            "static char *pg_get_triggerdef_worker(Oid trigid, bool pretty);",
            "static char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);",
            "static text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);",
            "static void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);",
            "static const char *get_simple_binary_op_name(OpExpr *expr);",
            "static bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);",
            "static char *get_relation_name(Oid relid);",
            "static char *generate_qualified_relation_name(Oid relid);",
            "static char *flatten_reloptions(Oid relid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define PRETTYFLAG_SCHEMA\t\t0x0004\n#define PRETTYFLAG_INDENT\t\t0x0002\n#define PRETTYFLAG_PAREN\t\t0x0001\n\nstatic char *pg_get_triggerdef_worker(Oid trigid, bool pretty);\nstatic char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);\nstatic text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);\nstatic void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);\nstatic const char *get_simple_binary_op_name(OpExpr *expr);\nstatic bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);\nstatic char *get_relation_name(Oid relid);\nstatic char *generate_qualified_relation_name(Oid relid);\nstatic char *flatten_reloptions(Oid relid);\n\nDatum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "y"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "CacheInvalidateCatalog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1245-1258",
          "snippet": "void\nCacheInvalidateCatalog(Oid catalogId)\n{\n\tOid\t\t\tdatabaseId;\n\n\tPrepareInvalidationState();\n\n\tif (IsSharedRelation(catalogId))\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\n\tRegisterCatalogInvalidation(databaseId, catalogId);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateCatalog(Oid catalogId)\n{\n\tOid\t\t\tdatabaseId;\n\n\tPrepareInvalidationState();\n\n\tif (IsSharedRelation(catalogId))\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\n\tRegisterCatalogInvalidation(databaseId, catalogId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sampler_random_fract",
          "args": [
            "rs->randstate"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "sampler_random_fract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "237-248",
          "snippet": "double\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\ndouble\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "floor",
          "args": [
            "X"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "floor_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_selfuncs.c",
          "lines": "1090-1122",
          "snippet": "static int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float *calc_hist(const float4 *hist, int nhist, int n);",
            "static int\tfloor_log2(uint32 n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"optimizer/clauses.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic float *calc_hist(const float4 *hist, int nhist, int n);\nstatic int\tfloor_log2(uint32 n);\n\nstatic int\nfloor_log2(uint32 n)\n{\n\tint\t\t\tlogval = 0;\n\n\tif (n == 0)\n\t\treturn -1;\n\tif (n >= (1 << 16))\n\t{\n\t\tn >>= 16;\n\t\tlogval += 16;\n\t}\n\tif (n >= (1 << 8))\n\t{\n\t\tn >>= 8;\n\t\tlogval += 8;\n\t}\n\tif (n >= (1 << 4))\n\t{\n\t\tn >>= 4;\n\t\tlogval += 4;\n\t}\n\tif (n >= (1 << 2))\n\t{\n\t\tn >>= 2;\n\t\tlogval += 2;\n\t}\n\tif (n >= (1 << 1))\n\t{\n\t\tlogval += 1;\n\t}\n\treturn logval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\ndouble\nreservoir_get_next_S(ReservoirState rs, double t, int n)\n{\n\tdouble\t\tS;\n\n\t/* The magic constant here is T from Vitter's paper */\n\tif (t <= (22.0 * n))\n\t{\n\t\t/* Process records using Algorithm X until t is large enough */\n\t\tdouble\t\tV,\n\t\t\t\t\tquot;\n\n\t\tV = sampler_random_fract(rs->randstate);\t/* Generate V */\n\t\tS = 0;\n\t\tt += 1;\n\t\t/* Note: \"num\" in Vitter's code is always equal to t - n */\n\t\tquot = (t - (double) n) / t;\n\t\t/* Find min S satisfying (4.1) */\n\t\twhile (quot > V)\n\t\t{\n\t\t\tS += 1;\n\t\t\tt += 1;\n\t\t\tquot *= (t - (double) n) / t;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Now apply Algorithm Z */\n\t\tdouble\t\tW = rs->W;\n\t\tdouble\t\tterm = t - (double) n + 1;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tdouble\t\tnumer,\n\t\t\t\t\t\tnumer_lim,\n\t\t\t\t\t\tdenom;\n\t\t\tdouble\t\tU,\n\t\t\t\t\t\tX,\n\t\t\t\t\t\tlhs,\n\t\t\t\t\t\trhs,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\ttmp;\n\n\t\t\t/* Generate U and X */\n\t\t\tU = sampler_random_fract(rs->randstate);\n\t\t\tX = t * (W - 1.0);\n\t\t\tS = floor(X);\t\t/* S is tentatively set to floor(X) */\n\t\t\t/* Test if U <= h(S)/cg(X) in the manner of (6.3) */\n\t\t\ttmp = (t + 1) / term;\n\t\t\tlhs = exp(log(((U * tmp * tmp) * (term + S)) / (t + X)) / n);\n\t\t\trhs = (((t + X) / (term + S)) * term) / t;\n\t\t\tif (lhs <= rhs)\n\t\t\t{\n\t\t\t\tW = rhs / lhs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Test if U <= f(S)/cg(X) */\n\t\t\ty = (((U * (t + 1)) / term) * (t + S + 1)) / (t + X);\n\t\t\tif ((double) n < S)\n\t\t\t{\n\t\t\t\tdenom = t;\n\t\t\t\tnumer_lim = term + S;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdenom = t - (double) n + S;\n\t\t\t\tnumer_lim = t + 1;\n\t\t\t}\n\t\t\tfor (numer = t + S; numer >= numer_lim; numer -= 1)\n\t\t\t{\n\t\t\t\ty *= numer / denom;\n\t\t\t\tdenom -= 1;\n\t\t\t}\n\t\t\tW = exp(-log(sampler_random_fract(rs->randstate)) / n); /* Generate W in advance */\n\t\t\tif (exp(log(y) / n) <= (t + X) / t)\n\t\t\t\tbreak;\n\t\t}\n\t\trs->W = W;\n\t}\n\treturn S;\n}"
  },
  {
    "function_name": "reservoir_init_selection_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
    "lines": "128-139",
    "snippet": "void\nreservoir_init_selection_state(ReservoirState rs, int n)\n{\n\t/*\n\t * Reservoir sampling is not used anywhere where it would need to return\n\t * repeatable results so we can initialize it randomly.\n\t */\n\tsampler_random_init_state(random(), rs->randstate);\n\n\t/* Initial value of W (for use when Algorithm Z is first applied) */\n\trs->W = exp(-log(sampler_random_fract(rs->randstate)) / n);\n}",
    "includes": [
      "#include \"utils/sampling.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp",
          "args": [
            "-log(sampler_random_fract(rs->randstate)) / n"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "pg_get_expr_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "2341-2364",
          "snippet": "Datum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PRETTYFLAG_SCHEMA\t\t0x0004",
            "#define PRETTYFLAG_INDENT\t\t0x0002",
            "#define PRETTYFLAG_PAREN\t\t0x0001"
          ],
          "globals_used": [
            "static char *pg_get_triggerdef_worker(Oid trigid, bool pretty);",
            "static char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);",
            "static text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);",
            "static void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);",
            "static const char *get_simple_binary_op_name(OpExpr *expr);",
            "static bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);",
            "static char *get_relation_name(Oid relid);",
            "static char *generate_qualified_relation_name(Oid relid);",
            "static char *flatten_reloptions(Oid relid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define PRETTYFLAG_SCHEMA\t\t0x0004\n#define PRETTYFLAG_INDENT\t\t0x0002\n#define PRETTYFLAG_PAREN\t\t0x0001\n\nstatic char *pg_get_triggerdef_worker(Oid trigid, bool pretty);\nstatic char *pg_get_ruledef_worker(Oid ruleoid, int prettyFlags);\nstatic text *pg_get_expr_worker(text *expr, Oid relid, const char *relname,\n\t\t\t\t   int prettyFlags);\nstatic void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc,\n\t\t\t int prettyFlags);\nstatic const char *get_simple_binary_op_name(OpExpr *expr);\nstatic bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags);\nstatic char *get_relation_name(Oid relid);\nstatic char *generate_qualified_relation_name(Oid relid);\nstatic char *flatten_reloptions(Oid relid);\n\nDatum\npg_get_expr_ext(PG_FUNCTION_ARGS)\n{\n\ttext\t   *expr = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\trelid = PG_GETARG_OID(1);\n\tbool\t\tpretty = PG_GETARG_BOOL(2);\n\tint\t\t\tprettyFlags;\n\tchar\t   *relname;\n\n\tprettyFlags = pretty ? (PRETTYFLAG_PAREN | PRETTYFLAG_INDENT | PRETTYFLAG_SCHEMA) : PRETTYFLAG_INDENT;\n\n\tif (OidIsValid(relid))\n\t{\n\t\t/* Get the name for the relation */\n\t\trelname = get_rel_name(relid);\n\t\t/* See notes above */\n\t\tif (relname == NULL)\n\t\t\tPG_RETURN_NULL();\n\t}\n\telse\n\t\trelname = NULL;\n\n\tPG_RETURN_TEXT_P(pg_get_expr_worker(expr, relid, relname, prettyFlags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "sampler_random_fract(rs->randstate)"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "CacheInvalidateCatalog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1245-1258",
          "snippet": "void\nCacheInvalidateCatalog(Oid catalogId)\n{\n\tOid\t\t\tdatabaseId;\n\n\tPrepareInvalidationState();\n\n\tif (IsSharedRelation(catalogId))\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\n\tRegisterCatalogInvalidation(databaseId, catalogId);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateCatalog(Oid catalogId)\n{\n\tOid\t\t\tdatabaseId;\n\n\tPrepareInvalidationState();\n\n\tif (IsSharedRelation(catalogId))\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\n\tRegisterCatalogInvalidation(databaseId, catalogId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sampler_random_fract",
          "args": [
            "rs->randstate"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "sampler_random_fract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "237-248",
          "snippet": "double\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\ndouble\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sampler_random_init_state",
          "args": [
            "random()",
            "rs->randstate"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "sampler_random_init_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "228-234",
          "snippet": "void\nsampler_random_init_state(long seed, SamplerRandomState randstate)\n{\n\trandstate[0] = 0x330e;\t\t/* same as pg_erand48, but could be anything */\n\trandstate[1] = (unsigned short) seed;\n\trandstate[2] = (unsigned short) (seed >> 16);\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\nsampler_random_init_state(long seed, SamplerRandomState randstate)\n{\n\trandstate[0] = 0x330e;\t\t/* same as pg_erand48, but could be anything */\n\trandstate[1] = (unsigned short) seed;\n\trandstate[2] = (unsigned short) (seed >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "random",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "anl_random_fract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "261-270",
          "snippet": "double\nanl_random_fract(void)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* and compute a random fraction */\n\treturn sampler_random_fract(oldrs.randstate);\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ReservoirStateData oldrs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nstatic ReservoirStateData oldrs;\n\ndouble\nanl_random_fract(void)\n{\n\t/* initialize if first time through */\n\tif (oldrs.randstate[0] == 0)\n\t\tsampler_random_init_state(random(), oldrs.randstate);\n\n\t/* and compute a random fraction */\n\treturn sampler_random_fract(oldrs.randstate);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\nreservoir_init_selection_state(ReservoirState rs, int n)\n{\n\t/*\n\t * Reservoir sampling is not used anywhere where it would need to return\n\t * repeatable results so we can initialize it randomly.\n\t */\n\tsampler_random_init_state(random(), rs->randstate);\n\n\t/* Initial value of W (for use when Algorithm Z is first applied) */\n\trs->W = exp(-log(sampler_random_fract(rs->randstate)) / n);\n}"
  },
  {
    "function_name": "BlockSampler_Next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
    "lines": "59-112",
    "snippet": "BlockNumber\nBlockSampler_Next(BlockSampler bs)\n{\n\tBlockNumber K = bs->N - bs->t;\t/* remaining blocks */\n\tint\t\t\tk = bs->n - bs->m;\t/* blocks still to sample */\n\tdouble\t\tp;\t\t\t\t/* probability to skip block */\n\tdouble\t\tV;\t\t\t\t/* random */\n\n\tAssert(BlockSampler_HasMore(bs));\t/* hence K > 0 and k > 0 */\n\n\tif ((BlockNumber) k >= K)\n\t{\n\t\t/* need all the rest */\n\t\tbs->m++;\n\t\treturn bs->t++;\n\t}\n\n\t/*----------\n\t * It is not obvious that this code matches Knuth's Algorithm S.\n\t * Knuth says to skip the current block with probability 1 - k/K.\n\t * If we are to skip, we should advance t (hence decrease K), and\n\t * repeat the same probabilistic test for the next block.  The naive\n\t * implementation thus requires a sampler_random_fract() call for each\n\t * block number.  But we can reduce this to one sampler_random_fract()\n\t * call per selected block, by noting that each time the while-test\n\t * succeeds, we can reinterpret V as a uniform random number in the range\n\t * 0 to p. Therefore, instead of choosing a new V, we just adjust p to be\n\t * the appropriate fraction of its former value, and our next loop\n\t * makes the appropriate probabilistic test.\n\t *\n\t * We have initially K > k > 0.  If the loop reduces K to equal k,\n\t * the next while-test must fail since p will become exactly zero\n\t * (we assume there will not be roundoff error in the division).\n\t * (Note: Knuth suggests a \"<=\" loop condition, but we use \"<\" just\n\t * to be doubly sure about roundoff error.)  Therefore K cannot become\n\t * less than k, which means that we cannot fail to select enough blocks.\n\t *----------\n\t */\n\tV = sampler_random_fract(bs->randstate);\n\tp = 1.0 - (double) k / (double) K;\n\twhile (V < p)\n\t{\n\t\t/* skip */\n\t\tbs->t++;\n\t\tK--;\t\t\t\t\t/* keep K == N - t */\n\n\t\t/* adjust p to be new cutoff point in reduced range */\n\t\tp *= 1.0 - (double) k / (double) K;\n\t}\n\n\t/* select */\n\tbs->m++;\n\treturn bs->t++;\n}",
    "includes": [
      "#include \"utils/sampling.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sampler_random_fract",
          "args": [
            "bs->randstate"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "sampler_random_fract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "237-248",
          "snippet": "double\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\ndouble\nsampler_random_fract(SamplerRandomState randstate)\n{\n\tdouble\t\tres;\n\n\t/* pg_erand48 returns a value in [0.0 - 1.0), so we must reject 0 */\n\tdo\n\t{\n\t\tres = pg_erand48(randstate);\n\t} while (res == 0.0);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "BlockSampler_HasMore(bs)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockSampler_HasMore",
          "args": [
            "bs"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSampler_HasMore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "53-57",
          "snippet": "bool\nBlockSampler_HasMore(BlockSampler bs)\n{\n\treturn (bs->t < bs->N) && (bs->m < bs->n);\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nbool\nBlockSampler_HasMore(BlockSampler bs)\n{\n\treturn (bs->t < bs->N) && (bs->m < bs->n);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nBlockNumber\nBlockSampler_Next(BlockSampler bs)\n{\n\tBlockNumber K = bs->N - bs->t;\t/* remaining blocks */\n\tint\t\t\tk = bs->n - bs->m;\t/* blocks still to sample */\n\tdouble\t\tp;\t\t\t\t/* probability to skip block */\n\tdouble\t\tV;\t\t\t\t/* random */\n\n\tAssert(BlockSampler_HasMore(bs));\t/* hence K > 0 and k > 0 */\n\n\tif ((BlockNumber) k >= K)\n\t{\n\t\t/* need all the rest */\n\t\tbs->m++;\n\t\treturn bs->t++;\n\t}\n\n\t/*----------\n\t * It is not obvious that this code matches Knuth's Algorithm S.\n\t * Knuth says to skip the current block with probability 1 - k/K.\n\t * If we are to skip, we should advance t (hence decrease K), and\n\t * repeat the same probabilistic test for the next block.  The naive\n\t * implementation thus requires a sampler_random_fract() call for each\n\t * block number.  But we can reduce this to one sampler_random_fract()\n\t * call per selected block, by noting that each time the while-test\n\t * succeeds, we can reinterpret V as a uniform random number in the range\n\t * 0 to p. Therefore, instead of choosing a new V, we just adjust p to be\n\t * the appropriate fraction of its former value, and our next loop\n\t * makes the appropriate probabilistic test.\n\t *\n\t * We have initially K > k > 0.  If the loop reduces K to equal k,\n\t * the next while-test must fail since p will become exactly zero\n\t * (we assume there will not be roundoff error in the division).\n\t * (Note: Knuth suggests a \"<=\" loop condition, but we use \"<\" just\n\t * to be doubly sure about roundoff error.)  Therefore K cannot become\n\t * less than k, which means that we cannot fail to select enough blocks.\n\t *----------\n\t */\n\tV = sampler_random_fract(bs->randstate);\n\tp = 1.0 - (double) k / (double) K;\n\twhile (V < p)\n\t{\n\t\t/* skip */\n\t\tbs->t++;\n\t\tK--;\t\t\t\t\t/* keep K == N - t */\n\n\t\t/* adjust p to be new cutoff point in reduced range */\n\t\tp *= 1.0 - (double) k / (double) K;\n\t}\n\n\t/* select */\n\tbs->m++;\n\treturn bs->t++;\n}"
  },
  {
    "function_name": "BlockSampler_HasMore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
    "lines": "53-57",
    "snippet": "bool\nBlockSampler_HasMore(BlockSampler bs)\n{\n\treturn (bs->t < bs->N) && (bs->m < bs->n);\n}",
    "includes": [
      "#include \"utils/sampling.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nbool\nBlockSampler_HasMore(BlockSampler bs)\n{\n\treturn (bs->t < bs->N) && (bs->m < bs->n);\n}"
  },
  {
    "function_name": "BlockSampler_Init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
    "lines": "36-51",
    "snippet": "void\nBlockSampler_Init(BlockSampler bs, BlockNumber nblocks, int samplesize,\n\t\t\t\t  long randseed)\n{\n\tbs->N = nblocks;\t\t\t/* measured table size */\n\n\t/*\n\t * If we decide to reduce samplesize for tables that have less or not much\n\t * more than samplesize blocks, here is the place to do it.\n\t */\n\tbs->n = samplesize;\n\tbs->t = 0;\t\t\t\t\t/* blocks scanned so far */\n\tbs->m = 0;\t\t\t\t\t/* blocks selected so far */\n\n\tsampler_random_init_state(randseed, bs->randstate);\n}",
    "includes": [
      "#include \"utils/sampling.h\"",
      "#include <math.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sampler_random_init_state",
          "args": [
            "randseed",
            "bs->randstate"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "sampler_random_init_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/sampling.c",
          "lines": "228-234",
          "snippet": "void\nsampler_random_init_state(long seed, SamplerRandomState randstate)\n{\n\trandstate[0] = 0x330e;\t\t/* same as pg_erand48, but could be anything */\n\trandstate[1] = (unsigned short) seed;\n\trandstate[2] = (unsigned short) (seed >> 16);\n}",
          "includes": [
            "#include \"utils/sampling.h\"",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\nsampler_random_init_state(long seed, SamplerRandomState randstate)\n{\n\trandstate[0] = 0x330e;\t\t/* same as pg_erand48, but could be anything */\n\trandstate[1] = (unsigned short) seed;\n\trandstate[2] = (unsigned short) (seed >> 16);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sampling.h\"\n#include <math.h>\n#include \"postgres.h\"\n\nvoid\nBlockSampler_Init(BlockSampler bs, BlockNumber nblocks, int samplesize,\n\t\t\t\t  long randseed)\n{\n\tbs->N = nblocks;\t\t\t/* measured table size */\n\n\t/*\n\t * If we decide to reduce samplesize for tables that have less or not much\n\t * more than samplesize blocks, here is the place to do it.\n\t */\n\tbs->n = samplesize;\n\tbs->t = 0;\t\t\t\t\t/* blocks scanned so far */\n\tbs->m = 0;\t\t\t\t\t/* blocks selected so far */\n\n\tsampler_random_init_state(randseed, bs->randstate);\n}"
  }
]