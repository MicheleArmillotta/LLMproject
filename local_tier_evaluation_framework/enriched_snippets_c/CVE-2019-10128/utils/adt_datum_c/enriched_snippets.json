[
  {
    "function_name": "datumRestore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
    "lines": "370-406",
    "snippet": "Datum\ndatumRestore(char **start_address, bool *isnull)\n{\n\tint\t\t\theader;\n\tvoid\t   *d;\n\n\t/* Read header word. */\n\tmemcpy(&header, *start_address, sizeof(int));\n\t*start_address += sizeof(int);\n\n\t/* If this datum is NULL, we can stop here. */\n\tif (header == -2)\n\t{\n\t\t*isnull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/* OK, datum is not null. */\n\t*isnull = false;\n\n\t/* If this datum is pass-by-value, sizeof(Datum) bytes follow. */\n\tif (header == -1)\n\t{\n\t\tDatum\t\tval;\n\n\t\tmemcpy(&val, *start_address, sizeof(Datum));\n\t\t*start_address += sizeof(Datum);\n\t\treturn val;\n\t}\n\n\t/* Pass-by-reference case; copy indicated number of bytes. */\n\tAssert(header > 0);\n\td = palloc(header);\n\tmemcpy(d, *start_address, header);\n\t*start_address += header;\n\treturn PointerGetDatum(d);\n}",
    "includes": [
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/datum.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "d"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "d",
            "*start_address",
            "header"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "header"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "header > 0"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&val",
            "*start_address",
            "sizeof(Datum)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&header",
            "*start_address",
            "sizeof(int)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumRestore(char **start_address, bool *isnull)\n{\n\tint\t\t\theader;\n\tvoid\t   *d;\n\n\t/* Read header word. */\n\tmemcpy(&header, *start_address, sizeof(int));\n\t*start_address += sizeof(int);\n\n\t/* If this datum is NULL, we can stop here. */\n\tif (header == -2)\n\t{\n\t\t*isnull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/* OK, datum is not null. */\n\t*isnull = false;\n\n\t/* If this datum is pass-by-value, sizeof(Datum) bytes follow. */\n\tif (header == -1)\n\t{\n\t\tDatum\t\tval;\n\n\t\tmemcpy(&val, *start_address, sizeof(Datum));\n\t\t*start_address += sizeof(Datum);\n\t\treturn val;\n\t}\n\n\t/* Pass-by-reference case; copy indicated number of bytes. */\n\tAssert(header > 0);\n\td = palloc(header);\n\tmemcpy(d, *start_address, header);\n\t*start_address += header;\n\treturn PointerGetDatum(d);\n}"
  },
  {
    "function_name": "datumSerialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
    "lines": "308-361",
    "snippet": "void\ndatumSerialize(Datum value, bool isnull, bool typByVal, int typLen,\n\t\t\t   char **start_address)\n{\n\tExpandedObjectHeader *eoh = NULL;\n\tint\t\t\theader;\n\n\t/* Write header word. */\n\tif (isnull)\n\t\theader = -2;\n\telse if (typByVal)\n\t\theader = -1;\n\telse if (typLen == -1 &&\n\t\t\t VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(value)))\n\t{\n\t\teoh = DatumGetEOHP(value);\n\t\theader = EOH_get_flat_size(eoh);\n\t}\n\telse\n\t\theader = datumGetSize(value, typByVal, typLen);\n\tmemcpy(*start_address, &header, sizeof(int));\n\t*start_address += sizeof(int);\n\n\t/* If not null, write payload bytes. */\n\tif (!isnull)\n\t{\n\t\tif (typByVal)\n\t\t{\n\t\t\tmemcpy(*start_address, &value, sizeof(Datum));\n\t\t\t*start_address += sizeof(Datum);\n\t\t}\n\t\telse if (eoh)\n\t\t{\n\t\t\tchar\t   *tmp;\n\n\t\t\t/*\n\t\t\t * EOH_flatten_into expects the target address to be maxaligned,\n\t\t\t * so we can't store directly to *start_address.\n\t\t\t */\n\t\t\ttmp = (char *) palloc(header);\n\t\t\tEOH_flatten_into(eoh, (void *) tmp, header);\n\t\t\tmemcpy(*start_address, tmp, header);\n\t\t\t*start_address += header;\n\n\t\t\t/* be tidy. */\n\t\t\tpfree(tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(*start_address, DatumGetPointer(value), header);\n\t\t\t*start_address += header;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/datum.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*start_address",
            "DatumGetPointer(value)",
            "header"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "tmp"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*start_address",
            "tmp",
            "header"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOH_flatten_into",
          "args": [
            "eoh",
            "(void *) tmp",
            "header"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_flatten_into",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "80-85",
          "snippet": "void\nEOH_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\t void *result, Size allocated_size)\n{\n\teohptr->eoh_methods->flatten_into(eohptr, result, allocated_size);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nvoid\nEOH_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\t void *result, Size allocated_size)\n{\n\teohptr->eoh_methods->flatten_into(eohptr, result, allocated_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "header"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*start_address",
            "&value",
            "sizeof(Datum)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*start_address",
            "&header",
            "sizeof(int)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumGetSize",
          "args": [
            "value",
            "typByVal",
            "typLen"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "datumGetSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "60-110",
          "snippet": "Size\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nSize\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EOH_get_flat_size",
          "args": [
            "eoh"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_get_flat_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "74-78",
          "snippet": "Size\nEOH_get_flat_size(ExpandedObjectHeader *eohptr)\n{\n\treturn eohptr->eoh_methods->get_flat_size(eohptr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nSize\nEOH_get_flat_size(ExpandedObjectHeader *eohptr)\n{\n\treturn eohptr->eoh_methods->get_flat_size(eohptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetEOHP",
          "args": [
            "value"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetEOHP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "28-38",
          "snippet": "ExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED",
          "args": [
            "DatumGetPointer(value)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nvoid\ndatumSerialize(Datum value, bool isnull, bool typByVal, int typLen,\n\t\t\t   char **start_address)\n{\n\tExpandedObjectHeader *eoh = NULL;\n\tint\t\t\theader;\n\n\t/* Write header word. */\n\tif (isnull)\n\t\theader = -2;\n\telse if (typByVal)\n\t\theader = -1;\n\telse if (typLen == -1 &&\n\t\t\t VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(value)))\n\t{\n\t\teoh = DatumGetEOHP(value);\n\t\theader = EOH_get_flat_size(eoh);\n\t}\n\telse\n\t\theader = datumGetSize(value, typByVal, typLen);\n\tmemcpy(*start_address, &header, sizeof(int));\n\t*start_address += sizeof(int);\n\n\t/* If not null, write payload bytes. */\n\tif (!isnull)\n\t{\n\t\tif (typByVal)\n\t\t{\n\t\t\tmemcpy(*start_address, &value, sizeof(Datum));\n\t\t\t*start_address += sizeof(Datum);\n\t\t}\n\t\telse if (eoh)\n\t\t{\n\t\t\tchar\t   *tmp;\n\n\t\t\t/*\n\t\t\t * EOH_flatten_into expects the target address to be maxaligned,\n\t\t\t * so we can't store directly to *start_address.\n\t\t\t */\n\t\t\ttmp = (char *) palloc(header);\n\t\t\tEOH_flatten_into(eoh, (void *) tmp, header);\n\t\t\tmemcpy(*start_address, tmp, header);\n\t\t\t*start_address += header;\n\n\t\t\t/* be tidy. */\n\t\t\tpfree(tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(*start_address, DatumGetPointer(value), header);\n\t\t\t*start_address += header;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "datumEstimateSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
    "lines": "261-282",
    "snippet": "Size\ndatumEstimateSpace(Datum value, bool isnull, bool typByVal, int typLen)\n{\n\tSize\t\tsz = sizeof(int);\n\n\tif (!isnull)\n\t{\n\t\t/* no need to use add_size, can't overflow */\n\t\tif (typByVal)\n\t\t\tsz += sizeof(Datum);\n\t\telse if (typLen == -1 &&\n\t\t\t\t VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(value)))\n\t\t{\n\t\t\t/* Expanded objects need to be flattened, see comment below */\n\t\t\tsz += EOH_get_flat_size(DatumGetEOHP(value));\n\t\t}\n\t\telse\n\t\t\tsz += datumGetSize(value, typByVal, typLen);\n\t}\n\n\treturn sz;\n}",
    "includes": [
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/datum.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "datumGetSize",
          "args": [
            "value",
            "typByVal",
            "typLen"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "datumGetSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "60-110",
          "snippet": "Size\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nSize\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EOH_get_flat_size",
          "args": [
            "DatumGetEOHP(value)"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_get_flat_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "74-78",
          "snippet": "Size\nEOH_get_flat_size(ExpandedObjectHeader *eohptr)\n{\n\treturn eohptr->eoh_methods->get_flat_size(eohptr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nSize\nEOH_get_flat_size(ExpandedObjectHeader *eohptr)\n{\n\treturn eohptr->eoh_methods->get_flat_size(eohptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetEOHP",
          "args": [
            "value"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetEOHP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "28-38",
          "snippet": "ExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED",
          "args": [
            "DatumGetPointer(value)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nSize\ndatumEstimateSpace(Datum value, bool isnull, bool typByVal, int typLen)\n{\n\tSize\t\tsz = sizeof(int);\n\n\tif (!isnull)\n\t{\n\t\t/* no need to use add_size, can't overflow */\n\t\tif (typByVal)\n\t\t\tsz += sizeof(Datum);\n\t\telse if (typLen == -1 &&\n\t\t\t\t VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(value)))\n\t\t{\n\t\t\t/* Expanded objects need to be flattened, see comment below */\n\t\t\tsz += EOH_get_flat_size(DatumGetEOHP(value));\n\t\t}\n\t\telse\n\t\t\tsz += datumGetSize(value, typByVal, typLen);\n\t}\n\n\treturn sz;\n}"
  },
  {
    "function_name": "datumIsEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
    "lines": "218-252",
    "snippet": "bool\ndatumIsEqual(Datum value1, Datum value2, bool typByVal, int typLen)\n{\n\tbool\t\tres;\n\n\tif (typByVal)\n\t{\n\t\t/*\n\t\t * just compare the two datums. NOTE: just comparing \"len\" bytes will\n\t\t * not do the work, because we do not know how these bytes are aligned\n\t\t * inside the \"Datum\".  We assume instead that any given datatype is\n\t\t * consistent about how it fills extraneous bits in the Datum.\n\t\t */\n\t\tres = (value1 == value2);\n\t}\n\telse\n\t{\n\t\tSize\t\tsize1,\n\t\t\t\t\tsize2;\n\t\tchar\t   *s1,\n\t\t\t\t   *s2;\n\n\t\t/*\n\t\t * Compare the bytes pointed by the pointers stored in the datums.\n\t\t */\n\t\tsize1 = datumGetSize(value1, typByVal, typLen);\n\t\tsize2 = datumGetSize(value2, typByVal, typLen);\n\t\tif (size1 != size2)\n\t\t\treturn false;\n\t\ts1 = (char *) DatumGetPointer(value1);\n\t\ts2 = (char *) DatumGetPointer(value2);\n\t\tres = (memcmp(s1, s2, size1) == 0);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/datum.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "s1",
            "s2",
            "size1"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value2"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value1"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumGetSize",
          "args": [
            "value2",
            "typByVal",
            "typLen"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "datumGetSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "60-110",
          "snippet": "Size\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nSize\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nbool\ndatumIsEqual(Datum value1, Datum value2, bool typByVal, int typLen)\n{\n\tbool\t\tres;\n\n\tif (typByVal)\n\t{\n\t\t/*\n\t\t * just compare the two datums. NOTE: just comparing \"len\" bytes will\n\t\t * not do the work, because we do not know how these bytes are aligned\n\t\t * inside the \"Datum\".  We assume instead that any given datatype is\n\t\t * consistent about how it fills extraneous bits in the Datum.\n\t\t */\n\t\tres = (value1 == value2);\n\t}\n\telse\n\t{\n\t\tSize\t\tsize1,\n\t\t\t\t\tsize2;\n\t\tchar\t   *s1,\n\t\t\t\t   *s2;\n\n\t\t/*\n\t\t * Compare the bytes pointed by the pointers stored in the datums.\n\t\t */\n\t\tsize1 = datumGetSize(value1, typByVal, typLen);\n\t\tsize2 = datumGetSize(value2, typByVal, typLen);\n\t\tif (size1 != size2)\n\t\t\treturn false;\n\t\ts1 = (char *) DatumGetPointer(value1);\n\t\ts2 = (char *) DatumGetPointer(value2);\n\t\tres = (memcmp(s1, s2, size1) == 0);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "datumTransfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
    "lines": "189-198",
    "snippet": "Datum\ndatumTransfer(Datum value, bool typByVal, int typLen)\n{\n\tif (!typByVal && typLen == -1 &&\n\t\tVARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(value)))\n\t\tvalue = TransferExpandedObject(value, CurrentMemoryContext);\n\telse\n\t\tvalue = datumCopy(value, typByVal, typLen);\n\treturn value;\n}",
    "includes": [
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/datum.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "value",
            "typByVal",
            "typLen"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TransferExpandedObject",
          "args": [
            "value",
            "CurrentMemoryContext"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "TransferExpandedObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "117-130",
          "snippet": "Datum\nTransferExpandedObject(Datum d, MemoryContext new_parent)\n{\n\tExpandedObjectHeader *eohptr = DatumGetEOHP(d);\n\n\t/* Assert caller gave a R/W pointer */\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)));\n\n\t/* Transfer ownership */\n\tMemoryContextSetParent(eohptr->eoh_context, new_parent);\n\n\t/* Return the object's standard read-write pointer */\n\treturn EOHPGetRWDatum(eohptr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nDatum\nTransferExpandedObject(Datum d, MemoryContext new_parent)\n{\n\tExpandedObjectHeader *eohptr = DatumGetEOHP(d);\n\n\t/* Assert caller gave a R/W pointer */\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)));\n\n\t/* Transfer ownership */\n\tMemoryContextSetParent(eohptr->eoh_context, new_parent);\n\n\t/* Return the object's standard read-write pointer */\n\treturn EOHPGetRWDatum(eohptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED_RW",
          "args": [
            "DatumGetPointer(value)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumTransfer(Datum value, bool typByVal, int typLen)\n{\n\tif (!typByVal && typLen == -1 &&\n\t\tVARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(value)))\n\t\tvalue = TransferExpandedObject(value, CurrentMemoryContext);\n\telse\n\t\tvalue = datumCopy(value, typByVal, typLen);\n\treturn value;\n}"
  },
  {
    "function_name": "datumCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
    "lines": "127-176",
    "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/datum.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "resultptr"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "resultptr",
            "DatumGetPointer(value)",
            "realSize"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "realSize"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "datumGetSize",
          "args": [
            "value",
            "typByVal",
            "typLen"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "datumGetSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "60-110",
          "snippet": "Size\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nSize\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "resultptr"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "resultptr",
            "vl",
            "realSize"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY",
          "args": [
            "vl"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "resultptr"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOH_flatten_into",
          "args": [
            "eoh",
            "(void *) resultptr",
            "resultsize"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_flatten_into",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "80-85",
          "snippet": "void\nEOH_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\t void *result, Size allocated_size)\n{\n\teohptr->eoh_methods->flatten_into(eohptr, result, allocated_size);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nvoid\nEOH_flatten_into(ExpandedObjectHeader *eohptr,\n\t\t\t\t void *result, Size allocated_size)\n{\n\teohptr->eoh_methods->flatten_into(eohptr, result, allocated_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EOH_get_flat_size",
          "args": [
            "eoh"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "EOH_get_flat_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "74-78",
          "snippet": "Size\nEOH_get_flat_size(ExpandedObjectHeader *eohptr)\n{\n\treturn eohptr->eoh_methods->get_flat_size(eohptr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nSize\nEOH_get_flat_size(ExpandedObjectHeader *eohptr)\n{\n\treturn eohptr->eoh_methods->get_flat_size(eohptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetEOHP",
          "args": [
            "value"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetEOHP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "28-38",
          "snippet": "ExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED",
          "args": [
            "vl"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "datumGetSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
    "lines": "60-110",
    "snippet": "Size\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}",
    "includes": [
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/datum.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid typLen: %d\"",
            "typLen"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "strlen(s) + 1"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\"))"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid Datum pointer\""
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATA_EXCEPTION"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "s"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY",
          "args": [
            "s"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\"))"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "s"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "value"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "typLen > 0 && typLen <= sizeof(Datum)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nSize\ndatumGetSize(Datum value, bool typByVal, int typLen)\n{\n\tSize\t\tsize;\n\n\tif (typByVal)\n\t{\n\t\t/* Pass-by-value types are always fixed-length */\n\t\tAssert(typLen > 0 && typLen <= sizeof(Datum));\n\t\tsize = (Size) typLen;\n\t}\n\telse\n\t{\n\t\tif (typLen > 0)\n\t\t{\n\t\t\t/* Fixed-length pass-by-ref type */\n\t\t\tsize = (Size) typLen;\n\t\t}\n\t\telse if (typLen == -1)\n\t\t{\n\t\t\t/* It is a varlena datatype */\n\t\t\tstruct varlena *s = (struct varlena *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) VARSIZE_ANY(s);\n\t\t}\n\t\telse if (typLen == -2)\n\t\t{\n\t\t\t/* It is a cstring datatype */\n\t\t\tchar\t   *s = (char *) DatumGetPointer(value);\n\n\t\t\tif (!PointerIsValid(s))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t\t errmsg(\"invalid Datum pointer\")));\n\n\t\t\tsize = (Size) (strlen(s) + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\telog(ERROR, \"invalid typLen: %d\", typLen);\n\t\t\tsize = 0;\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\treturn size;\n}"
  }
]