[
  {
    "function_name": "width_bucket_array_variable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "6510-6572",
    "snippet": "static int\nwidth_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry)\n{\n\tchar\t   *thresholds_data;\n\tint\t\t\ttyplen = typentry->typlen;\n\tbool\t\ttypbyval = typentry->typbyval;\n\tchar\t\ttypalign = typentry->typalign;\n\tFunctionCallInfoData locfcinfo;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\tthresholds_data = (char *) ARR_DATA_PTR(thresholds);\n\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Find the bucket */\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\t\tchar\t   *ptr;\n\t\tint\t\t\ti;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Locate mid'th array element by advancing from left element */\n\t\tptr = thresholds_data;\n\t\tfor (i = left; i < mid; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\n\t\tlocfcinfo.arg[0] = operand;\n\t\tlocfcinfo.arg[1] = fetch_att(ptr, typbyval, typlen);\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult < 0)\n\t\t\tright = mid;\n\t\telse\n\t\t{\n\t\t\tleft = mid + 1;\n\n\t\t\t/*\n\t\t\t * Move the thresholds pointer to match new \"left\" index, so we\n\t\t\t * don't have to seek over those elements again.  This trick\n\t\t\t * ensures we do only O(N) array indexing work, not O(N^2).\n\t\t\t */\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tthresholds_data = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\n\treturn left;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);",
      "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
      "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "ptr",
            "typalign"
          ],
          "line": 6567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "ptr",
            "typlen",
            "ptr"
          ],
          "line": 6566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "FunctionCallInvoke(&locfcinfo)"
          ],
          "line": 6553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&locfcinfo"
          ],
          "line": 6553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_att",
          "args": [
            "ptr",
            "typbyval",
            "typlen"
          ],
          "line": 6548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "ptr",
            "typalign"
          ],
          "line": 6544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "ptr",
            "typlen",
            "ptr"
          ],
          "line": 6543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ARR_NDIM(thresholds)",
            "ARR_DIMS(thresholds)"
          ],
          "line": 6531
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "thresholds"
          ],
          "line": 6531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "thresholds"
          ],
          "line": 6531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "&typentry->cmp_proc_finfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 6526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "thresholds"
          ],
          "line": 6524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\nwidth_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry)\n{\n\tchar\t   *thresholds_data;\n\tint\t\t\ttyplen = typentry->typlen;\n\tbool\t\ttypbyval = typentry->typbyval;\n\tchar\t\ttypalign = typentry->typalign;\n\tFunctionCallInfoData locfcinfo;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\tthresholds_data = (char *) ARR_DATA_PTR(thresholds);\n\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Find the bucket */\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\t\tchar\t   *ptr;\n\t\tint\t\t\ti;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Locate mid'th array element by advancing from left element */\n\t\tptr = thresholds_data;\n\t\tfor (i = left; i < mid; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\n\t\tlocfcinfo.arg[0] = operand;\n\t\tlocfcinfo.arg[1] = fetch_att(ptr, typbyval, typlen);\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult < 0)\n\t\t\tright = mid;\n\t\telse\n\t\t{\n\t\t\tleft = mid + 1;\n\n\t\t\t/*\n\t\t\t * Move the thresholds pointer to match new \"left\" index, so we\n\t\t\t * don't have to seek over those elements again.  This trick\n\t\t\t * ensures we do only O(N) array indexing work, not O(N^2).\n\t\t\t */\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tthresholds_data = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\n\treturn left;\n}"
  },
  {
    "function_name": "width_bucket_array_fixed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "6457-6505",
    "snippet": "static int\nwidth_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry)\n{\n\tchar\t   *thresholds_data;\n\tint\t\t\ttyplen = typentry->typlen;\n\tbool\t\ttypbyval = typentry->typbyval;\n\tFunctionCallInfoData locfcinfo;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\t/*\n\t * Since we know the array contains no NULLs, we can just index it\n\t * directly.\n\t */\n\tthresholds_data = (char *) ARR_DATA_PTR(thresholds);\n\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Find the bucket */\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\t\tchar\t   *ptr;\n\t\tint32\t\tcmpresult;\n\n\t\tptr = thresholds_data + mid * typlen;\n\n\t\tlocfcinfo.arg[0] = operand;\n\t\tlocfcinfo.arg[1] = fetch_att(ptr, typbyval, typlen);\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult < 0)\n\t\t\tright = mid;\n\t\telse\n\t\t\tleft = mid + 1;\n\t}\n\n\treturn left;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);",
      "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
      "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "FunctionCallInvoke(&locfcinfo)"
          ],
          "line": 6496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&locfcinfo"
          ],
          "line": 6496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_att",
          "args": [
            "ptr",
            "typbyval",
            "typlen"
          ],
          "line": 6491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ARR_NDIM(thresholds)",
            "ARR_DIMS(thresholds)"
          ],
          "line": 6481
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "thresholds"
          ],
          "line": 6481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "thresholds"
          ],
          "line": 6481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "&typentry->cmp_proc_finfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 6476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "thresholds"
          ],
          "line": 6474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\nwidth_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry)\n{\n\tchar\t   *thresholds_data;\n\tint\t\t\ttyplen = typentry->typlen;\n\tbool\t\ttypbyval = typentry->typbyval;\n\tFunctionCallInfoData locfcinfo;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\t/*\n\t * Since we know the array contains no NULLs, we can just index it\n\t * directly.\n\t */\n\tthresholds_data = (char *) ARR_DATA_PTR(thresholds);\n\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Find the bucket */\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\t\tchar\t   *ptr;\n\t\tint32\t\tcmpresult;\n\n\t\tptr = thresholds_data + mid * typlen;\n\n\t\tlocfcinfo.arg[0] = operand;\n\t\tlocfcinfo.arg[1] = fetch_att(ptr, typbyval, typlen);\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult < 0)\n\t\t\tright = mid;\n\t\telse\n\t\t\tleft = mid + 1;\n\t}\n\n\treturn left;\n}"
  },
  {
    "function_name": "width_bucket_array_float8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "6413-6452",
    "snippet": "static int\nwidth_bucket_array_float8(Datum operand, ArrayType *thresholds)\n{\n\tfloat8\t\top = DatumGetFloat8(operand);\n\tfloat8\t   *thresholds_data;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\t/*\n\t * Since we know the array contains no NULLs, we can just index it\n\t * directly.\n\t */\n\tthresholds_data = (float8 *) ARR_DATA_PTR(thresholds);\n\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\n\t/*\n\t * If the probe value is a NaN, it's greater than or equal to all possible\n\t * threshold values (including other NaNs), so we need not search.  Note\n\t * that this would give the same result as searching even if the array\n\t * contains multiple NaNs (as long as they're correctly sorted), since the\n\t * loop logic will find the rightmost of multiple equal threshold values.\n\t */\n\tif (isnan(op))\n\t\treturn right;\n\n\t/* Find the bucket */\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\n\t\tif (isnan(thresholds_data[mid]) || op < thresholds_data[mid])\n\t\t\tright = mid;\n\t\telse\n\t\t\tleft = mid + 1;\n\t}\n\n\treturn left;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "thresholds_data[mid]"
          ],
          "line": 6445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnan",
          "args": [
            "op"
          ],
          "line": 6437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ARR_NDIM(thresholds)",
            "ARR_DIMS(thresholds)"
          ],
          "line": 6428
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "thresholds"
          ],
          "line": 6428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "thresholds"
          ],
          "line": 6428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "thresholds"
          ],
          "line": 6425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "operand"
          ],
          "line": 6416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);\n\nstatic int\nwidth_bucket_array_float8(Datum operand, ArrayType *thresholds)\n{\n\tfloat8\t\top = DatumGetFloat8(operand);\n\tfloat8\t   *thresholds_data;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\t/*\n\t * Since we know the array contains no NULLs, we can just index it\n\t * directly.\n\t */\n\tthresholds_data = (float8 *) ARR_DATA_PTR(thresholds);\n\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\n\t/*\n\t * If the probe value is a NaN, it's greater than or equal to all possible\n\t * threshold values (including other NaNs), so we need not search.  Note\n\t * that this would give the same result as searching even if the array\n\t * contains multiple NaNs (as long as they're correctly sorted), since the\n\t * loop logic will find the rightmost of multiple equal threshold values.\n\t */\n\tif (isnan(op))\n\t\treturn right;\n\n\t/* Find the bucket */\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\n\t\tif (isnan(thresholds_data[mid]) || op < thresholds_data[mid])\n\t\t\tright = mid;\n\t\telse\n\t\t\tleft = mid + 1;\n\t}\n\n\treturn left;\n}"
  },
  {
    "function_name": "width_bucket_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "6350-6408",
    "snippet": "Datum\nwidth_bucket_array(PG_FUNCTION_ARGS)\n{\n\tDatum\t\toperand = PG_GETARG_DATUM(0);\n\tArrayType  *thresholds = PG_GETARG_ARRAYTYPE_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tOid\t\t\telement_type = ARR_ELEMTYPE(thresholds);\n\tint\t\t\tresult;\n\n\t/* Check input */\n\tif (ARR_NDIM(thresholds) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"thresholds must be one-dimensional array\")));\n\n\tif (array_contains_nulls(thresholds))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"thresholds array must not contain NULLs\")));\n\n\t/* We have a dedicated implementation for float8 data */\n\tif (element_type == FLOAT8OID)\n\t\tresult = width_bucket_array_float8(operand, thresholds);\n\telse\n\t{\n\t\tTypeCacheEntry *typentry;\n\n\t\t/* Cache information about the input type */\n\t\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != element_type)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t\t}\n\n\t\t/*\n\t\t * We have separate implementation paths for fixed- and variable-width\n\t\t * types, since indexing the array is a lot cheaper in the first case.\n\t\t */\n\t\tif (typentry->typlen > 0)\n\t\t\tresult = width_bucket_array_fixed(operand, thresholds,\n\t\t\t\t\t\t\t\t\t\t\t  collation, typentry);\n\t\telse\n\t\t\tresult = width_bucket_array_variable(operand, thresholds,\n\t\t\t\t\t\t\t\t\t\t\t\t collation, typentry);\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(thresholds, 1);\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
      "static int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);",
      "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
      "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 6407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "thresholds",
            "1"
          ],
          "line": 6405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "width_bucket_array_variable",
          "args": [
            "operand",
            "thresholds",
            "collation",
            "typentry"
          ],
          "line": 6400
        },
        "resolved": true,
        "details": {
          "function_name": "width_bucket_array_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "6510-6572",
          "snippet": "static int\nwidth_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry)\n{\n\tchar\t   *thresholds_data;\n\tint\t\t\ttyplen = typentry->typlen;\n\tbool\t\ttypbyval = typentry->typbyval;\n\tchar\t\ttypalign = typentry->typalign;\n\tFunctionCallInfoData locfcinfo;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\tthresholds_data = (char *) ARR_DATA_PTR(thresholds);\n\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Find the bucket */\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\t\tchar\t   *ptr;\n\t\tint\t\t\ti;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Locate mid'th array element by advancing from left element */\n\t\tptr = thresholds_data;\n\t\tfor (i = left; i < mid; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\n\t\tlocfcinfo.arg[0] = operand;\n\t\tlocfcinfo.arg[1] = fetch_att(ptr, typbyval, typlen);\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult < 0)\n\t\t\tright = mid;\n\t\telse\n\t\t{\n\t\t\tleft = mid + 1;\n\n\t\t\t/*\n\t\t\t * Move the thresholds pointer to match new \"left\" index, so we\n\t\t\t * don't have to seek over those elements again.  This trick\n\t\t\t * ensures we do only O(N) array indexing work, not O(N^2).\n\t\t\t */\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tthresholds_data = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\n\treturn left;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\nwidth_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry)\n{\n\tchar\t   *thresholds_data;\n\tint\t\t\ttyplen = typentry->typlen;\n\tbool\t\ttypbyval = typentry->typbyval;\n\tchar\t\ttypalign = typentry->typalign;\n\tFunctionCallInfoData locfcinfo;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\tthresholds_data = (char *) ARR_DATA_PTR(thresholds);\n\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Find the bucket */\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\t\tchar\t   *ptr;\n\t\tint\t\t\ti;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Locate mid'th array element by advancing from left element */\n\t\tptr = thresholds_data;\n\t\tfor (i = left; i < mid; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\n\t\tlocfcinfo.arg[0] = operand;\n\t\tlocfcinfo.arg[1] = fetch_att(ptr, typbyval, typlen);\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult < 0)\n\t\t\tright = mid;\n\t\telse\n\t\t{\n\t\t\tleft = mid + 1;\n\n\t\t\t/*\n\t\t\t * Move the thresholds pointer to match new \"left\" index, so we\n\t\t\t * don't have to seek over those elements again.  This trick\n\t\t\t * ensures we do only O(N) array indexing work, not O(N^2).\n\t\t\t */\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tthresholds_data = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\n\treturn left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "width_bucket_array_fixed",
          "args": [
            "operand",
            "thresholds",
            "collation",
            "typentry"
          ],
          "line": 6397
        },
        "resolved": true,
        "details": {
          "function_name": "width_bucket_array_fixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "6457-6505",
          "snippet": "static int\nwidth_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry)\n{\n\tchar\t   *thresholds_data;\n\tint\t\t\ttyplen = typentry->typlen;\n\tbool\t\ttypbyval = typentry->typbyval;\n\tFunctionCallInfoData locfcinfo;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\t/*\n\t * Since we know the array contains no NULLs, we can just index it\n\t * directly.\n\t */\n\tthresholds_data = (char *) ARR_DATA_PTR(thresholds);\n\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Find the bucket */\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\t\tchar\t   *ptr;\n\t\tint32\t\tcmpresult;\n\n\t\tptr = thresholds_data + mid * typlen;\n\n\t\tlocfcinfo.arg[0] = operand;\n\t\tlocfcinfo.arg[1] = fetch_att(ptr, typbyval, typlen);\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult < 0)\n\t\t\tright = mid;\n\t\telse\n\t\t\tleft = mid + 1;\n\t}\n\n\treturn left;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\nwidth_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry)\n{\n\tchar\t   *thresholds_data;\n\tint\t\t\ttyplen = typentry->typlen;\n\tbool\t\ttypbyval = typentry->typbyval;\n\tFunctionCallInfoData locfcinfo;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\t/*\n\t * Since we know the array contains no NULLs, we can just index it\n\t * directly.\n\t */\n\tthresholds_data = (char *) ARR_DATA_PTR(thresholds);\n\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Find the bucket */\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\t\tchar\t   *ptr;\n\t\tint32\t\tcmpresult;\n\n\t\tptr = thresholds_data + mid * typlen;\n\n\t\tlocfcinfo.arg[0] = operand;\n\t\tlocfcinfo.arg[1] = fetch_att(ptr, typbyval, typlen);\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult < 0)\n\t\t\tright = mid;\n\t\telse\n\t\t\tleft = mid + 1;\n\t}\n\n\treturn left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 6385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not identify a comparison function for type %s\"",
            "format_type_be(element_type)"
          ],
          "line": 6387
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 6388
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 6386
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->cmp_proc_finfo.fn_oid"
          ],
          "line": 6384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "element_type",
            "TYPECACHE_CMP_PROC_FINFO"
          ],
          "line": 6382
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "width_bucket_array_float8",
          "args": [
            "operand",
            "thresholds"
          ],
          "line": 6372
        },
        "resolved": true,
        "details": {
          "function_name": "width_bucket_array_float8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "6413-6452",
          "snippet": "static int\nwidth_bucket_array_float8(Datum operand, ArrayType *thresholds)\n{\n\tfloat8\t\top = DatumGetFloat8(operand);\n\tfloat8\t   *thresholds_data;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\t/*\n\t * Since we know the array contains no NULLs, we can just index it\n\t * directly.\n\t */\n\tthresholds_data = (float8 *) ARR_DATA_PTR(thresholds);\n\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\n\t/*\n\t * If the probe value is a NaN, it's greater than or equal to all possible\n\t * threshold values (including other NaNs), so we need not search.  Note\n\t * that this would give the same result as searching even if the array\n\t * contains multiple NaNs (as long as they're correctly sorted), since the\n\t * loop logic will find the rightmost of multiple equal threshold values.\n\t */\n\tif (isnan(op))\n\t\treturn right;\n\n\t/* Find the bucket */\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\n\t\tif (isnan(thresholds_data[mid]) || op < thresholds_data[mid])\n\t\t\tright = mid;\n\t\telse\n\t\t\tleft = mid + 1;\n\t}\n\n\treturn left;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);\n\nstatic int\nwidth_bucket_array_float8(Datum operand, ArrayType *thresholds)\n{\n\tfloat8\t\top = DatumGetFloat8(operand);\n\tfloat8\t   *thresholds_data;\n\tint\t\t\tleft;\n\tint\t\t\tright;\n\n\t/*\n\t * Since we know the array contains no NULLs, we can just index it\n\t * directly.\n\t */\n\tthresholds_data = (float8 *) ARR_DATA_PTR(thresholds);\n\n\tleft = 0;\n\tright = ArrayGetNItems(ARR_NDIM(thresholds), ARR_DIMS(thresholds));\n\n\t/*\n\t * If the probe value is a NaN, it's greater than or equal to all possible\n\t * threshold values (including other NaNs), so we need not search.  Note\n\t * that this would give the same result as searching even if the array\n\t * contains multiple NaNs (as long as they're correctly sorted), since the\n\t * loop logic will find the rightmost of multiple equal threshold values.\n\t */\n\tif (isnan(op))\n\t\treturn right;\n\n\t/* Find the bucket */\n\twhile (left < right)\n\t{\n\t\tint\t\t\tmid = (left + right) / 2;\n\n\t\tif (isnan(thresholds_data[mid]) || op < thresholds_data[mid])\n\t\t\tright = mid;\n\t\telse\n\t\t\tleft = mid + 1;\n\t}\n\n\treturn left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"thresholds array must not contain NULLs\"))"
          ],
          "line": 6366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contains_nulls",
          "args": [
            "thresholds"
          ],
          "line": 6365
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3527-3562",
          "snippet": "bool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"thresholds must be one-dimensional array\"))"
          ],
          "line": 6361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "thresholds"
          ],
          "line": 6360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "thresholds"
          ],
          "line": 6356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 6355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 6354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 6353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int\twidth_bucket_array_float8(Datum operand, ArrayType *thresholds);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nDatum\nwidth_bucket_array(PG_FUNCTION_ARGS)\n{\n\tDatum\t\toperand = PG_GETARG_DATUM(0);\n\tArrayType  *thresholds = PG_GETARG_ARRAYTYPE_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tOid\t\t\telement_type = ARR_ELEMTYPE(thresholds);\n\tint\t\t\tresult;\n\n\t/* Check input */\n\tif (ARR_NDIM(thresholds) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"thresholds must be one-dimensional array\")));\n\n\tif (array_contains_nulls(thresholds))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"thresholds array must not contain NULLs\")));\n\n\t/* We have a dedicated implementation for float8 data */\n\tif (element_type == FLOAT8OID)\n\t\tresult = width_bucket_array_float8(operand, thresholds);\n\telse\n\t{\n\t\tTypeCacheEntry *typentry;\n\n\t\t/* Cache information about the input type */\n\t\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != element_type)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t\t}\n\n\t\t/*\n\t\t * We have separate implementation paths for fixed- and variable-width\n\t\t * types, since indexing the array is a lot cheaper in the first case.\n\t\t */\n\t\tif (typentry->typlen > 0)\n\t\t\tresult = width_bucket_array_fixed(operand, thresholds,\n\t\t\t\t\t\t\t\t\t\t\t  collation, typentry);\n\t\telse\n\t\t\tresult = width_bucket_array_variable(operand, thresholds,\n\t\t\t\t\t\t\t\t\t\t\t\t collation, typentry);\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tPG_FREE_IF_COPY(thresholds, 1);\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "array_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "6321-6340",
    "snippet": "Datum\narray_replace(PG_FUNCTION_ARGS)\n{\n\tArrayType  *array;\n\tDatum\t\tsearch = PG_GETARG_DATUM(1);\n\tbool\t\tsearch_isnull = PG_ARGISNULL(1);\n\tDatum\t\treplace = PG_GETARG_DATUM(2);\n\tbool\t\treplace_isnull = PG_ARGISNULL(2);\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\n\tarray = array_replace_internal(array,\n\t\t\t\t\t\t\t\t   search, search_isnull,\n\t\t\t\t\t\t\t\t   replace, replace_isnull,\n\t\t\t\t\t\t\t\t   false, PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t   fcinfo);\n\tPG_RETURN_ARRAYTYPE_P(array);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "array"
          ],
          "line": 6339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_replace_internal",
          "args": [
            "array",
            "search",
            "search_isnull",
            "replace",
            "replace_isnull",
            "false",
            "PG_GET_COLLATION()",
            "fcinfo"
          ],
          "line": 6334
        },
        "resolved": true,
        "details": {
          "function_name": "array_replace_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "6041-6292",
          "snippet": "static ArrayType *\narray_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tOid\t\t\telement_type;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems,\n\t\t\t\tnresult;\n\tint\t\t\ti;\n\tint32\t\tnbytes = 0;\n\tint32\t\tdataoffset;\n\tbool\t\thasnulls;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t   *arraydataptr;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tbool\t\tchanged = false;\n\tTypeCacheEntry *typentry;\n\tFunctionCallInfoData locfcinfo;\n\n\telement_type = ARR_ELEMTYPE(array);\n\tndim = ARR_NDIM(array);\n\tdim = ARR_DIMS(array);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/* Return input array unmodified if it is empty */\n\tif (nitems <= 0)\n\t\treturn array;\n\n\t/*\n\t * We can't remove elements from multi-dimensional arrays, since the\n\t * result might not be rectangular.\n\t */\n\tif (remove && ndim > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"removing elements from multidimensional arrays is not supported\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Detoast values if they are toasted.  The replacement value must be\n\t * detoasted for insertion into the result array, while detoasting the\n\t * search value only once saves cycles.\n\t */\n\tif (typlen == -1)\n\t{\n\t\tif (!search_isnull)\n\t\t\tsearch = PointerGetDatum(PG_DETOAST_DATUM(search));\n\t\tif (!replace_isnull)\n\t\t\treplace = PointerGetDatum(PG_DETOAST_DATUM(replace));\n\t}\n\n\t/* Prepare to apply the comparison operator */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Allocate temporary arrays for new values */\n\tvalues = (Datum *) palloc(nitems * sizeof(Datum));\n\tnulls = (bool *) palloc(nitems * sizeof(bool));\n\n\t/* Loop over source data */\n\tarraydataptr = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\thasnulls = false;\n\tnresult = 0;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\telt;\n\t\tbool\t\tisNull;\n\t\tbool\t\toprresult;\n\t\tbool\t\tskip = false;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\tisNull = true;\n\t\t\t/* If searching for NULL, we have a match */\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\tif (remove)\n\t\t\t\t{\n\t\t\t\t\tskip = true;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse if (!replace_isnull)\n\t\t\t\t{\n\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\tisNull = false;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisNull = false;\n\t\t\telt = fetch_att(arraydataptr, typbyval, typlen);\n\t\t\tarraydataptr = att_addlength_datum(arraydataptr, typlen, elt);\n\t\t\tarraydataptr = (char *) att_align_nominal(arraydataptr, typalign);\n\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\t/* no match possible, keep element */\n\t\t\t\tvalues[nresult] = elt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Apply the operator to the element pair\n\t\t\t\t */\n\t\t\t\tlocfcinfo.arg[0] = elt;\n\t\t\t\tlocfcinfo.arg[1] = search;\n\t\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\t\tlocfcinfo.isnull = false;\n\t\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\t\tif (!oprresult)\n\t\t\t\t{\n\t\t\t\t\t/* no match, keep element */\n\t\t\t\t\tvalues[nresult] = elt;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* match, so replace or delete */\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tif (remove)\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\t\tisNull = replace_isnull;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t\tnulls[nresult] = isNull;\n\t\t\tif (isNull)\n\t\t\t\thasnulls = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Update total result size */\n\t\t\t\tnbytes = att_addlength_datum(nbytes, typlen, values[nresult]);\n\t\t\t\tnbytes = att_align_nominal(nbytes, typalign);\n\t\t\t\t/* check for overflow of total request */\n\t\t\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t\t}\n\t\t\tnresult++;\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If not changed just return the original array\n\t */\n\tif (!changed)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn array;\n\t}\n\n\t/* If all elements were removed return an empty array */\n\tif (nresult == 0)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn construct_empty_array(element_type);\n\t}\n\n\t/* Allocate and initialize the result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nresult);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndim;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = element_type;\n\tmemcpy(ARR_DIMS(result), ARR_DIMS(array), ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), ARR_LBOUND(array), ndim * sizeof(int));\n\n\tif (remove)\n\t{\n\t\t/* Adjust the result length */\n\t\tARR_DIMS(result)[0] = nresult;\n\t}\n\n\t/* Insert data into result array */\n\tCopyArrayEls(result,\n\t\t\t\t values, nulls, nresult,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t false);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
            "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic ArrayType *\narray_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tOid\t\t\telement_type;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems,\n\t\t\t\tnresult;\n\tint\t\t\ti;\n\tint32\t\tnbytes = 0;\n\tint32\t\tdataoffset;\n\tbool\t\thasnulls;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t   *arraydataptr;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tbool\t\tchanged = false;\n\tTypeCacheEntry *typentry;\n\tFunctionCallInfoData locfcinfo;\n\n\telement_type = ARR_ELEMTYPE(array);\n\tndim = ARR_NDIM(array);\n\tdim = ARR_DIMS(array);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/* Return input array unmodified if it is empty */\n\tif (nitems <= 0)\n\t\treturn array;\n\n\t/*\n\t * We can't remove elements from multi-dimensional arrays, since the\n\t * result might not be rectangular.\n\t */\n\tif (remove && ndim > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"removing elements from multidimensional arrays is not supported\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Detoast values if they are toasted.  The replacement value must be\n\t * detoasted for insertion into the result array, while detoasting the\n\t * search value only once saves cycles.\n\t */\n\tif (typlen == -1)\n\t{\n\t\tif (!search_isnull)\n\t\t\tsearch = PointerGetDatum(PG_DETOAST_DATUM(search));\n\t\tif (!replace_isnull)\n\t\t\treplace = PointerGetDatum(PG_DETOAST_DATUM(replace));\n\t}\n\n\t/* Prepare to apply the comparison operator */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Allocate temporary arrays for new values */\n\tvalues = (Datum *) palloc(nitems * sizeof(Datum));\n\tnulls = (bool *) palloc(nitems * sizeof(bool));\n\n\t/* Loop over source data */\n\tarraydataptr = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\thasnulls = false;\n\tnresult = 0;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\telt;\n\t\tbool\t\tisNull;\n\t\tbool\t\toprresult;\n\t\tbool\t\tskip = false;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\tisNull = true;\n\t\t\t/* If searching for NULL, we have a match */\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\tif (remove)\n\t\t\t\t{\n\t\t\t\t\tskip = true;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse if (!replace_isnull)\n\t\t\t\t{\n\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\tisNull = false;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisNull = false;\n\t\t\telt = fetch_att(arraydataptr, typbyval, typlen);\n\t\t\tarraydataptr = att_addlength_datum(arraydataptr, typlen, elt);\n\t\t\tarraydataptr = (char *) att_align_nominal(arraydataptr, typalign);\n\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\t/* no match possible, keep element */\n\t\t\t\tvalues[nresult] = elt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Apply the operator to the element pair\n\t\t\t\t */\n\t\t\t\tlocfcinfo.arg[0] = elt;\n\t\t\t\tlocfcinfo.arg[1] = search;\n\t\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\t\tlocfcinfo.isnull = false;\n\t\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\t\tif (!oprresult)\n\t\t\t\t{\n\t\t\t\t\t/* no match, keep element */\n\t\t\t\t\tvalues[nresult] = elt;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* match, so replace or delete */\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tif (remove)\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\t\tisNull = replace_isnull;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t\tnulls[nresult] = isNull;\n\t\t\tif (isNull)\n\t\t\t\thasnulls = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Update total result size */\n\t\t\t\tnbytes = att_addlength_datum(nbytes, typlen, values[nresult]);\n\t\t\t\tnbytes = att_align_nominal(nbytes, typalign);\n\t\t\t\t/* check for overflow of total request */\n\t\t\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t\t}\n\t\t\tnresult++;\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If not changed just return the original array\n\t */\n\tif (!changed)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn array;\n\t}\n\n\t/* If all elements were removed return an empty array */\n\tif (nresult == 0)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn construct_empty_array(element_type);\n\t}\n\n\t/* Allocate and initialize the result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nresult);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndim;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = element_type;\n\tmemcpy(ARR_DIMS(result), ARR_DIMS(array), ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), ARR_LBOUND(array), ndim * sizeof(int));\n\n\tif (remove)\n\t{\n\t\t/* Adjust the result length */\n\t\tARR_DIMS(result)[0] = nresult;\n\t}\n\n\t/* Insert data into result array */\n\tCopyArrayEls(result,\n\t\t\t\t values, nulls, nresult,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t false);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 6337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 6332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 6331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 6330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 6328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "2"
          ],
          "line": 6327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 6326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 6325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_replace(PG_FUNCTION_ARGS)\n{\n\tArrayType  *array;\n\tDatum\t\tsearch = PG_GETARG_DATUM(1);\n\tbool\t\tsearch_isnull = PG_ARGISNULL(1);\n\tDatum\t\treplace = PG_GETARG_DATUM(2);\n\tbool\t\treplace_isnull = PG_ARGISNULL(2);\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\n\tarray = array_replace_internal(array,\n\t\t\t\t\t\t\t\t   search, search_isnull,\n\t\t\t\t\t\t\t\t   replace, replace_isnull,\n\t\t\t\t\t\t\t\t   false, PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t   fcinfo);\n\tPG_RETURN_ARRAYTYPE_P(array);\n}"
  },
  {
    "function_name": "array_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "6299-6316",
    "snippet": "Datum\narray_remove(PG_FUNCTION_ARGS)\n{\n\tArrayType  *array;\n\tDatum\t\tsearch = PG_GETARG_DATUM(1);\n\tbool\t\tsearch_isnull = PG_ARGISNULL(1);\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\n\tarray = array_replace_internal(array,\n\t\t\t\t\t\t\t\t   search, search_isnull,\n\t\t\t\t\t\t\t\t   (Datum) 0, true,\n\t\t\t\t\t\t\t\t   true, PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t   fcinfo);\n\tPG_RETURN_ARRAYTYPE_P(array);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "array"
          ],
          "line": 6315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_replace_internal",
          "args": [
            "array",
            "search",
            "search_isnull",
            "(Datum) 0",
            "true",
            "true",
            "PG_GET_COLLATION()",
            "fcinfo"
          ],
          "line": 6310
        },
        "resolved": true,
        "details": {
          "function_name": "array_replace_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "6041-6292",
          "snippet": "static ArrayType *\narray_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tOid\t\t\telement_type;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems,\n\t\t\t\tnresult;\n\tint\t\t\ti;\n\tint32\t\tnbytes = 0;\n\tint32\t\tdataoffset;\n\tbool\t\thasnulls;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t   *arraydataptr;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tbool\t\tchanged = false;\n\tTypeCacheEntry *typentry;\n\tFunctionCallInfoData locfcinfo;\n\n\telement_type = ARR_ELEMTYPE(array);\n\tndim = ARR_NDIM(array);\n\tdim = ARR_DIMS(array);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/* Return input array unmodified if it is empty */\n\tif (nitems <= 0)\n\t\treturn array;\n\n\t/*\n\t * We can't remove elements from multi-dimensional arrays, since the\n\t * result might not be rectangular.\n\t */\n\tif (remove && ndim > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"removing elements from multidimensional arrays is not supported\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Detoast values if they are toasted.  The replacement value must be\n\t * detoasted for insertion into the result array, while detoasting the\n\t * search value only once saves cycles.\n\t */\n\tif (typlen == -1)\n\t{\n\t\tif (!search_isnull)\n\t\t\tsearch = PointerGetDatum(PG_DETOAST_DATUM(search));\n\t\tif (!replace_isnull)\n\t\t\treplace = PointerGetDatum(PG_DETOAST_DATUM(replace));\n\t}\n\n\t/* Prepare to apply the comparison operator */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Allocate temporary arrays for new values */\n\tvalues = (Datum *) palloc(nitems * sizeof(Datum));\n\tnulls = (bool *) palloc(nitems * sizeof(bool));\n\n\t/* Loop over source data */\n\tarraydataptr = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\thasnulls = false;\n\tnresult = 0;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\telt;\n\t\tbool\t\tisNull;\n\t\tbool\t\toprresult;\n\t\tbool\t\tskip = false;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\tisNull = true;\n\t\t\t/* If searching for NULL, we have a match */\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\tif (remove)\n\t\t\t\t{\n\t\t\t\t\tskip = true;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse if (!replace_isnull)\n\t\t\t\t{\n\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\tisNull = false;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisNull = false;\n\t\t\telt = fetch_att(arraydataptr, typbyval, typlen);\n\t\t\tarraydataptr = att_addlength_datum(arraydataptr, typlen, elt);\n\t\t\tarraydataptr = (char *) att_align_nominal(arraydataptr, typalign);\n\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\t/* no match possible, keep element */\n\t\t\t\tvalues[nresult] = elt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Apply the operator to the element pair\n\t\t\t\t */\n\t\t\t\tlocfcinfo.arg[0] = elt;\n\t\t\t\tlocfcinfo.arg[1] = search;\n\t\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\t\tlocfcinfo.isnull = false;\n\t\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\t\tif (!oprresult)\n\t\t\t\t{\n\t\t\t\t\t/* no match, keep element */\n\t\t\t\t\tvalues[nresult] = elt;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* match, so replace or delete */\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tif (remove)\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\t\tisNull = replace_isnull;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t\tnulls[nresult] = isNull;\n\t\t\tif (isNull)\n\t\t\t\thasnulls = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Update total result size */\n\t\t\t\tnbytes = att_addlength_datum(nbytes, typlen, values[nresult]);\n\t\t\t\tnbytes = att_align_nominal(nbytes, typalign);\n\t\t\t\t/* check for overflow of total request */\n\t\t\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t\t}\n\t\t\tnresult++;\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If not changed just return the original array\n\t */\n\tif (!changed)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn array;\n\t}\n\n\t/* If all elements were removed return an empty array */\n\tif (nresult == 0)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn construct_empty_array(element_type);\n\t}\n\n\t/* Allocate and initialize the result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nresult);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndim;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = element_type;\n\tmemcpy(ARR_DIMS(result), ARR_DIMS(array), ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), ARR_LBOUND(array), ndim * sizeof(int));\n\n\tif (remove)\n\t{\n\t\t/* Adjust the result length */\n\t\tARR_DIMS(result)[0] = nresult;\n\t}\n\n\t/* Insert data into result array */\n\tCopyArrayEls(result,\n\t\t\t\t values, nulls, nresult,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t false);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
            "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic ArrayType *\narray_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tOid\t\t\telement_type;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems,\n\t\t\t\tnresult;\n\tint\t\t\ti;\n\tint32\t\tnbytes = 0;\n\tint32\t\tdataoffset;\n\tbool\t\thasnulls;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t   *arraydataptr;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tbool\t\tchanged = false;\n\tTypeCacheEntry *typentry;\n\tFunctionCallInfoData locfcinfo;\n\n\telement_type = ARR_ELEMTYPE(array);\n\tndim = ARR_NDIM(array);\n\tdim = ARR_DIMS(array);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/* Return input array unmodified if it is empty */\n\tif (nitems <= 0)\n\t\treturn array;\n\n\t/*\n\t * We can't remove elements from multi-dimensional arrays, since the\n\t * result might not be rectangular.\n\t */\n\tif (remove && ndim > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"removing elements from multidimensional arrays is not supported\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Detoast values if they are toasted.  The replacement value must be\n\t * detoasted for insertion into the result array, while detoasting the\n\t * search value only once saves cycles.\n\t */\n\tif (typlen == -1)\n\t{\n\t\tif (!search_isnull)\n\t\t\tsearch = PointerGetDatum(PG_DETOAST_DATUM(search));\n\t\tif (!replace_isnull)\n\t\t\treplace = PointerGetDatum(PG_DETOAST_DATUM(replace));\n\t}\n\n\t/* Prepare to apply the comparison operator */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Allocate temporary arrays for new values */\n\tvalues = (Datum *) palloc(nitems * sizeof(Datum));\n\tnulls = (bool *) palloc(nitems * sizeof(bool));\n\n\t/* Loop over source data */\n\tarraydataptr = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\thasnulls = false;\n\tnresult = 0;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\telt;\n\t\tbool\t\tisNull;\n\t\tbool\t\toprresult;\n\t\tbool\t\tskip = false;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\tisNull = true;\n\t\t\t/* If searching for NULL, we have a match */\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\tif (remove)\n\t\t\t\t{\n\t\t\t\t\tskip = true;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse if (!replace_isnull)\n\t\t\t\t{\n\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\tisNull = false;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisNull = false;\n\t\t\telt = fetch_att(arraydataptr, typbyval, typlen);\n\t\t\tarraydataptr = att_addlength_datum(arraydataptr, typlen, elt);\n\t\t\tarraydataptr = (char *) att_align_nominal(arraydataptr, typalign);\n\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\t/* no match possible, keep element */\n\t\t\t\tvalues[nresult] = elt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Apply the operator to the element pair\n\t\t\t\t */\n\t\t\t\tlocfcinfo.arg[0] = elt;\n\t\t\t\tlocfcinfo.arg[1] = search;\n\t\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\t\tlocfcinfo.isnull = false;\n\t\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\t\tif (!oprresult)\n\t\t\t\t{\n\t\t\t\t\t/* no match, keep element */\n\t\t\t\t\tvalues[nresult] = elt;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* match, so replace or delete */\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tif (remove)\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\t\tisNull = replace_isnull;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t\tnulls[nresult] = isNull;\n\t\t\tif (isNull)\n\t\t\t\thasnulls = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Update total result size */\n\t\t\t\tnbytes = att_addlength_datum(nbytes, typlen, values[nresult]);\n\t\t\t\tnbytes = att_align_nominal(nbytes, typalign);\n\t\t\t\t/* check for overflow of total request */\n\t\t\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t\t}\n\t\t\tnresult++;\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If not changed just return the original array\n\t */\n\tif (!changed)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn array;\n\t}\n\n\t/* If all elements were removed return an empty array */\n\tif (nresult == 0)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn construct_empty_array(element_type);\n\t}\n\n\t/* Allocate and initialize the result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nresult);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndim;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = element_type;\n\tmemcpy(ARR_DIMS(result), ARR_DIMS(array), ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), ARR_LBOUND(array), ndim * sizeof(int));\n\n\tif (remove)\n\t{\n\t\t/* Adjust the result length */\n\t\tARR_DIMS(result)[0] = nresult;\n\t}\n\n\t/* Insert data into result array */\n\tCopyArrayEls(result,\n\t\t\t\t values, nulls, nresult,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t false);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 6313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 6308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 6307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 6306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 6304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 6303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_remove(PG_FUNCTION_ARGS)\n{\n\tArrayType  *array;\n\tDatum\t\tsearch = PG_GETARG_DATUM(1);\n\tbool\t\tsearch_isnull = PG_ARGISNULL(1);\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\n\tarray = array_replace_internal(array,\n\t\t\t\t\t\t\t\t   search, search_isnull,\n\t\t\t\t\t\t\t\t   (Datum) 0, true,\n\t\t\t\t\t\t\t\t   true, PG_GET_COLLATION(),\n\t\t\t\t\t\t\t\t   fcinfo);\n\tPG_RETURN_ARRAYTYPE_P(array);\n}"
  },
  {
    "function_name": "array_replace_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "6041-6292",
    "snippet": "static ArrayType *\narray_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tOid\t\t\telement_type;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems,\n\t\t\t\tnresult;\n\tint\t\t\ti;\n\tint32\t\tnbytes = 0;\n\tint32\t\tdataoffset;\n\tbool\t\thasnulls;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t   *arraydataptr;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tbool\t\tchanged = false;\n\tTypeCacheEntry *typentry;\n\tFunctionCallInfoData locfcinfo;\n\n\telement_type = ARR_ELEMTYPE(array);\n\tndim = ARR_NDIM(array);\n\tdim = ARR_DIMS(array);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/* Return input array unmodified if it is empty */\n\tif (nitems <= 0)\n\t\treturn array;\n\n\t/*\n\t * We can't remove elements from multi-dimensional arrays, since the\n\t * result might not be rectangular.\n\t */\n\tif (remove && ndim > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"removing elements from multidimensional arrays is not supported\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Detoast values if they are toasted.  The replacement value must be\n\t * detoasted for insertion into the result array, while detoasting the\n\t * search value only once saves cycles.\n\t */\n\tif (typlen == -1)\n\t{\n\t\tif (!search_isnull)\n\t\t\tsearch = PointerGetDatum(PG_DETOAST_DATUM(search));\n\t\tif (!replace_isnull)\n\t\t\treplace = PointerGetDatum(PG_DETOAST_DATUM(replace));\n\t}\n\n\t/* Prepare to apply the comparison operator */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Allocate temporary arrays for new values */\n\tvalues = (Datum *) palloc(nitems * sizeof(Datum));\n\tnulls = (bool *) palloc(nitems * sizeof(bool));\n\n\t/* Loop over source data */\n\tarraydataptr = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\thasnulls = false;\n\tnresult = 0;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\telt;\n\t\tbool\t\tisNull;\n\t\tbool\t\toprresult;\n\t\tbool\t\tskip = false;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\tisNull = true;\n\t\t\t/* If searching for NULL, we have a match */\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\tif (remove)\n\t\t\t\t{\n\t\t\t\t\tskip = true;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse if (!replace_isnull)\n\t\t\t\t{\n\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\tisNull = false;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisNull = false;\n\t\t\telt = fetch_att(arraydataptr, typbyval, typlen);\n\t\t\tarraydataptr = att_addlength_datum(arraydataptr, typlen, elt);\n\t\t\tarraydataptr = (char *) att_align_nominal(arraydataptr, typalign);\n\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\t/* no match possible, keep element */\n\t\t\t\tvalues[nresult] = elt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Apply the operator to the element pair\n\t\t\t\t */\n\t\t\t\tlocfcinfo.arg[0] = elt;\n\t\t\t\tlocfcinfo.arg[1] = search;\n\t\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\t\tlocfcinfo.isnull = false;\n\t\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\t\tif (!oprresult)\n\t\t\t\t{\n\t\t\t\t\t/* no match, keep element */\n\t\t\t\t\tvalues[nresult] = elt;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* match, so replace or delete */\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tif (remove)\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\t\tisNull = replace_isnull;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t\tnulls[nresult] = isNull;\n\t\t\tif (isNull)\n\t\t\t\thasnulls = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Update total result size */\n\t\t\t\tnbytes = att_addlength_datum(nbytes, typlen, values[nresult]);\n\t\t\t\tnbytes = att_align_nominal(nbytes, typalign);\n\t\t\t\t/* check for overflow of total request */\n\t\t\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t\t}\n\t\t\tnresult++;\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If not changed just return the original array\n\t */\n\tif (!changed)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn array;\n\t}\n\n\t/* If all elements were removed return an empty array */\n\tif (nresult == 0)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn construct_empty_array(element_type);\n\t}\n\n\t/* Allocate and initialize the result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nresult);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndim;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = element_type;\n\tmemcpy(ARR_DIMS(result), ARR_DIMS(array), ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), ARR_LBOUND(array), ndim * sizeof(int));\n\n\tif (remove)\n\t{\n\t\t/* Adjust the result length */\n\t\tARR_DIMS(result)[0] = nresult;\n\t}\n\n\t/* Insert data into result array */\n\tCopyArrayEls(result,\n\t\t\t\t values, nulls, nresult,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t false);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
      "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
      "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
      "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
      "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls"
          ],
          "line": 6289
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CopyArrayEls",
          "args": [
            "result",
            "values",
            "nulls",
            "nresult",
            "typlen",
            "typbyval",
            "typalign",
            "false"
          ],
          "line": 6283
        },
        "resolved": true,
        "details": {
          "function_name": "CopyArrayEls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "956-1004",
          "snippet": "void\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nvoid\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "result"
          ],
          "line": 6279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(result)",
            "ARR_LBOUND(array)",
            "ndim * sizeof(int)"
          ],
          "line": 6274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "array"
          ],
          "line": 6274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "result"
          ],
          "line": 6274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(result)",
            "ARR_DIMS(array)",
            "ndim * sizeof(int)"
          ],
          "line": 6273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 6273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "result"
          ],
          "line": 6273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "nbytes"
          ],
          "line": 6269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nbytes"
          ],
          "line": 6268
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndim"
          ],
          "line": 6266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndim",
            "nresult"
          ],
          "line": 6260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "element_type"
          ],
          "line": 6254
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t(int) MaxAllocSize))"
          ],
          "line": 6219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"array size exceeds the maximum allowed (%d)\"",
            "(int) MaxAllocSize"
          ],
          "line": 6221
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 6220
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSizeIsValid",
          "args": [
            "nbytes"
          ],
          "line": 6218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "nbytes",
            "typalign"
          ],
          "line": 6216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "nbytes",
            "typlen",
            "values[nresult]"
          ],
          "line": 6215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCallInvoke(&locfcinfo)"
          ],
          "line": 6186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&locfcinfo"
          ],
          "line": 6186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "arraydataptr",
            "typalign"
          ],
          "line": 6169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "arraydataptr",
            "typlen",
            "elt"
          ],
          "line": 6168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_att",
          "args": [
            "arraydataptr",
            "typbyval",
            "typlen"
          ],
          "line": 6167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "array"
          ],
          "line": 6132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "array"
          ],
          "line": 6131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nitems * sizeof(bool)"
          ],
          "line": 6128
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "&typentry->eq_opr_finfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 6123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM(replace)"
          ],
          "line": 6119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "replace"
          ],
          "line": 6119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM(search)"
          ],
          "line": 6117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "search"
          ],
          "line": 6117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 6099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 6102
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->eq_opr_finfo.fn_oid"
          ],
          "line": 6098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "element_type",
            "TYPECACHE_EQ_OPR_FINFO"
          ],
          "line": 6096
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"removing elements from multidimensional arrays is not supported\"))"
          ],
          "line": 6084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "dim"
          ],
          "line": 6073
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 6072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "array"
          ],
          "line": 6071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 6070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic ArrayType *\narray_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tOid\t\t\telement_type;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems,\n\t\t\t\tnresult;\n\tint\t\t\ti;\n\tint32\t\tnbytes = 0;\n\tint32\t\tdataoffset;\n\tbool\t\thasnulls;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t   *arraydataptr;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tbool\t\tchanged = false;\n\tTypeCacheEntry *typentry;\n\tFunctionCallInfoData locfcinfo;\n\n\telement_type = ARR_ELEMTYPE(array);\n\tndim = ARR_NDIM(array);\n\tdim = ARR_DIMS(array);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/* Return input array unmodified if it is empty */\n\tif (nitems <= 0)\n\t\treturn array;\n\n\t/*\n\t * We can't remove elements from multi-dimensional arrays, since the\n\t * result might not be rectangular.\n\t */\n\tif (remove && ndim > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"removing elements from multidimensional arrays is not supported\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Detoast values if they are toasted.  The replacement value must be\n\t * detoasted for insertion into the result array, while detoasting the\n\t * search value only once saves cycles.\n\t */\n\tif (typlen == -1)\n\t{\n\t\tif (!search_isnull)\n\t\t\tsearch = PointerGetDatum(PG_DETOAST_DATUM(search));\n\t\tif (!replace_isnull)\n\t\t\treplace = PointerGetDatum(PG_DETOAST_DATUM(replace));\n\t}\n\n\t/* Prepare to apply the comparison operator */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Allocate temporary arrays for new values */\n\tvalues = (Datum *) palloc(nitems * sizeof(Datum));\n\tnulls = (bool *) palloc(nitems * sizeof(bool));\n\n\t/* Loop over source data */\n\tarraydataptr = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\thasnulls = false;\n\tnresult = 0;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\telt;\n\t\tbool\t\tisNull;\n\t\tbool\t\toprresult;\n\t\tbool\t\tskip = false;\n\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\tisNull = true;\n\t\t\t/* If searching for NULL, we have a match */\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\tif (remove)\n\t\t\t\t{\n\t\t\t\t\tskip = true;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t\telse if (!replace_isnull)\n\t\t\t\t{\n\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\tisNull = false;\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tisNull = false;\n\t\t\telt = fetch_att(arraydataptr, typbyval, typlen);\n\t\t\tarraydataptr = att_addlength_datum(arraydataptr, typlen, elt);\n\t\t\tarraydataptr = (char *) att_align_nominal(arraydataptr, typalign);\n\n\t\t\tif (search_isnull)\n\t\t\t{\n\t\t\t\t/* no match possible, keep element */\n\t\t\t\tvalues[nresult] = elt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Apply the operator to the element pair\n\t\t\t\t */\n\t\t\t\tlocfcinfo.arg[0] = elt;\n\t\t\t\tlocfcinfo.arg[1] = search;\n\t\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\t\tlocfcinfo.isnull = false;\n\t\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\t\tif (!oprresult)\n\t\t\t\t{\n\t\t\t\t\t/* no match, keep element */\n\t\t\t\t\tvalues[nresult] = elt;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* match, so replace or delete */\n\t\t\t\t\tchanged = true;\n\t\t\t\t\tif (remove)\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalues[nresult] = replace;\n\t\t\t\t\t\tisNull = replace_isnull;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!skip)\n\t\t{\n\t\t\tnulls[nresult] = isNull;\n\t\t\tif (isNull)\n\t\t\t\thasnulls = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Update total result size */\n\t\t\t\tnbytes = att_addlength_datum(nbytes, typlen, values[nresult]);\n\t\t\t\tnbytes = att_align_nominal(nbytes, typalign);\n\t\t\t\t/* check for overflow of total request */\n\t\t\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t\t}\n\t\t\tnresult++;\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If not changed just return the original array\n\t */\n\tif (!changed)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn array;\n\t}\n\n\t/* If all elements were removed return an empty array */\n\tif (nresult == 0)\n\t{\n\t\tpfree(values);\n\t\tpfree(nulls);\n\t\treturn construct_empty_array(element_type);\n\t}\n\n\t/* Allocate and initialize the result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nresult);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndim;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = element_type;\n\tmemcpy(ARR_DIMS(result), ARR_DIMS(array), ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), ARR_LBOUND(array), ndim * sizeof(int));\n\n\tif (remove)\n\t{\n\t\t/* Adjust the result length */\n\t\tARR_DIMS(result)[0] = nresult;\n\t}\n\n\t/* Insert data into result array */\n\tCopyArrayEls(result,\n\t\t\t\t values, nulls, nresult,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t false);\n\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn result;\n}"
  },
  {
    "function_name": "array_unnest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5947-6030",
    "snippet": "Datum\narray_unnest(PG_FUNCTION_ARGS)\n{\n\ttypedef struct\n\t{\n\t\tarray_iter\titer;\n\t\tint\t\t\tnextelem;\n\t\tint\t\t\tnumelems;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t} array_unnest_fctx;\n\n\tFuncCallContext *funcctx;\n\tarray_unnest_fctx *fctx;\n\tMemoryContext oldcontext;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tAnyArrayType *arr;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/*\n\t\t * Get the array value and detoast if needed.  We can't do this\n\t\t * earlier because if we have to detoast, we want the detoasted copy\n\t\t * to be in multi_call_memory_ctx, so it will go away when we're done\n\t\t * and not before.  (If no detoast happens, we assume the originally\n\t\t * passed array will stick around till then.)\n\t\t */\n\t\tarr = PG_GETARG_ANY_ARRAY_P(0);\n\n\t\t/* allocate memory for user context */\n\t\tfctx = (array_unnest_fctx *) palloc(sizeof(array_unnest_fctx));\n\n\t\t/* initialize state */\n\t\tarray_iter_setup(&fctx->iter, arr);\n\t\tfctx->nextelem = 0;\n\t\tfctx->numelems = ArrayGetNItems(AARR_NDIM(arr), AARR_DIMS(arr));\n\n\t\tif (VARATT_IS_EXPANDED_HEADER(arr))\n\t\t{\n\t\t\t/* we can just grab the type data from expanded array */\n\t\t\tfctx->elmlen = arr->xpn.typlen;\n\t\t\tfctx->elmbyval = arr->xpn.typbyval;\n\t\t\tfctx->elmalign = arr->xpn.typalign;\n\t\t}\n\t\telse\n\t\t\tget_typlenbyvalalign(AARR_ELEMTYPE(arr),\n\t\t\t\t\t\t\t\t &fctx->elmlen,\n\t\t\t\t\t\t\t\t &fctx->elmbyval,\n\t\t\t\t\t\t\t\t &fctx->elmalign);\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = funcctx->user_fctx;\n\n\tif (fctx->nextelem < fctx->numelems)\n\t{\n\t\tint\t\t\toffset = fctx->nextelem++;\n\t\tDatum\t\telem;\n\n\t\telem = array_iter_next(&fctx->iter, &fcinfo->isnull, offset,\n\t\t\t\t\t\t\t   fctx->elmlen, fctx->elmbyval, fctx->elmalign);\n\n\t\tSRF_RETURN_NEXT(funcctx, elem);\n\t}\n\telse\n\t{\n\t\t/* do when there is no more left */\n\t\tSRF_RETURN_DONE(funcctx);\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 6028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "elem"
          ],
          "line": 6023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&fctx->iter",
            "&fcinfo->isnull",
            "offset",
            "fctx->elmlen",
            "fctx->elmbyval",
            "fctx->elmalign"
          ],
          "line": 6020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 6012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 6008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "AARR_ELEMTYPE(arr)",
            "&fctx->elmlen",
            "&fctx->elmbyval",
            "&fctx->elmalign"
          ],
          "line": 6002
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 6002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXPANDED_HEADER",
          "args": [
            "arr"
          ],
          "line": 5994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "AARR_NDIM(arr)",
            "AARR_DIMS(arr)"
          ],
          "line": 5992
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 5992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 5992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&fctx->iter",
            "arr"
          ],
          "line": 5990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(array_unnest_fctx)"
          ],
          "line": 5987
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 5984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 5975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 5970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 5965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_unnest(PG_FUNCTION_ARGS)\n{\n\ttypedef struct\n\t{\n\t\tarray_iter\titer;\n\t\tint\t\t\tnextelem;\n\t\tint\t\t\tnumelems;\n\t\tint16\t\telmlen;\n\t\tbool\t\telmbyval;\n\t\tchar\t\telmalign;\n\t} array_unnest_fctx;\n\n\tFuncCallContext *funcctx;\n\tarray_unnest_fctx *fctx;\n\tMemoryContext oldcontext;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tAnyArrayType *arr;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/*\n\t\t * Get the array value and detoast if needed.  We can't do this\n\t\t * earlier because if we have to detoast, we want the detoasted copy\n\t\t * to be in multi_call_memory_ctx, so it will go away when we're done\n\t\t * and not before.  (If no detoast happens, we assume the originally\n\t\t * passed array will stick around till then.)\n\t\t */\n\t\tarr = PG_GETARG_ANY_ARRAY_P(0);\n\n\t\t/* allocate memory for user context */\n\t\tfctx = (array_unnest_fctx *) palloc(sizeof(array_unnest_fctx));\n\n\t\t/* initialize state */\n\t\tarray_iter_setup(&fctx->iter, arr);\n\t\tfctx->nextelem = 0;\n\t\tfctx->numelems = ArrayGetNItems(AARR_NDIM(arr), AARR_DIMS(arr));\n\n\t\tif (VARATT_IS_EXPANDED_HEADER(arr))\n\t\t{\n\t\t\t/* we can just grab the type data from expanded array */\n\t\t\tfctx->elmlen = arr->xpn.typlen;\n\t\t\tfctx->elmbyval = arr->xpn.typbyval;\n\t\t\tfctx->elmalign = arr->xpn.typalign;\n\t\t}\n\t\telse\n\t\t\tget_typlenbyvalalign(AARR_ELEMTYPE(arr),\n\t\t\t\t\t\t\t\t &fctx->elmlen,\n\t\t\t\t\t\t\t\t &fctx->elmbyval,\n\t\t\t\t\t\t\t\t &fctx->elmalign);\n\n\t\tfuncctx->user_fctx = fctx;\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\tfctx = funcctx->user_fctx;\n\n\tif (fctx->nextelem < fctx->numelems)\n\t{\n\t\tint\t\t\toffset = fctx->nextelem++;\n\t\tDatum\t\telem;\n\n\t\telem = array_iter_next(&fctx->iter, &fcinfo->isnull, offset,\n\t\t\t\t\t\t\t   fctx->elmlen, fctx->elmbyval, fctx->elmalign);\n\n\t\tSRF_RETURN_NEXT(funcctx, elem);\n\t}\n\telse\n\t{\n\t\t/* do when there is no more left */\n\t\tSRF_RETURN_DONE(funcctx);\n\t}\n}"
  },
  {
    "function_name": "array_fill_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5780-5941",
    "snippet": "static ArrayType *\narray_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tint\t\t   *dimv;\n\tint\t\t   *lbsv;\n\tint\t\t\tndims;\n\tint\t\t\tnitems;\n\tint\t\t\tdeflbs[MAXDIM];\n\tint16\t\telmlen;\n\tbool\t\telmbyval;\n\tchar\t\telmalign;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * Params checks\n\t */\n\tif (ARR_NDIM(dims) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\tif (array_contains_nulls(dims))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\tdimv = (int *) ARR_DATA_PTR(dims);\n\tndims = (ARR_NDIM(dims) > 0) ? ARR_DIMS(dims)[0] : 0;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tif (lbs != NULL)\n\t{\n\t\tif (ARR_NDIM(lbs) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\t\tif (array_contains_nulls(lbs))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\t\tif (ndims != ((ARR_NDIM(lbs) > 0) ? ARR_DIMS(lbs)[0] : 0))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Low bound array has different size than dimensions array.\")));\n\n\t\tlbsv = (int *) ARR_DATA_PTR(lbs);\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < MAXDIM; i++)\n\t\t\tdeflbs[i] = 1;\n\n\t\tlbsv = deflbs;\n\t}\n\n\tnitems = ArrayGetNItems(ndims, dimv);\n\n\t/* fast track for empty array */\n\tif (nitems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/*\n\t * We arrange to look up info about element type only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = InvalidOid;\n\t}\n\n\tif (my_extra->element_type != elmtype)\n\t{\n\t\t/* Get info about element type */\n\t\tget_typlenbyvalalign(elmtype,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\t\tmy_extra->element_type = elmtype;\n\t}\n\n\telmlen = my_extra->typlen;\n\telmbyval = my_extra->typbyval;\n\telmalign = my_extra->typalign;\n\n\t/* compute required space */\n\tif (!isnull)\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t   *p;\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\ttotbytes;\n\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\tvalue = PointerGetDatum(PG_DETOAST_DATUM(value));\n\n\t\tnbytes = att_addlength_datum(0, elmlen, value);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\tAssert(nbytes > 0);\n\n\t\ttotbytes = nbytes * nitems;\n\n\t\t/* check for overflow of multiplication or total request */\n\t\tif (totbytes / nbytes != nitems ||\n\t\t\t!AllocSizeIsValid(totbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\n\t\t/*\n\t\t * This addition can't overflow, but it might cause us to go past\n\t\t * MaxAllocSize.  We leave it to palloc to complain in that case.\n\t\t */\n\t\ttotbytes += ARR_OVERHEAD_NONULLS(ndims);\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, totbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, 0);\n\n\t\tp = ARR_DATA_PTR(result);\n\t\tfor (i = 0; i < nitems; i++)\n\t\t\tp += ArrayCastAndSet(value, elmlen, elmbyval, elmalign, p);\n\t}\n\telse\n\t{\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\tdataoffset;\n\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nitems);\n\t\tnbytes = dataoffset;\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, nbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, dataoffset);\n\n\t\t/* create_array_envelope already zeroed the bitmap, so we're done */\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_array_envelope",
          "args": [
            "ndims",
            "dimv",
            "lbsv",
            "nbytes",
            "elmtype",
            "dataoffset"
          ],
          "line": 5934
        },
        "resolved": true,
        "details": {
          "function_name": "create_array_envelope",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5763-5778",
          "snippet": "static ArrayType *\ncreate_array_envelope(int ndims, int *dimv, int *lbsv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dimv, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbsv, ndims * sizeof(int));\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nstatic ArrayType *\ncreate_array_envelope(int ndims, int *dimv, int *lbsv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dimv, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbsv, ndims * sizeof(int));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndims",
            "nitems"
          ],
          "line": 5931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayCastAndSet",
          "args": [
            "value",
            "elmlen",
            "elmbyval",
            "elmalign",
            "p"
          ],
          "line": 5924
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayCastAndSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4548-4574",
          "snippet": "static int\nArrayCastAndSet(Datum src,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tchar *dest)\n{\n\tint\t\t\tinc;\n\n\tif (typlen > 0)\n\t{\n\t\tif (typbyval)\n\t\t\tstore_att_byval(dest, src, typlen);\n\t\telse\n\t\t\tmemmove(dest, DatumGetPointer(src), typlen);\n\t\tinc = att_align_nominal(typlen, typalign);\n\t}\n\telse\n\t{\n\t\tAssert(!typbyval);\n\t\tinc = att_addlength_datum(0, typlen, src);\n\t\tmemmove(dest, DatumGetPointer(src), inc);\n\t\tinc = att_align_nominal(inc, typalign);\n\t}\n\n\treturn inc;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ArrayCastAndSet(Datum src,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tchar *dest);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int ArrayCastAndSet(Datum src,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tchar *dest);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\nArrayCastAndSet(Datum src,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tchar *dest)\n{\n\tint\t\t\tinc;\n\n\tif (typlen > 0)\n\t{\n\t\tif (typbyval)\n\t\t\tstore_att_byval(dest, src, typlen);\n\t\telse\n\t\t\tmemmove(dest, DatumGetPointer(src), typlen);\n\t\tinc = att_align_nominal(typlen, typalign);\n\t}\n\telse\n\t{\n\t\tAssert(!typbyval);\n\t\tinc = att_addlength_datum(0, typlen, src);\n\t\tmemmove(dest, DatumGetPointer(src), inc);\n\t\tinc = att_align_nominal(inc, typalign);\n\t}\n\n\treturn inc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "result"
          ],
          "line": 5922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndims"
          ],
          "line": 5917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize))"
          ],
          "line": 5908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"array size exceeds the maximum allowed (%d)\"",
            "(int) MaxAllocSize"
          ],
          "line": 5910
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 5909
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSizeIsValid",
          "args": [
            "totbytes"
          ],
          "line": 5907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nbytes > 0"
          ],
          "line": 5901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "nbytes",
            "elmalign"
          ],
          "line": 5900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "0",
            "elmlen",
            "value"
          ],
          "line": 5899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM(value)"
          ],
          "line": 5897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "value"
          ],
          "line": 5897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "elmtype",
            "&my_extra->typlen",
            "&my_extra->typbyval",
            "&my_extra->typalign"
          ],
          "line": 5876
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(ArrayMetaState)"
          ],
          "line": 5867
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "elmtype"
          ],
          "line": 5858
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims",
            "dimv"
          ],
          "line": 5854
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "lbs"
          ],
          "line": 5842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Low bound array has different size than dimensions array.\"))"
          ],
          "line": 5837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Low bound array has different size than dimensions array.\""
          ],
          "line": 5840
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "lbs"
          ],
          "line": 5836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "lbs"
          ],
          "line": 5836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"dimension values cannot be null\"))"
          ],
          "line": 5832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contains_nulls",
          "args": [
            "lbs"
          ],
          "line": 5831
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3527-3562",
          "snippet": "bool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Dimension array must be one dimensional.\"))"
          ],
          "line": 5826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "lbs"
          ],
          "line": 5825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM))"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims))"
          ],
          "line": 5814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "dims"
          ],
          "line": 5811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "dims"
          ],
          "line": 5811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "dims"
          ],
          "line": 5810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension values cannot be null\"))"
          ],
          "line": 5806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t errdetail(\"Dimension array must be one dimensional.\"))"
          ],
          "line": 5800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "dims"
          ],
          "line": 5799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nstatic ArrayType *\narray_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tint\t\t   *dimv;\n\tint\t\t   *lbsv;\n\tint\t\t\tndims;\n\tint\t\t\tnitems;\n\tint\t\t\tdeflbs[MAXDIM];\n\tint16\t\telmlen;\n\tbool\t\telmbyval;\n\tchar\t\telmalign;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * Params checks\n\t */\n\tif (ARR_NDIM(dims) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\tif (array_contains_nulls(dims))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\tdimv = (int *) ARR_DATA_PTR(dims);\n\tndims = (ARR_NDIM(dims) > 0) ? ARR_DIMS(dims)[0] : 0;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tif (lbs != NULL)\n\t{\n\t\tif (ARR_NDIM(lbs) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\t\tif (array_contains_nulls(lbs))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\t\tif (ndims != ((ARR_NDIM(lbs) > 0) ? ARR_DIMS(lbs)[0] : 0))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Low bound array has different size than dimensions array.\")));\n\n\t\tlbsv = (int *) ARR_DATA_PTR(lbs);\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < MAXDIM; i++)\n\t\t\tdeflbs[i] = 1;\n\n\t\tlbsv = deflbs;\n\t}\n\n\tnitems = ArrayGetNItems(ndims, dimv);\n\n\t/* fast track for empty array */\n\tif (nitems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/*\n\t * We arrange to look up info about element type only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = InvalidOid;\n\t}\n\n\tif (my_extra->element_type != elmtype)\n\t{\n\t\t/* Get info about element type */\n\t\tget_typlenbyvalalign(elmtype,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\t\tmy_extra->element_type = elmtype;\n\t}\n\n\telmlen = my_extra->typlen;\n\telmbyval = my_extra->typbyval;\n\telmalign = my_extra->typalign;\n\n\t/* compute required space */\n\tif (!isnull)\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t   *p;\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\ttotbytes;\n\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\tvalue = PointerGetDatum(PG_DETOAST_DATUM(value));\n\n\t\tnbytes = att_addlength_datum(0, elmlen, value);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\tAssert(nbytes > 0);\n\n\t\ttotbytes = nbytes * nitems;\n\n\t\t/* check for overflow of multiplication or total request */\n\t\tif (totbytes / nbytes != nitems ||\n\t\t\t!AllocSizeIsValid(totbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\n\t\t/*\n\t\t * This addition can't overflow, but it might cause us to go past\n\t\t * MaxAllocSize.  We leave it to palloc to complain in that case.\n\t\t */\n\t\ttotbytes += ARR_OVERHEAD_NONULLS(ndims);\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, totbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, 0);\n\n\t\tp = ARR_DATA_PTR(result);\n\t\tfor (i = 0; i < nitems; i++)\n\t\t\tp += ArrayCastAndSet(value, elmlen, elmbyval, elmalign, p);\n\t}\n\telse\n\t{\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\tdataoffset;\n\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nitems);\n\t\tnbytes = dataoffset;\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, nbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, dataoffset);\n\n\t\t/* create_array_envelope already zeroed the bitmap, so we're done */\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "create_array_envelope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5763-5778",
    "snippet": "static ArrayType *\ncreate_array_envelope(int ndims, int *dimv, int *lbsv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dimv, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbsv, ndims * sizeof(int));\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(result)",
            "lbsv",
            "ndims * sizeof(int)"
          ],
          "line": 5775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "result"
          ],
          "line": 5775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(result)",
            "dimv",
            "ndims * sizeof(int)"
          ],
          "line": 5774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "result"
          ],
          "line": 5774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "nbytes"
          ],
          "line": 5770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nbytes"
          ],
          "line": 5769
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nstatic ArrayType *\ncreate_array_envelope(int ndims, int *dimv, int *lbsv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dimv, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbsv, ndims * sizeof(int));\n\n\treturn result;\n}"
  },
  {
    "function_name": "array_fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5728-5761",
    "snippet": "Datum\narray_fill(PG_FUNCTION_ARGS)\n{\n\tArrayType  *dims;\n\tArrayType  *result;\n\tOid\t\t\telmtype;\n\tDatum\t\tvalue;\n\tbool\t\tisnull;\n\n\tif (PG_ARGISNULL(1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension array or low bound array cannot be null\")));\n\n\tdims = PG_GETARG_ARRAYTYPE_P(1);\n\n\tif (!PG_ARGISNULL(0))\n\t{\n\t\tvalue = PG_GETARG_DATUM(0);\n\t\tisnull = false;\n\t}\n\telse\n\t{\n\t\tvalue = 0;\n\t\tisnull = true;\n\t}\n\n\telmtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (!OidIsValid(elmtype))\n\t\telog(ERROR, \"could not determine data type of input\");\n\n\tresult = array_fill_internal(dims, NULL, value, isnull, elmtype, fcinfo);\n\tPG_RETURN_ARRAYTYPE_P(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 5760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_fill_internal",
          "args": [
            "dims",
            "NULL",
            "value",
            "isnull",
            "elmtype",
            "fcinfo"
          ],
          "line": 5759
        },
        "resolved": true,
        "details": {
          "function_name": "array_fill_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5780-5941",
          "snippet": "static ArrayType *\narray_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tint\t\t   *dimv;\n\tint\t\t   *lbsv;\n\tint\t\t\tndims;\n\tint\t\t\tnitems;\n\tint\t\t\tdeflbs[MAXDIM];\n\tint16\t\telmlen;\n\tbool\t\telmbyval;\n\tchar\t\telmalign;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * Params checks\n\t */\n\tif (ARR_NDIM(dims) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\tif (array_contains_nulls(dims))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\tdimv = (int *) ARR_DATA_PTR(dims);\n\tndims = (ARR_NDIM(dims) > 0) ? ARR_DIMS(dims)[0] : 0;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tif (lbs != NULL)\n\t{\n\t\tif (ARR_NDIM(lbs) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\t\tif (array_contains_nulls(lbs))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\t\tif (ndims != ((ARR_NDIM(lbs) > 0) ? ARR_DIMS(lbs)[0] : 0))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Low bound array has different size than dimensions array.\")));\n\n\t\tlbsv = (int *) ARR_DATA_PTR(lbs);\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < MAXDIM; i++)\n\t\t\tdeflbs[i] = 1;\n\n\t\tlbsv = deflbs;\n\t}\n\n\tnitems = ArrayGetNItems(ndims, dimv);\n\n\t/* fast track for empty array */\n\tif (nitems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/*\n\t * We arrange to look up info about element type only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = InvalidOid;\n\t}\n\n\tif (my_extra->element_type != elmtype)\n\t{\n\t\t/* Get info about element type */\n\t\tget_typlenbyvalalign(elmtype,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\t\tmy_extra->element_type = elmtype;\n\t}\n\n\telmlen = my_extra->typlen;\n\telmbyval = my_extra->typbyval;\n\telmalign = my_extra->typalign;\n\n\t/* compute required space */\n\tif (!isnull)\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t   *p;\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\ttotbytes;\n\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\tvalue = PointerGetDatum(PG_DETOAST_DATUM(value));\n\n\t\tnbytes = att_addlength_datum(0, elmlen, value);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\tAssert(nbytes > 0);\n\n\t\ttotbytes = nbytes * nitems;\n\n\t\t/* check for overflow of multiplication or total request */\n\t\tif (totbytes / nbytes != nitems ||\n\t\t\t!AllocSizeIsValid(totbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\n\t\t/*\n\t\t * This addition can't overflow, but it might cause us to go past\n\t\t * MaxAllocSize.  We leave it to palloc to complain in that case.\n\t\t */\n\t\ttotbytes += ARR_OVERHEAD_NONULLS(ndims);\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, totbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, 0);\n\n\t\tp = ARR_DATA_PTR(result);\n\t\tfor (i = 0; i < nitems; i++)\n\t\t\tp += ArrayCastAndSet(value, elmlen, elmbyval, elmalign, p);\n\t}\n\telse\n\t{\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\tdataoffset;\n\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nitems);\n\t\tnbytes = dataoffset;\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, nbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, dataoffset);\n\n\t\t/* create_array_envelope already zeroed the bitmap, so we're done */\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nstatic ArrayType *\narray_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tint\t\t   *dimv;\n\tint\t\t   *lbsv;\n\tint\t\t\tndims;\n\tint\t\t\tnitems;\n\tint\t\t\tdeflbs[MAXDIM];\n\tint16\t\telmlen;\n\tbool\t\telmbyval;\n\tchar\t\telmalign;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * Params checks\n\t */\n\tif (ARR_NDIM(dims) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\tif (array_contains_nulls(dims))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\tdimv = (int *) ARR_DATA_PTR(dims);\n\tndims = (ARR_NDIM(dims) > 0) ? ARR_DIMS(dims)[0] : 0;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tif (lbs != NULL)\n\t{\n\t\tif (ARR_NDIM(lbs) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\t\tif (array_contains_nulls(lbs))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\t\tif (ndims != ((ARR_NDIM(lbs) > 0) ? ARR_DIMS(lbs)[0] : 0))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Low bound array has different size than dimensions array.\")));\n\n\t\tlbsv = (int *) ARR_DATA_PTR(lbs);\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < MAXDIM; i++)\n\t\t\tdeflbs[i] = 1;\n\n\t\tlbsv = deflbs;\n\t}\n\n\tnitems = ArrayGetNItems(ndims, dimv);\n\n\t/* fast track for empty array */\n\tif (nitems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/*\n\t * We arrange to look up info about element type only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = InvalidOid;\n\t}\n\n\tif (my_extra->element_type != elmtype)\n\t{\n\t\t/* Get info about element type */\n\t\tget_typlenbyvalalign(elmtype,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\t\tmy_extra->element_type = elmtype;\n\t}\n\n\telmlen = my_extra->typlen;\n\telmbyval = my_extra->typbyval;\n\telmalign = my_extra->typalign;\n\n\t/* compute required space */\n\tif (!isnull)\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t   *p;\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\ttotbytes;\n\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\tvalue = PointerGetDatum(PG_DETOAST_DATUM(value));\n\n\t\tnbytes = att_addlength_datum(0, elmlen, value);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\tAssert(nbytes > 0);\n\n\t\ttotbytes = nbytes * nitems;\n\n\t\t/* check for overflow of multiplication or total request */\n\t\tif (totbytes / nbytes != nitems ||\n\t\t\t!AllocSizeIsValid(totbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\n\t\t/*\n\t\t * This addition can't overflow, but it might cause us to go past\n\t\t * MaxAllocSize.  We leave it to palloc to complain in that case.\n\t\t */\n\t\ttotbytes += ARR_OVERHEAD_NONULLS(ndims);\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, totbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, 0);\n\n\t\tp = ARR_DATA_PTR(result);\n\t\tfor (i = 0; i < nitems; i++)\n\t\t\tp += ArrayCastAndSet(value, elmlen, elmbyval, elmalign, p);\n\t}\n\telse\n\t{\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\tdataoffset;\n\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nitems);\n\t\tnbytes = dataoffset;\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, nbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, dataoffset);\n\n\t\t/* create_array_envelope already zeroed the bitmap, so we're done */\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not determine data type of input\""
          ],
          "line": 5757
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "elmtype"
          ],
          "line": 5756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 5755
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 5746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 5744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 5742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension array or low bound array cannot be null\"))"
          ],
          "line": 5738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"dimension array or low bound array cannot be null\""
          ],
          "line": 5740
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 5739
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 5737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_fill(PG_FUNCTION_ARGS)\n{\n\tArrayType  *dims;\n\tArrayType  *result;\n\tOid\t\t\telmtype;\n\tDatum\t\tvalue;\n\tbool\t\tisnull;\n\n\tif (PG_ARGISNULL(1))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension array or low bound array cannot be null\")));\n\n\tdims = PG_GETARG_ARRAYTYPE_P(1);\n\n\tif (!PG_ARGISNULL(0))\n\t{\n\t\tvalue = PG_GETARG_DATUM(0);\n\t\tisnull = false;\n\t}\n\telse\n\t{\n\t\tvalue = 0;\n\t\tisnull = true;\n\t}\n\n\telmtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (!OidIsValid(elmtype))\n\t\telog(ERROR, \"could not determine data type of input\");\n\n\tresult = array_fill_internal(dims, NULL, value, isnull, elmtype, fcinfo);\n\tPG_RETURN_ARRAYTYPE_P(result);\n}"
  },
  {
    "function_name": "array_fill_with_lower_bounds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5687-5722",
    "snippet": "Datum\narray_fill_with_lower_bounds(PG_FUNCTION_ARGS)\n{\n\tArrayType  *dims;\n\tArrayType  *lbs;\n\tArrayType  *result;\n\tOid\t\t\telmtype;\n\tDatum\t\tvalue;\n\tbool\t\tisnull;\n\n\tif (PG_ARGISNULL(1) || PG_ARGISNULL(2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension array or low bound array cannot be null\")));\n\n\tdims = PG_GETARG_ARRAYTYPE_P(1);\n\tlbs = PG_GETARG_ARRAYTYPE_P(2);\n\n\tif (!PG_ARGISNULL(0))\n\t{\n\t\tvalue = PG_GETARG_DATUM(0);\n\t\tisnull = false;\n\t}\n\telse\n\t{\n\t\tvalue = 0;\n\t\tisnull = true;\n\t}\n\n\telmtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (!OidIsValid(elmtype))\n\t\telog(ERROR, \"could not determine data type of input\");\n\n\tresult = array_fill_internal(dims, lbs, value, isnull, elmtype, fcinfo);\n\tPG_RETURN_ARRAYTYPE_P(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 5721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_fill_internal",
          "args": [
            "dims",
            "lbs",
            "value",
            "isnull",
            "elmtype",
            "fcinfo"
          ],
          "line": 5720
        },
        "resolved": true,
        "details": {
          "function_name": "array_fill_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5780-5941",
          "snippet": "static ArrayType *\narray_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tint\t\t   *dimv;\n\tint\t\t   *lbsv;\n\tint\t\t\tndims;\n\tint\t\t\tnitems;\n\tint\t\t\tdeflbs[MAXDIM];\n\tint16\t\telmlen;\n\tbool\t\telmbyval;\n\tchar\t\telmalign;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * Params checks\n\t */\n\tif (ARR_NDIM(dims) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\tif (array_contains_nulls(dims))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\tdimv = (int *) ARR_DATA_PTR(dims);\n\tndims = (ARR_NDIM(dims) > 0) ? ARR_DIMS(dims)[0] : 0;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tif (lbs != NULL)\n\t{\n\t\tif (ARR_NDIM(lbs) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\t\tif (array_contains_nulls(lbs))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\t\tif (ndims != ((ARR_NDIM(lbs) > 0) ? ARR_DIMS(lbs)[0] : 0))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Low bound array has different size than dimensions array.\")));\n\n\t\tlbsv = (int *) ARR_DATA_PTR(lbs);\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < MAXDIM; i++)\n\t\t\tdeflbs[i] = 1;\n\n\t\tlbsv = deflbs;\n\t}\n\n\tnitems = ArrayGetNItems(ndims, dimv);\n\n\t/* fast track for empty array */\n\tif (nitems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/*\n\t * We arrange to look up info about element type only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = InvalidOid;\n\t}\n\n\tif (my_extra->element_type != elmtype)\n\t{\n\t\t/* Get info about element type */\n\t\tget_typlenbyvalalign(elmtype,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\t\tmy_extra->element_type = elmtype;\n\t}\n\n\telmlen = my_extra->typlen;\n\telmbyval = my_extra->typbyval;\n\telmalign = my_extra->typalign;\n\n\t/* compute required space */\n\tif (!isnull)\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t   *p;\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\ttotbytes;\n\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\tvalue = PointerGetDatum(PG_DETOAST_DATUM(value));\n\n\t\tnbytes = att_addlength_datum(0, elmlen, value);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\tAssert(nbytes > 0);\n\n\t\ttotbytes = nbytes * nitems;\n\n\t\t/* check for overflow of multiplication or total request */\n\t\tif (totbytes / nbytes != nitems ||\n\t\t\t!AllocSizeIsValid(totbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\n\t\t/*\n\t\t * This addition can't overflow, but it might cause us to go past\n\t\t * MaxAllocSize.  We leave it to palloc to complain in that case.\n\t\t */\n\t\ttotbytes += ARR_OVERHEAD_NONULLS(ndims);\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, totbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, 0);\n\n\t\tp = ARR_DATA_PTR(result);\n\t\tfor (i = 0; i < nitems; i++)\n\t\t\tp += ArrayCastAndSet(value, elmlen, elmbyval, elmalign, p);\n\t}\n\telse\n\t{\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\tdataoffset;\n\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nitems);\n\t\tnbytes = dataoffset;\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, nbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, dataoffset);\n\n\t\t/* create_array_envelope already zeroed the bitmap, so we're done */\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nstatic ArrayType *\narray_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo)\n{\n\tArrayType  *result;\n\tint\t\t   *dimv;\n\tint\t\t   *lbsv;\n\tint\t\t\tndims;\n\tint\t\t\tnitems;\n\tint\t\t\tdeflbs[MAXDIM];\n\tint16\t\telmlen;\n\tbool\t\telmbyval;\n\tchar\t\telmalign;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * Params checks\n\t */\n\tif (ARR_NDIM(dims) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\tif (array_contains_nulls(dims))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\tdimv = (int *) ARR_DATA_PTR(dims);\n\tndims = (ARR_NDIM(dims) > 0) ? ARR_DIMS(dims)[0] : 0;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tif (lbs != NULL)\n\t{\n\t\tif (ARR_NDIM(lbs) > 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Dimension array must be one dimensional.\")));\n\n\t\tif (array_contains_nulls(lbs))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"dimension values cannot be null\")));\n\n\t\tif (ndims != ((ARR_NDIM(lbs) > 0) ? ARR_DIMS(lbs)[0] : 0))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"),\n\t\t\t\t\t errdetail(\"Low bound array has different size than dimensions array.\")));\n\n\t\tlbsv = (int *) ARR_DATA_PTR(lbs);\n\t}\n\telse\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < MAXDIM; i++)\n\t\t\tdeflbs[i] = 1;\n\n\t\tlbsv = deflbs;\n\t}\n\n\tnitems = ArrayGetNItems(ndims, dimv);\n\n\t/* fast track for empty array */\n\tif (nitems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/*\n\t * We arrange to look up info about element type only once per series of\n\t * calls, assuming the element type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = InvalidOid;\n\t}\n\n\tif (my_extra->element_type != elmtype)\n\t{\n\t\t/* Get info about element type */\n\t\tget_typlenbyvalalign(elmtype,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\t\tmy_extra->element_type = elmtype;\n\t}\n\n\telmlen = my_extra->typlen;\n\telmbyval = my_extra->typbyval;\n\telmalign = my_extra->typalign;\n\n\t/* compute required space */\n\tif (!isnull)\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t   *p;\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\ttotbytes;\n\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\tvalue = PointerGetDatum(PG_DETOAST_DATUM(value));\n\n\t\tnbytes = att_addlength_datum(0, elmlen, value);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\tAssert(nbytes > 0);\n\n\t\ttotbytes = nbytes * nitems;\n\n\t\t/* check for overflow of multiplication or total request */\n\t\tif (totbytes / nbytes != nitems ||\n\t\t\t!AllocSizeIsValid(totbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\n\t\t/*\n\t\t * This addition can't overflow, but it might cause us to go past\n\t\t * MaxAllocSize.  We leave it to palloc to complain in that case.\n\t\t */\n\t\ttotbytes += ARR_OVERHEAD_NONULLS(ndims);\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, totbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, 0);\n\n\t\tp = ARR_DATA_PTR(result);\n\t\tfor (i = 0; i < nitems; i++)\n\t\t\tp += ArrayCastAndSet(value, elmlen, elmbyval, elmalign, p);\n\t}\n\telse\n\t{\n\t\tint\t\t\tnbytes;\n\t\tint\t\t\tdataoffset;\n\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nitems);\n\t\tnbytes = dataoffset;\n\n\t\tresult = create_array_envelope(ndims, dimv, lbsv, nbytes,\n\t\t\t\t\t\t\t\t\t   elmtype, dataoffset);\n\n\t\t/* create_array_envelope already zeroed the bitmap, so we're done */\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not determine data type of input\""
          ],
          "line": 5718
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "elmtype"
          ],
          "line": 5717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "0"
          ],
          "line": 5716
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 5707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 5705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "2"
          ],
          "line": 5703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 5702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension array or low bound array cannot be null\"))"
          ],
          "line": 5698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"dimension array or low bound array cannot be null\""
          ],
          "line": 5700
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 5699
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 5697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 5697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_fill_with_lower_bounds(PG_FUNCTION_ARGS)\n{\n\tArrayType  *dims;\n\tArrayType  *lbs;\n\tArrayType  *result;\n\tOid\t\t\telmtype;\n\tDatum\t\tvalue;\n\tbool\t\tisnull;\n\n\tif (PG_ARGISNULL(1) || PG_ARGISNULL(2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"dimension array or low bound array cannot be null\")));\n\n\tdims = PG_GETARG_ARRAYTYPE_P(1);\n\tlbs = PG_GETARG_ARRAYTYPE_P(2);\n\n\tif (!PG_ARGISNULL(0))\n\t{\n\t\tvalue = PG_GETARG_DATUM(0);\n\t\tisnull = false;\n\t}\n\telse\n\t{\n\t\tvalue = 0;\n\t\tisnull = true;\n\t}\n\n\telmtype = get_fn_expr_argtype(fcinfo->flinfo, 0);\n\tif (!OidIsValid(elmtype))\n\t\telog(ERROR, \"could not determine data type of input\");\n\n\tresult = array_fill_internal(dims, lbs, value, isnull, elmtype, fcinfo);\n\tPG_RETURN_ARRAYTYPE_P(result);\n}"
  },
  {
    "function_name": "generate_subscripts_nodir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5676-5681",
    "snippet": "Datum\ngenerate_subscripts_nodir(PG_FUNCTION_ARGS)\n{\n\t/* just call the other one -- it can handle both cases */\n\treturn generate_subscripts(fcinfo);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generate_subscripts",
          "args": [
            "fcinfo"
          ],
          "line": 5680
        },
        "resolved": true,
        "details": {
          "function_name": "generate_subscripts_nodir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5676-5681",
          "snippet": "Datum\ngenerate_subscripts_nodir(PG_FUNCTION_ARGS)\n{\n\t/* just call the other one -- it can handle both cases */\n\treturn generate_subscripts(fcinfo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\ngenerate_subscripts_nodir(PG_FUNCTION_ARGS)\n{\n\t/* just call the other one -- it can handle both cases */\n\treturn generate_subscripts(fcinfo);\n}"
  },
  {
    "function_name": "generate_subscripts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5612-5670",
    "snippet": "Datum\ngenerate_subscripts(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tMemoryContext oldcontext;\n\tgenerate_subscripts_fctx *fctx;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\t\tint\t\t\treqdim = PG_GETARG_INT32(1);\n\t\tint\t\t   *lb,\n\t\t\t\t   *dimv;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/* Sanity check: does it look like an array at all? */\n\t\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\t\tSRF_RETURN_DONE(funcctx);\n\n\t\t/* Sanity check: was the requested dim valid */\n\t\tif (reqdim <= 0 || reqdim > AARR_NDIM(v))\n\t\t\tSRF_RETURN_DONE(funcctx);\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\tfctx = (generate_subscripts_fctx *) palloc(sizeof(generate_subscripts_fctx));\n\n\t\tlb = AARR_LBOUND(v);\n\t\tdimv = AARR_DIMS(v);\n\n\t\tfctx->lower = lb[reqdim - 1];\n\t\tfctx->upper = dimv[reqdim - 1] + lb[reqdim - 1] - 1;\n\t\tfctx->reverse = (PG_NARGS() < 3) ? false : PG_GETARG_BOOL(2);\n\n\t\tfuncctx->user_fctx = fctx;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\n\tfctx = funcctx->user_fctx;\n\n\tif (fctx->lower <= fctx->upper)\n\t{\n\t\tif (!fctx->reverse)\n\t\t\tSRF_RETURN_NEXT(funcctx, Int32GetDatum(fctx->lower++));\n\t\telse\n\t\t\tSRF_RETURN_NEXT(funcctx, Int32GetDatum(fctx->upper--));\n\t}\n\telse\n\t\t/* done when there are no more elements left */\n\t\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 5669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "Int32GetDatum(fctx->upper--)"
          ],
          "line": 5665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "fctx->upper--"
          ],
          "line": 5665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "Int32GetDatum(fctx->lower++)"
          ],
          "line": 5663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "fctx->lower++"
          ],
          "line": 5663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 5656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 5653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "2"
          ],
          "line": 5649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 5649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "v"
          ],
          "line": 5645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "v"
          ],
          "line": 5644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(generate_subscripts_fctx)"
          ],
          "line": 5642
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 5641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 5636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 5635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 5632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 5631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 5631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 5628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 5623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 5622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 5620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ngenerate_subscripts(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tMemoryContext oldcontext;\n\tgenerate_subscripts_fctx *fctx;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\t\tint\t\t\treqdim = PG_GETARG_INT32(1);\n\t\tint\t\t   *lb,\n\t\t\t\t   *dimv;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/* Sanity check: does it look like an array at all? */\n\t\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\t\tSRF_RETURN_DONE(funcctx);\n\n\t\t/* Sanity check: was the requested dim valid */\n\t\tif (reqdim <= 0 || reqdim > AARR_NDIM(v))\n\t\t\tSRF_RETURN_DONE(funcctx);\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\tfctx = (generate_subscripts_fctx *) palloc(sizeof(generate_subscripts_fctx));\n\n\t\tlb = AARR_LBOUND(v);\n\t\tdimv = AARR_DIMS(v);\n\n\t\tfctx->lower = lb[reqdim - 1];\n\t\tfctx->upper = dimv[reqdim - 1] + lb[reqdim - 1] - 1;\n\t\tfctx->reverse = (PG_NARGS() < 3) ? false : PG_GETARG_BOOL(2);\n\n\t\tfuncctx->user_fctx = fctx;\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\n\tfctx = funcctx->user_fctx;\n\n\tif (fctx->lower <= fctx->upper)\n\t{\n\t\tif (!fctx->reverse)\n\t\t\tSRF_RETURN_NEXT(funcctx, Int32GetDatum(fctx->lower++));\n\t\telse\n\t\t\tSRF_RETURN_NEXT(funcctx, Int32GetDatum(fctx->upper--));\n\t}\n\telse\n\t\t/* done when there are no more elements left */\n\t\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "array_smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5591-5598",
    "snippet": "Datum\narray_smaller(PG_FUNCTION_ARGS)\n{\n\tif (array_cmp(fcinfo) < 0)\n\t\tPG_RETURN_DATUM(PG_GETARG_DATUM(0));\n\telse\n\t\tPG_RETURN_DATUM(PG_GETARG_DATUM(1));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "PG_GETARG_DATUM(1)"
          ],
          "line": 5597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 5597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "PG_GETARG_DATUM(0)"
          ],
          "line": 5595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 5595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 5594
        },
        "resolved": true,
        "details": {
          "function_name": "array_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3745-3907",
          "snippet": "static int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_smaller(PG_FUNCTION_ARGS)\n{\n\tif (array_cmp(fcinfo) < 0)\n\t\tPG_RETURN_DATUM(PG_GETARG_DATUM(0));\n\telse\n\t\tPG_RETURN_DATUM(PG_GETARG_DATUM(1));\n}"
  },
  {
    "function_name": "array_larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5582-5589",
    "snippet": "Datum\narray_larger(PG_FUNCTION_ARGS)\n{\n\tif (array_cmp(fcinfo) > 0)\n\t\tPG_RETURN_DATUM(PG_GETARG_DATUM(0));\n\telse\n\t\tPG_RETURN_DATUM(PG_GETARG_DATUM(1));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "PG_GETARG_DATUM(1)"
          ],
          "line": 5588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 5588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "PG_GETARG_DATUM(0)"
          ],
          "line": 5586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 5586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 5585
        },
        "resolved": true,
        "details": {
          "function_name": "array_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3745-3907",
          "snippet": "static int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_larger(PG_FUNCTION_ARGS)\n{\n\tif (array_cmp(fcinfo) > 0)\n\t\tPG_RETURN_DATUM(PG_GETARG_DATUM(0));\n\telse\n\t\tPG_RETURN_DATUM(PG_GETARG_DATUM(1));\n}"
  },
  {
    "function_name": "makeArrayResultAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5552-5579",
    "snippet": "Datum\nmakeArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t   MemoryContext rcontext, bool release)\n{\n\tDatum\t\tresult;\n\n\tif (astate->scalarstate)\n\t{\n\t\t/* Must use makeMdArrayResult to support \"release\" parameter */\n\t\tint\t\t\tndims;\n\t\tint\t\t\tdims[1];\n\t\tint\t\t\tlbs[1];\n\n\t\t/* If no elements were presented, we want to create an empty array */\n\t\tndims = (astate->scalarstate->nelems > 0) ? 1 : 0;\n\t\tdims[0] = astate->scalarstate->nelems;\n\t\tlbs[0] = 1;\n\n\t\tresult = makeMdArrayResult(astate->scalarstate, ndims, dims, lbs,\n\t\t\t\t\t\t\t\t   rcontext, release);\n\t}\n\telse\n\t{\n\t\tresult = makeArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t\trcontext, release);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeArrayResultArr",
          "args": [
            "astate->arraystate",
            "rcontext",
            "release"
          ],
          "line": 5575
        },
        "resolved": true,
        "details": {
          "function_name": "makeArrayResultArr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5404-5464",
          "snippet": "Datum\nmakeArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t   MemoryContext rcontext,\n\t\t\t\t   bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* No inputs, return empty array */\n\t\tresult = construct_empty_array(astate->element_type);\n\t}\n\telse\n\t{\n\t\tint\t\t\tdataoffset,\n\t\t\t\t\tnbytes;\n\n\t\t/* Compute required space */\n\t\tnbytes = astate->nbytes;\n\t\tif (astate->nullbitmap != NULL)\n\t\t{\n\t\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(astate->ndims, astate->nitems);\n\t\t\tnbytes += dataoffset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdataoffset = 0;\n\t\t\tnbytes += ARR_OVERHEAD_NONULLS(astate->ndims);\n\t\t}\n\n\t\tresult = (ArrayType *) palloc0(nbytes);\n\t\tSET_VARSIZE(result, nbytes);\n\t\tresult->ndim = astate->ndims;\n\t\tresult->dataoffset = dataoffset;\n\t\tresult->elemtype = astate->element_type;\n\n\t\tmemcpy(ARR_DIMS(result), astate->dims, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_LBOUND(result), astate->lbs, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_DATA_PTR(result), astate->data, astate->nbytes);\n\n\t\tif (astate->nullbitmap != NULL)\n\t\t\tarray_bitmap_copy(ARR_NULLBITMAP(result), 0,\n\t\t\t\t\t\t\t  astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nDatum\nmakeArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t   MemoryContext rcontext,\n\t\t\t\t   bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* No inputs, return empty array */\n\t\tresult = construct_empty_array(astate->element_type);\n\t}\n\telse\n\t{\n\t\tint\t\t\tdataoffset,\n\t\t\t\t\tnbytes;\n\n\t\t/* Compute required space */\n\t\tnbytes = astate->nbytes;\n\t\tif (astate->nullbitmap != NULL)\n\t\t{\n\t\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(astate->ndims, astate->nitems);\n\t\t\tnbytes += dataoffset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdataoffset = 0;\n\t\t\tnbytes += ARR_OVERHEAD_NONULLS(astate->ndims);\n\t\t}\n\n\t\tresult = (ArrayType *) palloc0(nbytes);\n\t\tSET_VARSIZE(result, nbytes);\n\t\tresult->ndim = astate->ndims;\n\t\tresult->dataoffset = dataoffset;\n\t\tresult->elemtype = astate->element_type;\n\n\t\tmemcpy(ARR_DIMS(result), astate->dims, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_LBOUND(result), astate->lbs, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_DATA_PTR(result), astate->data, astate->nbytes);\n\n\t\tif (astate->nullbitmap != NULL)\n\t\t\tarray_bitmap_copy(ARR_NULLBITMAP(result), 0,\n\t\t\t\t\t\t\t  astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeMdArrayResult",
          "args": [
            "astate->scalarstate",
            "ndims",
            "dims",
            "lbs",
            "rcontext",
            "release"
          ],
          "line": 5570
        },
        "resolved": true,
        "details": {
          "function_name": "makeMdArrayResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5149-5183",
          "snippet": "Datum\nmakeMdArrayResult(ArrayBuildState *astate,\n\t\t\t\t  int ndims,\n\t\t\t\t  int *dims,\n\t\t\t\t  int *lbs,\n\t\t\t\t  MemoryContext rcontext,\n\t\t\t\t  bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tresult = construct_md_array(astate->dvalues,\n\t\t\t\t\t\t\t\tastate->dnulls,\n\t\t\t\t\t\t\t\tndims,\n\t\t\t\t\t\t\t\tdims,\n\t\t\t\t\t\t\t\tlbs,\n\t\t\t\t\t\t\t\tastate->element_type,\n\t\t\t\t\t\t\t\tastate->typlen,\n\t\t\t\t\t\t\t\tastate->typbyval,\n\t\t\t\t\t\t\t\tastate->typalign);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nDatum\nmakeMdArrayResult(ArrayBuildState *astate,\n\t\t\t\t  int ndims,\n\t\t\t\t  int *dims,\n\t\t\t\t  int *lbs,\n\t\t\t\t  MemoryContext rcontext,\n\t\t\t\t  bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tresult = construct_md_array(astate->dvalues,\n\t\t\t\t\t\t\t\tastate->dnulls,\n\t\t\t\t\t\t\t\tndims,\n\t\t\t\t\t\t\t\tdims,\n\t\t\t\t\t\t\t\tlbs,\n\t\t\t\t\t\t\t\tastate->element_type,\n\t\t\t\t\t\t\t\tastate->typlen,\n\t\t\t\t\t\t\t\tastate->typbyval,\n\t\t\t\t\t\t\t\tastate->typalign);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmakeArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t   MemoryContext rcontext, bool release)\n{\n\tDatum\t\tresult;\n\n\tif (astate->scalarstate)\n\t{\n\t\t/* Must use makeMdArrayResult to support \"release\" parameter */\n\t\tint\t\t\tndims;\n\t\tint\t\t\tdims[1];\n\t\tint\t\t\tlbs[1];\n\n\t\t/* If no elements were presented, we want to create an empty array */\n\t\tndims = (astate->scalarstate->nelems > 0) ? 1 : 0;\n\t\tdims[0] = astate->scalarstate->nelems;\n\t\tlbs[0] = 1;\n\n\t\tresult = makeMdArrayResult(astate->scalarstate, ndims, dims, lbs,\n\t\t\t\t\t\t\t\t   rcontext, release);\n\t}\n\telse\n\t{\n\t\tresult = makeArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t\trcontext, release);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "accumArrayResultAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5524-5543",
    "snippet": "ArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "accumArrayResultArr",
          "args": [
            "astate->arraystate",
            "dvalue",
            "disnull",
            "input_type",
            "rcontext"
          ],
          "line": 5538
        },
        "resolved": true,
        "details": {
          "function_name": "accumArrayResultArr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5247-5395",
          "snippet": "ArrayBuildStateArr *\naccumArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid array_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tArrayType  *arg;\n\tMemoryContext oldcontext;\n\tint\t\t   *dims,\n\t\t\t   *lbs,\n\t\t\t\tndims,\n\t\t\t\tnitems,\n\t\t\t\tndatabytes;\n\tchar\t   *data;\n\tint\t\t\ti;\n\n\t/*\n\t * We disallow accumulating null subarrays.  Another plausible definition\n\t * is to ignore them, but callers that want that can just skip calling\n\t * this function.\n\t */\n\tif (disnull)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"cannot accumulate null arrays\")));\n\n\t/* Detoast input array in caller's context */\n\targ = DatumGetArrayTypeP(dvalue);\n\n\tif (astate == NULL)\n\t\tastate = initArrayResultArr(array_type, InvalidOid, rcontext, true);\n\telse\n\t\tAssert(astate->array_type == array_type);\n\n\toldcontext = MemoryContextSwitchTo(astate->mcontext);\n\n\t/* Collect this input's dimensions */\n\tndims = ARR_NDIM(arg);\n\tdims = ARR_DIMS(arg);\n\tlbs = ARR_LBOUND(arg);\n\tdata = ARR_DATA_PTR(arg);\n\tnitems = ArrayGetNItems(ndims, dims);\n\tndatabytes = ARR_SIZE(arg) - ARR_DATA_OFFSET(arg);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* First input; check/save the dimensionality info */\n\n\t\t/* Should we allow empty inputs and just produce an empty output? */\n\t\tif (ndims == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate empty arrays\")));\n\t\tif (ndims + 1 > MAXDIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tndims + 1, MAXDIM)));\n\n\t\t/*\n\t\t * The output array will have n+1 dimensions, with the ones after the\n\t\t * first matching the input's dimensions.\n\t\t */\n\t\tastate->ndims = ndims + 1;\n\t\tastate->dims[0] = 0;\n\t\tmemcpy(&astate->dims[1], dims, ndims * sizeof(int));\n\t\tastate->lbs[0] = 1;\n\t\tmemcpy(&astate->lbs[1], lbs, ndims * sizeof(int));\n\n\t\t/* Allocate at least enough data space for this item */\n\t\tastate->abytes = 1024;\n\t\twhile (astate->abytes <= ndatabytes)\n\t\t\tastate->abytes *= 2;\n\t\tastate->data = (char *) palloc(astate->abytes);\n\t}\n\telse\n\t{\n\t\t/* Second or later input: must match first input's dimensionality */\n\t\tif (astate->ndims != ndims + 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\tfor (i = 0; i < ndims; i++)\n\t\t{\n\t\t\tif (astate->dims[i + 1] != dims[i] || astate->lbs[i + 1] != lbs[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\t}\n\n\t\t/* Enlarge data space if needed */\n\t\tif (astate->nbytes + ndatabytes > astate->abytes)\n\t\t{\n\t\t\tastate->abytes = Max(astate->abytes * 2,\n\t\t\t\t\t\t\t\t astate->nbytes + ndatabytes);\n\t\t\tastate->data = (char *) repalloc(astate->data, astate->abytes);\n\t\t}\n\t}\n\n\t/*\n\t * Copy the data portion of the sub-array.  Note we assume that the\n\t * advertised data length of the sub-array is properly aligned.  We do not\n\t * have to worry about detoasting elements since whatever's in the\n\t * sub-array should be OK already.\n\t */\n\tmemcpy(astate->data + astate->nbytes, data, ndatabytes);\n\tastate->nbytes += ndatabytes;\n\n\t/* Deal with null bitmap if needed */\n\tif (astate->nullbitmap || ARR_HASNULL(arg))\n\t{\n\t\tint\t\t\tnewnitems = astate->nitems + nitems;\n\n\t\tif (astate->nullbitmap == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * First input with nulls; we must retrospectively handle any\n\t\t\t * previous inputs by marking all their items non-null.\n\t\t\t */\n\t\t\tastate->aitems = 256;\n\t\t\twhile (astate->aitems <= newnitems)\n\t\t\t\tastate->aitems *= 2;\n\t\t\tastate->nullbitmap = (bits8 *) palloc((astate->aitems + 7) / 8);\n\t\t\tarray_bitmap_copy(astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t\t}\n\t\telse if (newnitems > astate->aitems)\n\t\t{\n\t\t\tastate->aitems = Max(astate->aitems * 2, newnitems);\n\t\t\tastate->nullbitmap = (bits8 *)\n\t\t\t\trepalloc(astate->nullbitmap, (astate->aitems + 7) / 8);\n\t\t}\n\t\tarray_bitmap_copy(astate->nullbitmap, astate->nitems,\n\t\t\t\t\t\t  ARR_NULLBITMAP(arg), 0,\n\t\t\t\t\t\t  nitems);\n\t}\n\n\tastate->nitems += nitems;\n\tastate->dims[0] += 1;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Release detoasted copy if any */\n\tif ((Pointer) arg != DatumGetPointer(dvalue))\n\t\tpfree(arg);\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\n\nArrayBuildStateArr *\naccumArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid array_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tArrayType  *arg;\n\tMemoryContext oldcontext;\n\tint\t\t   *dims,\n\t\t\t   *lbs,\n\t\t\t\tndims,\n\t\t\t\tnitems,\n\t\t\t\tndatabytes;\n\tchar\t   *data;\n\tint\t\t\ti;\n\n\t/*\n\t * We disallow accumulating null subarrays.  Another plausible definition\n\t * is to ignore them, but callers that want that can just skip calling\n\t * this function.\n\t */\n\tif (disnull)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"cannot accumulate null arrays\")));\n\n\t/* Detoast input array in caller's context */\n\targ = DatumGetArrayTypeP(dvalue);\n\n\tif (astate == NULL)\n\t\tastate = initArrayResultArr(array_type, InvalidOid, rcontext, true);\n\telse\n\t\tAssert(astate->array_type == array_type);\n\n\toldcontext = MemoryContextSwitchTo(astate->mcontext);\n\n\t/* Collect this input's dimensions */\n\tndims = ARR_NDIM(arg);\n\tdims = ARR_DIMS(arg);\n\tlbs = ARR_LBOUND(arg);\n\tdata = ARR_DATA_PTR(arg);\n\tnitems = ArrayGetNItems(ndims, dims);\n\tndatabytes = ARR_SIZE(arg) - ARR_DATA_OFFSET(arg);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* First input; check/save the dimensionality info */\n\n\t\t/* Should we allow empty inputs and just produce an empty output? */\n\t\tif (ndims == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate empty arrays\")));\n\t\tif (ndims + 1 > MAXDIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tndims + 1, MAXDIM)));\n\n\t\t/*\n\t\t * The output array will have n+1 dimensions, with the ones after the\n\t\t * first matching the input's dimensions.\n\t\t */\n\t\tastate->ndims = ndims + 1;\n\t\tastate->dims[0] = 0;\n\t\tmemcpy(&astate->dims[1], dims, ndims * sizeof(int));\n\t\tastate->lbs[0] = 1;\n\t\tmemcpy(&astate->lbs[1], lbs, ndims * sizeof(int));\n\n\t\t/* Allocate at least enough data space for this item */\n\t\tastate->abytes = 1024;\n\t\twhile (astate->abytes <= ndatabytes)\n\t\t\tastate->abytes *= 2;\n\t\tastate->data = (char *) palloc(astate->abytes);\n\t}\n\telse\n\t{\n\t\t/* Second or later input: must match first input's dimensionality */\n\t\tif (astate->ndims != ndims + 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\tfor (i = 0; i < ndims; i++)\n\t\t{\n\t\t\tif (astate->dims[i + 1] != dims[i] || astate->lbs[i + 1] != lbs[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\t}\n\n\t\t/* Enlarge data space if needed */\n\t\tif (astate->nbytes + ndatabytes > astate->abytes)\n\t\t{\n\t\t\tastate->abytes = Max(astate->abytes * 2,\n\t\t\t\t\t\t\t\t astate->nbytes + ndatabytes);\n\t\t\tastate->data = (char *) repalloc(astate->data, astate->abytes);\n\t\t}\n\t}\n\n\t/*\n\t * Copy the data portion of the sub-array.  Note we assume that the\n\t * advertised data length of the sub-array is properly aligned.  We do not\n\t * have to worry about detoasting elements since whatever's in the\n\t * sub-array should be OK already.\n\t */\n\tmemcpy(astate->data + astate->nbytes, data, ndatabytes);\n\tastate->nbytes += ndatabytes;\n\n\t/* Deal with null bitmap if needed */\n\tif (astate->nullbitmap || ARR_HASNULL(arg))\n\t{\n\t\tint\t\t\tnewnitems = astate->nitems + nitems;\n\n\t\tif (astate->nullbitmap == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * First input with nulls; we must retrospectively handle any\n\t\t\t * previous inputs by marking all their items non-null.\n\t\t\t */\n\t\t\tastate->aitems = 256;\n\t\t\twhile (astate->aitems <= newnitems)\n\t\t\t\tastate->aitems *= 2;\n\t\t\tastate->nullbitmap = (bits8 *) palloc((astate->aitems + 7) / 8);\n\t\t\tarray_bitmap_copy(astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t\t}\n\t\telse if (newnitems > astate->aitems)\n\t\t{\n\t\t\tastate->aitems = Max(astate->aitems * 2, newnitems);\n\t\t\tastate->nullbitmap = (bits8 *)\n\t\t\t\trepalloc(astate->nullbitmap, (astate->aitems + 7) / 8);\n\t\t}\n\t\tarray_bitmap_copy(astate->nullbitmap, astate->nitems,\n\t\t\t\t\t\t  ARR_NULLBITMAP(arg), 0,\n\t\t\t\t\t\t  nitems);\n\t}\n\n\tastate->nitems += nitems;\n\tastate->dims[0] += 1;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Release detoasted copy if any */\n\tif ((Pointer) arg != DatumGetPointer(dvalue))\n\t\tpfree(arg);\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "accumArrayResult",
          "args": [
            "astate->scalarstate",
            "dvalue",
            "disnull",
            "input_type",
            "rcontext"
          ],
          "line": 5534
        },
        "resolved": true,
        "details": {
          "function_name": "accumArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5524-5543",
          "snippet": "ArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "initArrayResultAny",
          "args": [
            "input_type",
            "rcontext",
            "true"
          ],
          "line": 5531
        },
        "resolved": true,
        "details": {
          "function_name": "initArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5479-5514",
          "snippet": "ArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}"
  },
  {
    "function_name": "initArrayResultAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5479-5514",
    "snippet": "ArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "scalarstate->mcontext",
            "sizeof(ArrayBuildStateAny)"
          ],
          "line": 5507
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initArrayResult",
          "args": [
            "input_type",
            "rcontext",
            "subcontext"
          ],
          "line": 5505
        },
        "resolved": true,
        "details": {
          "function_name": "initArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5479-5514",
          "snippet": "ArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "OidIsValid(get_array_type(input_type))"
          ],
          "line": 5503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "get_array_type(input_type)"
          ],
          "line": 5503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_array_type",
          "args": [
            "input_type"
          ],
          "line": 5503
        },
        "resolved": true,
        "details": {
          "function_name": "get_array_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2553-2566",
          "snippet": "Oid\nget_array_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\tOid\t\t\tresult = InvalidOid;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tresult = ((Form_pg_type) GETSTRUCT(tp))->typarray;\n\t\tReleaseSysCache(tp);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_array_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\tOid\t\t\tresult = InvalidOid;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tresult = ((Form_pg_type) GETSTRUCT(tp))->typarray;\n\t\tReleaseSysCache(tp);\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initArrayResultArr",
          "args": [
            "input_type",
            "InvalidOid",
            "rcontext",
            "subcontext"
          ],
          "line": 5490
        },
        "resolved": true,
        "details": {
          "function_name": "initArrayResultArr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5201-5237",
          "snippet": "ArrayBuildStateArr *\ninitArrayResultArr(Oid array_type, Oid element_type, MemoryContext rcontext,\n\t\t\t\t   bool subcontext)\n{\n\tArrayBuildStateArr *astate;\n\tMemoryContext arr_context = rcontext;\t/* by default use the parent ctx */\n\n\t/* Lookup element type, unless element_type already provided */\n\tif (!OidIsValid(element_type))\n\t{\n\t\telement_type = get_element_type(array_type);\n\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"data type %s is not an array type\",\n\t\t\t\t\t\t\tformat_type_be(array_type))));\n\t}\n\n\t/* Make a temporary context to hold all the junk */\n\tif (subcontext)\n\t\tarr_context = AllocSetContextCreate(rcontext,\n\t\t\t\t\t\t\t\t\t\t\t\"accumArrayResultArr\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/* Note we initialize all fields to zero */\n\tastate = (ArrayBuildStateArr *)\n\t\tMemoryContextAllocZero(arr_context, sizeof(ArrayBuildStateArr));\n\tastate->mcontext = arr_context;\n\tastate->private_cxt = subcontext;\n\n\t/* Save relevant datatype information */\n\tastate->array_type = array_type;\n\tastate->element_type = element_type;\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateArr *\ninitArrayResultArr(Oid array_type, Oid element_type, MemoryContext rcontext,\n\t\t\t\t   bool subcontext)\n{\n\tArrayBuildStateArr *astate;\n\tMemoryContext arr_context = rcontext;\t/* by default use the parent ctx */\n\n\t/* Lookup element type, unless element_type already provided */\n\tif (!OidIsValid(element_type))\n\t{\n\t\telement_type = get_element_type(array_type);\n\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"data type %s is not an array type\",\n\t\t\t\t\t\t\tformat_type_be(array_type))));\n\t}\n\n\t/* Make a temporary context to hold all the junk */\n\tif (subcontext)\n\t\tarr_context = AllocSetContextCreate(rcontext,\n\t\t\t\t\t\t\t\t\t\t\t\"accumArrayResultArr\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/* Note we initialize all fields to zero */\n\tastate = (ArrayBuildStateArr *)\n\t\tMemoryContextAllocZero(arr_context, sizeof(ArrayBuildStateArr));\n\tastate->mcontext = arr_context;\n\tastate->private_cxt = subcontext;\n\n\t/* Save relevant datatype information */\n\tastate->array_type = array_type;\n\tastate->element_type = element_type;\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "element_type"
          ],
          "line": 5485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_element_type",
          "args": [
            "input_type"
          ],
          "line": 5483
        },
        "resolved": true,
        "details": {
          "function_name": "get_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2525-2545",
          "snippet": "Oid\nget_element_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tif (typtup->typlen == -1)\n\t\t\tresult = typtup->typelem;\n\t\telse\n\t\t\tresult = InvalidOid;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_element_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tif (typtup->typlen == -1)\n\t\t\tresult = typtup->typelem;\n\t\telse\n\t\t\tresult = InvalidOid;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}"
  },
  {
    "function_name": "makeArrayResultArr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5404-5464",
    "snippet": "Datum\nmakeArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t   MemoryContext rcontext,\n\t\t\t\t   bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* No inputs, return empty array */\n\t\tresult = construct_empty_array(astate->element_type);\n\t}\n\telse\n\t{\n\t\tint\t\t\tdataoffset,\n\t\t\t\t\tnbytes;\n\n\t\t/* Compute required space */\n\t\tnbytes = astate->nbytes;\n\t\tif (astate->nullbitmap != NULL)\n\t\t{\n\t\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(astate->ndims, astate->nitems);\n\t\t\tnbytes += dataoffset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdataoffset = 0;\n\t\t\tnbytes += ARR_OVERHEAD_NONULLS(astate->ndims);\n\t\t}\n\n\t\tresult = (ArrayType *) palloc0(nbytes);\n\t\tSET_VARSIZE(result, nbytes);\n\t\tresult->ndim = astate->ndims;\n\t\tresult->dataoffset = dataoffset;\n\t\tresult->elemtype = astate->element_type;\n\n\t\tmemcpy(ARR_DIMS(result), astate->dims, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_LBOUND(result), astate->lbs, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_DATA_PTR(result), astate->data, astate->nbytes);\n\n\t\tif (astate->nullbitmap != NULL)\n\t\t\tarray_bitmap_copy(ARR_NULLBITMAP(result), 0,\n\t\t\t\t\t\t\t  astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "result"
          ],
          "line": 5463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "astate->mcontext"
          ],
          "line": 5460
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "astate->private_cxt"
          ],
          "line": 5459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 5454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_bitmap_copy",
          "args": [
            "ARR_NULLBITMAP(result)",
            "0",
            "astate->nullbitmap",
            "0",
            "astate->nitems"
          ],
          "line": 5449
        },
        "resolved": true,
        "details": {
          "function_name": "array_bitmap_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4687-4751",
          "snippet": "void\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "result"
          ],
          "line": 5449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DATA_PTR(result)",
            "astate->data",
            "astate->nbytes"
          ],
          "line": 5446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "result"
          ],
          "line": 5446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(result)",
            "astate->lbs",
            "astate->ndims * sizeof(int)"
          ],
          "line": 5445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "result"
          ],
          "line": 5445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(result)",
            "astate->dims",
            "astate->ndims * sizeof(int)"
          ],
          "line": 5444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "result"
          ],
          "line": 5444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "nbytes"
          ],
          "line": 5439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nbytes"
          ],
          "line": 5438
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "astate->ndims"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "astate->ndims",
            "astate->nitems"
          ],
          "line": 5429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "astate->element_type"
          ],
          "line": 5418
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rcontext"
          ],
          "line": 5413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nDatum\nmakeArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t   MemoryContext rcontext,\n\t\t\t\t   bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* No inputs, return empty array */\n\t\tresult = construct_empty_array(astate->element_type);\n\t}\n\telse\n\t{\n\t\tint\t\t\tdataoffset,\n\t\t\t\t\tnbytes;\n\n\t\t/* Compute required space */\n\t\tnbytes = astate->nbytes;\n\t\tif (astate->nullbitmap != NULL)\n\t\t{\n\t\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(astate->ndims, astate->nitems);\n\t\t\tnbytes += dataoffset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdataoffset = 0;\n\t\t\tnbytes += ARR_OVERHEAD_NONULLS(astate->ndims);\n\t\t}\n\n\t\tresult = (ArrayType *) palloc0(nbytes);\n\t\tSET_VARSIZE(result, nbytes);\n\t\tresult->ndim = astate->ndims;\n\t\tresult->dataoffset = dataoffset;\n\t\tresult->elemtype = astate->element_type;\n\n\t\tmemcpy(ARR_DIMS(result), astate->dims, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_LBOUND(result), astate->lbs, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_DATA_PTR(result), astate->data, astate->nbytes);\n\n\t\tif (astate->nullbitmap != NULL)\n\t\t\tarray_bitmap_copy(ARR_NULLBITMAP(result), 0,\n\t\t\t\t\t\t\t  astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}"
  },
  {
    "function_name": "accumArrayResultArr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5247-5395",
    "snippet": "ArrayBuildStateArr *\naccumArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid array_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tArrayType  *arg;\n\tMemoryContext oldcontext;\n\tint\t\t   *dims,\n\t\t\t   *lbs,\n\t\t\t\tndims,\n\t\t\t\tnitems,\n\t\t\t\tndatabytes;\n\tchar\t   *data;\n\tint\t\t\ti;\n\n\t/*\n\t * We disallow accumulating null subarrays.  Another plausible definition\n\t * is to ignore them, but callers that want that can just skip calling\n\t * this function.\n\t */\n\tif (disnull)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"cannot accumulate null arrays\")));\n\n\t/* Detoast input array in caller's context */\n\targ = DatumGetArrayTypeP(dvalue);\n\n\tif (astate == NULL)\n\t\tastate = initArrayResultArr(array_type, InvalidOid, rcontext, true);\n\telse\n\t\tAssert(astate->array_type == array_type);\n\n\toldcontext = MemoryContextSwitchTo(astate->mcontext);\n\n\t/* Collect this input's dimensions */\n\tndims = ARR_NDIM(arg);\n\tdims = ARR_DIMS(arg);\n\tlbs = ARR_LBOUND(arg);\n\tdata = ARR_DATA_PTR(arg);\n\tnitems = ArrayGetNItems(ndims, dims);\n\tndatabytes = ARR_SIZE(arg) - ARR_DATA_OFFSET(arg);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* First input; check/save the dimensionality info */\n\n\t\t/* Should we allow empty inputs and just produce an empty output? */\n\t\tif (ndims == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate empty arrays\")));\n\t\tif (ndims + 1 > MAXDIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tndims + 1, MAXDIM)));\n\n\t\t/*\n\t\t * The output array will have n+1 dimensions, with the ones after the\n\t\t * first matching the input's dimensions.\n\t\t */\n\t\tastate->ndims = ndims + 1;\n\t\tastate->dims[0] = 0;\n\t\tmemcpy(&astate->dims[1], dims, ndims * sizeof(int));\n\t\tastate->lbs[0] = 1;\n\t\tmemcpy(&astate->lbs[1], lbs, ndims * sizeof(int));\n\n\t\t/* Allocate at least enough data space for this item */\n\t\tastate->abytes = 1024;\n\t\twhile (astate->abytes <= ndatabytes)\n\t\t\tastate->abytes *= 2;\n\t\tastate->data = (char *) palloc(astate->abytes);\n\t}\n\telse\n\t{\n\t\t/* Second or later input: must match first input's dimensionality */\n\t\tif (astate->ndims != ndims + 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\tfor (i = 0; i < ndims; i++)\n\t\t{\n\t\t\tif (astate->dims[i + 1] != dims[i] || astate->lbs[i + 1] != lbs[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\t}\n\n\t\t/* Enlarge data space if needed */\n\t\tif (astate->nbytes + ndatabytes > astate->abytes)\n\t\t{\n\t\t\tastate->abytes = Max(astate->abytes * 2,\n\t\t\t\t\t\t\t\t astate->nbytes + ndatabytes);\n\t\t\tastate->data = (char *) repalloc(astate->data, astate->abytes);\n\t\t}\n\t}\n\n\t/*\n\t * Copy the data portion of the sub-array.  Note we assume that the\n\t * advertised data length of the sub-array is properly aligned.  We do not\n\t * have to worry about detoasting elements since whatever's in the\n\t * sub-array should be OK already.\n\t */\n\tmemcpy(astate->data + astate->nbytes, data, ndatabytes);\n\tastate->nbytes += ndatabytes;\n\n\t/* Deal with null bitmap if needed */\n\tif (astate->nullbitmap || ARR_HASNULL(arg))\n\t{\n\t\tint\t\t\tnewnitems = astate->nitems + nitems;\n\n\t\tif (astate->nullbitmap == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * First input with nulls; we must retrospectively handle any\n\t\t\t * previous inputs by marking all their items non-null.\n\t\t\t */\n\t\t\tastate->aitems = 256;\n\t\t\twhile (astate->aitems <= newnitems)\n\t\t\t\tastate->aitems *= 2;\n\t\t\tastate->nullbitmap = (bits8 *) palloc((astate->aitems + 7) / 8);\n\t\t\tarray_bitmap_copy(astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t\t}\n\t\telse if (newnitems > astate->aitems)\n\t\t{\n\t\t\tastate->aitems = Max(astate->aitems * 2, newnitems);\n\t\t\tastate->nullbitmap = (bits8 *)\n\t\t\t\trepalloc(astate->nullbitmap, (astate->aitems + 7) / 8);\n\t\t}\n\t\tarray_bitmap_copy(astate->nullbitmap, astate->nitems,\n\t\t\t\t\t\t  ARR_NULLBITMAP(arg), 0,\n\t\t\t\t\t\t  nitems);\n\t}\n\n\tastate->nitems += nitems;\n\tastate->dims[0] += 1;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Release detoasted copy if any */\n\tif ((Pointer) arg != DatumGetPointer(dvalue))\n\t\tpfree(arg);\n\n\treturn astate;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "arg"
          ],
          "line": 5392
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "dvalue"
          ],
          "line": 5391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 5388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_bitmap_copy",
          "args": [
            "astate->nullbitmap",
            "astate->nitems",
            "ARR_NULLBITMAP(arg)",
            "0",
            "nitems"
          ],
          "line": 5380
        },
        "resolved": true,
        "details": {
          "function_name": "array_bitmap_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4687-4751",
          "snippet": "void\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "arg"
          ],
          "line": 5381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "astate->nullbitmap",
            "(astate->aitems + 7) / 8"
          ],
          "line": 5378
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "astate->aitems * 2",
            "newnitems"
          ],
          "line": 5376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "(astate->aitems + 7) / 8"
          ],
          "line": 5369
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arg"
          ],
          "line": 5356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "astate->data + astate->nbytes",
            "data",
            "ndatabytes"
          ],
          "line": 5352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "astate->abytes * 2",
            "astate->nbytes + ndatabytes"
          ],
          "line": 5340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\"))"
          ],
          "line": 5332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot accumulate arrays of different dimensionality\""
          ],
          "line": 5334
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_ARRAY_SUBSCRIPT_ERROR"
          ],
          "line": 5333
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\"))"
          ],
          "line": 5326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&astate->lbs[1]",
            "lbs",
            "ndims * sizeof(int)"
          ],
          "line": 5314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&astate->dims[1]",
            "dims",
            "ndims * sizeof(int)"
          ],
          "line": 5312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tndims + 1, MAXDIM))"
          ],
          "line": 5301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate empty arrays\"))"
          ],
          "line": 5297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_OFFSET",
          "args": [
            "arg"
          ],
          "line": 5289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_SIZE",
          "args": [
            "arg"
          ],
          "line": 5289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims",
            "dims"
          ],
          "line": 5288
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "arg"
          ],
          "line": 5287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "arg"
          ],
          "line": 5286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arg"
          ],
          "line": 5285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arg"
          ],
          "line": 5284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "astate->mcontext"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "astate->array_type == array_type"
          ],
          "line": 5279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initArrayResultArr",
          "args": [
            "array_type",
            "InvalidOid",
            "rcontext",
            "true"
          ],
          "line": 5277
        },
        "resolved": true,
        "details": {
          "function_name": "initArrayResultArr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5201-5237",
          "snippet": "ArrayBuildStateArr *\ninitArrayResultArr(Oid array_type, Oid element_type, MemoryContext rcontext,\n\t\t\t\t   bool subcontext)\n{\n\tArrayBuildStateArr *astate;\n\tMemoryContext arr_context = rcontext;\t/* by default use the parent ctx */\n\n\t/* Lookup element type, unless element_type already provided */\n\tif (!OidIsValid(element_type))\n\t{\n\t\telement_type = get_element_type(array_type);\n\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"data type %s is not an array type\",\n\t\t\t\t\t\t\tformat_type_be(array_type))));\n\t}\n\n\t/* Make a temporary context to hold all the junk */\n\tif (subcontext)\n\t\tarr_context = AllocSetContextCreate(rcontext,\n\t\t\t\t\t\t\t\t\t\t\t\"accumArrayResultArr\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/* Note we initialize all fields to zero */\n\tastate = (ArrayBuildStateArr *)\n\t\tMemoryContextAllocZero(arr_context, sizeof(ArrayBuildStateArr));\n\tastate->mcontext = arr_context;\n\tastate->private_cxt = subcontext;\n\n\t/* Save relevant datatype information */\n\tastate->array_type = array_type;\n\tastate->element_type = element_type;\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateArr *\ninitArrayResultArr(Oid array_type, Oid element_type, MemoryContext rcontext,\n\t\t\t\t   bool subcontext)\n{\n\tArrayBuildStateArr *astate;\n\tMemoryContext arr_context = rcontext;\t/* by default use the parent ctx */\n\n\t/* Lookup element type, unless element_type already provided */\n\tif (!OidIsValid(element_type))\n\t{\n\t\telement_type = get_element_type(array_type);\n\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"data type %s is not an array type\",\n\t\t\t\t\t\t\tformat_type_be(array_type))));\n\t}\n\n\t/* Make a temporary context to hold all the junk */\n\tif (subcontext)\n\t\tarr_context = AllocSetContextCreate(rcontext,\n\t\t\t\t\t\t\t\t\t\t\t\"accumArrayResultArr\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/* Note we initialize all fields to zero */\n\tastate = (ArrayBuildStateArr *)\n\t\tMemoryContextAllocZero(arr_context, sizeof(ArrayBuildStateArr));\n\tastate->mcontext = arr_context;\n\tastate->private_cxt = subcontext;\n\n\t/* Save relevant datatype information */\n\tastate->array_type = array_type;\n\tastate->element_type = element_type;\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "dvalue"
          ],
          "line": 5274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"cannot accumulate null arrays\"))"
          ],
          "line": 5269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\n\nArrayBuildStateArr *\naccumArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid array_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tArrayType  *arg;\n\tMemoryContext oldcontext;\n\tint\t\t   *dims,\n\t\t\t   *lbs,\n\t\t\t\tndims,\n\t\t\t\tnitems,\n\t\t\t\tndatabytes;\n\tchar\t   *data;\n\tint\t\t\ti;\n\n\t/*\n\t * We disallow accumulating null subarrays.  Another plausible definition\n\t * is to ignore them, but callers that want that can just skip calling\n\t * this function.\n\t */\n\tif (disnull)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"cannot accumulate null arrays\")));\n\n\t/* Detoast input array in caller's context */\n\targ = DatumGetArrayTypeP(dvalue);\n\n\tif (astate == NULL)\n\t\tastate = initArrayResultArr(array_type, InvalidOid, rcontext, true);\n\telse\n\t\tAssert(astate->array_type == array_type);\n\n\toldcontext = MemoryContextSwitchTo(astate->mcontext);\n\n\t/* Collect this input's dimensions */\n\tndims = ARR_NDIM(arg);\n\tdims = ARR_DIMS(arg);\n\tlbs = ARR_LBOUND(arg);\n\tdata = ARR_DATA_PTR(arg);\n\tnitems = ArrayGetNItems(ndims, dims);\n\tndatabytes = ARR_SIZE(arg) - ARR_DATA_OFFSET(arg);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* First input; check/save the dimensionality info */\n\n\t\t/* Should we allow empty inputs and just produce an empty output? */\n\t\tif (ndims == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate empty arrays\")));\n\t\tif (ndims + 1 > MAXDIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tndims + 1, MAXDIM)));\n\n\t\t/*\n\t\t * The output array will have n+1 dimensions, with the ones after the\n\t\t * first matching the input's dimensions.\n\t\t */\n\t\tastate->ndims = ndims + 1;\n\t\tastate->dims[0] = 0;\n\t\tmemcpy(&astate->dims[1], dims, ndims * sizeof(int));\n\t\tastate->lbs[0] = 1;\n\t\tmemcpy(&astate->lbs[1], lbs, ndims * sizeof(int));\n\n\t\t/* Allocate at least enough data space for this item */\n\t\tastate->abytes = 1024;\n\t\twhile (astate->abytes <= ndatabytes)\n\t\t\tastate->abytes *= 2;\n\t\tastate->data = (char *) palloc(astate->abytes);\n\t}\n\telse\n\t{\n\t\t/* Second or later input: must match first input's dimensionality */\n\t\tif (astate->ndims != ndims + 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\tfor (i = 0; i < ndims; i++)\n\t\t{\n\t\t\tif (astate->dims[i + 1] != dims[i] || astate->lbs[i + 1] != lbs[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\t}\n\n\t\t/* Enlarge data space if needed */\n\t\tif (astate->nbytes + ndatabytes > astate->abytes)\n\t\t{\n\t\t\tastate->abytes = Max(astate->abytes * 2,\n\t\t\t\t\t\t\t\t astate->nbytes + ndatabytes);\n\t\t\tastate->data = (char *) repalloc(astate->data, astate->abytes);\n\t\t}\n\t}\n\n\t/*\n\t * Copy the data portion of the sub-array.  Note we assume that the\n\t * advertised data length of the sub-array is properly aligned.  We do not\n\t * have to worry about detoasting elements since whatever's in the\n\t * sub-array should be OK already.\n\t */\n\tmemcpy(astate->data + astate->nbytes, data, ndatabytes);\n\tastate->nbytes += ndatabytes;\n\n\t/* Deal with null bitmap if needed */\n\tif (astate->nullbitmap || ARR_HASNULL(arg))\n\t{\n\t\tint\t\t\tnewnitems = astate->nitems + nitems;\n\n\t\tif (astate->nullbitmap == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * First input with nulls; we must retrospectively handle any\n\t\t\t * previous inputs by marking all their items non-null.\n\t\t\t */\n\t\t\tastate->aitems = 256;\n\t\t\twhile (astate->aitems <= newnitems)\n\t\t\t\tastate->aitems *= 2;\n\t\t\tastate->nullbitmap = (bits8 *) palloc((astate->aitems + 7) / 8);\n\t\t\tarray_bitmap_copy(astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t\t}\n\t\telse if (newnitems > astate->aitems)\n\t\t{\n\t\t\tastate->aitems = Max(astate->aitems * 2, newnitems);\n\t\t\tastate->nullbitmap = (bits8 *)\n\t\t\t\trepalloc(astate->nullbitmap, (astate->aitems + 7) / 8);\n\t\t}\n\t\tarray_bitmap_copy(astate->nullbitmap, astate->nitems,\n\t\t\t\t\t\t  ARR_NULLBITMAP(arg), 0,\n\t\t\t\t\t\t  nitems);\n\t}\n\n\tastate->nitems += nitems;\n\tastate->dims[0] += 1;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Release detoasted copy if any */\n\tif ((Pointer) arg != DatumGetPointer(dvalue))\n\t\tpfree(arg);\n\n\treturn astate;\n}"
  },
  {
    "function_name": "initArrayResultArr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5201-5237",
    "snippet": "ArrayBuildStateArr *\ninitArrayResultArr(Oid array_type, Oid element_type, MemoryContext rcontext,\n\t\t\t\t   bool subcontext)\n{\n\tArrayBuildStateArr *astate;\n\tMemoryContext arr_context = rcontext;\t/* by default use the parent ctx */\n\n\t/* Lookup element type, unless element_type already provided */\n\tif (!OidIsValid(element_type))\n\t{\n\t\telement_type = get_element_type(array_type);\n\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"data type %s is not an array type\",\n\t\t\t\t\t\t\tformat_type_be(array_type))));\n\t}\n\n\t/* Make a temporary context to hold all the junk */\n\tif (subcontext)\n\t\tarr_context = AllocSetContextCreate(rcontext,\n\t\t\t\t\t\t\t\t\t\t\t\"accumArrayResultArr\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/* Note we initialize all fields to zero */\n\tastate = (ArrayBuildStateArr *)\n\t\tMemoryContextAllocZero(arr_context, sizeof(ArrayBuildStateArr));\n\tastate->mcontext = arr_context;\n\tastate->private_cxt = subcontext;\n\n\t/* Save relevant datatype information */\n\tastate->array_type = array_type;\n\tastate->element_type = element_type;\n\n\treturn astate;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "arr_context",
            "sizeof(ArrayBuildStateArr)"
          ],
          "line": 5228
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "rcontext",
            "\"accumArrayResultArr\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 5222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"data type %s is not an array type\",\n\t\t\t\t\t\t\tformat_type_be(array_type)))"
          ],
          "line": 5214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"data type %s is not an array type\"",
            "format_type_be(array_type)"
          ],
          "line": 5216
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "array_type"
          ],
          "line": 5217
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 5215
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "element_type"
          ],
          "line": 5213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_element_type",
          "args": [
            "array_type"
          ],
          "line": 5211
        },
        "resolved": true,
        "details": {
          "function_name": "get_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2525-2545",
          "snippet": "Oid\nget_element_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tif (typtup->typlen == -1)\n\t\t\tresult = typtup->typelem;\n\t\telse\n\t\t\tresult = InvalidOid;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_element_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tif (typtup->typlen == -1)\n\t\t\tresult = typtup->typelem;\n\t\telse\n\t\t\tresult = InvalidOid;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "element_type"
          ],
          "line": 5209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateArr *\ninitArrayResultArr(Oid array_type, Oid element_type, MemoryContext rcontext,\n\t\t\t\t   bool subcontext)\n{\n\tArrayBuildStateArr *astate;\n\tMemoryContext arr_context = rcontext;\t/* by default use the parent ctx */\n\n\t/* Lookup element type, unless element_type already provided */\n\tif (!OidIsValid(element_type))\n\t{\n\t\telement_type = get_element_type(array_type);\n\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"data type %s is not an array type\",\n\t\t\t\t\t\t\tformat_type_be(array_type))));\n\t}\n\n\t/* Make a temporary context to hold all the junk */\n\tif (subcontext)\n\t\tarr_context = AllocSetContextCreate(rcontext,\n\t\t\t\t\t\t\t\t\t\t\t\"accumArrayResultArr\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/* Note we initialize all fields to zero */\n\tastate = (ArrayBuildStateArr *)\n\t\tMemoryContextAllocZero(arr_context, sizeof(ArrayBuildStateArr));\n\tastate->mcontext = arr_context;\n\tastate->private_cxt = subcontext;\n\n\t/* Save relevant datatype information */\n\tastate->array_type = array_type;\n\tastate->element_type = element_type;\n\n\treturn astate;\n}"
  },
  {
    "function_name": "makeMdArrayResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5149-5183",
    "snippet": "Datum\nmakeMdArrayResult(ArrayBuildState *astate,\n\t\t\t\t  int ndims,\n\t\t\t\t  int *dims,\n\t\t\t\t  int *lbs,\n\t\t\t\t  MemoryContext rcontext,\n\t\t\t\t  bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tresult = construct_md_array(astate->dvalues,\n\t\t\t\t\t\t\t\tastate->dnulls,\n\t\t\t\t\t\t\t\tndims,\n\t\t\t\t\t\t\t\tdims,\n\t\t\t\t\t\t\t\tlbs,\n\t\t\t\t\t\t\t\tastate->element_type,\n\t\t\t\t\t\t\t\tastate->typlen,\n\t\t\t\t\t\t\t\tastate->typbyval,\n\t\t\t\t\t\t\t\tastate->typalign);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "result"
          ],
          "line": 5182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "astate->mcontext"
          ],
          "line": 5179
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "astate->private_cxt"
          ],
          "line": 5178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 5173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_md_array",
          "args": [
            "astate->dvalues",
            "astate->dnulls",
            "ndims",
            "dims",
            "lbs",
            "astate->element_type",
            "astate->typlen",
            "astate->typbyval",
            "astate->typalign"
          ],
          "line": 5163
        },
        "resolved": true,
        "details": {
          "function_name": "construct_md_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3325-3404",
          "snippet": "ArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rcontext"
          ],
          "line": 5161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nDatum\nmakeMdArrayResult(ArrayBuildState *astate,\n\t\t\t\t  int ndims,\n\t\t\t\t  int *dims,\n\t\t\t\t  int *lbs,\n\t\t\t\t  MemoryContext rcontext,\n\t\t\t\t  bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tresult = construct_md_array(astate->dvalues,\n\t\t\t\t\t\t\t\tastate->dnulls,\n\t\t\t\t\t\t\t\tndims,\n\t\t\t\t\t\t\t\tdims,\n\t\t\t\t\t\t\t\tlbs,\n\t\t\t\t\t\t\t\tastate->element_type,\n\t\t\t\t\t\t\t\tastate->typlen,\n\t\t\t\t\t\t\t\tastate->typbyval,\n\t\t\t\t\t\t\t\tastate->typalign);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}"
  },
  {
    "function_name": "makeArrayResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5117-5132",
    "snippet": "Datum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeMdArrayResult",
          "args": [
            "astate",
            "ndims",
            "dims",
            "lbs",
            "rcontext",
            "astate->private_cxt"
          ],
          "line": 5130
        },
        "resolved": true,
        "details": {
          "function_name": "makeMdArrayResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5149-5183",
          "snippet": "Datum\nmakeMdArrayResult(ArrayBuildState *astate,\n\t\t\t\t  int ndims,\n\t\t\t\t  int *dims,\n\t\t\t\t  int *lbs,\n\t\t\t\t  MemoryContext rcontext,\n\t\t\t\t  bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tresult = construct_md_array(astate->dvalues,\n\t\t\t\t\t\t\t\tastate->dnulls,\n\t\t\t\t\t\t\t\tndims,\n\t\t\t\t\t\t\t\tdims,\n\t\t\t\t\t\t\t\tlbs,\n\t\t\t\t\t\t\t\tastate->element_type,\n\t\t\t\t\t\t\t\tastate->typlen,\n\t\t\t\t\t\t\t\tastate->typbyval,\n\t\t\t\t\t\t\t\tastate->typalign);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nDatum\nmakeMdArrayResult(ArrayBuildState *astate,\n\t\t\t\t  int ndims,\n\t\t\t\t  int *dims,\n\t\t\t\t  int *lbs,\n\t\t\t\t  MemoryContext rcontext,\n\t\t\t\t  bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tresult = construct_md_array(astate->dvalues,\n\t\t\t\t\t\t\t\tastate->dnulls,\n\t\t\t\t\t\t\t\tndims,\n\t\t\t\t\t\t\t\tdims,\n\t\t\t\t\t\t\t\tlbs,\n\t\t\t\t\t\t\t\tastate->element_type,\n\t\t\t\t\t\t\t\tastate->typlen,\n\t\t\t\t\t\t\t\tastate->typbyval,\n\t\t\t\t\t\t\t\tastate->typalign);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}"
  },
  {
    "function_name": "accumArrayResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5053-5106",
    "snippet": "ArrayBuildState *\naccumArrayResult(ArrayBuildState *astate,\n\t\t\t\t Datum dvalue, bool disnull,\n\t\t\t\t Oid element_type,\n\t\t\t\t MemoryContext rcontext)\n{\n\tMemoryContext oldcontext;\n\n\tif (astate == NULL)\n\t{\n\t\t/* First time through --- initialize */\n\t\tastate = initArrayResult(element_type, rcontext, true);\n\t}\n\telse\n\t{\n\t\tAssert(astate->element_type == element_type);\n\t}\n\n\toldcontext = MemoryContextSwitchTo(astate->mcontext);\n\n\t/* enlarge dvalues[]/dnulls[] if needed */\n\tif (astate->nelems >= astate->alen)\n\t{\n\t\tastate->alen *= 2;\n\t\tastate->dvalues = (Datum *)\n\t\t\trepalloc(astate->dvalues, astate->alen * sizeof(Datum));\n\t\tastate->dnulls = (bool *)\n\t\t\trepalloc(astate->dnulls, astate->alen * sizeof(bool));\n\t}\n\n\t/*\n\t * Ensure pass-by-ref stuff is copied into mcontext; and detoast it too if\n\t * it's varlena.  (You might think that detoasting is not needed here\n\t * because construct_md_array can detoast the array elements later.\n\t * However, we must not let construct_md_array modify the ArrayBuildState\n\t * because that would mean array_agg_finalfn damages its input, which is\n\t * verboten.  Also, this way frequently saves one copying step.)\n\t */\n\tif (!disnull && !astate->typbyval)\n\t{\n\t\tif (astate->typlen == -1)\n\t\t\tdvalue = PointerGetDatum(PG_DETOAST_DATUM_COPY(dvalue));\n\t\telse\n\t\t\tdvalue = datumCopy(dvalue, astate->typbyval, astate->typlen);\n\t}\n\n\tastate->dvalues[astate->nelems] = dvalue;\n\tastate->dnulls[astate->nelems] = disnull;\n\tastate->nelems++;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn astate;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 5103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "dvalue",
            "astate->typbyval",
            "astate->typlen"
          ],
          "line": 5096
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM_COPY(dvalue)"
          ],
          "line": 5094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM_COPY",
          "args": [
            "dvalue"
          ],
          "line": 5094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "astate->dnulls",
            "astate->alen * sizeof(bool)"
          ],
          "line": 5080
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "astate->mcontext"
          ],
          "line": 5071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "astate->element_type == element_type"
          ],
          "line": 5068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initArrayResult",
          "args": [
            "element_type",
            "rcontext",
            "true"
          ],
          "line": 5064
        },
        "resolved": true,
        "details": {
          "function_name": "initArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5479-5514",
          "snippet": "ArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildState *\naccumArrayResult(ArrayBuildState *astate,\n\t\t\t\t Datum dvalue, bool disnull,\n\t\t\t\t Oid element_type,\n\t\t\t\t MemoryContext rcontext)\n{\n\tMemoryContext oldcontext;\n\n\tif (astate == NULL)\n\t{\n\t\t/* First time through --- initialize */\n\t\tastate = initArrayResult(element_type, rcontext, true);\n\t}\n\telse\n\t{\n\t\tAssert(astate->element_type == element_type);\n\t}\n\n\toldcontext = MemoryContextSwitchTo(astate->mcontext);\n\n\t/* enlarge dvalues[]/dnulls[] if needed */\n\tif (astate->nelems >= astate->alen)\n\t{\n\t\tastate->alen *= 2;\n\t\tastate->dvalues = (Datum *)\n\t\t\trepalloc(astate->dvalues, astate->alen * sizeof(Datum));\n\t\tastate->dnulls = (bool *)\n\t\t\trepalloc(astate->dnulls, astate->alen * sizeof(bool));\n\t}\n\n\t/*\n\t * Ensure pass-by-ref stuff is copied into mcontext; and detoast it too if\n\t * it's varlena.  (You might think that detoasting is not needed here\n\t * because construct_md_array can detoast the array elements later.\n\t * However, we must not let construct_md_array modify the ArrayBuildState\n\t * because that would mean array_agg_finalfn damages its input, which is\n\t * verboten.  Also, this way frequently saves one copying step.)\n\t */\n\tif (!disnull && !astate->typbyval)\n\t{\n\t\tif (astate->typlen == -1)\n\t\t\tdvalue = PointerGetDatum(PG_DETOAST_DATUM_COPY(dvalue));\n\t\telse\n\t\t\tdvalue = datumCopy(dvalue, astate->typbyval, astate->typlen);\n\t}\n\n\tastate->dvalues[astate->nelems] = dvalue;\n\tastate->dnulls[astate->nelems] = disnull;\n\tastate->nelems++;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn astate;\n}"
  },
  {
    "function_name": "initArrayResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "5014-5043",
    "snippet": "ArrayBuildState *\ninitArrayResult(Oid element_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildState *astate;\n\tMemoryContext arr_context = rcontext;\n\n\t/* Make a temporary context to hold all the junk */\n\tif (subcontext)\n\t\tarr_context = AllocSetContextCreate(rcontext,\n\t\t\t\t\t\t\t\t\t\t\t\"accumArrayResult\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tastate = (ArrayBuildState *)\n\t\tMemoryContextAlloc(arr_context, sizeof(ArrayBuildState));\n\tastate->mcontext = arr_context;\n\tastate->private_cxt = subcontext;\n\tastate->alen = (subcontext ? 64 : 8);\t/* arbitrary starting array size */\n\tastate->dvalues = (Datum *)\n\t\tMemoryContextAlloc(arr_context, astate->alen * sizeof(Datum));\n\tastate->dnulls = (bool *)\n\t\tMemoryContextAlloc(arr_context, astate->alen * sizeof(bool));\n\tastate->nelems = 0;\n\tastate->element_type = element_type;\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &astate->typlen,\n\t\t\t\t\t\t &astate->typbyval,\n\t\t\t\t\t\t &astate->typalign);\n\n\treturn astate;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "element_type",
            "&astate->typlen",
            "&astate->typbyval",
            "&astate->typalign"
          ],
          "line": 5037
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "arr_context",
            "astate->alen * sizeof(bool)"
          ],
          "line": 5034
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "rcontext",
            "\"accumArrayResult\"",
            "ALLOCSET_DEFAULT_SIZES"
          ],
          "line": 5022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nArrayBuildState *\ninitArrayResult(Oid element_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildState *astate;\n\tMemoryContext arr_context = rcontext;\n\n\t/* Make a temporary context to hold all the junk */\n\tif (subcontext)\n\t\tarr_context = AllocSetContextCreate(rcontext,\n\t\t\t\t\t\t\t\t\t\t\t\"accumArrayResult\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\tastate = (ArrayBuildState *)\n\t\tMemoryContextAlloc(arr_context, sizeof(ArrayBuildState));\n\tastate->mcontext = arr_context;\n\tastate->private_cxt = subcontext;\n\tastate->alen = (subcontext ? 64 : 8);\t/* arbitrary starting array size */\n\tastate->dvalues = (Datum *)\n\t\tMemoryContextAlloc(arr_context, astate->alen * sizeof(Datum));\n\tastate->dnulls = (bool *)\n\t\tMemoryContextAlloc(arr_context, astate->alen * sizeof(bool));\n\tastate->nelems = 0;\n\tastate->element_type = element_type;\n\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t &astate->typlen,\n\t\t\t\t\t\t &astate->typbyval,\n\t\t\t\t\t\t &astate->typalign);\n\n\treturn astate;\n}"
  },
  {
    "function_name": "array_insert_slice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4891-4983",
    "snippet": "static void\narray_insert_slice(ArrayType *destArray,\n\t\t\t\t   ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim,\n\t\t\t\t   int *dim,\n\t\t\t\t   int *lb,\n\t\t\t\t   int *st,\n\t\t\t\t   int *endp,\n\t\t\t\t   int typlen,\n\t\t\t\t   bool typbyval,\n\t\t\t\t   char typalign)\n{\n\tchar\t   *destPtr = ARR_DATA_PTR(destArray);\n\tchar\t   *origPtr = ARR_DATA_PTR(origArray);\n\tchar\t   *srcPtr = ARR_DATA_PTR(srcArray);\n\tbits8\t   *destBitmap = ARR_NULLBITMAP(destArray);\n\tbits8\t   *origBitmap = ARR_NULLBITMAP(origArray);\n\tbits8\t   *srcBitmap = ARR_NULLBITMAP(srcArray);\n\tint\t\t\torignitems = ArrayGetNItems(ARR_NDIM(origArray),\n\t\t\t\t\t\t\t\t\t\t\tARR_DIMS(origArray));\n\tint\t\t\tdest_offset,\n\t\t\t\torig_offset,\n\t\t\t\tsrc_offset,\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\n\tdest_offset = ArrayGetOffset(ndim, dim, lb, st);\n\t/* copy items before the slice start */\n\tinc = array_copy(destPtr, dest_offset,\n\t\t\t\t\t origPtr, 0, origBitmap,\n\t\t\t\t\t typlen, typbyval, typalign);\n\tdestPtr += inc;\n\torigPtr += inc;\n\tif (destBitmap)\n\t\tarray_bitmap_copy(destBitmap, 0, origBitmap, 0, dest_offset);\n\torig_offset = dest_offset;\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_range(ndim, span, st, endp);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tsrc_offset = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\t/* Copy/advance over elements between here and next part of slice */\n\t\tif (dist[j])\n\t\t{\n\t\t\tinc = array_copy(destPtr, dist[j],\n\t\t\t\t\t\t\t origPtr, orig_offset, origBitmap,\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\t\tdestPtr += inc;\n\t\t\torigPtr += inc;\n\t\t\tif (destBitmap)\n\t\t\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t\t\t  origBitmap, orig_offset,\n\t\t\t\t\t\t\t\t  dist[j]);\n\t\t\tdest_offset += dist[j];\n\t\t\torig_offset += dist[j];\n\t\t}\n\t\t/* Copy new element at this slice position */\n\t\tinc = array_copy(destPtr, 1,\n\t\t\t\t\t\t srcPtr, src_offset, srcBitmap,\n\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\tif (destBitmap)\n\t\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t\t  srcBitmap, src_offset,\n\t\t\t\t\t\t\t  1);\n\t\tdestPtr += inc;\n\t\tsrcPtr += inc;\n\t\tdest_offset++;\n\t\tsrc_offset++;\n\t\t/* Advance over old element at this slice position */\n\t\torigPtr = array_seek(origPtr, orig_offset, origBitmap, 1,\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\torig_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n\n\t/* don't miss any data at the end */\n\tarray_copy(destPtr, orignitems - orig_offset,\n\t\t\t   origPtr, orig_offset, origBitmap,\n\t\t\t   typlen, typbyval, typalign);\n\tif (destBitmap)\n\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t  origBitmap, orig_offset,\n\t\t\t\t\t\t  orignitems - orig_offset);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_bitmap_copy",
          "args": [
            "destBitmap",
            "dest_offset",
            "origBitmap",
            "orig_offset",
            "orignitems - orig_offset"
          ],
          "line": 4980
        },
        "resolved": true,
        "details": {
          "function_name": "array_bitmap_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4687-4751",
          "snippet": "void\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_copy",
          "args": [
            "destPtr",
            "orignitems - orig_offset",
            "origPtr",
            "orig_offset",
            "origBitmap",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 4976
        },
        "resolved": true,
        "details": {
          "function_name": "array_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4657-4668",
          "snippet": "static int\narray_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tnumbytes;\n\n\tnumbytes = array_nelems_size(srcptr, offset, nullbitmap, nitems,\n\t\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\tmemcpy(destptr, srcptr, numbytes);\n\treturn numbytes;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\narray_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tnumbytes;\n\n\tnumbytes = array_nelems_size(srcptr, offset, nullbitmap, nitems,\n\t\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\tmemcpy(destptr, srcptr, numbytes);\n\treturn numbytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_next_tuple",
          "args": [
            "ndim",
            "indx",
            "span"
          ],
          "line": 4973
        },
        "resolved": true,
        "details": {
          "function_name": "mda_next_tuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "174-192",
          "snippet": "int\nmda_next_tuple(int n, int *curr, const int *span)\n{\n\tint\t\t\ti;\n\n\tif (n <= 0)\n\t\treturn -1;\n\n\tcurr[n - 1] = (curr[n - 1] + 1) % span[n - 1];\n\tfor (i = n - 1; i && curr[i] == 0; i--)\n\t\tcurr[i - 1] = (curr[i - 1] + 1) % span[i - 1];\n\n\tif (i)\n\t\treturn i;\n\tif (curr[0])\n\t\treturn 0;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nmda_next_tuple(int n, int *curr, const int *span)\n{\n\tint\t\t\ti;\n\n\tif (n <= 0)\n\t\treturn -1;\n\n\tcurr[n - 1] = (curr[n - 1] + 1) % span[n - 1];\n\tfor (i = n - 1; i && curr[i] == 0; i--)\n\t\tcurr[i - 1] = (curr[i - 1] + 1) % span[i - 1];\n\n\tif (i)\n\t\treturn i;\n\tif (curr[0])\n\t\treturn 0;\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_seek",
          "args": [
            "origPtr",
            "orig_offset",
            "origBitmap",
            "1",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 4970
        },
        "resolved": true,
        "details": {
          "function_name": "array_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4587-4628",
          "snippet": "static char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_get_offset_values",
          "args": [
            "ndim",
            "dist",
            "prod",
            "span"
          ],
          "line": 4935
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_offset_values",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "149-162",
          "snippet": "void\nmda_get_offset_values(int n, int *dist, const int *prod, const int *span)\n{\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdist[n - 1] = 0;\n\tfor (j = n - 2; j >= 0; j--)\n\t{\n\t\tdist[j] = prod[j] - 1;\n\t\tfor (i = j + 1; i < n; i++)\n\t\t\tdist[j] -= (span[i] - 1) * prod[i];\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_offset_values(int n, int *dist, const int *prod, const int *span)\n{\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdist[n - 1] = 0;\n\tfor (j = n - 2; j >= 0; j--)\n\t{\n\t\tdist[j] = prod[j] - 1;\n\t\tfor (i = j + 1; i < n; i++)\n\t\t\tdist[j] -= (span[i] - 1) * prod[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_get_range",
          "args": [
            "ndim",
            "span",
            "st",
            "endp"
          ],
          "line": 4934
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "119-126",
          "snippet": "void\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_get_prod",
          "args": [
            "ndim",
            "dim",
            "prod"
          ],
          "line": 4933
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_prod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "133-141",
          "snippet": "void\nmda_get_prod(int n, const int *range, int *prod)\n{\n\tint\t\t\ti;\n\n\tprod[n - 1] = 1;\n\tfor (i = n - 2; i >= 0; i--)\n\t\tprod[i] = prod[i + 1] * range[i + 1];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_prod(int n, const int *range, int *prod)\n{\n\tint\t\t\ti;\n\n\tprod[n - 1] = 1;\n\tfor (i = n - 2; i >= 0; i--)\n\t\tprod[i] = prod[i + 1] * range[i + 1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetOffset",
          "args": [
            "ndim",
            "dim",
            "lb",
            "st"
          ],
          "line": 4923
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "30-43",
          "snippet": "int\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ARR_NDIM(origArray)",
            "ARR_DIMS(origArray)"
          ],
          "line": 4910
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "origArray"
          ],
          "line": 4911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "origArray"
          ],
          "line": 4910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "srcArray"
          ],
          "line": 4909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "origArray"
          ],
          "line": 4908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "destArray"
          ],
          "line": 4907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "srcArray"
          ],
          "line": 4906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "origArray"
          ],
          "line": 4905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "destArray"
          ],
          "line": 4904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic void\narray_insert_slice(ArrayType *destArray,\n\t\t\t\t   ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim,\n\t\t\t\t   int *dim,\n\t\t\t\t   int *lb,\n\t\t\t\t   int *st,\n\t\t\t\t   int *endp,\n\t\t\t\t   int typlen,\n\t\t\t\t   bool typbyval,\n\t\t\t\t   char typalign)\n{\n\tchar\t   *destPtr = ARR_DATA_PTR(destArray);\n\tchar\t   *origPtr = ARR_DATA_PTR(origArray);\n\tchar\t   *srcPtr = ARR_DATA_PTR(srcArray);\n\tbits8\t   *destBitmap = ARR_NULLBITMAP(destArray);\n\tbits8\t   *origBitmap = ARR_NULLBITMAP(origArray);\n\tbits8\t   *srcBitmap = ARR_NULLBITMAP(srcArray);\n\tint\t\t\torignitems = ArrayGetNItems(ARR_NDIM(origArray),\n\t\t\t\t\t\t\t\t\t\t\tARR_DIMS(origArray));\n\tint\t\t\tdest_offset,\n\t\t\t\torig_offset,\n\t\t\t\tsrc_offset,\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\n\tdest_offset = ArrayGetOffset(ndim, dim, lb, st);\n\t/* copy items before the slice start */\n\tinc = array_copy(destPtr, dest_offset,\n\t\t\t\t\t origPtr, 0, origBitmap,\n\t\t\t\t\t typlen, typbyval, typalign);\n\tdestPtr += inc;\n\torigPtr += inc;\n\tif (destBitmap)\n\t\tarray_bitmap_copy(destBitmap, 0, origBitmap, 0, dest_offset);\n\torig_offset = dest_offset;\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_range(ndim, span, st, endp);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tsrc_offset = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\t/* Copy/advance over elements between here and next part of slice */\n\t\tif (dist[j])\n\t\t{\n\t\t\tinc = array_copy(destPtr, dist[j],\n\t\t\t\t\t\t\t origPtr, orig_offset, origBitmap,\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\t\tdestPtr += inc;\n\t\t\torigPtr += inc;\n\t\t\tif (destBitmap)\n\t\t\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t\t\t  origBitmap, orig_offset,\n\t\t\t\t\t\t\t\t  dist[j]);\n\t\t\tdest_offset += dist[j];\n\t\t\torig_offset += dist[j];\n\t\t}\n\t\t/* Copy new element at this slice position */\n\t\tinc = array_copy(destPtr, 1,\n\t\t\t\t\t\t srcPtr, src_offset, srcBitmap,\n\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\tif (destBitmap)\n\t\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t\t  srcBitmap, src_offset,\n\t\t\t\t\t\t\t  1);\n\t\tdestPtr += inc;\n\t\tsrcPtr += inc;\n\t\tdest_offset++;\n\t\tsrc_offset++;\n\t\t/* Advance over old element at this slice position */\n\t\torigPtr = array_seek(origPtr, orig_offset, origBitmap, 1,\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\torig_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n\n\t/* don't miss any data at the end */\n\tarray_copy(destPtr, orignitems - orig_offset,\n\t\t\t   origPtr, orig_offset, origBitmap,\n\t\t\t   typlen, typbyval, typalign);\n\tif (destBitmap)\n\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t  origBitmap, orig_offset,\n\t\t\t\t\t\t  orignitems - orig_offset);\n}"
  },
  {
    "function_name": "array_extract_slice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4818-4876",
    "snippet": "static void\narray_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim,\n\t\t\t\t\tint *dim,\n\t\t\t\t\tint *lb,\n\t\t\t\t\tchar *arraydataptr,\n\t\t\t\t\tbits8 *arraynullsptr,\n\t\t\t\t\tint *st,\n\t\t\t\t\tint *endp,\n\t\t\t\t\tint typlen,\n\t\t\t\t\tbool typbyval,\n\t\t\t\t\tchar typalign)\n{\n\tchar\t   *destdataptr = ARR_DATA_PTR(newarray);\n\tbits8\t   *destnullsptr = ARR_NULLBITMAP(newarray);\n\tchar\t   *srcdataptr;\n\tint\t\t\tsrc_offset,\n\t\t\t\tdest_offset,\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\n\tsrc_offset = ArrayGetOffset(ndim, dim, lb, st);\n\tsrcdataptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,\n\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_range(ndim, span, st, endp);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tdest_offset = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\tif (dist[j])\n\t\t{\n\t\t\t/* skip unwanted elements */\n\t\t\tsrcdataptr = array_seek(srcdataptr, src_offset, arraynullsptr,\n\t\t\t\t\t\t\t\t\tdist[j],\n\t\t\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\t\t\tsrc_offset += dist[j];\n\t\t}\n\t\tinc = array_copy(destdataptr, 1,\n\t\t\t\t\t\t srcdataptr, src_offset, arraynullsptr,\n\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\tif (destnullsptr)\n\t\t\tarray_bitmap_copy(destnullsptr, dest_offset,\n\t\t\t\t\t\t\t  arraynullsptr, src_offset,\n\t\t\t\t\t\t\t  1);\n\t\tdestdataptr += inc;\n\t\tsrcdataptr += inc;\n\t\tsrc_offset++;\n\t\tdest_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mda_next_tuple",
          "args": [
            "ndim",
            "indx",
            "span"
          ],
          "line": 4875
        },
        "resolved": true,
        "details": {
          "function_name": "mda_next_tuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "174-192",
          "snippet": "int\nmda_next_tuple(int n, int *curr, const int *span)\n{\n\tint\t\t\ti;\n\n\tif (n <= 0)\n\t\treturn -1;\n\n\tcurr[n - 1] = (curr[n - 1] + 1) % span[n - 1];\n\tfor (i = n - 1; i && curr[i] == 0; i--)\n\t\tcurr[i - 1] = (curr[i - 1] + 1) % span[i - 1];\n\n\tif (i)\n\t\treturn i;\n\tif (curr[0])\n\t\treturn 0;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nmda_next_tuple(int n, int *curr, const int *span)\n{\n\tint\t\t\ti;\n\n\tif (n <= 0)\n\t\treturn -1;\n\n\tcurr[n - 1] = (curr[n - 1] + 1) % span[n - 1];\n\tfor (i = n - 1; i && curr[i] == 0; i--)\n\t\tcurr[i - 1] = (curr[i - 1] + 1) % span[i - 1];\n\n\tif (i)\n\t\treturn i;\n\tif (curr[0])\n\t\treturn 0;\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_bitmap_copy",
          "args": [
            "destnullsptr",
            "dest_offset",
            "arraynullsptr",
            "src_offset",
            "1"
          ],
          "line": 4868
        },
        "resolved": true,
        "details": {
          "function_name": "array_bitmap_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4687-4751",
          "snippet": "void\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_copy",
          "args": [
            "destdataptr",
            "1",
            "srcdataptr",
            "src_offset",
            "arraynullsptr",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 4864
        },
        "resolved": true,
        "details": {
          "function_name": "array_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4657-4668",
          "snippet": "static int\narray_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tnumbytes;\n\n\tnumbytes = array_nelems_size(srcptr, offset, nullbitmap, nitems,\n\t\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\tmemcpy(destptr, srcptr, numbytes);\n\treturn numbytes;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\narray_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tnumbytes;\n\n\tnumbytes = array_nelems_size(srcptr, offset, nullbitmap, nitems,\n\t\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\tmemcpy(destptr, srcptr, numbytes);\n\treturn numbytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_seek",
          "args": [
            "srcdataptr",
            "src_offset",
            "arraynullsptr",
            "dist[j]",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 4859
        },
        "resolved": true,
        "details": {
          "function_name": "array_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4587-4628",
          "snippet": "static char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_get_offset_values",
          "args": [
            "ndim",
            "dist",
            "prod",
            "span"
          ],
          "line": 4849
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_offset_values",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "149-162",
          "snippet": "void\nmda_get_offset_values(int n, int *dist, const int *prod, const int *span)\n{\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdist[n - 1] = 0;\n\tfor (j = n - 2; j >= 0; j--)\n\t{\n\t\tdist[j] = prod[j] - 1;\n\t\tfor (i = j + 1; i < n; i++)\n\t\t\tdist[j] -= (span[i] - 1) * prod[i];\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_offset_values(int n, int *dist, const int *prod, const int *span)\n{\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdist[n - 1] = 0;\n\tfor (j = n - 2; j >= 0; j--)\n\t{\n\t\tdist[j] = prod[j] - 1;\n\t\tfor (i = j + 1; i < n; i++)\n\t\t\tdist[j] -= (span[i] - 1) * prod[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_get_range",
          "args": [
            "ndim",
            "span",
            "st",
            "endp"
          ],
          "line": 4848
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "119-126",
          "snippet": "void\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_get_prod",
          "args": [
            "ndim",
            "dim",
            "prod"
          ],
          "line": 4847
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_prod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "133-141",
          "snippet": "void\nmda_get_prod(int n, const int *range, int *prod)\n{\n\tint\t\t\ti;\n\n\tprod[n - 1] = 1;\n\tfor (i = n - 2; i >= 0; i--)\n\t\tprod[i] = prod[i + 1] * range[i + 1];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_prod(int n, const int *range, int *prod)\n{\n\tint\t\t\ti;\n\n\tprod[n - 1] = 1;\n\tfor (i = n - 2; i >= 0; i--)\n\t\tprod[i] = prod[i + 1] * range[i + 1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetOffset",
          "args": [
            "ndim",
            "dim",
            "lb",
            "st"
          ],
          "line": 4844
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "30-43",
          "snippet": "int\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "newarray"
          ],
          "line": 4832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "newarray"
          ],
          "line": 4831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic void\narray_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim,\n\t\t\t\t\tint *dim,\n\t\t\t\t\tint *lb,\n\t\t\t\t\tchar *arraydataptr,\n\t\t\t\t\tbits8 *arraynullsptr,\n\t\t\t\t\tint *st,\n\t\t\t\t\tint *endp,\n\t\t\t\t\tint typlen,\n\t\t\t\t\tbool typbyval,\n\t\t\t\t\tchar typalign)\n{\n\tchar\t   *destdataptr = ARR_DATA_PTR(newarray);\n\tbits8\t   *destnullsptr = ARR_NULLBITMAP(newarray);\n\tchar\t   *srcdataptr;\n\tint\t\t\tsrc_offset,\n\t\t\t\tdest_offset,\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\n\tsrc_offset = ArrayGetOffset(ndim, dim, lb, st);\n\tsrcdataptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,\n\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_range(ndim, span, st, endp);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tdest_offset = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\tif (dist[j])\n\t\t{\n\t\t\t/* skip unwanted elements */\n\t\t\tsrcdataptr = array_seek(srcdataptr, src_offset, arraynullsptr,\n\t\t\t\t\t\t\t\t\tdist[j],\n\t\t\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\t\t\tsrc_offset += dist[j];\n\t\t}\n\t\tinc = array_copy(destdataptr, 1,\n\t\t\t\t\t\t srcdataptr, src_offset, arraynullsptr,\n\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\tif (destnullsptr)\n\t\t\tarray_bitmap_copy(destnullsptr, dest_offset,\n\t\t\t\t\t\t\t  arraynullsptr, src_offset,\n\t\t\t\t\t\t\t  1);\n\t\tdestdataptr += inc;\n\t\tsrcdataptr += inc;\n\t\tsrc_offset++;\n\t\tdest_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n}"
  },
  {
    "function_name": "array_slice_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4758-4808",
    "snippet": "static int\narray_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tsrc_offset,\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tchar\t   *ptr;\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\tint\t\t\tcount = 0;\n\n\tmda_get_range(ndim, span, st, endp);\n\n\t/* Pretty easy for fixed element length without nulls ... */\n\tif (typlen > 0 && !arraynullsptr)\n\t\treturn ArrayGetNItems(ndim, span) * att_align_nominal(typlen, typalign);\n\n\t/* Else gotta do it the hard way */\n\tsrc_offset = ArrayGetOffset(ndim, dim, lb, st);\n\tptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,\n\t\t\t\t\t typlen, typbyval, typalign);\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\tif (dist[j])\n\t\t{\n\t\t\tptr = array_seek(ptr, src_offset, arraynullsptr, dist[j],\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\t\tsrc_offset += dist[j];\n\t\t}\n\t\tif (!array_get_isnull(arraynullsptr, src_offset))\n\t\t{\n\t\t\tinc = att_addlength_pointer(0, typlen, ptr);\n\t\t\tinc = att_align_nominal(inc, typalign);\n\t\t\tptr += inc;\n\t\t\tcount += inc;\n\t\t}\n\t\tsrc_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n\treturn count;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mda_next_tuple",
          "args": [
            "ndim",
            "indx",
            "span"
          ],
          "line": 4806
        },
        "resolved": true,
        "details": {
          "function_name": "mda_next_tuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "174-192",
          "snippet": "int\nmda_next_tuple(int n, int *curr, const int *span)\n{\n\tint\t\t\ti;\n\n\tif (n <= 0)\n\t\treturn -1;\n\n\tcurr[n - 1] = (curr[n - 1] + 1) % span[n - 1];\n\tfor (i = n - 1; i && curr[i] == 0; i--)\n\t\tcurr[i - 1] = (curr[i - 1] + 1) % span[i - 1];\n\n\tif (i)\n\t\treturn i;\n\tif (curr[0])\n\t\treturn 0;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nmda_next_tuple(int n, int *curr, const int *span)\n{\n\tint\t\t\ti;\n\n\tif (n <= 0)\n\t\treturn -1;\n\n\tcurr[n - 1] = (curr[n - 1] + 1) % span[n - 1];\n\tfor (i = n - 1; i && curr[i] == 0; i--)\n\t\tcurr[i - 1] = (curr[i - 1] + 1) % span[i - 1];\n\n\tif (i)\n\t\treturn i;\n\tif (curr[0])\n\t\treturn 0;\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "inc",
            "typalign"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "0",
            "typlen",
            "ptr"
          ],
          "line": 4800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_get_isnull",
          "args": [
            "arraynullsptr",
            "src_offset"
          ],
          "line": 4798
        },
        "resolved": true,
        "details": {
          "function_name": "array_get_isnull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4502-4510",
          "snippet": "static bool\narray_get_isnull(const bits8 *nullbitmap, int offset)\n{\n\tif (nullbitmap == NULL)\n\t\treturn false;\t\t\t/* assume not null */\n\tif (nullbitmap[offset / 8] & (1 << (offset % 8)))\n\t\treturn false;\t\t\t/* not null */\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\n\nstatic bool\narray_get_isnull(const bits8 *nullbitmap, int offset)\n{\n\tif (nullbitmap == NULL)\n\t\treturn false;\t\t\t/* assume not null */\n\tif (nullbitmap[offset / 8] & (1 << (offset % 8)))\n\t\treturn false;\t\t\t/* not null */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_seek",
          "args": [
            "ptr",
            "src_offset",
            "arraynullsptr",
            "dist[j]",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 4794
        },
        "resolved": true,
        "details": {
          "function_name": "array_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4587-4628",
          "snippet": "static char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_get_offset_values",
          "args": [
            "ndim",
            "dist",
            "prod",
            "span"
          ],
          "line": 4786
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_offset_values",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "149-162",
          "snippet": "void\nmda_get_offset_values(int n, int *dist, const int *prod, const int *span)\n{\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdist[n - 1] = 0;\n\tfor (j = n - 2; j >= 0; j--)\n\t{\n\t\tdist[j] = prod[j] - 1;\n\t\tfor (i = j + 1; i < n; i++)\n\t\t\tdist[j] -= (span[i] - 1) * prod[i];\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_offset_values(int n, int *dist, const int *prod, const int *span)\n{\n\tint\t\t\ti,\n\t\t\t\tj;\n\n\tdist[n - 1] = 0;\n\tfor (j = n - 2; j >= 0; j--)\n\t{\n\t\tdist[j] = prod[j] - 1;\n\t\tfor (i = j + 1; i < n; i++)\n\t\t\tdist[j] -= (span[i] - 1) * prod[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_get_prod",
          "args": [
            "ndim",
            "dim",
            "prod"
          ],
          "line": 4785
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_prod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "133-141",
          "snippet": "void\nmda_get_prod(int n, const int *range, int *prod)\n{\n\tint\t\t\ti;\n\n\tprod[n - 1] = 1;\n\tfor (i = n - 2; i >= 0; i--)\n\t\tprod[i] = prod[i + 1] * range[i + 1];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_prod(int n, const int *range, int *prod)\n{\n\tint\t\t\ti;\n\n\tprod[n - 1] = 1;\n\tfor (i = n - 2; i >= 0; i--)\n\t\tprod[i] = prod[i + 1] * range[i + 1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetOffset",
          "args": [
            "ndim",
            "dim",
            "lb",
            "st"
          ],
          "line": 4782
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "30-43",
          "snippet": "int\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "typlen",
            "typalign"
          ],
          "line": 4779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "span"
          ],
          "line": 4779
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_get_range",
          "args": [
            "ndim",
            "span",
            "st",
            "endp"
          ],
          "line": 4775
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "119-126",
          "snippet": "void\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\narray_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tsrc_offset,\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tchar\t   *ptr;\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\tint\t\t\tcount = 0;\n\n\tmda_get_range(ndim, span, st, endp);\n\n\t/* Pretty easy for fixed element length without nulls ... */\n\tif (typlen > 0 && !arraynullsptr)\n\t\treturn ArrayGetNItems(ndim, span) * att_align_nominal(typlen, typalign);\n\n\t/* Else gotta do it the hard way */\n\tsrc_offset = ArrayGetOffset(ndim, dim, lb, st);\n\tptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,\n\t\t\t\t\t typlen, typbyval, typalign);\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\tif (dist[j])\n\t\t{\n\t\t\tptr = array_seek(ptr, src_offset, arraynullsptr, dist[j],\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\t\tsrc_offset += dist[j];\n\t\t}\n\t\tif (!array_get_isnull(arraynullsptr, src_offset))\n\t\t{\n\t\t\tinc = att_addlength_pointer(0, typlen, ptr);\n\t\t\tinc = att_align_nominal(inc, typalign);\n\t\t\tptr += inc;\n\t\t\tcount += inc;\n\t\t}\n\t\tsrc_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n\treturn count;\n}"
  },
  {
    "function_name": "array_bitmap_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4687-4751",
    "snippet": "void\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "destbitmap"
          ],
          "line": 4697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}"
  },
  {
    "function_name": "array_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4657-4668",
    "snippet": "static int\narray_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tnumbytes;\n\n\tnumbytes = array_nelems_size(srcptr, offset, nullbitmap, nitems,\n\t\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\tmemcpy(destptr, srcptr, numbytes);\n\treturn numbytes;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "destptr",
            "srcptr",
            "numbytes"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_nelems_size",
          "args": [
            "srcptr",
            "offset",
            "nullbitmap",
            "nitems",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 4664
        },
        "resolved": true,
        "details": {
          "function_name": "array_nelems_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4635-4641",
          "snippet": "static int\narray_nelems_size(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t\t\t  int typlen, bool typbyval, char typalign)\n{\n\treturn array_seek(ptr, offset, nullbitmap, nitems,\n\t\t\t\t\t  typlen, typbyval, typalign) - ptr;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\narray_nelems_size(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t\t\t  int typlen, bool typbyval, char typalign)\n{\n\treturn array_seek(ptr, offset, nullbitmap, nitems,\n\t\t\t\t\t  typlen, typbyval, typalign) - ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\narray_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tnumbytes;\n\n\tnumbytes = array_nelems_size(srcptr, offset, nullbitmap, nitems,\n\t\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\tmemcpy(destptr, srcptr, numbytes);\n\treturn numbytes;\n}"
  },
  {
    "function_name": "array_nelems_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4635-4641",
    "snippet": "static int\narray_nelems_size(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t\t\t  int typlen, bool typbyval, char typalign)\n{\n\treturn array_seek(ptr, offset, nullbitmap, nitems,\n\t\t\t\t\t  typlen, typbyval, typalign) - ptr;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_seek",
          "args": [
            "ptr",
            "offset",
            "nullbitmap",
            "nitems",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 4639
        },
        "resolved": true,
        "details": {
          "function_name": "array_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4587-4628",
          "snippet": "static char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\narray_nelems_size(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t\t\t  int typlen, bool typbyval, char typalign)\n{\n\treturn array_seek(ptr, offset, nullbitmap, nitems,\n\t\t\t\t\t  typlen, typbyval, typalign) - ptr;\n}"
  },
  {
    "function_name": "array_seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4587-4628",
    "snippet": "static char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "ptr",
            "typalign"
          ],
          "line": 4624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "ptr",
            "typlen",
            "ptr"
          ],
          "line": 4623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "ptr",
            "typalign"
          ],
          "line": 4609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "ptr",
            "typlen",
            "ptr"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "typlen",
            "typalign"
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}"
  },
  {
    "function_name": "ArrayCastAndSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4548-4574",
    "snippet": "static int\nArrayCastAndSet(Datum src,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tchar *dest)\n{\n\tint\t\t\tinc;\n\n\tif (typlen > 0)\n\t{\n\t\tif (typbyval)\n\t\t\tstore_att_byval(dest, src, typlen);\n\t\telse\n\t\t\tmemmove(dest, DatumGetPointer(src), typlen);\n\t\tinc = att_align_nominal(typlen, typalign);\n\t}\n\telse\n\t{\n\t\tAssert(!typbyval);\n\t\tinc = att_addlength_datum(0, typlen, src);\n\t\tmemmove(dest, DatumGetPointer(src), inc);\n\t\tinc = att_align_nominal(inc, typalign);\n\t}\n\n\treturn inc;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int ArrayCastAndSet(Datum src,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tchar *dest);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "inc",
            "typalign"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dest",
            "DatumGetPointer(src)",
            "inc"
          ],
          "line": 4569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "src"
          ],
          "line": 4569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "0",
            "typlen",
            "src"
          ],
          "line": 4568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!typbyval"
          ],
          "line": 4567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "typlen",
            "typalign"
          ],
          "line": 4563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dest",
            "DatumGetPointer(src)",
            "typlen"
          ],
          "line": 4562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "src"
          ],
          "line": 4562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_att_byval",
          "args": [
            "dest",
            "src",
            "typlen"
          ],
          "line": 4560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int ArrayCastAndSet(Datum src,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tchar *dest);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\nArrayCastAndSet(Datum src,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tchar *dest)\n{\n\tint\t\t\tinc;\n\n\tif (typlen > 0)\n\t{\n\t\tif (typbyval)\n\t\t\tstore_att_byval(dest, src, typlen);\n\t\telse\n\t\t\tmemmove(dest, DatumGetPointer(src), typlen);\n\t\tinc = att_align_nominal(typlen, typalign);\n\t}\n\telse\n\t{\n\t\tAssert(!typbyval);\n\t\tinc = att_addlength_datum(0, typlen, src);\n\t\tmemmove(dest, DatumGetPointer(src), inc);\n\t\tinc = att_align_nominal(inc, typalign);\n\t}\n\n\treturn inc;\n}"
  },
  {
    "function_name": "ArrayCast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4537-4541",
    "snippet": "static Datum\nArrayCast(char *value, bool byval, int len)\n{\n\treturn fetch_att(value, byval, len);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum ArrayCast(char *value, bool byval, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fetch_att",
          "args": [
            "value",
            "byval",
            "len"
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum ArrayCast(char *value, bool byval, int len);\n\nstatic Datum\nArrayCast(char *value, bool byval, int len)\n{\n\treturn fetch_att(value, byval, len);\n}"
  },
  {
    "function_name": "array_set_isnull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4519-4530",
    "snippet": "static void\narray_set_isnull(bits8 *nullbitmap, int offset, bool isNull)\n{\n\tint\t\t\tbitmask;\n\n\tnullbitmap += offset / 8;\n\tbitmask = 1 << (offset % 8);\n\tif (isNull)\n\t\t*nullbitmap &= ~bitmask;\n\telse\n\t\t*nullbitmap |= bitmask;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
      "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
      "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\n\nstatic void\narray_set_isnull(bits8 *nullbitmap, int offset, bool isNull)\n{\n\tint\t\t\tbitmask;\n\n\tnullbitmap += offset / 8;\n\tbitmask = 1 << (offset % 8);\n\tif (isNull)\n\t\t*nullbitmap &= ~bitmask;\n\telse\n\t\t*nullbitmap |= bitmask;\n}"
  },
  {
    "function_name": "array_get_isnull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4502-4510",
    "snippet": "static bool\narray_get_isnull(const bits8 *nullbitmap, int offset)\n{\n\tif (nullbitmap == NULL)\n\t\treturn false;\t\t\t/* assume not null */\n\tif (nullbitmap[offset / 8] & (1 << (offset % 8)))\n\t\treturn false;\t\t\t/* not null */\n\treturn true;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool array_get_isnull(const bits8 *nullbitmap, int offset);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\n\nstatic bool\narray_get_isnull(const bits8 *nullbitmap, int offset)\n{\n\tif (nullbitmap == NULL)\n\t\treturn false;\t\t\t/* assume not null */\n\tif (nullbitmap[offset / 8] & (1 << (offset % 8)))\n\t\treturn false;\t\t\t/* not null */\n\treturn true;\n}"
  },
  {
    "function_name": "array_free_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4480-4489",
    "snippet": "void\narray_free_iterator(ArrayIterator iterator)\n{\n\tif (iterator->slice_ndim > 0)\n\t{\n\t\tpfree(iterator->slice_values);\n\t\tpfree(iterator->slice_nulls);\n\t}\n\tpfree(iterator);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "iterator"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_free_iterator(ArrayIterator iterator)\n{\n\tif (iterator->slice_ndim > 0)\n\t{\n\t\tpfree(iterator->slice_values);\n\t\tpfree(iterator->slice_nulls);\n\t}\n\tpfree(iterator);\n}"
  },
  {
    "function_name": "array_iterate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4397-4475",
    "snippet": "bool\narray_iterate(ArrayIterator iterator, Datum *value, bool *isnull)\n{\n\t/* Done if we have reached the end of the array */\n\tif (iterator->current_item >= iterator->nitems)\n\t\treturn false;\n\n\tif (iterator->slice_ndim == 0)\n\t{\n\t\t/*\n\t\t * Scalar case: return one element.\n\t\t */\n\t\tif (array_get_isnull(iterator->nullbitmap, iterator->current_item++))\n\t\t{\n\t\t\t*isnull = true;\n\t\t\t*value = (Datum) 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* non-NULL, so fetch the individual Datum to return */\n\t\t\tchar\t   *p = iterator->data_ptr;\n\n\t\t\t*isnull = false;\n\t\t\t*value = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t/* Move our data pointer forward to the next element */\n\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\titerator->data_ptr = p;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Slice case: build and return an array of the requested size.\n\t\t */\n\t\tArrayType  *result;\n\t\tDatum\t   *values = iterator->slice_values;\n\t\tbool\t   *nulls = iterator->slice_nulls;\n\t\tchar\t   *p = iterator->data_ptr;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < iterator->slice_len; i++)\n\t\t{\n\t\t\tif (array_get_isnull(iterator->nullbitmap,\n\t\t\t\t\t\t\t\t iterator->current_item++))\n\t\t\t{\n\t\t\t\tnulls[i] = true;\n\t\t\t\tvalues[i] = (Datum) 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnulls[i] = false;\n\t\t\t\tvalues[i] = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t\t/* Move our data pointer forward to the next element */\n\t\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\t}\n\t\t}\n\n\t\titerator->data_ptr = p;\n\n\t\tresult = construct_md_array(values,\n\t\t\t\t\t\t\t\t\tnulls,\n\t\t\t\t\t\t\t\t\titerator->slice_ndim,\n\t\t\t\t\t\t\t\t\titerator->slice_dims,\n\t\t\t\t\t\t\t\t\titerator->slice_lbound,\n\t\t\t\t\t\t\t\t\tARR_ELEMTYPE(iterator->arr),\n\t\t\t\t\t\t\t\t\titerator->typlen,\n\t\t\t\t\t\t\t\t\titerator->typbyval,\n\t\t\t\t\t\t\t\t\titerator->typalign);\n\n\t\t*isnull = false;\n\t\t*value = PointerGetDatum(result);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "result"
          ],
          "line": 4471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_md_array",
          "args": [
            "values",
            "nulls",
            "iterator->slice_ndim",
            "iterator->slice_dims",
            "iterator->slice_lbound",
            "ARR_ELEMTYPE(iterator->arr)",
            "iterator->typlen",
            "iterator->typbyval",
            "iterator->typalign"
          ],
          "line": 4460
        },
        "resolved": true,
        "details": {
          "function_name": "construct_md_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3325-3404",
          "snippet": "ArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "iterator->arr"
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "p",
            "iterator->typalign"
          ],
          "line": 4454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "p",
            "iterator->typlen",
            "p"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_att",
          "args": [
            "p",
            "iterator->typbyval",
            "iterator->typlen"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_get_isnull",
          "args": [
            "iterator->nullbitmap",
            "iterator->current_item++"
          ],
          "line": 4441
        },
        "resolved": true,
        "details": {
          "function_name": "array_get_isnull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4502-4510",
          "snippet": "static bool\narray_get_isnull(const bits8 *nullbitmap, int offset)\n{\n\tif (nullbitmap == NULL)\n\t\treturn false;\t\t\t/* assume not null */\n\tif (nullbitmap[offset / 8] & (1 << (offset % 8)))\n\t\treturn false;\t\t\t/* not null */\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\n\nstatic bool\narray_get_isnull(const bits8 *nullbitmap, int offset)\n{\n\tif (nullbitmap == NULL)\n\t\treturn false;\t\t\t/* assume not null */\n\tif (nullbitmap[offset / 8] & (1 << (offset % 8)))\n\t\treturn false;\t\t\t/* not null */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "p",
            "iterator->typalign"
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "p",
            "iterator->typlen",
            "p"
          ],
          "line": 4423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_att",
          "args": [
            "p",
            "iterator->typbyval",
            "iterator->typlen"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nbool\narray_iterate(ArrayIterator iterator, Datum *value, bool *isnull)\n{\n\t/* Done if we have reached the end of the array */\n\tif (iterator->current_item >= iterator->nitems)\n\t\treturn false;\n\n\tif (iterator->slice_ndim == 0)\n\t{\n\t\t/*\n\t\t * Scalar case: return one element.\n\t\t */\n\t\tif (array_get_isnull(iterator->nullbitmap, iterator->current_item++))\n\t\t{\n\t\t\t*isnull = true;\n\t\t\t*value = (Datum) 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* non-NULL, so fetch the individual Datum to return */\n\t\t\tchar\t   *p = iterator->data_ptr;\n\n\t\t\t*isnull = false;\n\t\t\t*value = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t/* Move our data pointer forward to the next element */\n\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\titerator->data_ptr = p;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Slice case: build and return an array of the requested size.\n\t\t */\n\t\tArrayType  *result;\n\t\tDatum\t   *values = iterator->slice_values;\n\t\tbool\t   *nulls = iterator->slice_nulls;\n\t\tchar\t   *p = iterator->data_ptr;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < iterator->slice_len; i++)\n\t\t{\n\t\t\tif (array_get_isnull(iterator->nullbitmap,\n\t\t\t\t\t\t\t\t iterator->current_item++))\n\t\t\t{\n\t\t\t\tnulls[i] = true;\n\t\t\t\tvalues[i] = (Datum) 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnulls[i] = false;\n\t\t\t\tvalues[i] = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t\t/* Move our data pointer forward to the next element */\n\t\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\t}\n\t\t}\n\n\t\titerator->data_ptr = p;\n\n\t\tresult = construct_md_array(values,\n\t\t\t\t\t\t\t\t\tnulls,\n\t\t\t\t\t\t\t\t\titerator->slice_ndim,\n\t\t\t\t\t\t\t\t\titerator->slice_dims,\n\t\t\t\t\t\t\t\t\titerator->slice_lbound,\n\t\t\t\t\t\t\t\t\tARR_ELEMTYPE(iterator->arr),\n\t\t\t\t\t\t\t\t\titerator->typlen,\n\t\t\t\t\t\t\t\t\titerator->typbyval,\n\t\t\t\t\t\t\t\t\titerator->typalign);\n\n\t\t*isnull = false;\n\t\t*value = PointerGetDatum(result);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "array_create_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4318-4389",
    "snippet": "ArrayIterator\narray_create_iterator(ArrayType *arr, int slice_ndim, ArrayMetaState *mstate)\n{\n\tArrayIterator iterator = palloc0(sizeof(ArrayIteratorData));\n\n\t/*\n\t * Sanity-check inputs --- caller should have got this right already\n\t */\n\tAssert(PointerIsValid(arr));\n\tif (slice_ndim < 0 || slice_ndim > ARR_NDIM(arr))\n\t\telog(ERROR, \"invalid arguments to array_create_iterator\");\n\n\t/*\n\t * Remember basic info about the array and its element type\n\t */\n\titerator->arr = arr;\n\titerator->nullbitmap = ARR_NULLBITMAP(arr);\n\titerator->nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));\n\n\tif (mstate != NULL)\n\t{\n\t\tAssert(mstate->element_type == ARR_ELEMTYPE(arr));\n\n\t\titerator->typlen = mstate->typlen;\n\t\titerator->typbyval = mstate->typbyval;\n\t\titerator->typalign = mstate->typalign;\n\t}\n\telse\n\t\tget_typlenbyvalalign(ARR_ELEMTYPE(arr),\n\t\t\t\t\t\t\t &iterator->typlen,\n\t\t\t\t\t\t\t &iterator->typbyval,\n\t\t\t\t\t\t\t &iterator->typalign);\n\n\t/*\n\t * Remember the slicing parameters.\n\t */\n\titerator->slice_ndim = slice_ndim;\n\n\tif (slice_ndim > 0)\n\t{\n\t\t/*\n\t\t * Get pointers into the array's dims and lbound arrays to represent\n\t\t * the dims/lbound arrays of a slice.  These are the same as the\n\t\t * rightmost N dimensions of the array.\n\t\t */\n\t\titerator->slice_dims = ARR_DIMS(arr) + ARR_NDIM(arr) - slice_ndim;\n\t\titerator->slice_lbound = ARR_LBOUND(arr) + ARR_NDIM(arr) - slice_ndim;\n\n\t\t/*\n\t\t * Compute number of elements in a slice.\n\t\t */\n\t\titerator->slice_len = ArrayGetNItems(slice_ndim,\n\t\t\t\t\t\t\t\t\t\t\t iterator->slice_dims);\n\n\t\t/*\n\t\t * Create workspace for building sub-arrays.\n\t\t */\n\t\titerator->slice_values = (Datum *)\n\t\t\tpalloc(iterator->slice_len * sizeof(Datum));\n\t\titerator->slice_nulls = (bool *)\n\t\t\tpalloc(iterator->slice_len * sizeof(bool));\n\t}\n\n\t/*\n\t * Initialize our data pointer and linear element number.  These will\n\t * advance through the array during array_iterate().\n\t */\n\titerator->data_ptr = ARR_DATA_PTR(arr);\n\titerator->current_item = 0;\n\n\treturn iterator;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "arr"
          ],
          "line": 4385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "iterator->slice_len * sizeof(bool)"
          ],
          "line": 4378
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "slice_ndim",
            "iterator->slice_dims"
          ],
          "line": 4369
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 4364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "arr"
          ],
          "line": 4364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "ARR_ELEMTYPE(arr)",
            "&iterator->typlen",
            "&iterator->typbyval",
            "&iterator->typalign"
          ],
          "line": 4346
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "mstate->element_type == ARR_ELEMTYPE(arr)"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 4339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "arr"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid arguments to array_create_iterator\""
          ],
          "line": 4328
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 4327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "PointerIsValid(arr)"
          ],
          "line": 4326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "arr"
          ],
          "line": 4326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(ArrayIteratorData)"
          ],
          "line": 4321
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nArrayIterator\narray_create_iterator(ArrayType *arr, int slice_ndim, ArrayMetaState *mstate)\n{\n\tArrayIterator iterator = palloc0(sizeof(ArrayIteratorData));\n\n\t/*\n\t * Sanity-check inputs --- caller should have got this right already\n\t */\n\tAssert(PointerIsValid(arr));\n\tif (slice_ndim < 0 || slice_ndim > ARR_NDIM(arr))\n\t\telog(ERROR, \"invalid arguments to array_create_iterator\");\n\n\t/*\n\t * Remember basic info about the array and its element type\n\t */\n\titerator->arr = arr;\n\titerator->nullbitmap = ARR_NULLBITMAP(arr);\n\titerator->nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));\n\n\tif (mstate != NULL)\n\t{\n\t\tAssert(mstate->element_type == ARR_ELEMTYPE(arr));\n\n\t\titerator->typlen = mstate->typlen;\n\t\titerator->typbyval = mstate->typbyval;\n\t\titerator->typalign = mstate->typalign;\n\t}\n\telse\n\t\tget_typlenbyvalalign(ARR_ELEMTYPE(arr),\n\t\t\t\t\t\t\t &iterator->typlen,\n\t\t\t\t\t\t\t &iterator->typbyval,\n\t\t\t\t\t\t\t &iterator->typalign);\n\n\t/*\n\t * Remember the slicing parameters.\n\t */\n\titerator->slice_ndim = slice_ndim;\n\n\tif (slice_ndim > 0)\n\t{\n\t\t/*\n\t\t * Get pointers into the array's dims and lbound arrays to represent\n\t\t * the dims/lbound arrays of a slice.  These are the same as the\n\t\t * rightmost N dimensions of the array.\n\t\t */\n\t\titerator->slice_dims = ARR_DIMS(arr) + ARR_NDIM(arr) - slice_ndim;\n\t\titerator->slice_lbound = ARR_LBOUND(arr) + ARR_NDIM(arr) - slice_ndim;\n\n\t\t/*\n\t\t * Compute number of elements in a slice.\n\t\t */\n\t\titerator->slice_len = ArrayGetNItems(slice_ndim,\n\t\t\t\t\t\t\t\t\t\t\t iterator->slice_dims);\n\n\t\t/*\n\t\t * Create workspace for building sub-arrays.\n\t\t */\n\t\titerator->slice_values = (Datum *)\n\t\t\tpalloc(iterator->slice_len * sizeof(Datum));\n\t\titerator->slice_nulls = (bool *)\n\t\t\tpalloc(iterator->slice_len * sizeof(bool));\n\t}\n\n\t/*\n\t * Initialize our data pointer and linear element number.  These will\n\t * advance through the array during array_iterate().\n\t */\n\titerator->data_ptr = ARR_DATA_PTR(arr);\n\titerator->current_item = 0;\n\n\treturn iterator;\n}"
  },
  {
    "function_name": "arraycontained",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4281-4297",
    "snippet": "Datum\narraycontained(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tbool\t\tresult;\n\n\tresult = array_contain_compare(array1, array2, collation, true,\n\t\t\t\t\t\t\t\t   &fcinfo->flinfo->fn_extra);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 4296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array2",
            "1"
          ],
          "line": 4294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array1",
            "0"
          ],
          "line": 4293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contain_compare",
          "args": [
            "array1",
            "array2",
            "collation",
            "true",
            "&fcinfo->flinfo->fn_extra"
          ],
          "line": 4289
        },
        "resolved": true,
        "details": {
          "function_name": "array_contain_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4102-4243",
          "snippet": "static bool\narray_contain_compare(AnyArrayType *array1, AnyArrayType *array2, Oid collation,\n\t\t\t\t\t  bool matchall, void **fn_extra)\n{\n\tbool\t\tresult = matchall;\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tTypeCacheEntry *typentry;\n\tint\t\t\tnelems1;\n\tDatum\t   *values2;\n\tbool\t   *nulls2;\n\tint\t\t\tnelems2;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tarray_iter\tit1;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.  The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) *fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t*fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Since we probably will need to scan array2 multiple times, it's\n\t * worthwhile to use deconstruct_array on it.  We scan array1 the hard way\n\t * however, since we very likely won't need to look at all of it.\n\t */\n\tif (VARATT_IS_EXPANDED_HEADER(array2))\n\t{\n\t\t/* This should be safe even if input is read-only */\n\t\tdeconstruct_expanded_array(&(array2->xpn));\n\t\tvalues2 = array2->xpn.dvalues;\n\t\tnulls2 = array2->xpn.dnulls;\n\t\tnelems2 = array2->xpn.nelems;\n\t}\n\telse\n\t\tdeconstruct_array(&(array2->flt),\n\t\t\t\t\t\t  element_type, typlen, typbyval, typalign,\n\t\t\t\t\t\t  &values2, &nulls2, &nelems2);\n\n\t/*\n\t * Apply the comparison operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tnelems1 = ArrayGetNItems(AARR_NDIM(array1), AARR_DIMS(array1));\n\tarray_iter_setup(&it1, array1);\n\n\tfor (i = 0; i < nelems1; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tbool\t\tisnull1;\n\n\t\t/* Get element, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We assume that the comparison operator is strict, so a NULL can't\n\t\t * match anything.  XXX this diverges from the \"NULL=NULL\" behavior of\n\t\t * array_eq, should we act like that?\n\t\t */\n\t\tif (isnull1)\n\t\t{\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < nelems2; j++)\n\t\t{\n\t\t\tDatum\t\telt2 = values2[j];\n\t\t\tbool\t\tisnull2 = nulls2 ? nulls2[j] : false;\n\t\t\tbool\t\toprresult;\n\n\t\t\tif (isnull2)\n\t\t\t\tcontinue;\t\t/* can't match */\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (oprresult)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < nelems2)\n\t\t{\n\t\t\t/* found a match for elt1 */\n\t\t\tif (!matchall)\n\t\t\t{\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no match for elt1 */\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic bool\narray_contain_compare(AnyArrayType *array1, AnyArrayType *array2, Oid collation,\n\t\t\t\t\t  bool matchall, void **fn_extra)\n{\n\tbool\t\tresult = matchall;\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tTypeCacheEntry *typentry;\n\tint\t\t\tnelems1;\n\tDatum\t   *values2;\n\tbool\t   *nulls2;\n\tint\t\t\tnelems2;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tarray_iter\tit1;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.  The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) *fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t*fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Since we probably will need to scan array2 multiple times, it's\n\t * worthwhile to use deconstruct_array on it.  We scan array1 the hard way\n\t * however, since we very likely won't need to look at all of it.\n\t */\n\tif (VARATT_IS_EXPANDED_HEADER(array2))\n\t{\n\t\t/* This should be safe even if input is read-only */\n\t\tdeconstruct_expanded_array(&(array2->xpn));\n\t\tvalues2 = array2->xpn.dvalues;\n\t\tnulls2 = array2->xpn.dnulls;\n\t\tnelems2 = array2->xpn.nelems;\n\t}\n\telse\n\t\tdeconstruct_array(&(array2->flt),\n\t\t\t\t\t\t  element_type, typlen, typbyval, typalign,\n\t\t\t\t\t\t  &values2, &nulls2, &nelems2);\n\n\t/*\n\t * Apply the comparison operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tnelems1 = ArrayGetNItems(AARR_NDIM(array1), AARR_DIMS(array1));\n\tarray_iter_setup(&it1, array1);\n\n\tfor (i = 0; i < nelems1; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tbool\t\tisnull1;\n\n\t\t/* Get element, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We assume that the comparison operator is strict, so a NULL can't\n\t\t * match anything.  XXX this diverges from the \"NULL=NULL\" behavior of\n\t\t * array_eq, should we act like that?\n\t\t */\n\t\tif (isnull1)\n\t\t{\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < nelems2; j++)\n\t\t{\n\t\t\tDatum\t\telt2 = values2[j];\n\t\t\tbool\t\tisnull2 = nulls2 ? nulls2[j] : false;\n\t\t\tbool\t\toprresult;\n\n\t\t\tif (isnull2)\n\t\t\t\tcontinue;\t\t/* can't match */\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (oprresult)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < nelems2)\n\t\t{\n\t\t\t/* found a match for elt1 */\n\t\t\tif (!matchall)\n\t\t\t{\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no match for elt1 */\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 4286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "1"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narraycontained(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tbool\t\tresult;\n\n\tresult = array_contain_compare(array1, array2, collation, true,\n\t\t\t\t\t\t\t\t   &fcinfo->flinfo->fn_extra);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "arraycontains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4263-4279",
    "snippet": "Datum\narraycontains(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tbool\t\tresult;\n\n\tresult = array_contain_compare(array2, array1, collation, true,\n\t\t\t\t\t\t\t\t   &fcinfo->flinfo->fn_extra);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 4278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array2",
            "1"
          ],
          "line": 4276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array1",
            "0"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contain_compare",
          "args": [
            "array2",
            "array1",
            "collation",
            "true",
            "&fcinfo->flinfo->fn_extra"
          ],
          "line": 4271
        },
        "resolved": true,
        "details": {
          "function_name": "array_contain_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4102-4243",
          "snippet": "static bool\narray_contain_compare(AnyArrayType *array1, AnyArrayType *array2, Oid collation,\n\t\t\t\t\t  bool matchall, void **fn_extra)\n{\n\tbool\t\tresult = matchall;\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tTypeCacheEntry *typentry;\n\tint\t\t\tnelems1;\n\tDatum\t   *values2;\n\tbool\t   *nulls2;\n\tint\t\t\tnelems2;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tarray_iter\tit1;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.  The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) *fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t*fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Since we probably will need to scan array2 multiple times, it's\n\t * worthwhile to use deconstruct_array on it.  We scan array1 the hard way\n\t * however, since we very likely won't need to look at all of it.\n\t */\n\tif (VARATT_IS_EXPANDED_HEADER(array2))\n\t{\n\t\t/* This should be safe even if input is read-only */\n\t\tdeconstruct_expanded_array(&(array2->xpn));\n\t\tvalues2 = array2->xpn.dvalues;\n\t\tnulls2 = array2->xpn.dnulls;\n\t\tnelems2 = array2->xpn.nelems;\n\t}\n\telse\n\t\tdeconstruct_array(&(array2->flt),\n\t\t\t\t\t\t  element_type, typlen, typbyval, typalign,\n\t\t\t\t\t\t  &values2, &nulls2, &nelems2);\n\n\t/*\n\t * Apply the comparison operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tnelems1 = ArrayGetNItems(AARR_NDIM(array1), AARR_DIMS(array1));\n\tarray_iter_setup(&it1, array1);\n\n\tfor (i = 0; i < nelems1; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tbool\t\tisnull1;\n\n\t\t/* Get element, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We assume that the comparison operator is strict, so a NULL can't\n\t\t * match anything.  XXX this diverges from the \"NULL=NULL\" behavior of\n\t\t * array_eq, should we act like that?\n\t\t */\n\t\tif (isnull1)\n\t\t{\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < nelems2; j++)\n\t\t{\n\t\t\tDatum\t\telt2 = values2[j];\n\t\t\tbool\t\tisnull2 = nulls2 ? nulls2[j] : false;\n\t\t\tbool\t\toprresult;\n\n\t\t\tif (isnull2)\n\t\t\t\tcontinue;\t\t/* can't match */\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (oprresult)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < nelems2)\n\t\t{\n\t\t\t/* found a match for elt1 */\n\t\t\tif (!matchall)\n\t\t\t{\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no match for elt1 */\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic bool\narray_contain_compare(AnyArrayType *array1, AnyArrayType *array2, Oid collation,\n\t\t\t\t\t  bool matchall, void **fn_extra)\n{\n\tbool\t\tresult = matchall;\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tTypeCacheEntry *typentry;\n\tint\t\t\tnelems1;\n\tDatum\t   *values2;\n\tbool\t   *nulls2;\n\tint\t\t\tnelems2;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tarray_iter\tit1;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.  The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) *fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t*fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Since we probably will need to scan array2 multiple times, it's\n\t * worthwhile to use deconstruct_array on it.  We scan array1 the hard way\n\t * however, since we very likely won't need to look at all of it.\n\t */\n\tif (VARATT_IS_EXPANDED_HEADER(array2))\n\t{\n\t\t/* This should be safe even if input is read-only */\n\t\tdeconstruct_expanded_array(&(array2->xpn));\n\t\tvalues2 = array2->xpn.dvalues;\n\t\tnulls2 = array2->xpn.dnulls;\n\t\tnelems2 = array2->xpn.nelems;\n\t}\n\telse\n\t\tdeconstruct_array(&(array2->flt),\n\t\t\t\t\t\t  element_type, typlen, typbyval, typalign,\n\t\t\t\t\t\t  &values2, &nulls2, &nelems2);\n\n\t/*\n\t * Apply the comparison operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tnelems1 = ArrayGetNItems(AARR_NDIM(array1), AARR_DIMS(array1));\n\tarray_iter_setup(&it1, array1);\n\n\tfor (i = 0; i < nelems1; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tbool\t\tisnull1;\n\n\t\t/* Get element, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We assume that the comparison operator is strict, so a NULL can't\n\t\t * match anything.  XXX this diverges from the \"NULL=NULL\" behavior of\n\t\t * array_eq, should we act like that?\n\t\t */\n\t\tif (isnull1)\n\t\t{\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < nelems2; j++)\n\t\t{\n\t\t\tDatum\t\telt2 = values2[j];\n\t\t\tbool\t\tisnull2 = nulls2 ? nulls2[j] : false;\n\t\t\tbool\t\toprresult;\n\n\t\t\tif (isnull2)\n\t\t\t\tcontinue;\t\t/* can't match */\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (oprresult)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < nelems2)\n\t\t{\n\t\t\t/* found a match for elt1 */\n\t\t\tif (!matchall)\n\t\t\t{\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no match for elt1 */\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "1"
          ],
          "line": 4267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 4266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narraycontains(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tbool\t\tresult;\n\n\tresult = array_contain_compare(array2, array1, collation, true,\n\t\t\t\t\t\t\t\t   &fcinfo->flinfo->fn_extra);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "arrayoverlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4245-4261",
    "snippet": "Datum\narrayoverlap(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tbool\t\tresult;\n\n\tresult = array_contain_compare(array1, array2, collation, false,\n\t\t\t\t\t\t\t\t   &fcinfo->flinfo->fn_extra);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array2",
            "1"
          ],
          "line": 4258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array1",
            "0"
          ],
          "line": 4257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contain_compare",
          "args": [
            "array1",
            "array2",
            "collation",
            "false",
            "&fcinfo->flinfo->fn_extra"
          ],
          "line": 4253
        },
        "resolved": true,
        "details": {
          "function_name": "array_contain_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4102-4243",
          "snippet": "static bool\narray_contain_compare(AnyArrayType *array1, AnyArrayType *array2, Oid collation,\n\t\t\t\t\t  bool matchall, void **fn_extra)\n{\n\tbool\t\tresult = matchall;\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tTypeCacheEntry *typentry;\n\tint\t\t\tnelems1;\n\tDatum\t   *values2;\n\tbool\t   *nulls2;\n\tint\t\t\tnelems2;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tarray_iter\tit1;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.  The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) *fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t*fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Since we probably will need to scan array2 multiple times, it's\n\t * worthwhile to use deconstruct_array on it.  We scan array1 the hard way\n\t * however, since we very likely won't need to look at all of it.\n\t */\n\tif (VARATT_IS_EXPANDED_HEADER(array2))\n\t{\n\t\t/* This should be safe even if input is read-only */\n\t\tdeconstruct_expanded_array(&(array2->xpn));\n\t\tvalues2 = array2->xpn.dvalues;\n\t\tnulls2 = array2->xpn.dnulls;\n\t\tnelems2 = array2->xpn.nelems;\n\t}\n\telse\n\t\tdeconstruct_array(&(array2->flt),\n\t\t\t\t\t\t  element_type, typlen, typbyval, typalign,\n\t\t\t\t\t\t  &values2, &nulls2, &nelems2);\n\n\t/*\n\t * Apply the comparison operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tnelems1 = ArrayGetNItems(AARR_NDIM(array1), AARR_DIMS(array1));\n\tarray_iter_setup(&it1, array1);\n\n\tfor (i = 0; i < nelems1; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tbool\t\tisnull1;\n\n\t\t/* Get element, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We assume that the comparison operator is strict, so a NULL can't\n\t\t * match anything.  XXX this diverges from the \"NULL=NULL\" behavior of\n\t\t * array_eq, should we act like that?\n\t\t */\n\t\tif (isnull1)\n\t\t{\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < nelems2; j++)\n\t\t{\n\t\t\tDatum\t\telt2 = values2[j];\n\t\t\tbool\t\tisnull2 = nulls2 ? nulls2[j] : false;\n\t\t\tbool\t\toprresult;\n\n\t\t\tif (isnull2)\n\t\t\t\tcontinue;\t\t/* can't match */\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (oprresult)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < nelems2)\n\t\t{\n\t\t\t/* found a match for elt1 */\n\t\t\tif (!matchall)\n\t\t\t{\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no match for elt1 */\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic bool\narray_contain_compare(AnyArrayType *array1, AnyArrayType *array2, Oid collation,\n\t\t\t\t\t  bool matchall, void **fn_extra)\n{\n\tbool\t\tresult = matchall;\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tTypeCacheEntry *typentry;\n\tint\t\t\tnelems1;\n\tDatum\t   *values2;\n\tbool\t   *nulls2;\n\tint\t\t\tnelems2;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tarray_iter\tit1;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.  The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) *fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t*fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Since we probably will need to scan array2 multiple times, it's\n\t * worthwhile to use deconstruct_array on it.  We scan array1 the hard way\n\t * however, since we very likely won't need to look at all of it.\n\t */\n\tif (VARATT_IS_EXPANDED_HEADER(array2))\n\t{\n\t\t/* This should be safe even if input is read-only */\n\t\tdeconstruct_expanded_array(&(array2->xpn));\n\t\tvalues2 = array2->xpn.dvalues;\n\t\tnulls2 = array2->xpn.dnulls;\n\t\tnelems2 = array2->xpn.nelems;\n\t}\n\telse\n\t\tdeconstruct_array(&(array2->flt),\n\t\t\t\t\t\t  element_type, typlen, typbyval, typalign,\n\t\t\t\t\t\t  &values2, &nulls2, &nelems2);\n\n\t/*\n\t * Apply the comparison operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tnelems1 = ArrayGetNItems(AARR_NDIM(array1), AARR_DIMS(array1));\n\tarray_iter_setup(&it1, array1);\n\n\tfor (i = 0; i < nelems1; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tbool\t\tisnull1;\n\n\t\t/* Get element, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We assume that the comparison operator is strict, so a NULL can't\n\t\t * match anything.  XXX this diverges from the \"NULL=NULL\" behavior of\n\t\t * array_eq, should we act like that?\n\t\t */\n\t\tif (isnull1)\n\t\t{\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < nelems2; j++)\n\t\t{\n\t\t\tDatum\t\telt2 = values2[j];\n\t\t\tbool\t\tisnull2 = nulls2 ? nulls2[j] : false;\n\t\t\tbool\t\toprresult;\n\n\t\t\tif (isnull2)\n\t\t\t\tcontinue;\t\t/* can't match */\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (oprresult)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < nelems2)\n\t\t{\n\t\t\t/* found a match for elt1 */\n\t\t\tif (!matchall)\n\t\t\t{\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no match for elt1 */\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 4250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "1"
          ],
          "line": 4249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 4248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narrayoverlap(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tbool\t\tresult;\n\n\tresult = array_contain_compare(array1, array2, collation, false,\n\t\t\t\t\t\t\t\t   &fcinfo->flinfo->fn_extra);\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "array_contain_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4102-4243",
    "snippet": "static bool\narray_contain_compare(AnyArrayType *array1, AnyArrayType *array2, Oid collation,\n\t\t\t\t\t  bool matchall, void **fn_extra)\n{\n\tbool\t\tresult = matchall;\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tTypeCacheEntry *typentry;\n\tint\t\t\tnelems1;\n\tDatum\t   *values2;\n\tbool\t   *nulls2;\n\tint\t\t\tnelems2;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tarray_iter\tit1;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.  The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) *fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t*fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Since we probably will need to scan array2 multiple times, it's\n\t * worthwhile to use deconstruct_array on it.  We scan array1 the hard way\n\t * however, since we very likely won't need to look at all of it.\n\t */\n\tif (VARATT_IS_EXPANDED_HEADER(array2))\n\t{\n\t\t/* This should be safe even if input is read-only */\n\t\tdeconstruct_expanded_array(&(array2->xpn));\n\t\tvalues2 = array2->xpn.dvalues;\n\t\tnulls2 = array2->xpn.dnulls;\n\t\tnelems2 = array2->xpn.nelems;\n\t}\n\telse\n\t\tdeconstruct_array(&(array2->flt),\n\t\t\t\t\t\t  element_type, typlen, typbyval, typalign,\n\t\t\t\t\t\t  &values2, &nulls2, &nelems2);\n\n\t/*\n\t * Apply the comparison operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tnelems1 = ArrayGetNItems(AARR_NDIM(array1), AARR_DIMS(array1));\n\tarray_iter_setup(&it1, array1);\n\n\tfor (i = 0; i < nelems1; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tbool\t\tisnull1;\n\n\t\t/* Get element, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We assume that the comparison operator is strict, so a NULL can't\n\t\t * match anything.  XXX this diverges from the \"NULL=NULL\" behavior of\n\t\t * array_eq, should we act like that?\n\t\t */\n\t\tif (isnull1)\n\t\t{\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < nelems2; j++)\n\t\t{\n\t\t\tDatum\t\telt2 = values2[j];\n\t\t\tbool\t\tisnull2 = nulls2 ? nulls2[j] : false;\n\t\t\tbool\t\toprresult;\n\n\t\t\tif (isnull2)\n\t\t\t\tcontinue;\t\t/* can't match */\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (oprresult)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < nelems2)\n\t\t{\n\t\t\t/* found a match for elt1 */\n\t\t\tif (!matchall)\n\t\t\t{\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no match for elt1 */\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
      "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCallInvoke(&locfcinfo)"
          ],
          "line": 4217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&locfcinfo"
          ],
          "line": 4217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&it1",
            "&isnull1",
            "i",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 4183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&it1",
            "array1"
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "AARR_NDIM(array1)",
            "AARR_DIMS(array1)"
          ],
          "line": 4174
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "array1"
          ],
          "line": 4174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "array1"
          ],
          "line": 4174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "&typentry->eq_opr_finfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "&(array2->flt)",
            "element_type",
            "typlen",
            "typbyval",
            "typalign",
            "&values2",
            "&nulls2",
            "&nelems2"
          ],
          "line": 4163
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_expanded_array",
          "args": [
            "&(array2->xpn)"
          ],
          "line": 4157
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_expanded_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
          "lines": "423-453",
          "snippet": "void\ndeconstruct_expanded_array(ExpandedArrayHeader *eah)\n{\n\tif (eah->dvalues == NULL)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\t\tDatum\t   *dvalues;\n\t\tbool\t   *dnulls;\n\t\tint\t\t\tnelems;\n\n\t\tdnulls = NULL;\n\t\tdeconstruct_array(eah->fvalue,\n\t\t\t\t\t\t  eah->element_type,\n\t\t\t\t\t\t  eah->typlen, eah->typbyval, eah->typalign,\n\t\t\t\t\t\t  &dvalues,\n\t\t\t\t\t\t  ARR_HASNULL(eah->fvalue) ? &dnulls : NULL,\n\t\t\t\t\t\t  &nelems);\n\n\t\t/*\n\t\t * Update header only after successful completion of this step.  If\n\t\t * deconstruct_array fails partway through, worst consequence is some\n\t\t * leaked memory in the object's context.  If the caller fails at a\n\t\t * later point, that's fine, since the deconstructed representation is\n\t\t * valid anyhow.\n\t\t */\n\t\teah->dvalues = dvalues;\n\t\teah->dnulls = dnulls;\n\t\teah->dvalueslen = eah->nelems = nelems;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/array.h\"",
            "#include \"access/tupmacs.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nvoid\ndeconstruct_expanded_array(ExpandedArrayHeader *eah)\n{\n\tif (eah->dvalues == NULL)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\t\tDatum\t   *dvalues;\n\t\tbool\t   *dnulls;\n\t\tint\t\t\tnelems;\n\n\t\tdnulls = NULL;\n\t\tdeconstruct_array(eah->fvalue,\n\t\t\t\t\t\t  eah->element_type,\n\t\t\t\t\t\t  eah->typlen, eah->typbyval, eah->typalign,\n\t\t\t\t\t\t  &dvalues,\n\t\t\t\t\t\t  ARR_HASNULL(eah->fvalue) ? &dnulls : NULL,\n\t\t\t\t\t\t  &nelems);\n\n\t\t/*\n\t\t * Update header only after successful completion of this step.  If\n\t\t * deconstruct_array fails partway through, worst consequence is some\n\t\t * leaked memory in the object's context.  If the caller fails at a\n\t\t * later point, that's fine, since the deconstructed representation is\n\t\t * valid anyhow.\n\t\t */\n\t\teah->dvalues = dvalues;\n\t\teah->dnulls = dnulls;\n\t\teah->dvalueslen = eah->nelems = nelems;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXPANDED_HEADER",
          "args": [
            "array2"
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 4139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not identify an equality operator for type %s\"",
            "format_type_be(element_type)"
          ],
          "line": 4141
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 4142
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 4140
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->eq_opr_finfo.fn_oid"
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "element_type",
            "TYPECACHE_EQ_OPR_FINFO"
          ],
          "line": 4136
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\"))"
          ],
          "line": 4122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "array2"
          ],
          "line": 4121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "array1"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic bool\narray_contain_compare(AnyArrayType *array1, AnyArrayType *array2, Oid collation,\n\t\t\t\t\t  bool matchall, void **fn_extra)\n{\n\tbool\t\tresult = matchall;\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tTypeCacheEntry *typentry;\n\tint\t\t\tnelems1;\n\tDatum\t   *values2;\n\tbool\t   *nulls2;\n\tint\t\t\tnelems2;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tarray_iter\tit1;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the equality function only once per series of\n\t * calls, assuming the element type doesn't change underneath us.  The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) *fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t*fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * Since we probably will need to scan array2 multiple times, it's\n\t * worthwhile to use deconstruct_array on it.  We scan array1 the hard way\n\t * however, since we very likely won't need to look at all of it.\n\t */\n\tif (VARATT_IS_EXPANDED_HEADER(array2))\n\t{\n\t\t/* This should be safe even if input is read-only */\n\t\tdeconstruct_expanded_array(&(array2->xpn));\n\t\tvalues2 = array2->xpn.dvalues;\n\t\tnulls2 = array2->xpn.dnulls;\n\t\tnelems2 = array2->xpn.nelems;\n\t}\n\telse\n\t\tdeconstruct_array(&(array2->flt),\n\t\t\t\t\t\t  element_type, typlen, typbyval, typalign,\n\t\t\t\t\t\t  &values2, &nulls2, &nelems2);\n\n\t/*\n\t * Apply the comparison operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tnelems1 = ArrayGetNItems(AARR_NDIM(array1), AARR_DIMS(array1));\n\tarray_iter_setup(&it1, array1);\n\n\tfor (i = 0; i < nelems1; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tbool\t\tisnull1;\n\n\t\t/* Get element, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We assume that the comparison operator is strict, so a NULL can't\n\t\t * match anything.  XXX this diverges from the \"NULL=NULL\" behavior of\n\t\t * array_eq, should we act like that?\n\t\t */\n\t\tif (isnull1)\n\t\t{\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < nelems2; j++)\n\t\t{\n\t\t\tDatum\t\telt2 = values2[j];\n\t\t\tbool\t\tisnull2 = nulls2 ? nulls2[j] : false;\n\t\t\tbool\t\toprresult;\n\n\t\t\tif (isnull2)\n\t\t\t\tcontinue;\t\t/* can't match */\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (oprresult)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j < nelems2)\n\t\t{\n\t\t\t/* found a match for elt1 */\n\t\t\tif (!matchall)\n\t\t\t{\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no match for elt1 */\n\t\t\tif (matchall)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "hash_array_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "4013-4085",
    "snippet": "Datum\nhash_array_extended(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array = PG_GETARG_ANY_ARRAY_P(0);\n\tuint64\t\tseed = PG_GETARG_INT64(1);\n\tint\t\t\tndims = AARR_NDIM(array);\n\tint\t\t   *dims = AARR_DIMS(array);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array);\n\tuint64\t\tresult = 1;\n\tint\t\t\tnitems;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tarray_iter\titer;\n\tFunctionCallInfoData locfcinfo;\n\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_HASH_EXTENDED_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->hash_extended_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an extended hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\tInitFunctionCallInfoData(locfcinfo, &typentry->hash_extended_proc_finfo, 2,\n\t\t\t\t\t\t\t InvalidOid, NULL, NULL);\n\n\t/* Loop over source data */\n\tnitems = ArrayGetNItems(ndims, dims);\n\tarray_iter_setup(&iter, array);\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\telt;\n\t\tbool\t\tisnull;\n\t\tuint64\t\telthash;\n\n\t\t/* Get element, checking for NULL */\n\t\telt = array_iter_next(&iter, &isnull, i, typlen, typbyval, typalign);\n\n\t\tif (isnull)\n\t\t{\n\t\t\telthash = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Apply the hash function */\n\t\t\tlocfcinfo.arg[0] = elt;\n\t\t\tlocfcinfo.arg[1] = Int64GetDatum(seed);\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\telthash = DatumGetUInt64(FunctionCallInvoke(&locfcinfo));\n\t\t}\n\n\t\tresult = (result << 5) - result + elthash;\n\t}\n\n\tAARR_FREE_IF_COPY(array, 0);\n\n\tPG_RETURN_UINT64(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
      "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
      "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_UINT64",
          "args": [
            "result"
          ],
          "line": 4084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array",
            "0"
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt64",
          "args": [
            "FunctionCallInvoke(&locfcinfo)"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&locfcinfo"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatum",
          "args": [
            "seed"
          ],
          "line": 4072
        },
        "resolved": true,
        "details": {
          "function_name": "Int64GetDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1876-1883",
          "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&iter",
            "&isnull",
            "i",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&iter",
            "array"
          ],
          "line": 4053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims",
            "dims"
          ],
          "line": 4052
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "&typentry->hash_extended_proc_finfo",
            "2",
            "InvalidOid",
            "NULL",
            "NULL"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an extended hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 4038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not identify an extended hash function for type %s\"",
            "format_type_be(element_type)"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->hash_extended_proc_finfo.fn_oid"
          ],
          "line": 4037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "element_type",
            "TYPECACHE_HASH_EXTENDED_PROC_FINFO"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "array"
          ],
          "line": 4019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "array"
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "1"
          ],
          "line": 4017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 4016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nDatum\nhash_array_extended(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array = PG_GETARG_ANY_ARRAY_P(0);\n\tuint64\t\tseed = PG_GETARG_INT64(1);\n\tint\t\t\tndims = AARR_NDIM(array);\n\tint\t\t   *dims = AARR_DIMS(array);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array);\n\tuint64\t\tresult = 1;\n\tint\t\t\tnitems;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tarray_iter\titer;\n\tFunctionCallInfoData locfcinfo;\n\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_HASH_EXTENDED_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->hash_extended_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an extended hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\tInitFunctionCallInfoData(locfcinfo, &typentry->hash_extended_proc_finfo, 2,\n\t\t\t\t\t\t\t InvalidOid, NULL, NULL);\n\n\t/* Loop over source data */\n\tnitems = ArrayGetNItems(ndims, dims);\n\tarray_iter_setup(&iter, array);\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\telt;\n\t\tbool\t\tisnull;\n\t\tuint64\t\telthash;\n\n\t\t/* Get element, checking for NULL */\n\t\telt = array_iter_next(&iter, &isnull, i, typlen, typbyval, typalign);\n\n\t\tif (isnull)\n\t\t{\n\t\t\telthash = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Apply the hash function */\n\t\t\tlocfcinfo.arg[0] = elt;\n\t\t\tlocfcinfo.arg[1] = Int64GetDatum(seed);\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\telthash = DatumGetUInt64(FunctionCallInvoke(&locfcinfo));\n\t\t}\n\n\t\tresult = (result << 5) - result + elthash;\n\t}\n\n\tAARR_FREE_IF_COPY(array, 0);\n\n\tPG_RETURN_UINT64(result);\n}"
  },
  {
    "function_name": "hash_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3916-4007",
    "snippet": "Datum\nhash_array(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array = PG_GETARG_ANY_ARRAY_P(0);\n\tint\t\t\tndims = AARR_NDIM(array);\n\tint\t\t   *dims = AARR_DIMS(array);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array);\n\tuint32\t\tresult = 1;\n\tint\t\t\tnitems;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tarray_iter\titer;\n\tFunctionCallInfoData locfcinfo;\n\n\t/*\n\t * We arrange to look up the hash function only once per series of calls,\n\t * assuming the element type doesn't change underneath us.  The typcache\n\t * is used so that we have no memory leakage when being used as an index\n\t * support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_HASH_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->hash_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the hash function to each array element.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->hash_proc_finfo, 1,\n\t\t\t\t\t\t\t InvalidOid, NULL, NULL);\n\n\t/* Loop over source data */\n\tnitems = ArrayGetNItems(ndims, dims);\n\tarray_iter_setup(&iter, array);\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\telt;\n\t\tbool\t\tisnull;\n\t\tuint32\t\telthash;\n\n\t\t/* Get element, checking for NULL */\n\t\telt = array_iter_next(&iter, &isnull, i, typlen, typbyval, typalign);\n\n\t\tif (isnull)\n\t\t{\n\t\t\t/* Treat nulls as having hashvalue 0 */\n\t\t\telthash = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Apply the hash function */\n\t\t\tlocfcinfo.arg[0] = elt;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\telthash = DatumGetUInt32(FunctionCallInvoke(&locfcinfo));\n\t\t}\n\n\t\t/*\n\t\t * Combine hash values of successive elements by multiplying the\n\t\t * current value by 31 and adding on the new element's hash value.\n\t\t *\n\t\t * The result is a sum in which each element's hash value is\n\t\t * multiplied by a different power of 31. This is modulo 2^32\n\t\t * arithmetic, and the powers of 31 modulo 2^32 form a cyclic group of\n\t\t * order 2^27. So for arrays of up to 2^27 elements, each element's\n\t\t * hash value is multiplied by a different (odd) number, resulting in\n\t\t * a good mixing of all the elements' hash values.\n\t\t */\n\t\tresult = (result << 5) - result + elthash;\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array, 0);\n\n\tPG_RETURN_UINT32(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
      "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
      "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_UINT32",
          "args": [
            "result"
          ],
          "line": 4006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array",
            "0"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "FunctionCallInvoke(&locfcinfo)"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&locfcinfo"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&iter",
            "&isnull",
            "i",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&iter",
            "array"
          ],
          "line": 3964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims",
            "dims"
          ],
          "line": 3963
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "&typentry->hash_proc_finfo",
            "1",
            "InvalidOid",
            "NULL",
            "NULL"
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not identify a hash function for type %s\"",
            "format_type_be(element_type)"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 3949
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 3947
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->hash_proc_finfo.fn_oid"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "element_type",
            "TYPECACHE_HASH_PROC_FINFO"
          ],
          "line": 3943
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "array"
          ],
          "line": 3921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "array"
          ],
          "line": 3920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 3919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nDatum\nhash_array(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array = PG_GETARG_ANY_ARRAY_P(0);\n\tint\t\t\tndims = AARR_NDIM(array);\n\tint\t\t   *dims = AARR_DIMS(array);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array);\n\tuint32\t\tresult = 1;\n\tint\t\t\tnitems;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\ti;\n\tarray_iter\titer;\n\tFunctionCallInfoData locfcinfo;\n\n\t/*\n\t * We arrange to look up the hash function only once per series of calls,\n\t * assuming the element type doesn't change underneath us.  The typcache\n\t * is used so that we have no memory leakage when being used as an index\n\t * support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_HASH_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->hash_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a hash function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the hash function to each array element.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->hash_proc_finfo, 1,\n\t\t\t\t\t\t\t InvalidOid, NULL, NULL);\n\n\t/* Loop over source data */\n\tnitems = ArrayGetNItems(ndims, dims);\n\tarray_iter_setup(&iter, array);\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\telt;\n\t\tbool\t\tisnull;\n\t\tuint32\t\telthash;\n\n\t\t/* Get element, checking for NULL */\n\t\telt = array_iter_next(&iter, &isnull, i, typlen, typbyval, typalign);\n\n\t\tif (isnull)\n\t\t{\n\t\t\t/* Treat nulls as having hashvalue 0 */\n\t\t\telthash = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Apply the hash function */\n\t\t\tlocfcinfo.arg[0] = elt;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\telthash = DatumGetUInt32(FunctionCallInvoke(&locfcinfo));\n\t\t}\n\n\t\t/*\n\t\t * Combine hash values of successive elements by multiplying the\n\t\t * current value by 31 and adding on the new element's hash value.\n\t\t *\n\t\t * The result is a sum in which each element's hash value is\n\t\t * multiplied by a different power of 31. This is modulo 2^32\n\t\t * arithmetic, and the powers of 31 modulo 2^32 form a cyclic group of\n\t\t * order 2^27. So for arrays of up to 2^27 elements, each element's\n\t\t * hash value is multiplied by a different (odd) number, resulting in\n\t\t * a good mixing of all the elements' hash values.\n\t\t */\n\t\tresult = (result << 5) - result + elthash;\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array, 0);\n\n\tPG_RETURN_UINT32(result);\n}"
  },
  {
    "function_name": "array_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3745-3907",
    "snippet": "static int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
      "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
      "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array2",
            "1"
          ],
          "line": 3904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array1",
            "0"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "array2"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "array1"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt32",
          "args": [
            "FunctionCallInvoke(&locfcinfo)"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&locfcinfo"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&it2",
            "&isnull2",
            "i",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&it1",
            "&isnull1",
            "i",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&it2",
            "array2"
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&it1",
            "array1"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "nitems1",
            "nitems2"
          ],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "&typentry->cmp_proc_finfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not identify a comparison function for type %s\"",
            "format_type_be(element_type)"
          ],
          "line": 3789
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 3790
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 3788
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->cmp_proc_finfo.fn_oid"
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "element_type",
            "TYPECACHE_CMP_PROC_FINFO"
          ],
          "line": 3784
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\"))"
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "array2"
          ],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "array1"
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims2",
            "dims2"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "array2"
          ],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "array1"
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "array2"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "array1"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 3750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "1"
          ],
          "line": 3749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 3748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}"
  },
  {
    "function_name": "btarraycmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3733-3737",
    "snippet": "Datum\nbtarraycmp(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_INT32(array_cmp(fcinfo));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "array_cmp(fcinfo)"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "array_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3745-3907",
          "snippet": "static int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\nbtarraycmp(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_INT32(array_cmp(fcinfo));\n}"
  },
  {
    "function_name": "array_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3727-3731",
    "snippet": "Datum\narray_ge(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(array_cmp(fcinfo) >= 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "array_cmp(fcinfo) >= 0"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "array_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3745-3907",
          "snippet": "static int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_ge(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(array_cmp(fcinfo) >= 0);\n}"
  },
  {
    "function_name": "array_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3721-3725",
    "snippet": "Datum\narray_le(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(array_cmp(fcinfo) <= 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "array_cmp(fcinfo) <= 0"
          ],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 3724
        },
        "resolved": true,
        "details": {
          "function_name": "array_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3745-3907",
          "snippet": "static int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_le(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(array_cmp(fcinfo) <= 0);\n}"
  },
  {
    "function_name": "array_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3715-3719",
    "snippet": "Datum\narray_gt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(array_cmp(fcinfo) > 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "array_cmp(fcinfo) > 0"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "array_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3745-3907",
          "snippet": "static int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_gt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(array_cmp(fcinfo) > 0);\n}"
  },
  {
    "function_name": "array_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3709-3713",
    "snippet": "Datum\narray_lt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(array_cmp(fcinfo) < 0);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "array_cmp(fcinfo) < 0"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_cmp",
          "args": [
            "fcinfo"
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "array_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3745-3907",
          "snippet": "static int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nstatic int\narray_cmp(FunctionCallInfo fcinfo)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tint\t\t\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tint\t\t\tresult = 0;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tmin_nitems;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/*\n\t * We arrange to look up the comparison function only once per series of\n\t * calls, assuming the element type doesn't change underneath us. The\n\t * typcache is used so that we have no memory leakage when being used as\n\t * an index support function.\n\t */\n\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\tif (typentry == NULL ||\n\t\ttypentry->type_id != element_type)\n\t{\n\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t TYPECACHE_CMP_PROC_FINFO);\n\t\tif (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify a comparison function for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t}\n\ttyplen = typentry->typlen;\n\ttypbyval = typentry->typbyval;\n\ttypalign = typentry->typalign;\n\n\t/*\n\t * apply the operator to each pair of array elements.\n\t */\n\tInitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,\n\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t/* Loop over source data */\n\tmin_nitems = Min(nitems1, nitems2);\n\tarray_iter_setup(&it1, array1);\n\tarray_iter_setup(&it2, array2);\n\n\tfor (i = 0; i < min_nitems; i++)\n\t{\n\t\tDatum\t\telt1;\n\t\tDatum\t\telt2;\n\t\tbool\t\tisnull1;\n\t\tbool\t\tisnull2;\n\t\tint32\t\tcmpresult;\n\n\t\t/* Get elements, checking for NULL */\n\t\telt1 = array_iter_next(&it1, &isnull1, i, typlen, typbyval, typalign);\n\t\telt2 = array_iter_next(&it2, &isnull2, i, typlen, typbyval, typalign);\n\n\t\t/*\n\t\t * We consider two NULLs equal; NULL > not-NULL.\n\t\t */\n\t\tif (isnull1 && isnull2)\n\t\t\tcontinue;\n\t\tif (isnull1)\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (isnull2)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Compare the pair of elements */\n\t\tlocfcinfo.arg[0] = elt1;\n\t\tlocfcinfo.arg[1] = elt2;\n\t\tlocfcinfo.argnull[0] = false;\n\t\tlocfcinfo.argnull[1] = false;\n\t\tlocfcinfo.isnull = false;\n\t\tcmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));\n\n\t\tif (cmpresult == 0)\n\t\t\tcontinue;\t\t\t/* equal */\n\n\t\tif (cmpresult < 0)\n\t\t{\n\t\t\t/* arg1 is less than arg2 */\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* arg1 is greater than arg2 */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If arrays contain same data (up to end of shorter one), apply\n\t * additional rules to sort by dimensionality.  The relative significance\n\t * of the different bits of information is historical; mainly we just care\n\t * that we don't say \"equal\" for arrays of different dimensionality.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (nitems1 != nitems2)\n\t\t\tresult = (nitems1 < nitems2) ? -1 : 1;\n\t\telse if (ndims1 != ndims2)\n\t\t\tresult = (ndims1 < ndims2) ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t{\n\t\t\t\tif (dims1[i] != dims2[i])\n\t\t\t\t{\n\t\t\t\t\tresult = (dims1[i] < dims2[i]) ? -1 : 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result == 0)\n\t\t\t{\n\t\t\t\tint\t\t   *lbound1 = AARR_LBOUND(array1);\n\t\t\t\tint\t\t   *lbound2 = AARR_LBOUND(array2);\n\n\t\t\t\tfor (i = 0; i < ndims1; i++)\n\t\t\t\t{\n\t\t\t\t\tif (lbound1[i] != lbound2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = (lbound1[i] < lbound2[i]) ? -1 : 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_lt(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(array_cmp(fcinfo) < 0);\n}"
  },
  {
    "function_name": "array_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3703-3707",
    "snippet": "Datum\narray_ne(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(!DatumGetBool(array_eq(fcinfo)));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!DatumGetBool(array_eq(fcinfo))"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "array_eq(fcinfo)"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_eq",
          "args": [
            "fcinfo"
          ],
          "line": 3706
        },
        "resolved": true,
        "details": {
          "function_name": "array_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3574-3691",
          "snippet": "Datum\narray_eq(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t   *lbs1 = AARR_LBOUND(array1);\n\tint\t\t   *lbs2 = AARR_LBOUND(array2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tbool\t\tresult = true;\n\tint\t\t\tnitems;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/* fast path if the arrays do not have the same dimensionality */\n\tif (ndims1 != ndims2 ||\n\t\tmemcmp(dims1, dims2, ndims1 * sizeof(int)) != 0 ||\n\t\tmemcmp(lbs1, lbs2, ndims1 * sizeof(int)) != 0)\n\t\tresult = false;\n\telse\n\t{\n\t\t/*\n\t\t * We arrange to look up the equality function only once per series of\n\t\t * calls, assuming the element type doesn't change underneath us.  The\n\t\t * typcache is used so that we have no memory leakage when being used\n\t\t * as an index support function.\n\t\t */\n\t\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != element_type)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t\t}\n\t\ttyplen = typentry->typlen;\n\t\ttypbyval = typentry->typbyval;\n\t\ttypalign = typentry->typalign;\n\n\t\t/*\n\t\t * apply the operator to each pair of array elements.\n\t\t */\n\t\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t\t/* Loop over source data */\n\t\tnitems = ArrayGetNItems(ndims1, dims1);\n\t\tarray_iter_setup(&it1, array1);\n\t\tarray_iter_setup(&it2, array2);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tDatum\t\telt1;\n\t\t\tDatum\t\telt2;\n\t\t\tbool\t\tisnull1;\n\t\t\tbool\t\tisnull2;\n\t\t\tbool\t\toprresult;\n\n\t\t\t/* Get elements, checking for NULL */\n\t\t\telt1 = array_iter_next(&it1, &isnull1, i,\n\t\t\t\t\t\t\t\t   typlen, typbyval, typalign);\n\t\t\telt2 = array_iter_next(&it2, &isnull2, i,\n\t\t\t\t\t\t\t\t   typlen, typbyval, typalign);\n\n\t\t\t/*\n\t\t\t * We consider two NULLs equal; NULL and not-NULL are unequal.\n\t\t\t */\n\t\t\tif (isnull1 && isnull2)\n\t\t\t\tcontinue;\n\t\t\tif (isnull1 || isnull2)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (!oprresult)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
            "static int\tarray_cmp(FunctionCallInfo fcinfo);",
            "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
            "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
            "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
            "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nDatum\narray_eq(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t   *lbs1 = AARR_LBOUND(array1);\n\tint\t\t   *lbs2 = AARR_LBOUND(array2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tbool\t\tresult = true;\n\tint\t\t\tnitems;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/* fast path if the arrays do not have the same dimensionality */\n\tif (ndims1 != ndims2 ||\n\t\tmemcmp(dims1, dims2, ndims1 * sizeof(int)) != 0 ||\n\t\tmemcmp(lbs1, lbs2, ndims1 * sizeof(int)) != 0)\n\t\tresult = false;\n\telse\n\t{\n\t\t/*\n\t\t * We arrange to look up the equality function only once per series of\n\t\t * calls, assuming the element type doesn't change underneath us.  The\n\t\t * typcache is used so that we have no memory leakage when being used\n\t\t * as an index support function.\n\t\t */\n\t\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != element_type)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t\t}\n\t\ttyplen = typentry->typlen;\n\t\ttypbyval = typentry->typbyval;\n\t\ttypalign = typentry->typalign;\n\n\t\t/*\n\t\t * apply the operator to each pair of array elements.\n\t\t */\n\t\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t\t/* Loop over source data */\n\t\tnitems = ArrayGetNItems(ndims1, dims1);\n\t\tarray_iter_setup(&it1, array1);\n\t\tarray_iter_setup(&it2, array2);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tDatum\t\telt1;\n\t\t\tDatum\t\telt2;\n\t\t\tbool\t\tisnull1;\n\t\t\tbool\t\tisnull2;\n\t\t\tbool\t\toprresult;\n\n\t\t\t/* Get elements, checking for NULL */\n\t\t\telt1 = array_iter_next(&it1, &isnull1, i,\n\t\t\t\t\t\t\t\t   typlen, typbyval, typalign);\n\t\t\telt2 = array_iter_next(&it2, &isnull2, i,\n\t\t\t\t\t\t\t\t   typlen, typbyval, typalign);\n\n\t\t\t/*\n\t\t\t * We consider two NULLs equal; NULL and not-NULL are unequal.\n\t\t\t */\n\t\t\tif (isnull1 && isnull2)\n\t\t\t\tcontinue;\n\t\t\tif (isnull1 || isnull2)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (!oprresult)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_ne(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_BOOL(!DatumGetBool(array_eq(fcinfo)));\n}"
  },
  {
    "function_name": "array_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3574-3691",
    "snippet": "Datum\narray_eq(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t   *lbs1 = AARR_LBOUND(array1);\n\tint\t\t   *lbs2 = AARR_LBOUND(array2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tbool\t\tresult = true;\n\tint\t\t\tnitems;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/* fast path if the arrays do not have the same dimensionality */\n\tif (ndims1 != ndims2 ||\n\t\tmemcmp(dims1, dims2, ndims1 * sizeof(int)) != 0 ||\n\t\tmemcmp(lbs1, lbs2, ndims1 * sizeof(int)) != 0)\n\t\tresult = false;\n\telse\n\t{\n\t\t/*\n\t\t * We arrange to look up the equality function only once per series of\n\t\t * calls, assuming the element type doesn't change underneath us.  The\n\t\t * typcache is used so that we have no memory leakage when being used\n\t\t * as an index support function.\n\t\t */\n\t\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != element_type)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t\t}\n\t\ttyplen = typentry->typlen;\n\t\ttypbyval = typentry->typbyval;\n\t\ttypalign = typentry->typalign;\n\n\t\t/*\n\t\t * apply the operator to each pair of array elements.\n\t\t */\n\t\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t\t/* Loop over source data */\n\t\tnitems = ArrayGetNItems(ndims1, dims1);\n\t\tarray_iter_setup(&it1, array1);\n\t\tarray_iter_setup(&it2, array2);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tDatum\t\telt1;\n\t\t\tDatum\t\telt2;\n\t\t\tbool\t\tisnull1;\n\t\t\tbool\t\tisnull2;\n\t\t\tbool\t\toprresult;\n\n\t\t\t/* Get elements, checking for NULL */\n\t\t\telt1 = array_iter_next(&it1, &isnull1, i,\n\t\t\t\t\t\t\t\t   typlen, typbyval, typalign);\n\t\t\telt2 = array_iter_next(&it2, &isnull2, i,\n\t\t\t\t\t\t\t\t   typlen, typbyval, typalign);\n\n\t\t\t/*\n\t\t\t * We consider two NULLs equal; NULL and not-NULL are unequal.\n\t\t\t */\n\t\t\tif (isnull1 && isnull2)\n\t\t\t\tcontinue;\n\t\t\tif (isnull1 || isnull2)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (!oprresult)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);",
      "static int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);",
      "static int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array2",
            "1"
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_FREE_IF_COPY",
          "args": [
            "array1",
            "0"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCallInvoke(&locfcinfo)"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&locfcinfo"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&it2",
            "&isnull2",
            "i",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 3655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&it1",
            "&isnull1",
            "i",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 3653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&it2",
            "array2"
          ],
          "line": 3642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&it1",
            "array1"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims1",
            "dims1"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "locfcinfo",
            "&typentry->eq_opr_finfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not identify an equality operator for type %s\"",
            "format_type_be(element_type)"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 3626
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 3624
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->eq_opr_finfo.fn_oid"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "element_type",
            "TYPECACHE_EQ_OPR_FINFO"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "lbs1",
            "lbs2",
            "ndims1 * sizeof(int)"
          ],
          "line": 3606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dims1",
            "dims2",
            "ndims1 * sizeof(int)"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\"))"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "array2"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "array1"
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "array2"
          ],
          "line": 3585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "array1"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "array2"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "array1"
          ],
          "line": 3582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "array2"
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "array1"
          ],
          "line": 3580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "1"
          ],
          "line": 3578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\nstatic int width_bucket_array_fixed(Datum operand,\n\t\t\t\t\t\t ArrayType *thresholds,\n\t\t\t\t\t\t Oid collation,\n\t\t\t\t\t\t TypeCacheEntry *typentry);\nstatic int width_bucket_array_variable(Datum operand,\n\t\t\t\t\t\t\tArrayType *thresholds,\n\t\t\t\t\t\t\tOid collation,\n\t\t\t\t\t\t\tTypeCacheEntry *typentry);\n\nDatum\narray_eq(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0);\n\tAnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1);\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tint\t\t\tndims1 = AARR_NDIM(array1);\n\tint\t\t\tndims2 = AARR_NDIM(array2);\n\tint\t\t   *dims1 = AARR_DIMS(array1);\n\tint\t\t   *dims2 = AARR_DIMS(array2);\n\tint\t\t   *lbs1 = AARR_LBOUND(array1);\n\tint\t\t   *lbs2 = AARR_LBOUND(array2);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(array1);\n\tbool\t\tresult = true;\n\tint\t\t\tnitems;\n\tTypeCacheEntry *typentry;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tarray_iter\tit1;\n\tarray_iter\tit2;\n\tint\t\t\ti;\n\tFunctionCallInfoData locfcinfo;\n\n\tif (element_type != AARR_ELEMTYPE(array2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot compare arrays of different element types\")));\n\n\t/* fast path if the arrays do not have the same dimensionality */\n\tif (ndims1 != ndims2 ||\n\t\tmemcmp(dims1, dims2, ndims1 * sizeof(int)) != 0 ||\n\t\tmemcmp(lbs1, lbs2, ndims1 * sizeof(int)) != 0)\n\t\tresult = false;\n\telse\n\t{\n\t\t/*\n\t\t * We arrange to look up the equality function only once per series of\n\t\t * calls, assuming the element type doesn't change underneath us.  The\n\t\t * typcache is used so that we have no memory leakage when being used\n\t\t * as an index support function.\n\t\t */\n\t\ttypentry = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\t\tif (typentry == NULL ||\n\t\t\ttypentry->type_id != element_type)\n\t\t{\n\t\t\ttypentry = lookup_type_cache(element_type,\n\t\t\t\t\t\t\t\t\t\t TYPECACHE_EQ_OPR_FINFO);\n\t\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\t\tfcinfo->flinfo->fn_extra = (void *) typentry;\n\t\t}\n\t\ttyplen = typentry->typlen;\n\t\ttypbyval = typentry->typbyval;\n\t\ttypalign = typentry->typalign;\n\n\t\t/*\n\t\t * apply the operator to each pair of array elements.\n\t\t */\n\t\tInitFunctionCallInfoData(locfcinfo, &typentry->eq_opr_finfo, 2,\n\t\t\t\t\t\t\t\t collation, NULL, NULL);\n\n\t\t/* Loop over source data */\n\t\tnitems = ArrayGetNItems(ndims1, dims1);\n\t\tarray_iter_setup(&it1, array1);\n\t\tarray_iter_setup(&it2, array2);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tDatum\t\telt1;\n\t\t\tDatum\t\telt2;\n\t\t\tbool\t\tisnull1;\n\t\t\tbool\t\tisnull2;\n\t\t\tbool\t\toprresult;\n\n\t\t\t/* Get elements, checking for NULL */\n\t\t\telt1 = array_iter_next(&it1, &isnull1, i,\n\t\t\t\t\t\t\t\t   typlen, typbyval, typalign);\n\t\t\telt2 = array_iter_next(&it2, &isnull2, i,\n\t\t\t\t\t\t\t\t   typlen, typbyval, typalign);\n\n\t\t\t/*\n\t\t\t * We consider two NULLs equal; NULL and not-NULL are unequal.\n\t\t\t */\n\t\t\tif (isnull1 && isnull2)\n\t\t\t\tcontinue;\n\t\t\tif (isnull1 || isnull2)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Apply the operator to the element pair\n\t\t\t */\n\t\t\tlocfcinfo.arg[0] = elt1;\n\t\t\tlocfcinfo.arg[1] = elt2;\n\t\t\tlocfcinfo.argnull[0] = false;\n\t\t\tlocfcinfo.argnull[1] = false;\n\t\t\tlocfcinfo.isnull = false;\n\t\t\toprresult = DatumGetBool(FunctionCallInvoke(&locfcinfo));\n\t\t\tif (!oprresult)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Avoid leaking memory when handed toasted input. */\n\tAARR_FREE_IF_COPY(array1, 0);\n\tAARR_FREE_IF_COPY(array2, 1);\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "array_contains_nulls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3527-3562",
    "snippet": "bool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "array"
          ],
          "line": 3540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ARR_NDIM(array)",
            "ARR_DIMS(array)"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "array"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "array"
          ],
          "line": 3535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "deconstruct_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3460-3519",
    "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "p",
            "elmalign"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "p",
            "elmlen",
            "p"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_att",
          "args": [
            "p",
            "elmbyval",
            "elmlen"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\"))"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"null array element not allowed in this context\""
          ],
          "line": 3499
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "array"
          ],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "array"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nelems * sizeof(bool)"
          ],
          "line": 3479
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nelems * sizeof(Datum)"
          ],
          "line": 3477
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ARR_NDIM(array)",
            "ARR_DIMS(array)"
          ],
          "line": 3476
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "array"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ARR_ELEMTYPE(array) == elmtype"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "construct_empty_expanded_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3426-3437",
    "snippet": "ExpandedArrayHeader *\nconstruct_empty_expanded_array(Oid element_type,\n\t\t\t\t\t\t\t   MemoryContext parentcontext,\n\t\t\t\t\t\t\t   ArrayMetaState *metacache)\n{\n\tArrayType  *array = construct_empty_array(element_type);\n\tDatum\t\td;\n\n\td = expand_array(PointerGetDatum(array), parentcontext, metacache);\n\tpfree(array);\n\treturn (ExpandedArrayHeader *) DatumGetEOHP(d);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetEOHP",
          "args": [
            "d"
          ],
          "line": 3436
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetEOHP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "28-38",
          "snippet": "ExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "array"
          ],
          "line": 3435
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_array",
          "args": [
            "PointerGetDatum(array)",
            "parentcontext",
            "metacache"
          ],
          "line": 3434
        },
        "resolved": true,
        "details": {
          "function_name": "expand_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
          "lines": "49-179",
          "snippet": "Datum\nexpand_array(Datum arraydatum, MemoryContext parentcontext,\n\t\t\t ArrayMetaState *metacache)\n{\n\tArrayType  *array;\n\tExpandedArrayHeader *eah;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tArrayMetaState fakecache;\n\n\t/*\n\t * Allocate private context for expanded object.  We start by assuming\n\t * that the array won't be very large; but if it does grow a lot, don't\n\t * constrain aset.c's large-context behavior.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded array\",\n\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\t/* Set up expanded array header */\n\teah = (ExpandedArrayHeader *)\n\t\tMemoryContextAlloc(objcxt, sizeof(ExpandedArrayHeader));\n\n\tEOH_init_header(&eah->hdr, &EA_methods, objcxt);\n\teah->ea_magic = EA_MAGIC;\n\n\t/* If the source is an expanded array, we may be able to optimize */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\tExpandedArrayHeader *oldeah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\n\t\tAssert(oldeah->ea_magic == EA_MAGIC);\n\n\t\t/*\n\t\t * Update caller's cache if provided; we don't need it this time, but\n\t\t * next call might be for a non-expanded source array.  Furthermore,\n\t\t * if the caller didn't provide a cache area, use some local storage\n\t\t * to cache anyway, thereby avoiding a catalog lookup in the case\n\t\t * where we fall through to the flat-copy code path.\n\t\t */\n\t\tif (metacache == NULL)\n\t\t\tmetacache = &fakecache;\n\t\tmetacache->element_type = oldeah->element_type;\n\t\tmetacache->typlen = oldeah->typlen;\n\t\tmetacache->typbyval = oldeah->typbyval;\n\t\tmetacache->typalign = oldeah->typalign;\n\n\t\t/*\n\t\t * If element type is pass-by-value and we have a Datum-array\n\t\t * representation, just copy the source's metadata and Datum/isnull\n\t\t * arrays.  The original flat array, if present at all, adds no\n\t\t * additional information so we need not copy it.\n\t\t */\n\t\tif (oldeah->typbyval && oldeah->dvalues != NULL)\n\t\t{\n\t\t\tcopy_byval_expanded_array(eah, oldeah);\n\t\t\t/* return a R/W pointer to the expanded array */\n\t\t\treturn EOHPGetRWDatum(&eah->hdr);\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, either we have only a flat representation or the\n\t\t * elements are pass-by-reference.  In either case, the best thing\n\t\t * seems to be to copy the source as a flat representation and then\n\t\t * deconstruct that later if necessary.  For the pass-by-ref case, we\n\t\t * could perhaps save some cycles with custom code that generates the\n\t\t * deconstructed representation in parallel with copying the values,\n\t\t * but it would be a lot of extra code for fairly marginal gain.  So,\n\t\t * fall through into the flat-source code path.\n\t\t */\n\t}\n\n\t/*\n\t * Detoast and copy source array into private context, as a flat array.\n\t *\n\t * Note that this coding risks leaking some memory in the private context\n\t * if we have to fetch data from a TOAST table; however, experimentation\n\t * says that the leak is minimal.  Doing it this way saves a copy step,\n\t * which seems worthwhile, especially if the array is large enough to need\n\t * external storage.\n\t */\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tarray = DatumGetArrayTypePCopy(arraydatum);\n\tMemoryContextSwitchTo(oldcxt);\n\n\teah->ndims = ARR_NDIM(array);\n\t/* note these pointers point into the fvalue header! */\n\teah->dims = ARR_DIMS(array);\n\teah->lbound = ARR_LBOUND(array);\n\n\t/* Save array's element-type data for possible use later */\n\teah->element_type = ARR_ELEMTYPE(array);\n\tif (metacache && metacache->element_type == eah->element_type)\n\t{\n\t\t/* We have a valid cache of representational data */\n\t\teah->typlen = metacache->typlen;\n\t\teah->typbyval = metacache->typbyval;\n\t\teah->typalign = metacache->typalign;\n\t}\n\telse\n\t{\n\t\t/* No, so look it up */\n\t\tget_typlenbyvalalign(eah->element_type,\n\t\t\t\t\t\t\t &eah->typlen,\n\t\t\t\t\t\t\t &eah->typbyval,\n\t\t\t\t\t\t\t &eah->typalign);\n\t\t/* Update cache if provided */\n\t\tif (metacache)\n\t\t{\n\t\t\tmetacache->element_type = eah->element_type;\n\t\t\tmetacache->typlen = eah->typlen;\n\t\t\tmetacache->typbyval = eah->typbyval;\n\t\t\tmetacache->typalign = eah->typalign;\n\t\t}\n\t}\n\n\t/* we don't make a deconstructed representation now */\n\teah->dvalues = NULL;\n\teah->dnulls = NULL;\n\teah->dvalueslen = 0;\n\teah->nelems = 0;\n\teah->flat_size = 0;\n\n\t/* remember we have a flat representation */\n\teah->fvalue = array;\n\teah->fstartptr = ARR_DATA_PTR(array);\n\teah->fendptr = ((char *) array) + ARR_SIZE(array);\n\n\t/* return a R/W pointer to the expanded array */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/array.h\"",
            "#include \"access/tupmacs.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const ExpandedObjectMethods EA_methods =\n{\n\tEA_get_flat_size,\n\tEA_flatten_into\n};",
            "static void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nstatic const ExpandedObjectMethods EA_methods =\n{\n\tEA_get_flat_size,\n\tEA_flatten_into\n};\nstatic void copy_byval_expanded_array(ExpandedArrayHeader *eah,\n\t\t\t\t\t\t  ExpandedArrayHeader *oldeah);\n\nDatum\nexpand_array(Datum arraydatum, MemoryContext parentcontext,\n\t\t\t ArrayMetaState *metacache)\n{\n\tArrayType  *array;\n\tExpandedArrayHeader *eah;\n\tMemoryContext objcxt;\n\tMemoryContext oldcxt;\n\tArrayMetaState fakecache;\n\n\t/*\n\t * Allocate private context for expanded object.  We start by assuming\n\t * that the array won't be very large; but if it does grow a lot, don't\n\t * constrain aset.c's large-context behavior.\n\t */\n\tobjcxt = AllocSetContextCreate(parentcontext,\n\t\t\t\t\t\t\t\t   \"expanded array\",\n\t\t\t\t\t\t\t\t   ALLOCSET_START_SMALL_SIZES);\n\n\t/* Set up expanded array header */\n\teah = (ExpandedArrayHeader *)\n\t\tMemoryContextAlloc(objcxt, sizeof(ExpandedArrayHeader));\n\n\tEOH_init_header(&eah->hdr, &EA_methods, objcxt);\n\teah->ea_magic = EA_MAGIC;\n\n\t/* If the source is an expanded array, we may be able to optimize */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\tExpandedArrayHeader *oldeah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\n\t\tAssert(oldeah->ea_magic == EA_MAGIC);\n\n\t\t/*\n\t\t * Update caller's cache if provided; we don't need it this time, but\n\t\t * next call might be for a non-expanded source array.  Furthermore,\n\t\t * if the caller didn't provide a cache area, use some local storage\n\t\t * to cache anyway, thereby avoiding a catalog lookup in the case\n\t\t * where we fall through to the flat-copy code path.\n\t\t */\n\t\tif (metacache == NULL)\n\t\t\tmetacache = &fakecache;\n\t\tmetacache->element_type = oldeah->element_type;\n\t\tmetacache->typlen = oldeah->typlen;\n\t\tmetacache->typbyval = oldeah->typbyval;\n\t\tmetacache->typalign = oldeah->typalign;\n\n\t\t/*\n\t\t * If element type is pass-by-value and we have a Datum-array\n\t\t * representation, just copy the source's metadata and Datum/isnull\n\t\t * arrays.  The original flat array, if present at all, adds no\n\t\t * additional information so we need not copy it.\n\t\t */\n\t\tif (oldeah->typbyval && oldeah->dvalues != NULL)\n\t\t{\n\t\t\tcopy_byval_expanded_array(eah, oldeah);\n\t\t\t/* return a R/W pointer to the expanded array */\n\t\t\treturn EOHPGetRWDatum(&eah->hdr);\n\t\t}\n\n\t\t/*\n\t\t * Otherwise, either we have only a flat representation or the\n\t\t * elements are pass-by-reference.  In either case, the best thing\n\t\t * seems to be to copy the source as a flat representation and then\n\t\t * deconstruct that later if necessary.  For the pass-by-ref case, we\n\t\t * could perhaps save some cycles with custom code that generates the\n\t\t * deconstructed representation in parallel with copying the values,\n\t\t * but it would be a lot of extra code for fairly marginal gain.  So,\n\t\t * fall through into the flat-source code path.\n\t\t */\n\t}\n\n\t/*\n\t * Detoast and copy source array into private context, as a flat array.\n\t *\n\t * Note that this coding risks leaking some memory in the private context\n\t * if we have to fetch data from a TOAST table; however, experimentation\n\t * says that the leak is minimal.  Doing it this way saves a copy step,\n\t * which seems worthwhile, especially if the array is large enough to need\n\t * external storage.\n\t */\n\toldcxt = MemoryContextSwitchTo(objcxt);\n\tarray = DatumGetArrayTypePCopy(arraydatum);\n\tMemoryContextSwitchTo(oldcxt);\n\n\teah->ndims = ARR_NDIM(array);\n\t/* note these pointers point into the fvalue header! */\n\teah->dims = ARR_DIMS(array);\n\teah->lbound = ARR_LBOUND(array);\n\n\t/* Save array's element-type data for possible use later */\n\teah->element_type = ARR_ELEMTYPE(array);\n\tif (metacache && metacache->element_type == eah->element_type)\n\t{\n\t\t/* We have a valid cache of representational data */\n\t\teah->typlen = metacache->typlen;\n\t\teah->typbyval = metacache->typbyval;\n\t\teah->typalign = metacache->typalign;\n\t}\n\telse\n\t{\n\t\t/* No, so look it up */\n\t\tget_typlenbyvalalign(eah->element_type,\n\t\t\t\t\t\t\t &eah->typlen,\n\t\t\t\t\t\t\t &eah->typbyval,\n\t\t\t\t\t\t\t &eah->typalign);\n\t\t/* Update cache if provided */\n\t\tif (metacache)\n\t\t{\n\t\t\tmetacache->element_type = eah->element_type;\n\t\t\tmetacache->typlen = eah->typlen;\n\t\t\tmetacache->typbyval = eah->typbyval;\n\t\t\tmetacache->typalign = eah->typalign;\n\t\t}\n\t}\n\n\t/* we don't make a deconstructed representation now */\n\teah->dvalues = NULL;\n\teah->dnulls = NULL;\n\teah->dvalueslen = 0;\n\teah->nelems = 0;\n\teah->flat_size = 0;\n\n\t/* remember we have a flat representation */\n\teah->fvalue = array;\n\teah->fstartptr = ARR_DATA_PTR(array);\n\teah->fendptr = ((char *) array) + ARR_SIZE(array);\n\n\t/* return a R/W pointer to the expanded array */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "array"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "element_type"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nExpandedArrayHeader *\nconstruct_empty_expanded_array(Oid element_type,\n\t\t\t\t\t\t\t   MemoryContext parentcontext,\n\t\t\t\t\t\t\t   ArrayMetaState *metacache)\n{\n\tArrayType  *array = construct_empty_array(element_type);\n\tDatum\t\td;\n\n\td = expand_array(PointerGetDatum(array), parentcontext, metacache);\n\tpfree(array);\n\treturn (ExpandedArrayHeader *) DatumGetEOHP(d);\n}"
  },
  {
    "function_name": "construct_empty_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3409-3420",
    "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "sizeof(ArrayType)"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(ArrayType)"
          ],
          "line": 3414
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
  },
  {
    "function_name": "construct_md_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3325-3404",
    "snippet": "ArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CopyArrayEls",
          "args": [
            "result",
            "elems",
            "nulls",
            "nelems",
            "elmlen",
            "elmbyval",
            "elmalign",
            "false"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "CopyArrayEls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "956-1004",
          "snippet": "void\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nvoid\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(result)",
            "lbs",
            "ndims * sizeof(int)"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "result"
          ],
          "line": 3396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(result)",
            "dims",
            "ndims * sizeof(int)"
          ],
          "line": 3395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "result"
          ],
          "line": 3395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "nbytes"
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nbytes"
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndims"
          ],
          "line": 3388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndims",
            "nelems"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize))"
          ],
          "line": 3373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"array size exceeds the maximum allowed (%d)\"",
            "(int) MaxAllocSize"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSizeIsValid",
          "args": [
            "nbytes"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "nbytes",
            "elmalign"
          ],
          "line": 3370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "nbytes",
            "elmlen",
            "elems[i]"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM(elems[i])"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "elems[i]"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "elmtype"
          ],
          "line": 3354
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims",
            "dims"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM))"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims))"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}"
  },
  {
    "function_name": "construct_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3290-3303",
    "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "construct_md_array",
          "args": [
            "elems",
            "NULL",
            "1",
            "dims",
            "lbs",
            "elmtype",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 3301
        },
        "resolved": true,
        "details": {
          "function_name": "construct_md_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3325-3404",
          "snippet": "ArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
  },
  {
    "function_name": "array_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3130-3271",
    "snippet": "Datum\narray_map(Datum arrayd,\n\t\t  ExprState *exprstate, ExprContext *econtext,\n\t\t  Oid retType, ArrayMapState *amstate)\n{\n\tAnyArrayType *v = DatumGetAnyArrayP(arrayd);\n\tArrayType  *result;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\ti;\n\tint32\t\tnbytes = 0;\n\tint32\t\tdataoffset;\n\tbool\t\thasnulls;\n\tOid\t\t\tinpType;\n\tint\t\t\tinp_typlen;\n\tbool\t\tinp_typbyval;\n\tchar\t\tinp_typalign;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tarray_iter\titer;\n\tArrayMetaState *inp_extra;\n\tArrayMetaState *ret_extra;\n\tDatum\t   *transform_source = exprstate->innermost_caseval;\n\tbool\t   *transform_source_isnull = exprstate->innermost_casenull;\n\n\tinpType = AARR_ELEMTYPE(v);\n\tndim = AARR_NDIM(v);\n\tdim = AARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/* Check for empty array */\n\tif (nitems <= 0)\n\t{\n\t\t/* Return empty array */\n\t\treturn PointerGetDatum(construct_empty_array(retType));\n\t}\n\n\t/*\n\t * We arrange to look up info about input and return element types only\n\t * once per series of calls, assuming the element type doesn't change\n\t * underneath us.\n\t */\n\tinp_extra = &amstate->inp_extra;\n\tret_extra = &amstate->ret_extra;\n\n\tif (inp_extra->element_type != inpType)\n\t{\n\t\tget_typlenbyvalalign(inpType,\n\t\t\t\t\t\t\t &inp_extra->typlen,\n\t\t\t\t\t\t\t &inp_extra->typbyval,\n\t\t\t\t\t\t\t &inp_extra->typalign);\n\t\tinp_extra->element_type = inpType;\n\t}\n\tinp_typlen = inp_extra->typlen;\n\tinp_typbyval = inp_extra->typbyval;\n\tinp_typalign = inp_extra->typalign;\n\n\tif (ret_extra->element_type != retType)\n\t{\n\t\tget_typlenbyvalalign(retType,\n\t\t\t\t\t\t\t &ret_extra->typlen,\n\t\t\t\t\t\t\t &ret_extra->typbyval,\n\t\t\t\t\t\t\t &ret_extra->typalign);\n\t\tret_extra->element_type = retType;\n\t}\n\ttyplen = ret_extra->typlen;\n\ttypbyval = ret_extra->typbyval;\n\ttypalign = ret_extra->typalign;\n\n\t/* Allocate temporary arrays for new values */\n\tvalues = (Datum *) palloc(nitems * sizeof(Datum));\n\tnulls = (bool *) palloc(nitems * sizeof(bool));\n\n\t/* Loop over source data */\n\tarray_iter_setup(&iter, v);\n\thasnulls = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\t*transform_source =\n\t\t\tarray_iter_next(&iter, transform_source_isnull, i,\n\t\t\t\t\t\t\tinp_typlen, inp_typbyval, inp_typalign);\n\n\t\t/* Apply the given expression to source element */\n\t\tvalues[i] = ExecEvalExpr(exprstate, econtext, &nulls[i]);\n\n\t\tif (nulls[i])\n\t\t\thasnulls = true;\n\t\telse\n\t\t{\n\t\t\t/* Ensure data is not toasted */\n\t\t\tif (typlen == -1)\n\t\t\t\tvalues[i] = PointerGetDatum(PG_DETOAST_DATUM(values[i]));\n\t\t\t/* Update total result size */\n\t\t\tnbytes = att_addlength_datum(nbytes, typlen, values[i]);\n\t\t\tnbytes = att_align_nominal(nbytes, typalign);\n\t\t\t/* check for overflow of total request */\n\t\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t}\n\t}\n\n\t/* Allocate and fill the result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndim;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = retType;\n\tmemcpy(ARR_DIMS(result), AARR_DIMS(v), ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), AARR_LBOUND(v), ndim * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t values, nulls, nitems,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t false);\n\n\t/*\n\t * Note: do not risk trying to pfree the results of the called expression\n\t */\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn PointerGetDatum(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "result"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nulls"
          ],
          "line": 3268
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CopyArrayEls",
          "args": [
            "result",
            "values",
            "nulls",
            "nitems",
            "typlen",
            "typbyval",
            "typalign",
            "false"
          ],
          "line": 3259
        },
        "resolved": true,
        "details": {
          "function_name": "CopyArrayEls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "956-1004",
          "snippet": "void\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nvoid\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(result)",
            "AARR_LBOUND(v)",
            "ndim * sizeof(int)"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "v"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "result"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(result)",
            "AARR_DIMS(v)",
            "ndim * sizeof(int)"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "v"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "result"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "nbytes"
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nbytes"
          ],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndim"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndim",
            "nitems"
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize))"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"array size exceeds the maximum allowed (%d)\"",
            "(int) MaxAllocSize"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSizeIsValid",
          "args": [
            "nbytes"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "nbytes",
            "typalign"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "nbytes",
            "typlen",
            "values[i]"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM(values[i])"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "values[i]"
          ],
          "line": 3227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecEvalExpr",
          "args": [
            "exprstate",
            "econtext",
            "&nulls[i]"
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&iter",
            "transform_source_isnull",
            "i",
            "inp_typlen",
            "inp_typbyval",
            "inp_typalign"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&iter",
            "v"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nitems * sizeof(bool)"
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "retType",
            "&ret_extra->typlen",
            "&ret_extra->typbyval",
            "&ret_extra->typalign"
          ],
          "line": 3193
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "construct_empty_array(retType)"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "retType"
          ],
          "line": 3168
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "dim"
          ],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "v"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 3160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "v"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetAnyArrayP",
          "args": [
            "arrayd"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetAnyArrayP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
          "lines": "400-417",
          "snippet": "AnyArrayType *\nDatumGetAnyArrayP(Datum d)\n{\n\tExpandedArrayHeader *eah;\n\n\t/*\n\t * If it's an expanded array (RW or RO), return the header pointer.\n\t */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(d)))\n\t{\n\t\teah = (ExpandedArrayHeader *) DatumGetEOHP(d);\n\t\tAssert(eah->ea_magic == EA_MAGIC);\n\t\treturn (AnyArrayType *) eah;\n\t}\n\n\t/* Else do regular detoasting as needed */\n\treturn (AnyArrayType *) PG_DETOAST_DATUM(d);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/array.h\"",
            "#include \"access/tupmacs.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nAnyArrayType *\nDatumGetAnyArrayP(Datum d)\n{\n\tExpandedArrayHeader *eah;\n\n\t/*\n\t * If it's an expanded array (RW or RO), return the header pointer.\n\t */\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(d)))\n\t{\n\t\teah = (ExpandedArrayHeader *) DatumGetEOHP(d);\n\t\tAssert(eah->ea_magic == EA_MAGIC);\n\t\treturn (AnyArrayType *) eah;\n\t}\n\n\t/* Else do regular detoasting as needed */\n\treturn (AnyArrayType *) PG_DETOAST_DATUM(d);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nDatum\narray_map(Datum arrayd,\n\t\t  ExprState *exprstate, ExprContext *econtext,\n\t\t  Oid retType, ArrayMapState *amstate)\n{\n\tAnyArrayType *v = DatumGetAnyArrayP(arrayd);\n\tArrayType  *result;\n\tDatum\t   *values;\n\tbool\t   *nulls;\n\tint\t\t   *dim;\n\tint\t\t\tndim;\n\tint\t\t\tnitems;\n\tint\t\t\ti;\n\tint32\t\tnbytes = 0;\n\tint32\t\tdataoffset;\n\tbool\t\thasnulls;\n\tOid\t\t\tinpType;\n\tint\t\t\tinp_typlen;\n\tbool\t\tinp_typbyval;\n\tchar\t\tinp_typalign;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tarray_iter\titer;\n\tArrayMetaState *inp_extra;\n\tArrayMetaState *ret_extra;\n\tDatum\t   *transform_source = exprstate->innermost_caseval;\n\tbool\t   *transform_source_isnull = exprstate->innermost_casenull;\n\n\tinpType = AARR_ELEMTYPE(v);\n\tndim = AARR_NDIM(v);\n\tdim = AARR_DIMS(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/* Check for empty array */\n\tif (nitems <= 0)\n\t{\n\t\t/* Return empty array */\n\t\treturn PointerGetDatum(construct_empty_array(retType));\n\t}\n\n\t/*\n\t * We arrange to look up info about input and return element types only\n\t * once per series of calls, assuming the element type doesn't change\n\t * underneath us.\n\t */\n\tinp_extra = &amstate->inp_extra;\n\tret_extra = &amstate->ret_extra;\n\n\tif (inp_extra->element_type != inpType)\n\t{\n\t\tget_typlenbyvalalign(inpType,\n\t\t\t\t\t\t\t &inp_extra->typlen,\n\t\t\t\t\t\t\t &inp_extra->typbyval,\n\t\t\t\t\t\t\t &inp_extra->typalign);\n\t\tinp_extra->element_type = inpType;\n\t}\n\tinp_typlen = inp_extra->typlen;\n\tinp_typbyval = inp_extra->typbyval;\n\tinp_typalign = inp_extra->typalign;\n\n\tif (ret_extra->element_type != retType)\n\t{\n\t\tget_typlenbyvalalign(retType,\n\t\t\t\t\t\t\t &ret_extra->typlen,\n\t\t\t\t\t\t\t &ret_extra->typbyval,\n\t\t\t\t\t\t\t &ret_extra->typalign);\n\t\tret_extra->element_type = retType;\n\t}\n\ttyplen = ret_extra->typlen;\n\ttypbyval = ret_extra->typbyval;\n\ttypalign = ret_extra->typalign;\n\n\t/* Allocate temporary arrays for new values */\n\tvalues = (Datum *) palloc(nitems * sizeof(Datum));\n\tnulls = (bool *) palloc(nitems * sizeof(bool));\n\n\t/* Loop over source data */\n\tarray_iter_setup(&iter, v);\n\thasnulls = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\t*transform_source =\n\t\t\tarray_iter_next(&iter, transform_source_isnull, i,\n\t\t\t\t\t\t\tinp_typlen, inp_typbyval, inp_typalign);\n\n\t\t/* Apply the given expression to source element */\n\t\tvalues[i] = ExecEvalExpr(exprstate, econtext, &nulls[i]);\n\n\t\tif (nulls[i])\n\t\t\thasnulls = true;\n\t\telse\n\t\t{\n\t\t\t/* Ensure data is not toasted */\n\t\t\tif (typlen == -1)\n\t\t\t\tvalues[i] = PointerGetDatum(PG_DETOAST_DATUM(values[i]));\n\t\t\t/* Update total result size */\n\t\t\tnbytes = att_addlength_datum(nbytes, typlen, values[i]);\n\t\t\tnbytes = att_align_nominal(nbytes, typalign);\n\t\t\t/* check for overflow of total request */\n\t\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t}\n\t}\n\n\t/* Allocate and fill the result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndim;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = retType;\n\tmemcpy(ARR_DIMS(result), AARR_DIMS(v), ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), AARR_LBOUND(v), ndim * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t values, nulls, nitems,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t false);\n\n\t/*\n\t * Note: do not risk trying to pfree the results of the called expression\n\t */\n\tpfree(values);\n\tpfree(nulls);\n\n\treturn PointerGetDatum(result);\n}"
  },
  {
    "function_name": "array_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3092-3102",
    "snippet": "ArrayType *\narray_set(ArrayType *array, int nSubscripts, int *indx,\n\t\t  Datum dataValue, bool isNull,\n\t\t  int arraytyplen, int elmlen, bool elmbyval, char elmalign)\n{\n\treturn DatumGetArrayTypeP(array_set_element(PointerGetDatum(array),\n\t\t\t\t\t\t\t\t\t\t\t\tnSubscripts, indx,\n\t\t\t\t\t\t\t\t\t\t\t\tdataValue, isNull,\n\t\t\t\t\t\t\t\t\t\t\t\tarraytyplen,\n\t\t\t\t\t\t\t\t\t\t\t\telmlen, elmbyval, elmalign));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "array_set_element(PointerGetDatum(array),\n\t\t\t\t\t\t\t\t\t\t\t\tnSubscripts, indx,\n\t\t\t\t\t\t\t\t\t\t\t\tdataValue, isNull,\n\t\t\t\t\t\t\t\t\t\t\t\tarraytyplen,\n\t\t\t\t\t\t\t\t\t\t\t\telmlen, elmbyval, elmalign)"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_set_element",
          "args": [
            "PointerGetDatum(array)",
            "nSubscripts",
            "indx",
            "dataValue",
            "isNull",
            "arraytyplen",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "array_set_element_expanded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "2480-2716",
          "snippet": "static Datum\narray_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tbool\t\tdimschanged,\n\t\t\t\tnewhasnulls;\n\tint\t\t\taddedbefore,\n\t\t\t\taddedafter;\n\tchar\t   *oldValue;\n\n\t/* Convert to R/W object if not so already */\n\teah = DatumGetExpandedArray(arraydatum);\n\n\t/* Sanity-check caller's info against object; we don't use it otherwise */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\t/*\n\t * Copy dimension info into local storage.  This allows us to modify the\n\t * dimensions if needed, while not messing up the expanded value if we\n\t * fail partway through.\n\t */\n\tndim = eah->ndims;\n\tAssert(ndim >= 0 && ndim <= MAXDIM);\n\tmemcpy(dim, eah->dims, ndim * sizeof(int));\n\tmemcpy(lb, eah->lbound, ndim * sizeof(int));\n\tdimschanged = false;\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts.\n\t */\n\tif (ndim == 0)\n\t{\n\t\t/*\n\t\t * Allocate adequate space for new dimension info.  This is harmless\n\t\t * if we fail later.\n\t\t */\n\t\tAssert(nSubscripts > 0 && nSubscripts <= MAXDIM);\n\t\teah->dims = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t   nSubscripts * sizeof(int));\n\t\teah->lbound = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t nSubscripts * sizeof(int));\n\n\t\t/* Update local copies of dimension info */\n\t\tndim = nSubscripts;\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 0;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\t\tdimschanged = true;\n\t}\n\telse if (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/*\n\t * Deconstruct array if we didn't already.  (Someday maybe add a special\n\t * case path for fixed-length, no-nulls cases, where we can overwrite an\n\t * element in place without ever deconstructing.  But today is not that\n\t * day.)\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\t/*\n\t * Copy new element into array's context, if needed (we assume it's\n\t * already detoasted, so no junk should be created).  If we fail further\n\t * down, this memory is leaked, but that's reasonably harmless.\n\t */\n\tif (!eah->typbyval && !isNull)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\n\t\tdataValue = datumCopy(dataValue, false, eah->typlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\tnewhasnulls = ((dnulls != NULL) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts (this logic matches original array_set_element)\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tdimschanged = true;\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tdimschanged = true;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/* Now we can calculate linear offset of target item in array */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/* Physically enlarge existing dvalues/dnulls arrays if needed */\n\tif (dim[0] > eah->dvalueslen)\n\t{\n\t\t/* We want some extra space if we're enlarging */\n\t\tint\t\t\tnewlen = dim[0] + dim[0] / 8;\n\n\t\tnewlen = Max(newlen, dim[0]);\t/* integer overflow guard */\n\t\teah->dvalues = dvalues = (Datum *)\n\t\t\trepalloc(dvalues, newlen * sizeof(Datum));\n\t\tif (dnulls)\n\t\t\teah->dnulls = dnulls = (bool *)\n\t\t\t\trepalloc(dnulls, newlen * sizeof(bool));\n\t\teah->dvalueslen = newlen;\n\t}\n\n\t/*\n\t * If we need a nulls bitmap and don't already have one, create it, being\n\t * sure to mark all existing entries as not null.\n\t */\n\tif (newhasnulls && dnulls == NULL)\n\t\teah->dnulls = dnulls = (bool *)\n\t\t\tMemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   eah->dvalueslen * sizeof(bool));\n\n\t/*\n\t * We now have all the needed space allocated, so we're ready to make\n\t * irreversible changes.  Be very wary of allowing failure below here.\n\t */\n\n\t/* Flattened value will no longer represent array accurately */\n\teah->fvalue = NULL;\n\t/* And we don't know the flattened size either */\n\teah->flat_size = 0;\n\n\t/* Update dimensionality info if needed */\n\tif (dimschanged)\n\t{\n\t\teah->ndims = ndim;\n\t\tmemcpy(eah->dims, dim, ndim * sizeof(int));\n\t\tmemcpy(eah->lbound, lb, ndim * sizeof(int));\n\t}\n\n\t/* Reposition items if needed, and fill addedbefore items with nulls */\n\tif (addedbefore > 0)\n\t{\n\t\tmemmove(dvalues + addedbefore, dvalues, eah->nelems * sizeof(Datum));\n\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\tdvalues[i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tmemmove(dnulls + addedbefore, dnulls, eah->nelems * sizeof(bool));\n\t\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\t\tdnulls[i] = true;\n\t\t}\n\t\teah->nelems += addedbefore;\n\t}\n\n\t/* fill addedafter items with nulls */\n\tif (addedafter > 0)\n\t{\n\t\tfor (i = 0; i < addedafter; i++)\n\t\t\tdvalues[eah->nelems + i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tfor (i = 0; i < addedafter; i++)\n\t\t\t\tdnulls[eah->nelems + i] = true;\n\t\t}\n\t\teah->nelems += addedafter;\n\t}\n\n\t/* Grab old element value for pfree'ing, if needed. */\n\tif (!eah->typbyval && (dnulls == NULL || !dnulls[offset]))\n\t\toldValue = (char *) DatumGetPointer(dvalues[offset]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new element. */\n\tdvalues[offset] = dataValue;\n\tif (dnulls)\n\t\tdnulls[offset] = isNull;\n\n\t/*\n\t * Free old element if needed; this keeps repeated element replacements\n\t * from bloating the array's storage.  If the pfree somehow fails, it\n\t * won't corrupt the array.\n\t */\n\tif (oldValue)\n\t{\n\t\t/* Don't try to pfree a part of the original flat array */\n\t\tif (oldValue < eah->fstartptr || oldValue >= eah->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n\n\t/* Done, return standard TOAST pointer for object */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic Datum\narray_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tbool\t\tdimschanged,\n\t\t\t\tnewhasnulls;\n\tint\t\t\taddedbefore,\n\t\t\t\taddedafter;\n\tchar\t   *oldValue;\n\n\t/* Convert to R/W object if not so already */\n\teah = DatumGetExpandedArray(arraydatum);\n\n\t/* Sanity-check caller's info against object; we don't use it otherwise */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\t/*\n\t * Copy dimension info into local storage.  This allows us to modify the\n\t * dimensions if needed, while not messing up the expanded value if we\n\t * fail partway through.\n\t */\n\tndim = eah->ndims;\n\tAssert(ndim >= 0 && ndim <= MAXDIM);\n\tmemcpy(dim, eah->dims, ndim * sizeof(int));\n\tmemcpy(lb, eah->lbound, ndim * sizeof(int));\n\tdimschanged = false;\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts.\n\t */\n\tif (ndim == 0)\n\t{\n\t\t/*\n\t\t * Allocate adequate space for new dimension info.  This is harmless\n\t\t * if we fail later.\n\t\t */\n\t\tAssert(nSubscripts > 0 && nSubscripts <= MAXDIM);\n\t\teah->dims = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t   nSubscripts * sizeof(int));\n\t\teah->lbound = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t nSubscripts * sizeof(int));\n\n\t\t/* Update local copies of dimension info */\n\t\tndim = nSubscripts;\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 0;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\t\tdimschanged = true;\n\t}\n\telse if (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/*\n\t * Deconstruct array if we didn't already.  (Someday maybe add a special\n\t * case path for fixed-length, no-nulls cases, where we can overwrite an\n\t * element in place without ever deconstructing.  But today is not that\n\t * day.)\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\t/*\n\t * Copy new element into array's context, if needed (we assume it's\n\t * already detoasted, so no junk should be created).  If we fail further\n\t * down, this memory is leaked, but that's reasonably harmless.\n\t */\n\tif (!eah->typbyval && !isNull)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\n\t\tdataValue = datumCopy(dataValue, false, eah->typlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\tnewhasnulls = ((dnulls != NULL) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts (this logic matches original array_set_element)\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tdimschanged = true;\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tdimschanged = true;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/* Now we can calculate linear offset of target item in array */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/* Physically enlarge existing dvalues/dnulls arrays if needed */\n\tif (dim[0] > eah->dvalueslen)\n\t{\n\t\t/* We want some extra space if we're enlarging */\n\t\tint\t\t\tnewlen = dim[0] + dim[0] / 8;\n\n\t\tnewlen = Max(newlen, dim[0]);\t/* integer overflow guard */\n\t\teah->dvalues = dvalues = (Datum *)\n\t\t\trepalloc(dvalues, newlen * sizeof(Datum));\n\t\tif (dnulls)\n\t\t\teah->dnulls = dnulls = (bool *)\n\t\t\t\trepalloc(dnulls, newlen * sizeof(bool));\n\t\teah->dvalueslen = newlen;\n\t}\n\n\t/*\n\t * If we need a nulls bitmap and don't already have one, create it, being\n\t * sure to mark all existing entries as not null.\n\t */\n\tif (newhasnulls && dnulls == NULL)\n\t\teah->dnulls = dnulls = (bool *)\n\t\t\tMemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   eah->dvalueslen * sizeof(bool));\n\n\t/*\n\t * We now have all the needed space allocated, so we're ready to make\n\t * irreversible changes.  Be very wary of allowing failure below here.\n\t */\n\n\t/* Flattened value will no longer represent array accurately */\n\teah->fvalue = NULL;\n\t/* And we don't know the flattened size either */\n\teah->flat_size = 0;\n\n\t/* Update dimensionality info if needed */\n\tif (dimschanged)\n\t{\n\t\teah->ndims = ndim;\n\t\tmemcpy(eah->dims, dim, ndim * sizeof(int));\n\t\tmemcpy(eah->lbound, lb, ndim * sizeof(int));\n\t}\n\n\t/* Reposition items if needed, and fill addedbefore items with nulls */\n\tif (addedbefore > 0)\n\t{\n\t\tmemmove(dvalues + addedbefore, dvalues, eah->nelems * sizeof(Datum));\n\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\tdvalues[i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tmemmove(dnulls + addedbefore, dnulls, eah->nelems * sizeof(bool));\n\t\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\t\tdnulls[i] = true;\n\t\t}\n\t\teah->nelems += addedbefore;\n\t}\n\n\t/* fill addedafter items with nulls */\n\tif (addedafter > 0)\n\t{\n\t\tfor (i = 0; i < addedafter; i++)\n\t\t\tdvalues[eah->nelems + i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tfor (i = 0; i < addedafter; i++)\n\t\t\t\tdnulls[eah->nelems + i] = true;\n\t\t}\n\t\teah->nelems += addedafter;\n\t}\n\n\t/* Grab old element value for pfree'ing, if needed. */\n\tif (!eah->typbyval && (dnulls == NULL || !dnulls[offset]))\n\t\toldValue = (char *) DatumGetPointer(dvalues[offset]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new element. */\n\tdvalues[offset] = dataValue;\n\tif (dnulls)\n\t\tdnulls[offset] = isNull;\n\n\t/*\n\t * Free old element if needed; this keeps repeated element replacements\n\t * from bloating the array's storage.  If the pfree somehow fails, it\n\t * won't corrupt the array.\n\t */\n\tif (oldValue)\n\t{\n\t\t/* Don't try to pfree a part of the original flat array */\n\t\tif (oldValue < eah->fstartptr || oldValue >= eah->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n\n\t/* Done, return standard TOAST pointer for object */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "array"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\n\nArrayType *\narray_set(ArrayType *array, int nSubscripts, int *indx,\n\t\t  Datum dataValue, bool isNull,\n\t\t  int arraytyplen, int elmlen, bool elmbyval, char elmalign)\n{\n\treturn DatumGetArrayTypeP(array_set_element(PointerGetDatum(array),\n\t\t\t\t\t\t\t\t\t\t\t\tnSubscripts, indx,\n\t\t\t\t\t\t\t\t\t\t\t\tdataValue, isNull,\n\t\t\t\t\t\t\t\t\t\t\t\tarraytyplen,\n\t\t\t\t\t\t\t\t\t\t\t\telmlen, elmbyval, elmalign));\n}"
  },
  {
    "function_name": "array_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "3075-3083",
    "snippet": "Datum\narray_ref(ArrayType *array, int nSubscripts, int *indx,\n\t\t  int arraytyplen, int elmlen, bool elmbyval, char elmalign,\n\t\t  bool *isNull)\n{\n\treturn array_get_element(PointerGetDatum(array), nSubscripts, indx,\n\t\t\t\t\t\t\t arraytyplen, elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t\t isNull);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_get_element",
          "args": [
            "PointerGetDatum(array)",
            "nSubscripts",
            "indx",
            "arraytyplen",
            "elmlen",
            "elmbyval",
            "elmalign",
            "isNull"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "array_get_element_expanded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "1919-1996",
          "snippet": "static Datum\narray_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull)\n{\n\tExpandedArrayHeader *eah;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t\toffset;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\n\teah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* sanity-check caller's info against object */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\tndim = eah->ndims;\n\tdim = eah->dims;\n\tlb = eah->lbound;\n\n\t/*\n\t * Return NULL for invalid subscript\n\t */\n\tif (ndim != nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (indx[i] < lb[i] || indx[i] >= (dim[i] + lb[i]))\n\t\t{\n\t\t\t*isNull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the element number\n\t */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/*\n\t * Deconstruct array if we didn't already.  Note that we apply this even\n\t * if the input is nominally read-only: it should be safe enough.\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\t/*\n\t * Check for NULL array element\n\t */\n\tif (dnulls && dnulls[offset])\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/*\n\t * OK, get the element.  It's OK to return a pass-by-ref value as a\n\t * pointer into the expanded array, for the same reason that regular\n\t * array_get_element can return a pointer into flat arrays: the value is\n\t * assumed not to change for as long as the Datum reference can exist.\n\t */\n\t*isNull = false;\n\treturn dvalues[offset];\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic Datum\narray_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull)\n{\n\tExpandedArrayHeader *eah;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t\toffset;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\n\teah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* sanity-check caller's info against object */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\tndim = eah->ndims;\n\tdim = eah->dims;\n\tlb = eah->lbound;\n\n\t/*\n\t * Return NULL for invalid subscript\n\t */\n\tif (ndim != nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (indx[i] < lb[i] || indx[i] >= (dim[i] + lb[i]))\n\t\t{\n\t\t\t*isNull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the element number\n\t */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/*\n\t * Deconstruct array if we didn't already.  Note that we apply this even\n\t * if the input is nominally read-only: it should be safe enough.\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\t/*\n\t * Check for NULL array element\n\t */\n\tif (dnulls && dnulls[offset])\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/*\n\t * OK, get the element.  It's OK to return a pass-by-ref value as a\n\t * pointer into the expanded array, for the same reason that regular\n\t * array_get_element can return a pointer into flat arrays: the value is\n\t * assumed not to change for as long as the Datum reference can exist.\n\t */\n\t*isNull = false;\n\treturn dvalues[offset];\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "array"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\n\nDatum\narray_ref(ArrayType *array, int nSubscripts, int *indx,\n\t\t  int arraytyplen, int elmlen, bool elmbyval, char elmalign,\n\t\t  bool *isNull)\n{\n\treturn array_get_element(PointerGetDatum(array), nSubscripts, indx,\n\t\t\t\t\t\t\t arraytyplen, elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t\t isNull);\n}"
  },
  {
    "function_name": "array_set_slice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "2758-3066",
    "snippet": "Datum\narray_set_slice(Datum arraydatum,\n\t\t\t\tint nSubscripts,\n\t\t\t\tint *upperIndx,\n\t\t\t\tint *lowerIndx,\n\t\t\t\tbool *upperProvided,\n\t\t\t\tbool *lowerProvided,\n\t\t\t\tDatum srcArrayDatum,\n\t\t\t\tbool isNull,\n\t\t\t\tint arraytyplen,\n\t\t\t\tint elmlen,\n\t\t\t\tbool elmbyval,\n\t\t\t\tchar elmalign)\n{\n\tArrayType  *array;\n\tArrayType  *srcArray;\n\tArrayType  *newarray;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\tspan[MAXDIM];\n\tbool\t\tnewhasnulls;\n\tint\t\t\tnitems,\n\t\t\t\tnsrcitems,\n\t\t\t\tolddatasize,\n\t\t\t\tnewsize,\n\t\t\t\tolditemsize,\n\t\t\t\tnewitemsize,\n\t\t\t\toverheadlen,\n\t\t\t\toldoverheadlen,\n\t\t\t\taddedbefore,\n\t\t\t\taddedafter,\n\t\t\t\tlenbefore,\n\t\t\t\tlenafter,\n\t\t\t\titemsbefore,\n\t\t\t\titemsafter,\n\t\t\t\tnolditems;\n\n\t/* Currently, assignment from a NULL source array is a no-op */\n\tif (isNull)\n\t\treturn arraydatum;\n\n\tif (arraytyplen > 0)\n\t{\n\t\t/*\n\t\t * fixed-length arrays -- not got round to doing this...\n\t\t */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"updates on slices of fixed-length arrays not implemented\")));\n\t}\n\n\t/* detoast arrays if necessary */\n\tarray = DatumGetArrayTypeP(arraydatum);\n\tsrcArray = DatumGetArrayTypeP(srcArrayDatum);\n\n\t/* note: we assume srcArray contains no toasted elements */\n\n\tndim = ARR_NDIM(array);\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the upper and lower bounds to the\n\t * supplied subscripts\n\t */\n\tif (ndim == 0)\n\t{\n\t\tDatum\t   *dvalues;\n\t\tbool\t   *dnulls;\n\t\tint\t\t\tnelems;\n\t\tOid\t\t\telmtype = ARR_ELEMTYPE(array);\n\n\t\tdeconstruct_array(srcArray, elmtype, elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &dvalues, &dnulls, &nelems);\n\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tif (!upperProvided[i] || !lowerProvided[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array slice subscript must provide both boundaries\"),\n\t\t\t\t\t\t errdetail(\"When assigning to a slice of an empty array value,\"\n\t\t\t\t\t\t\t\t   \" slice boundaries must be fully specified.\")));\n\n\t\t\tdim[i] = 1 + upperIndx[i] - lowerIndx[i];\n\t\t\tlb[i] = lowerIndx[i];\n\t\t}\n\n\t\t/* complain if too few source items; we ignore extras, however */\n\t\tif (nelems < ArrayGetNItems(nSubscripts, dim))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"source array too small\")));\n\n\t\treturn PointerGetDatum(construct_md_array(dvalues, dnulls, nSubscripts,\n\t\t\t\t\t\t\t\t\t\t\t\t  dim, lb, elmtype,\n\t\t\t\t\t\t\t\t\t\t\t\t  elmlen, elmbyval, elmalign));\n\t}\n\n\tif (ndim < nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/* copy dim/lb since we may modify them */\n\tmemcpy(dim, ARR_DIMS(array), ndim * sizeof(int));\n\tmemcpy(lb, ARR_LBOUND(array), ndim * sizeof(int));\n\n\tnewhasnulls = (ARR_HASNULL(array) || ARR_HASNULL(srcArray));\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts\n\t */\n\tif (ndim == 1)\n\t{\n\t\tAssert(nSubscripts == 1);\n\t\tif (!lowerProvided[0])\n\t\t\tlowerIndx[0] = lb[0];\n\t\tif (!upperProvided[0])\n\t\t\tupperIndx[0] = dim[0] + lb[0] - 1;\n\t\tif (lowerIndx[0] > upperIndx[0])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\")));\n\t\tif (lowerIndx[0] < lb[0])\n\t\t{\n\t\t\tif (upperIndx[0] < lb[0] - 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t\taddedbefore = lb[0] - lowerIndx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = lowerIndx[0];\n\t\t}\n\t\tif (upperIndx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\tif (lowerIndx[0] > (dim[0] + lb[0]))\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t\taddedafter = upperIndx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tif (!lowerProvided[i])\n\t\t\t\tlowerIndx[i] = lb[i];\n\t\t\tif (!upperProvided[i])\n\t\t\t\tupperIndx[i] = dim[i] + lb[i] - 1;\n\t\t\tif (lowerIndx[i] > upperIndx[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\")));\n\t\t\tif (lowerIndx[i] < lb[i] ||\n\t\t\t\tupperIndx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t\t/* fill any missing subscript positions with full array range */\n\t\tfor (; i < ndim; i++)\n\t\t{\n\t\t\tlowerIndx[i] = lb[i];\n\t\t\tupperIndx[i] = dim[i] + lb[i] - 1;\n\t\t\tif (lowerIndx[i] > upperIndx[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\")));\n\t\t}\n\t}\n\n\t/* Do this mainly to check for overflow */\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/*\n\t * Make sure source array has enough entries.  Note we ignore the shape of\n\t * the source array and just read entries serially.\n\t */\n\tmda_get_range(ndim, span, lowerIndx, upperIndx);\n\tnsrcitems = ArrayGetNItems(ndim, span);\n\tif (nsrcitems > ArrayGetNItems(ARR_NDIM(srcArray), ARR_DIMS(srcArray)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"source array too small\")));\n\n\t/*\n\t * Compute space occupied by new entries, space occupied by replaced\n\t * entries, and required space for new array.\n\t */\n\tif (newhasnulls)\n\t\toverheadlen = ARR_OVERHEAD_WITHNULLS(ndim, nitems);\n\telse\n\t\toverheadlen = ARR_OVERHEAD_NONULLS(ndim);\n\tnewitemsize = array_nelems_size(ARR_DATA_PTR(srcArray), 0,\n\t\t\t\t\t\t\t\t\tARR_NULLBITMAP(srcArray), nsrcitems,\n\t\t\t\t\t\t\t\t\telmlen, elmbyval, elmalign);\n\toldoverheadlen = ARR_DATA_OFFSET(array);\n\tolddatasize = ARR_SIZE(array) - oldoverheadlen;\n\tif (ndim > 1)\n\t{\n\t\t/*\n\t\t * here we do not need to cope with extension of the array; it would\n\t\t * be a lot more complicated if we had to do so...\n\t\t */\n\t\tolditemsize = array_slice_size(ARR_DATA_PTR(array),\n\t\t\t\t\t\t\t\t\t   ARR_NULLBITMAP(array),\n\t\t\t\t\t\t\t\t\t   ndim, dim, lb,\n\t\t\t\t\t\t\t\t\t   lowerIndx, upperIndx,\n\t\t\t\t\t\t\t\t\t   elmlen, elmbyval, elmalign);\n\t\tlenbefore = lenafter = 0;\t/* keep compiler quiet */\n\t\titemsbefore = itemsafter = nolditems = 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * here we must allow for possibility of slice larger than orig array\n\t\t * and/or not adjacent to orig array subscripts\n\t\t */\n\t\tint\t\t\toldlb = ARR_LBOUND(array)[0];\n\t\tint\t\t\toldub = oldlb + ARR_DIMS(array)[0] - 1;\n\t\tint\t\t\tslicelb = Max(oldlb, lowerIndx[0]);\n\t\tint\t\t\tsliceub = Min(oldub, upperIndx[0]);\n\t\tchar\t   *oldarraydata = ARR_DATA_PTR(array);\n\t\tbits8\t   *oldarraybitmap = ARR_NULLBITMAP(array);\n\n\t\t/* count/size of old array entries that will go before the slice */\n\t\titemsbefore = Min(slicelb, oldub + 1) - oldlb;\n\t\tlenbefore = array_nelems_size(oldarraydata, 0, oldarraybitmap,\n\t\t\t\t\t\t\t\t\t  itemsbefore,\n\t\t\t\t\t\t\t\t\t  elmlen, elmbyval, elmalign);\n\t\t/* count/size of old array entries that will be replaced by slice */\n\t\tif (slicelb > sliceub)\n\t\t{\n\t\t\tnolditems = 0;\n\t\t\tolditemsize = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnolditems = sliceub - slicelb + 1;\n\t\t\tolditemsize = array_nelems_size(oldarraydata + lenbefore,\n\t\t\t\t\t\t\t\t\t\t\titemsbefore, oldarraybitmap,\n\t\t\t\t\t\t\t\t\t\t\tnolditems,\n\t\t\t\t\t\t\t\t\t\t\telmlen, elmbyval, elmalign);\n\t\t}\n\t\t/* count/size of old array entries that will go after the slice */\n\t\titemsafter = oldub + 1 - Max(sliceub + 1, oldlb);\n\t\tlenafter = olddatasize - lenbefore - olditemsize;\n\t}\n\n\tnewsize = overheadlen + olddatasize - olditemsize + newitemsize;\n\n\tnewarray = (ArrayType *) palloc0(newsize);\n\tSET_VARSIZE(newarray, newsize);\n\tnewarray->ndim = ndim;\n\tnewarray->dataoffset = newhasnulls ? overheadlen : 0;\n\tnewarray->elemtype = ARR_ELEMTYPE(array);\n\tmemcpy(ARR_DIMS(newarray), dim, ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(newarray), lb, ndim * sizeof(int));\n\n\tif (ndim > 1)\n\t{\n\t\t/*\n\t\t * here we do not need to cope with extension of the array; it would\n\t\t * be a lot more complicated if we had to do so...\n\t\t */\n\t\tarray_insert_slice(newarray, array, srcArray,\n\t\t\t\t\t\t   ndim, dim, lb,\n\t\t\t\t\t\t   lowerIndx, upperIndx,\n\t\t\t\t\t\t   elmlen, elmbyval, elmalign);\n\t}\n\telse\n\t{\n\t\t/* fill in data */\n\t\tmemcpy((char *) newarray + overheadlen,\n\t\t\t   (char *) array + oldoverheadlen,\n\t\t\t   lenbefore);\n\t\tmemcpy((char *) newarray + overheadlen + lenbefore,\n\t\t\t   ARR_DATA_PTR(srcArray),\n\t\t\t   newitemsize);\n\t\tmemcpy((char *) newarray + overheadlen + lenbefore + newitemsize,\n\t\t\t   (char *) array + oldoverheadlen + lenbefore + olditemsize,\n\t\t\t   lenafter);\n\t\t/* fill in nulls bitmap if needed */\n\t\tif (newhasnulls)\n\t\t{\n\t\t\tbits8\t   *newnullbitmap = ARR_NULLBITMAP(newarray);\n\t\t\tbits8\t   *oldnullbitmap = ARR_NULLBITMAP(array);\n\n\t\t\t/* Zero the bitmap to handle marking inserted positions null */\n\t\t\tMemSet(newnullbitmap, 0, (nitems + 7) / 8);\n\t\t\tarray_bitmap_copy(newnullbitmap, addedbefore,\n\t\t\t\t\t\t\t  oldnullbitmap, 0,\n\t\t\t\t\t\t\t  itemsbefore);\n\t\t\tarray_bitmap_copy(newnullbitmap, lowerIndx[0] - lb[0],\n\t\t\t\t\t\t\t  ARR_NULLBITMAP(srcArray), 0,\n\t\t\t\t\t\t\t  nsrcitems);\n\t\t\tarray_bitmap_copy(newnullbitmap, addedbefore + itemsbefore + nolditems,\n\t\t\t\t\t\t\t  oldnullbitmap, itemsbefore + nolditems,\n\t\t\t\t\t\t\t  itemsafter);\n\t\t}\n\t}\n\n\treturn PointerGetDatum(newarray);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "newarray"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_bitmap_copy",
          "args": [
            "newnullbitmap",
            "addedbefore + itemsbefore + nolditems",
            "oldnullbitmap",
            "itemsbefore + nolditems",
            "itemsafter"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "array_bitmap_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4687-4751",
          "snippet": "void\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "srcArray"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "newnullbitmap",
            "0",
            "(nitems + 7) / 8"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "array"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "newarray"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) newarray + overheadlen + lenbefore + newitemsize",
            "(char *) array + oldoverheadlen + lenbefore + olditemsize",
            "lenafter"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) newarray + overheadlen + lenbefore",
            "ARR_DATA_PTR(srcArray)",
            "newitemsize"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "srcArray"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) newarray + overheadlen",
            "(char *) array + oldoverheadlen",
            "lenbefore"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_insert_slice",
          "args": [
            "newarray",
            "array",
            "srcArray",
            "ndim",
            "dim",
            "lb",
            "lowerIndx",
            "upperIndx",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "array_insert_slice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4891-4983",
          "snippet": "static void\narray_insert_slice(ArrayType *destArray,\n\t\t\t\t   ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim,\n\t\t\t\t   int *dim,\n\t\t\t\t   int *lb,\n\t\t\t\t   int *st,\n\t\t\t\t   int *endp,\n\t\t\t\t   int typlen,\n\t\t\t\t   bool typbyval,\n\t\t\t\t   char typalign)\n{\n\tchar\t   *destPtr = ARR_DATA_PTR(destArray);\n\tchar\t   *origPtr = ARR_DATA_PTR(origArray);\n\tchar\t   *srcPtr = ARR_DATA_PTR(srcArray);\n\tbits8\t   *destBitmap = ARR_NULLBITMAP(destArray);\n\tbits8\t   *origBitmap = ARR_NULLBITMAP(origArray);\n\tbits8\t   *srcBitmap = ARR_NULLBITMAP(srcArray);\n\tint\t\t\torignitems = ArrayGetNItems(ARR_NDIM(origArray),\n\t\t\t\t\t\t\t\t\t\t\tARR_DIMS(origArray));\n\tint\t\t\tdest_offset,\n\t\t\t\torig_offset,\n\t\t\t\tsrc_offset,\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\n\tdest_offset = ArrayGetOffset(ndim, dim, lb, st);\n\t/* copy items before the slice start */\n\tinc = array_copy(destPtr, dest_offset,\n\t\t\t\t\t origPtr, 0, origBitmap,\n\t\t\t\t\t typlen, typbyval, typalign);\n\tdestPtr += inc;\n\torigPtr += inc;\n\tif (destBitmap)\n\t\tarray_bitmap_copy(destBitmap, 0, origBitmap, 0, dest_offset);\n\torig_offset = dest_offset;\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_range(ndim, span, st, endp);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tsrc_offset = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\t/* Copy/advance over elements between here and next part of slice */\n\t\tif (dist[j])\n\t\t{\n\t\t\tinc = array_copy(destPtr, dist[j],\n\t\t\t\t\t\t\t origPtr, orig_offset, origBitmap,\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\t\tdestPtr += inc;\n\t\t\torigPtr += inc;\n\t\t\tif (destBitmap)\n\t\t\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t\t\t  origBitmap, orig_offset,\n\t\t\t\t\t\t\t\t  dist[j]);\n\t\t\tdest_offset += dist[j];\n\t\t\torig_offset += dist[j];\n\t\t}\n\t\t/* Copy new element at this slice position */\n\t\tinc = array_copy(destPtr, 1,\n\t\t\t\t\t\t srcPtr, src_offset, srcBitmap,\n\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\tif (destBitmap)\n\t\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t\t  srcBitmap, src_offset,\n\t\t\t\t\t\t\t  1);\n\t\tdestPtr += inc;\n\t\tsrcPtr += inc;\n\t\tdest_offset++;\n\t\tsrc_offset++;\n\t\t/* Advance over old element at this slice position */\n\t\torigPtr = array_seek(origPtr, orig_offset, origBitmap, 1,\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\torig_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n\n\t/* don't miss any data at the end */\n\tarray_copy(destPtr, orignitems - orig_offset,\n\t\t\t   origPtr, orig_offset, origBitmap,\n\t\t\t   typlen, typbyval, typalign);\n\tif (destBitmap)\n\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t  origBitmap, orig_offset,\n\t\t\t\t\t\t  orignitems - orig_offset);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic void\narray_insert_slice(ArrayType *destArray,\n\t\t\t\t   ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim,\n\t\t\t\t   int *dim,\n\t\t\t\t   int *lb,\n\t\t\t\t   int *st,\n\t\t\t\t   int *endp,\n\t\t\t\t   int typlen,\n\t\t\t\t   bool typbyval,\n\t\t\t\t   char typalign)\n{\n\tchar\t   *destPtr = ARR_DATA_PTR(destArray);\n\tchar\t   *origPtr = ARR_DATA_PTR(origArray);\n\tchar\t   *srcPtr = ARR_DATA_PTR(srcArray);\n\tbits8\t   *destBitmap = ARR_NULLBITMAP(destArray);\n\tbits8\t   *origBitmap = ARR_NULLBITMAP(origArray);\n\tbits8\t   *srcBitmap = ARR_NULLBITMAP(srcArray);\n\tint\t\t\torignitems = ArrayGetNItems(ARR_NDIM(origArray),\n\t\t\t\t\t\t\t\t\t\t\tARR_DIMS(origArray));\n\tint\t\t\tdest_offset,\n\t\t\t\torig_offset,\n\t\t\t\tsrc_offset,\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\n\tdest_offset = ArrayGetOffset(ndim, dim, lb, st);\n\t/* copy items before the slice start */\n\tinc = array_copy(destPtr, dest_offset,\n\t\t\t\t\t origPtr, 0, origBitmap,\n\t\t\t\t\t typlen, typbyval, typalign);\n\tdestPtr += inc;\n\torigPtr += inc;\n\tif (destBitmap)\n\t\tarray_bitmap_copy(destBitmap, 0, origBitmap, 0, dest_offset);\n\torig_offset = dest_offset;\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_range(ndim, span, st, endp);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tsrc_offset = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\t/* Copy/advance over elements between here and next part of slice */\n\t\tif (dist[j])\n\t\t{\n\t\t\tinc = array_copy(destPtr, dist[j],\n\t\t\t\t\t\t\t origPtr, orig_offset, origBitmap,\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\t\tdestPtr += inc;\n\t\t\torigPtr += inc;\n\t\t\tif (destBitmap)\n\t\t\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t\t\t  origBitmap, orig_offset,\n\t\t\t\t\t\t\t\t  dist[j]);\n\t\t\tdest_offset += dist[j];\n\t\t\torig_offset += dist[j];\n\t\t}\n\t\t/* Copy new element at this slice position */\n\t\tinc = array_copy(destPtr, 1,\n\t\t\t\t\t\t srcPtr, src_offset, srcBitmap,\n\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\tif (destBitmap)\n\t\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t\t  srcBitmap, src_offset,\n\t\t\t\t\t\t\t  1);\n\t\tdestPtr += inc;\n\t\tsrcPtr += inc;\n\t\tdest_offset++;\n\t\tsrc_offset++;\n\t\t/* Advance over old element at this slice position */\n\t\torigPtr = array_seek(origPtr, orig_offset, origBitmap, 1,\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\torig_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n\n\t/* don't miss any data at the end */\n\tarray_copy(destPtr, orignitems - orig_offset,\n\t\t\t   origPtr, orig_offset, origBitmap,\n\t\t\t   typlen, typbyval, typalign);\n\tif (destBitmap)\n\t\tarray_bitmap_copy(destBitmap, dest_offset,\n\t\t\t\t\t\t  origBitmap, orig_offset,\n\t\t\t\t\t\t  orignitems - orig_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(newarray)",
            "lb",
            "ndim * sizeof(int)"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "newarray"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(newarray)",
            "dim",
            "ndim * sizeof(int)"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "newarray"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "newarray",
            "newsize"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "newsize"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "sliceub + 1",
            "oldlb"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_nelems_size",
          "args": [
            "oldarraydata + lenbefore",
            "itemsbefore",
            "oldarraybitmap",
            "nolditems",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "array_nelems_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4635-4641",
          "snippet": "static int\narray_nelems_size(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t\t\t  int typlen, bool typbyval, char typalign)\n{\n\treturn array_seek(ptr, offset, nullbitmap, nitems,\n\t\t\t\t\t  typlen, typbyval, typalign) - ptr;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\narray_nelems_size(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t\t\t  int typlen, bool typbyval, char typalign)\n{\n\treturn array_seek(ptr, offset, nullbitmap, nitems,\n\t\t\t\t\t  typlen, typbyval, typalign) - ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "slicelb",
            "oldub + 1"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "array"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "array"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "oldub",
            "upperIndx[0]"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "oldlb",
            "lowerIndx[0]"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "array"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_slice_size",
          "args": [
            "ARR_DATA_PTR(array)",
            "ARR_NULLBITMAP(array)",
            "ndim",
            "dim",
            "lb",
            "lowerIndx",
            "upperIndx",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "array_slice_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4758-4808",
          "snippet": "static int\narray_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tsrc_offset,\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tchar\t   *ptr;\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\tint\t\t\tcount = 0;\n\n\tmda_get_range(ndim, span, st, endp);\n\n\t/* Pretty easy for fixed element length without nulls ... */\n\tif (typlen > 0 && !arraynullsptr)\n\t\treturn ArrayGetNItems(ndim, span) * att_align_nominal(typlen, typalign);\n\n\t/* Else gotta do it the hard way */\n\tsrc_offset = ArrayGetOffset(ndim, dim, lb, st);\n\tptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,\n\t\t\t\t\t typlen, typbyval, typalign);\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\tif (dist[j])\n\t\t{\n\t\t\tptr = array_seek(ptr, src_offset, arraynullsptr, dist[j],\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\t\tsrc_offset += dist[j];\n\t\t}\n\t\tif (!array_get_isnull(arraynullsptr, src_offset))\n\t\t{\n\t\t\tinc = att_addlength_pointer(0, typlen, ptr);\n\t\t\tinc = att_align_nominal(inc, typalign);\n\t\t\tptr += inc;\n\t\t\tcount += inc;\n\t\t}\n\t\tsrc_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n\treturn count;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\narray_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tsrc_offset,\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tchar\t   *ptr;\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\tint\t\t\tcount = 0;\n\n\tmda_get_range(ndim, span, st, endp);\n\n\t/* Pretty easy for fixed element length without nulls ... */\n\tif (typlen > 0 && !arraynullsptr)\n\t\treturn ArrayGetNItems(ndim, span) * att_align_nominal(typlen, typalign);\n\n\t/* Else gotta do it the hard way */\n\tsrc_offset = ArrayGetOffset(ndim, dim, lb, st);\n\tptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,\n\t\t\t\t\t typlen, typbyval, typalign);\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\tif (dist[j])\n\t\t{\n\t\t\tptr = array_seek(ptr, src_offset, arraynullsptr, dist[j],\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\t\tsrc_offset += dist[j];\n\t\t}\n\t\tif (!array_get_isnull(arraynullsptr, src_offset))\n\t\t{\n\t\t\tinc = att_addlength_pointer(0, typlen, ptr);\n\t\t\tinc = att_align_nominal(inc, typalign);\n\t\t\tptr += inc;\n\t\t\tcount += inc;\n\t\t}\n\t\tsrc_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "array"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "array"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_SIZE",
          "args": [
            "array"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_OFFSET",
          "args": [
            "array"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "srcArray"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "srcArray"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndim"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndim",
            "nitems"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"source array too small\"))"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"source array too small\""
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_ARRAY_SUBSCRIPT_ERROR"
          ],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ARR_NDIM(srcArray)",
            "ARR_DIMS(srcArray)"
          ],
          "line": 2943
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "srcArray"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "srcArray"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mda_get_range",
          "args": [
            "ndim",
            "span",
            "lowerIndx",
            "upperIndx"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "119-126",
          "snippet": "void\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\"))"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\"))"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\"))"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\"))"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nSubscripts == 1"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "srcArray"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "array"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lb",
            "ARR_LBOUND(array)",
            "ndim * sizeof(int)"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "array"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dim",
            "ARR_DIMS(array)",
            "ndim * sizeof(int)"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "construct_md_array(dvalues, dnulls, nSubscripts,\n\t\t\t\t\t\t\t\t\t\t\t\t  dim, lb, elmtype,\n\t\t\t\t\t\t\t\t\t\t\t\t  elmlen, elmbyval, elmalign)"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_md_array",
          "args": [
            "dvalues",
            "dnulls",
            "nSubscripts",
            "dim",
            "lb",
            "elmtype",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "construct_md_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3325-3404",
          "snippet": "ArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"source array too small\"))"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array slice subscript must provide both boundaries\"),\n\t\t\t\t\t\t errdetail(\"When assigning to a slice of an empty array value,\"\n\t\t\t\t\t\t\t\t   \" slice boundaries must be fully specified.\"))"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"When assigning to a slice of an empty array value,\"\n\t\t\t\t\t\t\t\t   \" slice boundaries must be fully specified.\""
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "srcArray",
            "elmtype",
            "elmlen",
            "elmbyval",
            "elmalign",
            "&dvalues",
            "&dnulls",
            "&nelems"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "array"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "srcArrayDatum"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "arraydatum"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"updates on slices of fixed-length arrays not implemented\"))"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nDatum\narray_set_slice(Datum arraydatum,\n\t\t\t\tint nSubscripts,\n\t\t\t\tint *upperIndx,\n\t\t\t\tint *lowerIndx,\n\t\t\t\tbool *upperProvided,\n\t\t\t\tbool *lowerProvided,\n\t\t\t\tDatum srcArrayDatum,\n\t\t\t\tbool isNull,\n\t\t\t\tint arraytyplen,\n\t\t\t\tint elmlen,\n\t\t\t\tbool elmbyval,\n\t\t\t\tchar elmalign)\n{\n\tArrayType  *array;\n\tArrayType  *srcArray;\n\tArrayType  *newarray;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\tspan[MAXDIM];\n\tbool\t\tnewhasnulls;\n\tint\t\t\tnitems,\n\t\t\t\tnsrcitems,\n\t\t\t\tolddatasize,\n\t\t\t\tnewsize,\n\t\t\t\tolditemsize,\n\t\t\t\tnewitemsize,\n\t\t\t\toverheadlen,\n\t\t\t\toldoverheadlen,\n\t\t\t\taddedbefore,\n\t\t\t\taddedafter,\n\t\t\t\tlenbefore,\n\t\t\t\tlenafter,\n\t\t\t\titemsbefore,\n\t\t\t\titemsafter,\n\t\t\t\tnolditems;\n\n\t/* Currently, assignment from a NULL source array is a no-op */\n\tif (isNull)\n\t\treturn arraydatum;\n\n\tif (arraytyplen > 0)\n\t{\n\t\t/*\n\t\t * fixed-length arrays -- not got round to doing this...\n\t\t */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"updates on slices of fixed-length arrays not implemented\")));\n\t}\n\n\t/* detoast arrays if necessary */\n\tarray = DatumGetArrayTypeP(arraydatum);\n\tsrcArray = DatumGetArrayTypeP(srcArrayDatum);\n\n\t/* note: we assume srcArray contains no toasted elements */\n\n\tndim = ARR_NDIM(array);\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the upper and lower bounds to the\n\t * supplied subscripts\n\t */\n\tif (ndim == 0)\n\t{\n\t\tDatum\t   *dvalues;\n\t\tbool\t   *dnulls;\n\t\tint\t\t\tnelems;\n\t\tOid\t\t\telmtype = ARR_ELEMTYPE(array);\n\n\t\tdeconstruct_array(srcArray, elmtype, elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t  &dvalues, &dnulls, &nelems);\n\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tif (!upperProvided[i] || !lowerProvided[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array slice subscript must provide both boundaries\"),\n\t\t\t\t\t\t errdetail(\"When assigning to a slice of an empty array value,\"\n\t\t\t\t\t\t\t\t   \" slice boundaries must be fully specified.\")));\n\n\t\t\tdim[i] = 1 + upperIndx[i] - lowerIndx[i];\n\t\t\tlb[i] = lowerIndx[i];\n\t\t}\n\n\t\t/* complain if too few source items; we ignore extras, however */\n\t\tif (nelems < ArrayGetNItems(nSubscripts, dim))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"source array too small\")));\n\n\t\treturn PointerGetDatum(construct_md_array(dvalues, dnulls, nSubscripts,\n\t\t\t\t\t\t\t\t\t\t\t\t  dim, lb, elmtype,\n\t\t\t\t\t\t\t\t\t\t\t\t  elmlen, elmbyval, elmalign));\n\t}\n\n\tif (ndim < nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/* copy dim/lb since we may modify them */\n\tmemcpy(dim, ARR_DIMS(array), ndim * sizeof(int));\n\tmemcpy(lb, ARR_LBOUND(array), ndim * sizeof(int));\n\n\tnewhasnulls = (ARR_HASNULL(array) || ARR_HASNULL(srcArray));\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts\n\t */\n\tif (ndim == 1)\n\t{\n\t\tAssert(nSubscripts == 1);\n\t\tif (!lowerProvided[0])\n\t\t\tlowerIndx[0] = lb[0];\n\t\tif (!upperProvided[0])\n\t\t\tupperIndx[0] = dim[0] + lb[0] - 1;\n\t\tif (lowerIndx[0] > upperIndx[0])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\")));\n\t\tif (lowerIndx[0] < lb[0])\n\t\t{\n\t\t\tif (upperIndx[0] < lb[0] - 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t\taddedbefore = lb[0] - lowerIndx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = lowerIndx[0];\n\t\t}\n\t\tif (upperIndx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\tif (lowerIndx[0] > (dim[0] + lb[0]))\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t\taddedafter = upperIndx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tif (!lowerProvided[i])\n\t\t\t\tlowerIndx[i] = lb[i];\n\t\t\tif (!upperProvided[i])\n\t\t\t\tupperIndx[i] = dim[i] + lb[i] - 1;\n\t\t\tif (lowerIndx[i] > upperIndx[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\")));\n\t\t\tif (lowerIndx[i] < lb[i] ||\n\t\t\t\tupperIndx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t\t/* fill any missing subscript positions with full array range */\n\t\tfor (; i < ndim; i++)\n\t\t{\n\t\t\tlowerIndx[i] = lb[i];\n\t\t\tupperIndx[i] = dim[i] + lb[i] - 1;\n\t\t\tif (lowerIndx[i] > upperIndx[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\")));\n\t\t}\n\t}\n\n\t/* Do this mainly to check for overflow */\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/*\n\t * Make sure source array has enough entries.  Note we ignore the shape of\n\t * the source array and just read entries serially.\n\t */\n\tmda_get_range(ndim, span, lowerIndx, upperIndx);\n\tnsrcitems = ArrayGetNItems(ndim, span);\n\tif (nsrcitems > ArrayGetNItems(ARR_NDIM(srcArray), ARR_DIMS(srcArray)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"source array too small\")));\n\n\t/*\n\t * Compute space occupied by new entries, space occupied by replaced\n\t * entries, and required space for new array.\n\t */\n\tif (newhasnulls)\n\t\toverheadlen = ARR_OVERHEAD_WITHNULLS(ndim, nitems);\n\telse\n\t\toverheadlen = ARR_OVERHEAD_NONULLS(ndim);\n\tnewitemsize = array_nelems_size(ARR_DATA_PTR(srcArray), 0,\n\t\t\t\t\t\t\t\t\tARR_NULLBITMAP(srcArray), nsrcitems,\n\t\t\t\t\t\t\t\t\telmlen, elmbyval, elmalign);\n\toldoverheadlen = ARR_DATA_OFFSET(array);\n\tolddatasize = ARR_SIZE(array) - oldoverheadlen;\n\tif (ndim > 1)\n\t{\n\t\t/*\n\t\t * here we do not need to cope with extension of the array; it would\n\t\t * be a lot more complicated if we had to do so...\n\t\t */\n\t\tolditemsize = array_slice_size(ARR_DATA_PTR(array),\n\t\t\t\t\t\t\t\t\t   ARR_NULLBITMAP(array),\n\t\t\t\t\t\t\t\t\t   ndim, dim, lb,\n\t\t\t\t\t\t\t\t\t   lowerIndx, upperIndx,\n\t\t\t\t\t\t\t\t\t   elmlen, elmbyval, elmalign);\n\t\tlenbefore = lenafter = 0;\t/* keep compiler quiet */\n\t\titemsbefore = itemsafter = nolditems = 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * here we must allow for possibility of slice larger than orig array\n\t\t * and/or not adjacent to orig array subscripts\n\t\t */\n\t\tint\t\t\toldlb = ARR_LBOUND(array)[0];\n\t\tint\t\t\toldub = oldlb + ARR_DIMS(array)[0] - 1;\n\t\tint\t\t\tslicelb = Max(oldlb, lowerIndx[0]);\n\t\tint\t\t\tsliceub = Min(oldub, upperIndx[0]);\n\t\tchar\t   *oldarraydata = ARR_DATA_PTR(array);\n\t\tbits8\t   *oldarraybitmap = ARR_NULLBITMAP(array);\n\n\t\t/* count/size of old array entries that will go before the slice */\n\t\titemsbefore = Min(slicelb, oldub + 1) - oldlb;\n\t\tlenbefore = array_nelems_size(oldarraydata, 0, oldarraybitmap,\n\t\t\t\t\t\t\t\t\t  itemsbefore,\n\t\t\t\t\t\t\t\t\t  elmlen, elmbyval, elmalign);\n\t\t/* count/size of old array entries that will be replaced by slice */\n\t\tif (slicelb > sliceub)\n\t\t{\n\t\t\tnolditems = 0;\n\t\t\tolditemsize = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnolditems = sliceub - slicelb + 1;\n\t\t\tolditemsize = array_nelems_size(oldarraydata + lenbefore,\n\t\t\t\t\t\t\t\t\t\t\titemsbefore, oldarraybitmap,\n\t\t\t\t\t\t\t\t\t\t\tnolditems,\n\t\t\t\t\t\t\t\t\t\t\telmlen, elmbyval, elmalign);\n\t\t}\n\t\t/* count/size of old array entries that will go after the slice */\n\t\titemsafter = oldub + 1 - Max(sliceub + 1, oldlb);\n\t\tlenafter = olddatasize - lenbefore - olditemsize;\n\t}\n\n\tnewsize = overheadlen + olddatasize - olditemsize + newitemsize;\n\n\tnewarray = (ArrayType *) palloc0(newsize);\n\tSET_VARSIZE(newarray, newsize);\n\tnewarray->ndim = ndim;\n\tnewarray->dataoffset = newhasnulls ? overheadlen : 0;\n\tnewarray->elemtype = ARR_ELEMTYPE(array);\n\tmemcpy(ARR_DIMS(newarray), dim, ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(newarray), lb, ndim * sizeof(int));\n\n\tif (ndim > 1)\n\t{\n\t\t/*\n\t\t * here we do not need to cope with extension of the array; it would\n\t\t * be a lot more complicated if we had to do so...\n\t\t */\n\t\tarray_insert_slice(newarray, array, srcArray,\n\t\t\t\t\t\t   ndim, dim, lb,\n\t\t\t\t\t\t   lowerIndx, upperIndx,\n\t\t\t\t\t\t   elmlen, elmbyval, elmalign);\n\t}\n\telse\n\t{\n\t\t/* fill in data */\n\t\tmemcpy((char *) newarray + overheadlen,\n\t\t\t   (char *) array + oldoverheadlen,\n\t\t\t   lenbefore);\n\t\tmemcpy((char *) newarray + overheadlen + lenbefore,\n\t\t\t   ARR_DATA_PTR(srcArray),\n\t\t\t   newitemsize);\n\t\tmemcpy((char *) newarray + overheadlen + lenbefore + newitemsize,\n\t\t\t   (char *) array + oldoverheadlen + lenbefore + olditemsize,\n\t\t\t   lenafter);\n\t\t/* fill in nulls bitmap if needed */\n\t\tif (newhasnulls)\n\t\t{\n\t\t\tbits8\t   *newnullbitmap = ARR_NULLBITMAP(newarray);\n\t\t\tbits8\t   *oldnullbitmap = ARR_NULLBITMAP(array);\n\n\t\t\t/* Zero the bitmap to handle marking inserted positions null */\n\t\t\tMemSet(newnullbitmap, 0, (nitems + 7) / 8);\n\t\t\tarray_bitmap_copy(newnullbitmap, addedbefore,\n\t\t\t\t\t\t\t  oldnullbitmap, 0,\n\t\t\t\t\t\t\t  itemsbefore);\n\t\t\tarray_bitmap_copy(newnullbitmap, lowerIndx[0] - lb[0],\n\t\t\t\t\t\t\t  ARR_NULLBITMAP(srcArray), 0,\n\t\t\t\t\t\t\t  nsrcitems);\n\t\t\tarray_bitmap_copy(newnullbitmap, addedbefore + itemsbefore + nolditems,\n\t\t\t\t\t\t\t  oldnullbitmap, itemsbefore + nolditems,\n\t\t\t\t\t\t\t  itemsafter);\n\t\t}\n\t}\n\n\treturn PointerGetDatum(newarray);\n}"
  },
  {
    "function_name": "array_set_element_expanded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "2480-2716",
    "snippet": "static Datum\narray_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tbool\t\tdimschanged,\n\t\t\t\tnewhasnulls;\n\tint\t\t\taddedbefore,\n\t\t\t\taddedafter;\n\tchar\t   *oldValue;\n\n\t/* Convert to R/W object if not so already */\n\teah = DatumGetExpandedArray(arraydatum);\n\n\t/* Sanity-check caller's info against object; we don't use it otherwise */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\t/*\n\t * Copy dimension info into local storage.  This allows us to modify the\n\t * dimensions if needed, while not messing up the expanded value if we\n\t * fail partway through.\n\t */\n\tndim = eah->ndims;\n\tAssert(ndim >= 0 && ndim <= MAXDIM);\n\tmemcpy(dim, eah->dims, ndim * sizeof(int));\n\tmemcpy(lb, eah->lbound, ndim * sizeof(int));\n\tdimschanged = false;\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts.\n\t */\n\tif (ndim == 0)\n\t{\n\t\t/*\n\t\t * Allocate adequate space for new dimension info.  This is harmless\n\t\t * if we fail later.\n\t\t */\n\t\tAssert(nSubscripts > 0 && nSubscripts <= MAXDIM);\n\t\teah->dims = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t   nSubscripts * sizeof(int));\n\t\teah->lbound = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t nSubscripts * sizeof(int));\n\n\t\t/* Update local copies of dimension info */\n\t\tndim = nSubscripts;\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 0;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\t\tdimschanged = true;\n\t}\n\telse if (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/*\n\t * Deconstruct array if we didn't already.  (Someday maybe add a special\n\t * case path for fixed-length, no-nulls cases, where we can overwrite an\n\t * element in place without ever deconstructing.  But today is not that\n\t * day.)\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\t/*\n\t * Copy new element into array's context, if needed (we assume it's\n\t * already detoasted, so no junk should be created).  If we fail further\n\t * down, this memory is leaked, but that's reasonably harmless.\n\t */\n\tif (!eah->typbyval && !isNull)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\n\t\tdataValue = datumCopy(dataValue, false, eah->typlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\tnewhasnulls = ((dnulls != NULL) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts (this logic matches original array_set_element)\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tdimschanged = true;\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tdimschanged = true;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/* Now we can calculate linear offset of target item in array */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/* Physically enlarge existing dvalues/dnulls arrays if needed */\n\tif (dim[0] > eah->dvalueslen)\n\t{\n\t\t/* We want some extra space if we're enlarging */\n\t\tint\t\t\tnewlen = dim[0] + dim[0] / 8;\n\n\t\tnewlen = Max(newlen, dim[0]);\t/* integer overflow guard */\n\t\teah->dvalues = dvalues = (Datum *)\n\t\t\trepalloc(dvalues, newlen * sizeof(Datum));\n\t\tif (dnulls)\n\t\t\teah->dnulls = dnulls = (bool *)\n\t\t\t\trepalloc(dnulls, newlen * sizeof(bool));\n\t\teah->dvalueslen = newlen;\n\t}\n\n\t/*\n\t * If we need a nulls bitmap and don't already have one, create it, being\n\t * sure to mark all existing entries as not null.\n\t */\n\tif (newhasnulls && dnulls == NULL)\n\t\teah->dnulls = dnulls = (bool *)\n\t\t\tMemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   eah->dvalueslen * sizeof(bool));\n\n\t/*\n\t * We now have all the needed space allocated, so we're ready to make\n\t * irreversible changes.  Be very wary of allowing failure below here.\n\t */\n\n\t/* Flattened value will no longer represent array accurately */\n\teah->fvalue = NULL;\n\t/* And we don't know the flattened size either */\n\teah->flat_size = 0;\n\n\t/* Update dimensionality info if needed */\n\tif (dimschanged)\n\t{\n\t\teah->ndims = ndim;\n\t\tmemcpy(eah->dims, dim, ndim * sizeof(int));\n\t\tmemcpy(eah->lbound, lb, ndim * sizeof(int));\n\t}\n\n\t/* Reposition items if needed, and fill addedbefore items with nulls */\n\tif (addedbefore > 0)\n\t{\n\t\tmemmove(dvalues + addedbefore, dvalues, eah->nelems * sizeof(Datum));\n\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\tdvalues[i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tmemmove(dnulls + addedbefore, dnulls, eah->nelems * sizeof(bool));\n\t\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\t\tdnulls[i] = true;\n\t\t}\n\t\teah->nelems += addedbefore;\n\t}\n\n\t/* fill addedafter items with nulls */\n\tif (addedafter > 0)\n\t{\n\t\tfor (i = 0; i < addedafter; i++)\n\t\t\tdvalues[eah->nelems + i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tfor (i = 0; i < addedafter; i++)\n\t\t\t\tdnulls[eah->nelems + i] = true;\n\t\t}\n\t\teah->nelems += addedafter;\n\t}\n\n\t/* Grab old element value for pfree'ing, if needed. */\n\tif (!eah->typbyval && (dnulls == NULL || !dnulls[offset]))\n\t\toldValue = (char *) DatumGetPointer(dvalues[offset]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new element. */\n\tdvalues[offset] = dataValue;\n\tif (dnulls)\n\t\tdnulls[offset] = isNull;\n\n\t/*\n\t * Free old element if needed; this keeps repeated element replacements\n\t * from bloating the array's storage.  If the pfree somehow fails, it\n\t * won't corrupt the array.\n\t */\n\tif (oldValue)\n\t{\n\t\t/* Don't try to pfree a part of the original flat array */\n\t\tif (oldValue < eah->fstartptr || oldValue >= eah->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n\n\t/* Done, return standard TOAST pointer for object */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
      "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EOHPGetRWDatum",
          "args": [
            "&eah->hdr"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "oldValue"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "dvalues[offset]"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dnulls + addedbefore",
            "dnulls",
            "eah->nelems * sizeof(bool)"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dvalues + addedbefore",
            "dvalues",
            "eah->nelems * sizeof(Datum)"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "eah->lbound",
            "lb",
            "ndim * sizeof(int)"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "eah->dims",
            "dim",
            "ndim * sizeof(int)"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "eah->hdr.eoh_context",
            "eah->dvalueslen * sizeof(bool)"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "dnulls",
            "newlen * sizeof(bool)"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "newlen",
            "dim[0]"
          ],
          "line": 2627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetOffset",
          "args": [
            "nSubscripts",
            "dim",
            "lb",
            "indx"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "30-43",
          "snippet": "int\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\"))"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"array subscript out of range\""
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_ARRAY_SUBSCRIPT_ERROR"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "dataValue",
            "false",
            "eah->typlen"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "eah->hdr.eoh_context"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_expanded_array",
          "args": [
            "eah"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_expanded_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
          "lines": "423-453",
          "snippet": "void\ndeconstruct_expanded_array(ExpandedArrayHeader *eah)\n{\n\tif (eah->dvalues == NULL)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\t\tDatum\t   *dvalues;\n\t\tbool\t   *dnulls;\n\t\tint\t\t\tnelems;\n\n\t\tdnulls = NULL;\n\t\tdeconstruct_array(eah->fvalue,\n\t\t\t\t\t\t  eah->element_type,\n\t\t\t\t\t\t  eah->typlen, eah->typbyval, eah->typalign,\n\t\t\t\t\t\t  &dvalues,\n\t\t\t\t\t\t  ARR_HASNULL(eah->fvalue) ? &dnulls : NULL,\n\t\t\t\t\t\t  &nelems);\n\n\t\t/*\n\t\t * Update header only after successful completion of this step.  If\n\t\t * deconstruct_array fails partway through, worst consequence is some\n\t\t * leaked memory in the object's context.  If the caller fails at a\n\t\t * later point, that's fine, since the deconstructed representation is\n\t\t * valid anyhow.\n\t\t */\n\t\teah->dvalues = dvalues;\n\t\teah->dnulls = dnulls;\n\t\teah->dvalueslen = eah->nelems = nelems;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/array.h\"",
            "#include \"access/tupmacs.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nvoid\ndeconstruct_expanded_array(ExpandedArrayHeader *eah)\n{\n\tif (eah->dvalues == NULL)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\t\tDatum\t   *dvalues;\n\t\tbool\t   *dnulls;\n\t\tint\t\t\tnelems;\n\n\t\tdnulls = NULL;\n\t\tdeconstruct_array(eah->fvalue,\n\t\t\t\t\t\t  eah->element_type,\n\t\t\t\t\t\t  eah->typlen, eah->typbyval, eah->typalign,\n\t\t\t\t\t\t  &dvalues,\n\t\t\t\t\t\t  ARR_HASNULL(eah->fvalue) ? &dnulls : NULL,\n\t\t\t\t\t\t  &nelems);\n\n\t\t/*\n\t\t * Update header only after successful completion of this step.  If\n\t\t * deconstruct_array fails partway through, worst consequence is some\n\t\t * leaked memory in the object's context.  If the caller fails at a\n\t\t * later point, that's fine, since the deconstructed representation is\n\t\t * valid anyhow.\n\t\t */\n\t\teah->dvalues = dvalues;\n\t\teah->dnulls = dnulls;\n\t\teah->dvalueslen = eah->nelems = nelems;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "nSubscripts > 0 && nSubscripts <= MAXDIM"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lb",
            "eah->lbound",
            "ndim * sizeof(int)"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dim",
            "eah->dims",
            "ndim * sizeof(int)"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ndim >= 0 && ndim <= MAXDIM"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "elmalign == eah->typalign"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "elmbyval == eah->typbyval"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "elmlen == eah->typlen"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "arraytyplen == -1"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetExpandedArray",
          "args": [
            "arraydatum"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetExpandedArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
          "lines": "351-366",
          "snippet": "ExpandedArrayHeader *\nDatumGetExpandedArray(Datum d)\n{\n\t/* If it's a writable expanded array already, just return it */\n\tif (VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)))\n\t{\n\t\tExpandedArrayHeader *eah = (ExpandedArrayHeader *) DatumGetEOHP(d);\n\n\t\tAssert(eah->ea_magic == EA_MAGIC);\n\t\treturn eah;\n\t}\n\n\t/* Else expand the hard way */\n\td = expand_array(d, CurrentMemoryContext, NULL);\n\treturn (ExpandedArrayHeader *) DatumGetEOHP(d);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/array.h\"",
            "#include \"access/tupmacs.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nExpandedArrayHeader *\nDatumGetExpandedArray(Datum d)\n{\n\t/* If it's a writable expanded array already, just return it */\n\tif (VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)))\n\t{\n\t\tExpandedArrayHeader *eah = (ExpandedArrayHeader *) DatumGetEOHP(d);\n\n\t\tAssert(eah->ea_magic == EA_MAGIC);\n\t\treturn eah;\n\t}\n\n\t/* Else expand the hard way */\n\td = expand_array(d, CurrentMemoryContext, NULL);\n\treturn (ExpandedArrayHeader *) DatumGetEOHP(d);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic Datum\narray_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tbool\t\tdimschanged,\n\t\t\t\tnewhasnulls;\n\tint\t\t\taddedbefore,\n\t\t\t\taddedafter;\n\tchar\t   *oldValue;\n\n\t/* Convert to R/W object if not so already */\n\teah = DatumGetExpandedArray(arraydatum);\n\n\t/* Sanity-check caller's info against object; we don't use it otherwise */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\t/*\n\t * Copy dimension info into local storage.  This allows us to modify the\n\t * dimensions if needed, while not messing up the expanded value if we\n\t * fail partway through.\n\t */\n\tndim = eah->ndims;\n\tAssert(ndim >= 0 && ndim <= MAXDIM);\n\tmemcpy(dim, eah->dims, ndim * sizeof(int));\n\tmemcpy(lb, eah->lbound, ndim * sizeof(int));\n\tdimschanged = false;\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts.\n\t */\n\tif (ndim == 0)\n\t{\n\t\t/*\n\t\t * Allocate adequate space for new dimension info.  This is harmless\n\t\t * if we fail later.\n\t\t */\n\t\tAssert(nSubscripts > 0 && nSubscripts <= MAXDIM);\n\t\teah->dims = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t   nSubscripts * sizeof(int));\n\t\teah->lbound = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t nSubscripts * sizeof(int));\n\n\t\t/* Update local copies of dimension info */\n\t\tndim = nSubscripts;\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 0;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\t\tdimschanged = true;\n\t}\n\telse if (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/*\n\t * Deconstruct array if we didn't already.  (Someday maybe add a special\n\t * case path for fixed-length, no-nulls cases, where we can overwrite an\n\t * element in place without ever deconstructing.  But today is not that\n\t * day.)\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\t/*\n\t * Copy new element into array's context, if needed (we assume it's\n\t * already detoasted, so no junk should be created).  If we fail further\n\t * down, this memory is leaked, but that's reasonably harmless.\n\t */\n\tif (!eah->typbyval && !isNull)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\n\t\tdataValue = datumCopy(dataValue, false, eah->typlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\tnewhasnulls = ((dnulls != NULL) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts (this logic matches original array_set_element)\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tdimschanged = true;\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tdimschanged = true;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/* Now we can calculate linear offset of target item in array */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/* Physically enlarge existing dvalues/dnulls arrays if needed */\n\tif (dim[0] > eah->dvalueslen)\n\t{\n\t\t/* We want some extra space if we're enlarging */\n\t\tint\t\t\tnewlen = dim[0] + dim[0] / 8;\n\n\t\tnewlen = Max(newlen, dim[0]);\t/* integer overflow guard */\n\t\teah->dvalues = dvalues = (Datum *)\n\t\t\trepalloc(dvalues, newlen * sizeof(Datum));\n\t\tif (dnulls)\n\t\t\teah->dnulls = dnulls = (bool *)\n\t\t\t\trepalloc(dnulls, newlen * sizeof(bool));\n\t\teah->dvalueslen = newlen;\n\t}\n\n\t/*\n\t * If we need a nulls bitmap and don't already have one, create it, being\n\t * sure to mark all existing entries as not null.\n\t */\n\tif (newhasnulls && dnulls == NULL)\n\t\teah->dnulls = dnulls = (bool *)\n\t\t\tMemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   eah->dvalueslen * sizeof(bool));\n\n\t/*\n\t * We now have all the needed space allocated, so we're ready to make\n\t * irreversible changes.  Be very wary of allowing failure below here.\n\t */\n\n\t/* Flattened value will no longer represent array accurately */\n\teah->fvalue = NULL;\n\t/* And we don't know the flattened size either */\n\teah->flat_size = 0;\n\n\t/* Update dimensionality info if needed */\n\tif (dimschanged)\n\t{\n\t\teah->ndims = ndim;\n\t\tmemcpy(eah->dims, dim, ndim * sizeof(int));\n\t\tmemcpy(eah->lbound, lb, ndim * sizeof(int));\n\t}\n\n\t/* Reposition items if needed, and fill addedbefore items with nulls */\n\tif (addedbefore > 0)\n\t{\n\t\tmemmove(dvalues + addedbefore, dvalues, eah->nelems * sizeof(Datum));\n\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\tdvalues[i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tmemmove(dnulls + addedbefore, dnulls, eah->nelems * sizeof(bool));\n\t\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\t\tdnulls[i] = true;\n\t\t}\n\t\teah->nelems += addedbefore;\n\t}\n\n\t/* fill addedafter items with nulls */\n\tif (addedafter > 0)\n\t{\n\t\tfor (i = 0; i < addedafter; i++)\n\t\t\tdvalues[eah->nelems + i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tfor (i = 0; i < addedafter; i++)\n\t\t\t\tdnulls[eah->nelems + i] = true;\n\t\t}\n\t\teah->nelems += addedafter;\n\t}\n\n\t/* Grab old element value for pfree'ing, if needed. */\n\tif (!eah->typbyval && (dnulls == NULL || !dnulls[offset]))\n\t\toldValue = (char *) DatumGetPointer(dvalues[offset]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new element. */\n\tdvalues[offset] = dataValue;\n\tif (dnulls)\n\t\tdnulls[offset] = isNull;\n\n\t/*\n\t * Free old element if needed; this keeps repeated element replacements\n\t * from bloating the array's storage.  If the pfree somehow fails, it\n\t * won't corrupt the array.\n\t */\n\tif (oldValue)\n\t{\n\t\t/* Don't try to pfree a part of the original flat array */\n\t\tif (oldValue < eah->fstartptr || oldValue >= eah->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n\n\t/* Done, return standard TOAST pointer for object */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}"
  },
  {
    "function_name": "array_set_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "2198-2471",
    "snippet": "Datum\narray_set_element(Datum arraydatum,\n\t\t\t\t  int nSubscripts,\n\t\t\t\t  int *indx,\n\t\t\t\t  Datum dataValue,\n\t\t\t\t  bool isNull,\n\t\t\t\t  int arraytyplen,\n\t\t\t\t  int elmlen,\n\t\t\t\t  bool elmbyval,\n\t\t\t\t  char elmalign)\n{\n\tArrayType  *array;\n\tArrayType  *newarray;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tchar\t   *elt_ptr;\n\tbool\t\tnewhasnulls;\n\tbits8\t   *oldnullbitmap;\n\tint\t\t\toldnitems,\n\t\t\t\tnewnitems,\n\t\t\t\tolddatasize,\n\t\t\t\tnewsize,\n\t\t\t\tolditemlen,\n\t\t\t\tnewitemlen,\n\t\t\t\toverheadlen,\n\t\t\t\toldoverheadlen,\n\t\t\t\taddedbefore,\n\t\t\t\taddedafter,\n\t\t\t\tlenbefore,\n\t\t\t\tlenafter;\n\n\tif (arraytyplen > 0)\n\t{\n\t\t/*\n\t\t * fixed-length arrays -- these are assumed to be 1-d, 0-based. We\n\t\t * cannot extend them, either.\n\t\t */\n\t\tchar\t   *resultarray;\n\n\t\tif (nSubscripts != 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t\tif (indx[0] < 0 || indx[0] * elmlen >= arraytyplen)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\n\t\tif (isNull)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"cannot assign null value to an element of a fixed-length array\")));\n\n\t\tresultarray = (char *) palloc(arraytyplen);\n\t\tmemcpy(resultarray, DatumGetPointer(arraydatum), arraytyplen);\n\t\telt_ptr = (char *) resultarray + indx[0] * elmlen;\n\t\tArrayCastAndSet(dataValue, elmlen, elmbyval, elmalign, elt_ptr);\n\t\treturn PointerGetDatum(resultarray);\n\t}\n\n\tif (nSubscripts <= 0 || nSubscripts > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/* make sure item to be inserted is not toasted */\n\tif (elmlen == -1 && !isNull)\n\t\tdataValue = PointerGetDatum(PG_DETOAST_DATUM(dataValue));\n\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\t/* expanded array: let's do this in a separate function */\n\t\treturn array_set_element_expanded(arraydatum,\n\t\t\t\t\t\t\t\t\t\t  nSubscripts,\n\t\t\t\t\t\t\t\t\t\t  indx,\n\t\t\t\t\t\t\t\t\t\t  dataValue,\n\t\t\t\t\t\t\t\t\t\t  isNull,\n\t\t\t\t\t\t\t\t\t\t  arraytyplen,\n\t\t\t\t\t\t\t\t\t\t  elmlen,\n\t\t\t\t\t\t\t\t\t\t  elmbyval,\n\t\t\t\t\t\t\t\t\t\t  elmalign);\n\t}\n\n\t/* detoast input array if necessary */\n\tarray = DatumGetArrayTypeP(arraydatum);\n\n\tndim = ARR_NDIM(array);\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts\n\t */\n\tif (ndim == 0)\n\t{\n\t\tOid\t\t\telmtype = ARR_ELEMTYPE(array);\n\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 1;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\n\t\treturn PointerGetDatum(construct_md_array(&dataValue, &isNull,\n\t\t\t\t\t\t\t\t\t\t\t\t  nSubscripts, dim, lb,\n\t\t\t\t\t\t\t\t\t\t\t\t  elmtype,\n\t\t\t\t\t\t\t\t\t\t\t\t  elmlen, elmbyval, elmalign));\n\t}\n\n\tif (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/* copy dim/lb since we may modify them */\n\tmemcpy(dim, ARR_DIMS(array), ndim * sizeof(int));\n\tmemcpy(lb, ARR_LBOUND(array), ndim * sizeof(int));\n\n\tnewhasnulls = (ARR_HASNULL(array) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/*\n\t * Compute sizes of items and areas to copy\n\t */\n\tnewnitems = ArrayGetNItems(ndim, dim);\n\tif (newhasnulls)\n\t\toverheadlen = ARR_OVERHEAD_WITHNULLS(ndim, newnitems);\n\telse\n\t\toverheadlen = ARR_OVERHEAD_NONULLS(ndim);\n\toldnitems = ArrayGetNItems(ndim, ARR_DIMS(array));\n\toldnullbitmap = ARR_NULLBITMAP(array);\n\toldoverheadlen = ARR_DATA_OFFSET(array);\n\tolddatasize = ARR_SIZE(array) - oldoverheadlen;\n\tif (addedbefore)\n\t{\n\t\toffset = 0;\n\t\tlenbefore = 0;\n\t\tolditemlen = 0;\n\t\tlenafter = olddatasize;\n\t}\n\telse if (addedafter)\n\t{\n\t\toffset = oldnitems;\n\t\tlenbefore = olddatasize;\n\t\tolditemlen = 0;\n\t\tlenafter = 0;\n\t}\n\telse\n\t{\n\t\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\t\telt_ptr = array_seek(ARR_DATA_PTR(array), 0, oldnullbitmap, offset,\n\t\t\t\t\t\t\t elmlen, elmbyval, elmalign);\n\t\tlenbefore = (int) (elt_ptr - ARR_DATA_PTR(array));\n\t\tif (array_get_isnull(oldnullbitmap, offset))\n\t\t\tolditemlen = 0;\n\t\telse\n\t\t{\n\t\t\tolditemlen = att_addlength_pointer(0, elmlen, elt_ptr);\n\t\t\tolditemlen = att_align_nominal(olditemlen, elmalign);\n\t\t}\n\t\tlenafter = (int) (olddatasize - lenbefore - olditemlen);\n\t}\n\n\tif (isNull)\n\t\tnewitemlen = 0;\n\telse\n\t{\n\t\tnewitemlen = att_addlength_datum(0, elmlen, dataValue);\n\t\tnewitemlen = att_align_nominal(newitemlen, elmalign);\n\t}\n\n\tnewsize = overheadlen + lenbefore + newitemlen + lenafter;\n\n\t/*\n\t * OK, create the new array and fill in header/dimensions\n\t */\n\tnewarray = (ArrayType *) palloc0(newsize);\n\tSET_VARSIZE(newarray, newsize);\n\tnewarray->ndim = ndim;\n\tnewarray->dataoffset = newhasnulls ? overheadlen : 0;\n\tnewarray->elemtype = ARR_ELEMTYPE(array);\n\tmemcpy(ARR_DIMS(newarray), dim, ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(newarray), lb, ndim * sizeof(int));\n\n\t/*\n\t * Fill in data\n\t */\n\tmemcpy((char *) newarray + overheadlen,\n\t\t   (char *) array + oldoverheadlen,\n\t\t   lenbefore);\n\tif (!isNull)\n\t\tArrayCastAndSet(dataValue, elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t(char *) newarray + overheadlen + lenbefore);\n\tmemcpy((char *) newarray + overheadlen + lenbefore + newitemlen,\n\t\t   (char *) array + oldoverheadlen + lenbefore + olditemlen,\n\t\t   lenafter);\n\n\t/*\n\t * Fill in nulls bitmap if needed\n\t *\n\t * Note: it's possible we just replaced the last NULL with a non-NULL, and\n\t * could get rid of the bitmap.  Seems not worth testing for though.\n\t */\n\tif (newhasnulls)\n\t{\n\t\tbits8\t   *newnullbitmap = ARR_NULLBITMAP(newarray);\n\n\t\t/* Zero the bitmap to take care of marking inserted positions null */\n\t\tMemSet(newnullbitmap, 0, (newnitems + 7) / 8);\n\t\t/* Fix the inserted value */\n\t\tif (addedafter)\n\t\t\tarray_set_isnull(newnullbitmap, newnitems - 1, isNull);\n\t\telse\n\t\t\tarray_set_isnull(newnullbitmap, offset, isNull);\n\t\t/* Fix the copied range(s) */\n\t\tif (addedbefore)\n\t\t\tarray_bitmap_copy(newnullbitmap, addedbefore,\n\t\t\t\t\t\t\t  oldnullbitmap, 0,\n\t\t\t\t\t\t\t  oldnitems);\n\t\telse\n\t\t{\n\t\t\tarray_bitmap_copy(newnullbitmap, 0,\n\t\t\t\t\t\t\t  oldnullbitmap, 0,\n\t\t\t\t\t\t\t  offset);\n\t\t\tif (addedafter == 0)\n\t\t\t\tarray_bitmap_copy(newnullbitmap, offset + 1,\n\t\t\t\t\t\t\t\t  oldnullbitmap, offset + 1,\n\t\t\t\t\t\t\t\t  oldnitems - offset - 1);\n\t\t}\n\t}\n\n\treturn PointerGetDatum(newarray);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
      "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "newarray"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_bitmap_copy",
          "args": [
            "newnullbitmap",
            "offset + 1",
            "oldnullbitmap",
            "offset + 1",
            "oldnitems - offset - 1"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "array_bitmap_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4687-4751",
          "snippet": "void\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_set_isnull",
          "args": [
            "newnullbitmap",
            "offset",
            "isNull"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "array_set_isnull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4519-4530",
          "snippet": "static void\narray_set_isnull(bits8 *nullbitmap, int offset, bool isNull)\n{\n\tint\t\t\tbitmask;\n\n\tnullbitmap += offset / 8;\n\tbitmask = 1 << (offset % 8);\n\tif (isNull)\n\t\t*nullbitmap &= ~bitmask;\n\telse\n\t\t*nullbitmap |= bitmask;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\n\nstatic void\narray_set_isnull(bits8 *nullbitmap, int offset, bool isNull)\n{\n\tint\t\t\tbitmask;\n\n\tnullbitmap += offset / 8;\n\tbitmask = 1 << (offset % 8);\n\tif (isNull)\n\t\t*nullbitmap &= ~bitmask;\n\telse\n\t\t*nullbitmap |= bitmask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "newnullbitmap",
            "0",
            "(newnitems + 7) / 8"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "newarray"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) newarray + overheadlen + lenbefore + newitemlen",
            "(char *) array + oldoverheadlen + lenbefore + olditemlen",
            "lenafter"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayCastAndSet",
          "args": [
            "dataValue",
            "elmlen",
            "elmbyval",
            "elmalign",
            "(char *) newarray + overheadlen + lenbefore"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayCastAndSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4548-4574",
          "snippet": "static int\nArrayCastAndSet(Datum src,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tchar *dest)\n{\n\tint\t\t\tinc;\n\n\tif (typlen > 0)\n\t{\n\t\tif (typbyval)\n\t\t\tstore_att_byval(dest, src, typlen);\n\t\telse\n\t\t\tmemmove(dest, DatumGetPointer(src), typlen);\n\t\tinc = att_align_nominal(typlen, typalign);\n\t}\n\telse\n\t{\n\t\tAssert(!typbyval);\n\t\tinc = att_addlength_datum(0, typlen, src);\n\t\tmemmove(dest, DatumGetPointer(src), inc);\n\t\tinc = att_align_nominal(inc, typalign);\n\t}\n\n\treturn inc;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ArrayCastAndSet(Datum src,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tchar *dest);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int ArrayCastAndSet(Datum src,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tchar *dest);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\nArrayCastAndSet(Datum src,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tchar *dest)\n{\n\tint\t\t\tinc;\n\n\tif (typlen > 0)\n\t{\n\t\tif (typbyval)\n\t\t\tstore_att_byval(dest, src, typlen);\n\t\telse\n\t\t\tmemmove(dest, DatumGetPointer(src), typlen);\n\t\tinc = att_align_nominal(typlen, typalign);\n\t}\n\telse\n\t{\n\t\tAssert(!typbyval);\n\t\tinc = att_addlength_datum(0, typlen, src);\n\t\tmemmove(dest, DatumGetPointer(src), inc);\n\t\tinc = att_align_nominal(inc, typalign);\n\t}\n\n\treturn inc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) newarray + overheadlen",
            "(char *) array + oldoverheadlen",
            "lenbefore"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(newarray)",
            "lb",
            "ndim * sizeof(int)"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "newarray"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(newarray)",
            "dim",
            "ndim * sizeof(int)"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "newarray"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "newarray",
            "newsize"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "newsize"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "newitemlen",
            "elmalign"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "0",
            "elmlen",
            "dataValue"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "olditemlen",
            "elmalign"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_pointer",
          "args": [
            "0",
            "elmlen",
            "elt_ptr"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_get_isnull",
          "args": [
            "oldnullbitmap",
            "offset"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "array_get_isnull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4502-4510",
          "snippet": "static bool\narray_get_isnull(const bits8 *nullbitmap, int offset)\n{\n\tif (nullbitmap == NULL)\n\t\treturn false;\t\t\t/* assume not null */\n\tif (nullbitmap[offset / 8] & (1 << (offset % 8)))\n\t\treturn false;\t\t\t/* not null */\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\n\nstatic bool\narray_get_isnull(const bits8 *nullbitmap, int offset)\n{\n\tif (nullbitmap == NULL)\n\t\treturn false;\t\t\t/* assume not null */\n\tif (nullbitmap[offset / 8] & (1 << (offset % 8)))\n\t\treturn false;\t\t\t/* not null */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "array"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_seek",
          "args": [
            "ARR_DATA_PTR(array)",
            "0",
            "oldnullbitmap",
            "offset",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "array_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4587-4628",
          "snippet": "static char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "array"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetOffset",
          "args": [
            "nSubscripts",
            "dim",
            "lb",
            "indx"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "30-43",
          "snippet": "int\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_SIZE",
          "args": [
            "array"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_OFFSET",
          "args": [
            "array"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "array"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "ARR_DIMS(array)"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndim"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndim",
            "newnitems"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\"))"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"array subscript out of range\""
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_ARRAY_SUBSCRIPT_ERROR"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "array"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lb",
            "ARR_LBOUND(array)",
            "ndim * sizeof(int)"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "array"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dim",
            "ARR_DIMS(array)",
            "ndim * sizeof(int)"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "construct_md_array(&dataValue, &isNull,\n\t\t\t\t\t\t\t\t\t\t\t\t  nSubscripts, dim, lb,\n\t\t\t\t\t\t\t\t\t\t\t\t  elmtype,\n\t\t\t\t\t\t\t\t\t\t\t\t  elmlen, elmbyval, elmalign)"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_md_array",
          "args": [
            "&dataValue",
            "&isNull",
            "nSubscripts",
            "dim",
            "lb",
            "elmtype",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "construct_md_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3325-3404",
          "snippet": "ArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_md_array(Datum *elems,\n\t\t\t\t   bool *nulls,\n\t\t\t\t   int ndims,\n\t\t\t\t   int *dims,\n\t\t\t\t   int *lbs,\n\t\t\t\t   Oid elmtype, int elmlen, bool elmbyval, char elmalign)\n{\n\tArrayType  *result;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tint\t\t\ti;\n\tint\t\t\tnelems;\n\n\tif (ndims < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndims)));\n\tif (ndims > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndims, MAXDIM)));\n\n\tnelems = ArrayGetNItems(ndims, dims);\n\n\t/* if ndims <= 0 or any dims[i] == 0, return empty array */\n\tif (nelems <= 0)\n\t\treturn construct_empty_array(elmtype);\n\n\t/* compute required space */\n\tnbytes = 0;\n\thasnulls = false;\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\thasnulls = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* make sure data is not toasted */\n\t\tif (elmlen == -1)\n\t\t\telems[i] = PointerGetDatum(PG_DETOAST_DATUM(elems[i]));\n\t\tnbytes = att_addlength_datum(nbytes, elmlen, elems[i]);\n\t\tnbytes = att_align_nominal(nbytes, elmalign);\n\t\t/* check for overflow of total request */\n\t\tif (!AllocSizeIsValid(nbytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t}\n\n\t/* Allocate and initialize result array */\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nelems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = elmtype;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\n\tCopyArrayEls(result,\n\t\t\t\t elems, nulls, nelems,\n\t\t\t\t elmlen, elmbyval, elmalign,\n\t\t\t\t false);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "array"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "arraydatum"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_set_element_expanded",
          "args": [
            "arraydatum",
            "nSubscripts",
            "indx",
            "dataValue",
            "isNull",
            "arraytyplen",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "array_set_element_expanded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "2480-2716",
          "snippet": "static Datum\narray_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tbool\t\tdimschanged,\n\t\t\t\tnewhasnulls;\n\tint\t\t\taddedbefore,\n\t\t\t\taddedafter;\n\tchar\t   *oldValue;\n\n\t/* Convert to R/W object if not so already */\n\teah = DatumGetExpandedArray(arraydatum);\n\n\t/* Sanity-check caller's info against object; we don't use it otherwise */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\t/*\n\t * Copy dimension info into local storage.  This allows us to modify the\n\t * dimensions if needed, while not messing up the expanded value if we\n\t * fail partway through.\n\t */\n\tndim = eah->ndims;\n\tAssert(ndim >= 0 && ndim <= MAXDIM);\n\tmemcpy(dim, eah->dims, ndim * sizeof(int));\n\tmemcpy(lb, eah->lbound, ndim * sizeof(int));\n\tdimschanged = false;\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts.\n\t */\n\tif (ndim == 0)\n\t{\n\t\t/*\n\t\t * Allocate adequate space for new dimension info.  This is harmless\n\t\t * if we fail later.\n\t\t */\n\t\tAssert(nSubscripts > 0 && nSubscripts <= MAXDIM);\n\t\teah->dims = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t   nSubscripts * sizeof(int));\n\t\teah->lbound = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t nSubscripts * sizeof(int));\n\n\t\t/* Update local copies of dimension info */\n\t\tndim = nSubscripts;\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 0;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\t\tdimschanged = true;\n\t}\n\telse if (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/*\n\t * Deconstruct array if we didn't already.  (Someday maybe add a special\n\t * case path for fixed-length, no-nulls cases, where we can overwrite an\n\t * element in place without ever deconstructing.  But today is not that\n\t * day.)\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\t/*\n\t * Copy new element into array's context, if needed (we assume it's\n\t * already detoasted, so no junk should be created).  If we fail further\n\t * down, this memory is leaked, but that's reasonably harmless.\n\t */\n\tif (!eah->typbyval && !isNull)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\n\t\tdataValue = datumCopy(dataValue, false, eah->typlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\tnewhasnulls = ((dnulls != NULL) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts (this logic matches original array_set_element)\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tdimschanged = true;\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tdimschanged = true;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/* Now we can calculate linear offset of target item in array */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/* Physically enlarge existing dvalues/dnulls arrays if needed */\n\tif (dim[0] > eah->dvalueslen)\n\t{\n\t\t/* We want some extra space if we're enlarging */\n\t\tint\t\t\tnewlen = dim[0] + dim[0] / 8;\n\n\t\tnewlen = Max(newlen, dim[0]);\t/* integer overflow guard */\n\t\teah->dvalues = dvalues = (Datum *)\n\t\t\trepalloc(dvalues, newlen * sizeof(Datum));\n\t\tif (dnulls)\n\t\t\teah->dnulls = dnulls = (bool *)\n\t\t\t\trepalloc(dnulls, newlen * sizeof(bool));\n\t\teah->dvalueslen = newlen;\n\t}\n\n\t/*\n\t * If we need a nulls bitmap and don't already have one, create it, being\n\t * sure to mark all existing entries as not null.\n\t */\n\tif (newhasnulls && dnulls == NULL)\n\t\teah->dnulls = dnulls = (bool *)\n\t\t\tMemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   eah->dvalueslen * sizeof(bool));\n\n\t/*\n\t * We now have all the needed space allocated, so we're ready to make\n\t * irreversible changes.  Be very wary of allowing failure below here.\n\t */\n\n\t/* Flattened value will no longer represent array accurately */\n\teah->fvalue = NULL;\n\t/* And we don't know the flattened size either */\n\teah->flat_size = 0;\n\n\t/* Update dimensionality info if needed */\n\tif (dimschanged)\n\t{\n\t\teah->ndims = ndim;\n\t\tmemcpy(eah->dims, dim, ndim * sizeof(int));\n\t\tmemcpy(eah->lbound, lb, ndim * sizeof(int));\n\t}\n\n\t/* Reposition items if needed, and fill addedbefore items with nulls */\n\tif (addedbefore > 0)\n\t{\n\t\tmemmove(dvalues + addedbefore, dvalues, eah->nelems * sizeof(Datum));\n\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\tdvalues[i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tmemmove(dnulls + addedbefore, dnulls, eah->nelems * sizeof(bool));\n\t\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\t\tdnulls[i] = true;\n\t\t}\n\t\teah->nelems += addedbefore;\n\t}\n\n\t/* fill addedafter items with nulls */\n\tif (addedafter > 0)\n\t{\n\t\tfor (i = 0; i < addedafter; i++)\n\t\t\tdvalues[eah->nelems + i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tfor (i = 0; i < addedafter; i++)\n\t\t\t\tdnulls[eah->nelems + i] = true;\n\t\t}\n\t\teah->nelems += addedafter;\n\t}\n\n\t/* Grab old element value for pfree'ing, if needed. */\n\tif (!eah->typbyval && (dnulls == NULL || !dnulls[offset]))\n\t\toldValue = (char *) DatumGetPointer(dvalues[offset]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new element. */\n\tdvalues[offset] = dataValue;\n\tif (dnulls)\n\t\tdnulls[offset] = isNull;\n\n\t/*\n\t * Free old element if needed; this keeps repeated element replacements\n\t * from bloating the array's storage.  If the pfree somehow fails, it\n\t * won't corrupt the array.\n\t */\n\tif (oldValue)\n\t{\n\t\t/* Don't try to pfree a part of the original flat array */\n\t\tif (oldValue < eah->fstartptr || oldValue >= eah->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n\n\t/* Done, return standard TOAST pointer for object */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic Datum\narray_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tbool\t\tdimschanged,\n\t\t\t\tnewhasnulls;\n\tint\t\t\taddedbefore,\n\t\t\t\taddedafter;\n\tchar\t   *oldValue;\n\n\t/* Convert to R/W object if not so already */\n\teah = DatumGetExpandedArray(arraydatum);\n\n\t/* Sanity-check caller's info against object; we don't use it otherwise */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\t/*\n\t * Copy dimension info into local storage.  This allows us to modify the\n\t * dimensions if needed, while not messing up the expanded value if we\n\t * fail partway through.\n\t */\n\tndim = eah->ndims;\n\tAssert(ndim >= 0 && ndim <= MAXDIM);\n\tmemcpy(dim, eah->dims, ndim * sizeof(int));\n\tmemcpy(lb, eah->lbound, ndim * sizeof(int));\n\tdimschanged = false;\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts.\n\t */\n\tif (ndim == 0)\n\t{\n\t\t/*\n\t\t * Allocate adequate space for new dimension info.  This is harmless\n\t\t * if we fail later.\n\t\t */\n\t\tAssert(nSubscripts > 0 && nSubscripts <= MAXDIM);\n\t\teah->dims = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t   nSubscripts * sizeof(int));\n\t\teah->lbound = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t nSubscripts * sizeof(int));\n\n\t\t/* Update local copies of dimension info */\n\t\tndim = nSubscripts;\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 0;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\t\tdimschanged = true;\n\t}\n\telse if (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/*\n\t * Deconstruct array if we didn't already.  (Someday maybe add a special\n\t * case path for fixed-length, no-nulls cases, where we can overwrite an\n\t * element in place without ever deconstructing.  But today is not that\n\t * day.)\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\t/*\n\t * Copy new element into array's context, if needed (we assume it's\n\t * already detoasted, so no junk should be created).  If we fail further\n\t * down, this memory is leaked, but that's reasonably harmless.\n\t */\n\tif (!eah->typbyval && !isNull)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\n\t\tdataValue = datumCopy(dataValue, false, eah->typlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\tnewhasnulls = ((dnulls != NULL) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts (this logic matches original array_set_element)\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tdimschanged = true;\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tdimschanged = true;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/* Now we can calculate linear offset of target item in array */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/* Physically enlarge existing dvalues/dnulls arrays if needed */\n\tif (dim[0] > eah->dvalueslen)\n\t{\n\t\t/* We want some extra space if we're enlarging */\n\t\tint\t\t\tnewlen = dim[0] + dim[0] / 8;\n\n\t\tnewlen = Max(newlen, dim[0]);\t/* integer overflow guard */\n\t\teah->dvalues = dvalues = (Datum *)\n\t\t\trepalloc(dvalues, newlen * sizeof(Datum));\n\t\tif (dnulls)\n\t\t\teah->dnulls = dnulls = (bool *)\n\t\t\t\trepalloc(dnulls, newlen * sizeof(bool));\n\t\teah->dvalueslen = newlen;\n\t}\n\n\t/*\n\t * If we need a nulls bitmap and don't already have one, create it, being\n\t * sure to mark all existing entries as not null.\n\t */\n\tif (newhasnulls && dnulls == NULL)\n\t\teah->dnulls = dnulls = (bool *)\n\t\t\tMemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   eah->dvalueslen * sizeof(bool));\n\n\t/*\n\t * We now have all the needed space allocated, so we're ready to make\n\t * irreversible changes.  Be very wary of allowing failure below here.\n\t */\n\n\t/* Flattened value will no longer represent array accurately */\n\teah->fvalue = NULL;\n\t/* And we don't know the flattened size either */\n\teah->flat_size = 0;\n\n\t/* Update dimensionality info if needed */\n\tif (dimschanged)\n\t{\n\t\teah->ndims = ndim;\n\t\tmemcpy(eah->dims, dim, ndim * sizeof(int));\n\t\tmemcpy(eah->lbound, lb, ndim * sizeof(int));\n\t}\n\n\t/* Reposition items if needed, and fill addedbefore items with nulls */\n\tif (addedbefore > 0)\n\t{\n\t\tmemmove(dvalues + addedbefore, dvalues, eah->nelems * sizeof(Datum));\n\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\tdvalues[i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tmemmove(dnulls + addedbefore, dnulls, eah->nelems * sizeof(bool));\n\t\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\t\tdnulls[i] = true;\n\t\t}\n\t\teah->nelems += addedbefore;\n\t}\n\n\t/* fill addedafter items with nulls */\n\tif (addedafter > 0)\n\t{\n\t\tfor (i = 0; i < addedafter; i++)\n\t\t\tdvalues[eah->nelems + i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tfor (i = 0; i < addedafter; i++)\n\t\t\t\tdnulls[eah->nelems + i] = true;\n\t\t}\n\t\teah->nelems += addedafter;\n\t}\n\n\t/* Grab old element value for pfree'ing, if needed. */\n\tif (!eah->typbyval && (dnulls == NULL || !dnulls[offset]))\n\t\toldValue = (char *) DatumGetPointer(dvalues[offset]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new element. */\n\tdvalues[offset] = dataValue;\n\tif (dnulls)\n\t\tdnulls[offset] = isNull;\n\n\t/*\n\t * Free old element if needed; this keeps repeated element replacements\n\t * from bloating the array's storage.  If the pfree somehow fails, it\n\t * won't corrupt the array.\n\t */\n\tif (oldValue)\n\t{\n\t\t/* Don't try to pfree a part of the original flat array */\n\t\tif (oldValue < eah->fstartptr || oldValue >= eah->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n\n\t/* Done, return standard TOAST pointer for object */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED",
          "args": [
            "DatumGetPointer(arraydatum)"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "arraydatum"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM(dataValue)"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "dataValue"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "resultarray"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "resultarray",
            "DatumGetPointer(arraydatum)",
            "arraytyplen"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "arraydatum"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "arraytyplen"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"cannot assign null value to an element of a fixed-length array\"))"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"array subscript out of range\"))"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\"))"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nDatum\narray_set_element(Datum arraydatum,\n\t\t\t\t  int nSubscripts,\n\t\t\t\t  int *indx,\n\t\t\t\t  Datum dataValue,\n\t\t\t\t  bool isNull,\n\t\t\t\t  int arraytyplen,\n\t\t\t\t  int elmlen,\n\t\t\t\t  bool elmbyval,\n\t\t\t\t  char elmalign)\n{\n\tArrayType  *array;\n\tArrayType  *newarray;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tchar\t   *elt_ptr;\n\tbool\t\tnewhasnulls;\n\tbits8\t   *oldnullbitmap;\n\tint\t\t\toldnitems,\n\t\t\t\tnewnitems,\n\t\t\t\tolddatasize,\n\t\t\t\tnewsize,\n\t\t\t\tolditemlen,\n\t\t\t\tnewitemlen,\n\t\t\t\toverheadlen,\n\t\t\t\toldoverheadlen,\n\t\t\t\taddedbefore,\n\t\t\t\taddedafter,\n\t\t\t\tlenbefore,\n\t\t\t\tlenafter;\n\n\tif (arraytyplen > 0)\n\t{\n\t\t/*\n\t\t * fixed-length arrays -- these are assumed to be 1-d, 0-based. We\n\t\t * cannot extend them, either.\n\t\t */\n\t\tchar\t   *resultarray;\n\n\t\tif (nSubscripts != 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t\tif (indx[0] < 0 || indx[0] * elmlen >= arraytyplen)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\n\t\tif (isNull)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"cannot assign null value to an element of a fixed-length array\")));\n\n\t\tresultarray = (char *) palloc(arraytyplen);\n\t\tmemcpy(resultarray, DatumGetPointer(arraydatum), arraytyplen);\n\t\telt_ptr = (char *) resultarray + indx[0] * elmlen;\n\t\tArrayCastAndSet(dataValue, elmlen, elmbyval, elmalign, elt_ptr);\n\t\treturn PointerGetDatum(resultarray);\n\t}\n\n\tif (nSubscripts <= 0 || nSubscripts > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/* make sure item to be inserted is not toasted */\n\tif (elmlen == -1 && !isNull)\n\t\tdataValue = PointerGetDatum(PG_DETOAST_DATUM(dataValue));\n\n\tif (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\t/* expanded array: let's do this in a separate function */\n\t\treturn array_set_element_expanded(arraydatum,\n\t\t\t\t\t\t\t\t\t\t  nSubscripts,\n\t\t\t\t\t\t\t\t\t\t  indx,\n\t\t\t\t\t\t\t\t\t\t  dataValue,\n\t\t\t\t\t\t\t\t\t\t  isNull,\n\t\t\t\t\t\t\t\t\t\t  arraytyplen,\n\t\t\t\t\t\t\t\t\t\t  elmlen,\n\t\t\t\t\t\t\t\t\t\t  elmbyval,\n\t\t\t\t\t\t\t\t\t\t  elmalign);\n\t}\n\n\t/* detoast input array if necessary */\n\tarray = DatumGetArrayTypeP(arraydatum);\n\n\tndim = ARR_NDIM(array);\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts\n\t */\n\tif (ndim == 0)\n\t{\n\t\tOid\t\t\telmtype = ARR_ELEMTYPE(array);\n\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 1;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\n\t\treturn PointerGetDatum(construct_md_array(&dataValue, &isNull,\n\t\t\t\t\t\t\t\t\t\t\t\t  nSubscripts, dim, lb,\n\t\t\t\t\t\t\t\t\t\t\t\t  elmtype,\n\t\t\t\t\t\t\t\t\t\t\t\t  elmlen, elmbyval, elmalign));\n\t}\n\n\tif (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/* copy dim/lb since we may modify them */\n\tmemcpy(dim, ARR_DIMS(array), ndim * sizeof(int));\n\tmemcpy(lb, ARR_LBOUND(array), ndim * sizeof(int));\n\n\tnewhasnulls = (ARR_HASNULL(array) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/*\n\t * Compute sizes of items and areas to copy\n\t */\n\tnewnitems = ArrayGetNItems(ndim, dim);\n\tif (newhasnulls)\n\t\toverheadlen = ARR_OVERHEAD_WITHNULLS(ndim, newnitems);\n\telse\n\t\toverheadlen = ARR_OVERHEAD_NONULLS(ndim);\n\toldnitems = ArrayGetNItems(ndim, ARR_DIMS(array));\n\toldnullbitmap = ARR_NULLBITMAP(array);\n\toldoverheadlen = ARR_DATA_OFFSET(array);\n\tolddatasize = ARR_SIZE(array) - oldoverheadlen;\n\tif (addedbefore)\n\t{\n\t\toffset = 0;\n\t\tlenbefore = 0;\n\t\tolditemlen = 0;\n\t\tlenafter = olddatasize;\n\t}\n\telse if (addedafter)\n\t{\n\t\toffset = oldnitems;\n\t\tlenbefore = olddatasize;\n\t\tolditemlen = 0;\n\t\tlenafter = 0;\n\t}\n\telse\n\t{\n\t\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\t\telt_ptr = array_seek(ARR_DATA_PTR(array), 0, oldnullbitmap, offset,\n\t\t\t\t\t\t\t elmlen, elmbyval, elmalign);\n\t\tlenbefore = (int) (elt_ptr - ARR_DATA_PTR(array));\n\t\tif (array_get_isnull(oldnullbitmap, offset))\n\t\t\tolditemlen = 0;\n\t\telse\n\t\t{\n\t\t\tolditemlen = att_addlength_pointer(0, elmlen, elt_ptr);\n\t\t\tolditemlen = att_align_nominal(olditemlen, elmalign);\n\t\t}\n\t\tlenafter = (int) (olddatasize - lenbefore - olditemlen);\n\t}\n\n\tif (isNull)\n\t\tnewitemlen = 0;\n\telse\n\t{\n\t\tnewitemlen = att_addlength_datum(0, elmlen, dataValue);\n\t\tnewitemlen = att_align_nominal(newitemlen, elmalign);\n\t}\n\n\tnewsize = overheadlen + lenbefore + newitemlen + lenafter;\n\n\t/*\n\t * OK, create the new array and fill in header/dimensions\n\t */\n\tnewarray = (ArrayType *) palloc0(newsize);\n\tSET_VARSIZE(newarray, newsize);\n\tnewarray->ndim = ndim;\n\tnewarray->dataoffset = newhasnulls ? overheadlen : 0;\n\tnewarray->elemtype = ARR_ELEMTYPE(array);\n\tmemcpy(ARR_DIMS(newarray), dim, ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(newarray), lb, ndim * sizeof(int));\n\n\t/*\n\t * Fill in data\n\t */\n\tmemcpy((char *) newarray + overheadlen,\n\t\t   (char *) array + oldoverheadlen,\n\t\t   lenbefore);\n\tif (!isNull)\n\t\tArrayCastAndSet(dataValue, elmlen, elmbyval, elmalign,\n\t\t\t\t\t\t(char *) newarray + overheadlen + lenbefore);\n\tmemcpy((char *) newarray + overheadlen + lenbefore + newitemlen,\n\t\t   (char *) array + oldoverheadlen + lenbefore + olditemlen,\n\t\t   lenafter);\n\n\t/*\n\t * Fill in nulls bitmap if needed\n\t *\n\t * Note: it's possible we just replaced the last NULL with a non-NULL, and\n\t * could get rid of the bitmap.  Seems not worth testing for though.\n\t */\n\tif (newhasnulls)\n\t{\n\t\tbits8\t   *newnullbitmap = ARR_NULLBITMAP(newarray);\n\n\t\t/* Zero the bitmap to take care of marking inserted positions null */\n\t\tMemSet(newnullbitmap, 0, (newnitems + 7) / 8);\n\t\t/* Fix the inserted value */\n\t\tif (addedafter)\n\t\t\tarray_set_isnull(newnullbitmap, newnitems - 1, isNull);\n\t\telse\n\t\t\tarray_set_isnull(newnullbitmap, offset, isNull);\n\t\t/* Fix the copied range(s) */\n\t\tif (addedbefore)\n\t\t\tarray_bitmap_copy(newnullbitmap, addedbefore,\n\t\t\t\t\t\t\t  oldnullbitmap, 0,\n\t\t\t\t\t\t\t  oldnitems);\n\t\telse\n\t\t{\n\t\t\tarray_bitmap_copy(newnullbitmap, 0,\n\t\t\t\t\t\t\t  oldnullbitmap, 0,\n\t\t\t\t\t\t\t  offset);\n\t\t\tif (addedafter == 0)\n\t\t\t\tarray_bitmap_copy(newnullbitmap, offset + 1,\n\t\t\t\t\t\t\t\t  oldnullbitmap, offset + 1,\n\t\t\t\t\t\t\t\t  oldnitems - offset - 1);\n\t\t}\n\t}\n\n\treturn PointerGetDatum(newarray);\n}"
  },
  {
    "function_name": "array_get_slice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "2027-2164",
    "snippet": "Datum\narray_get_slice(Datum arraydatum,\n\t\t\t\tint nSubscripts,\n\t\t\t\tint *upperIndx,\n\t\t\t\tint *lowerIndx,\n\t\t\t\tbool *upperProvided,\n\t\t\t\tbool *lowerProvided,\n\t\t\t\tint arraytyplen,\n\t\t\t\tint elmlen,\n\t\t\t\tbool elmbyval,\n\t\t\t\tchar elmalign)\n{\n\tArrayType  *array;\n\tArrayType  *newarray;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t   *newlb;\n\tint\t\t\tfixedDim[1],\n\t\t\t\tfixedLb[1];\n\tOid\t\t\telemtype;\n\tchar\t   *arraydataptr;\n\tbits8\t   *arraynullsptr;\n\tint32\t\tdataoffset;\n\tint\t\t\tbytes,\n\t\t\t\tspan[MAXDIM];\n\n\tif (arraytyplen > 0)\n\t{\n\t\t/*\n\t\t * fixed-length arrays -- currently, cannot slice these because parser\n\t\t * labels output as being of the fixed-length array type! Code below\n\t\t * shows how we could support it if the parser were changed to label\n\t\t * output as a suitable varlena array type.\n\t\t */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"slices of fixed-length arrays not implemented\")));\n\n\t\t/*\n\t\t * fixed-length arrays -- these are assumed to be 1-d, 0-based\n\t\t *\n\t\t * XXX where would we get the correct ELEMTYPE from?\n\t\t */\n\t\tndim = 1;\n\t\tfixedDim[0] = arraytyplen / elmlen;\n\t\tfixedLb[0] = 0;\n\t\tdim = fixedDim;\n\t\tlb = fixedLb;\n\t\telemtype = InvalidOid;\t/* XXX */\n\t\tarraydataptr = (char *) DatumGetPointer(arraydatum);\n\t\tarraynullsptr = NULL;\n\t}\n\telse\n\t{\n\t\t/* detoast input array if necessary */\n\t\tarray = DatumGetArrayTypeP(arraydatum);\n\n\t\tndim = ARR_NDIM(array);\n\t\tdim = ARR_DIMS(array);\n\t\tlb = ARR_LBOUND(array);\n\t\telemtype = ARR_ELEMTYPE(array);\n\t\tarraydataptr = ARR_DATA_PTR(array);\n\t\tarraynullsptr = ARR_NULLBITMAP(array);\n\t}\n\n\t/*\n\t * Check provided subscripts.  A slice exceeding the current array limits\n\t * is silently truncated to the array limits.  If we end up with an empty\n\t * slice, return an empty array.\n\t */\n\tif (ndim < nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t\treturn PointerGetDatum(construct_empty_array(elemtype));\n\n\tfor (i = 0; i < nSubscripts; i++)\n\t{\n\t\tif (!lowerProvided[i] || lowerIndx[i] < lb[i])\n\t\t\tlowerIndx[i] = lb[i];\n\t\tif (!upperProvided[i] || upperIndx[i] >= (dim[i] + lb[i]))\n\t\t\tupperIndx[i] = dim[i] + lb[i] - 1;\n\t\tif (lowerIndx[i] > upperIndx[i])\n\t\t\treturn PointerGetDatum(construct_empty_array(elemtype));\n\t}\n\t/* fill any missing subscript positions with full array range */\n\tfor (; i < ndim; i++)\n\t{\n\t\tlowerIndx[i] = lb[i];\n\t\tupperIndx[i] = dim[i] + lb[i] - 1;\n\t\tif (lowerIndx[i] > upperIndx[i])\n\t\t\treturn PointerGetDatum(construct_empty_array(elemtype));\n\t}\n\n\tmda_get_range(ndim, span, lowerIndx, upperIndx);\n\n\tbytes = array_slice_size(arraydataptr, arraynullsptr,\n\t\t\t\t\t\t\t ndim, dim, lb,\n\t\t\t\t\t\t\t lowerIndx, upperIndx,\n\t\t\t\t\t\t\t elmlen, elmbyval, elmalign);\n\n\t/*\n\t * Currently, we put a null bitmap in the result if the source has one;\n\t * could be smarter ...\n\t */\n\tif (arraynullsptr)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, ArrayGetNItems(ndim, span));\n\t\tbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\n\tnewarray = (ArrayType *) palloc0(bytes);\n\tSET_VARSIZE(newarray, bytes);\n\tnewarray->ndim = ndim;\n\tnewarray->dataoffset = dataoffset;\n\tnewarray->elemtype = elemtype;\n\tmemcpy(ARR_DIMS(newarray), span, ndim * sizeof(int));\n\n\t/*\n\t * Lower bounds of the new array are set to 1.  Formerly (before 7.3) we\n\t * copied the given lowerIndx values ... but that seems confusing.\n\t */\n\tnewlb = ARR_LBOUND(newarray);\n\tfor (i = 0; i < ndim; i++)\n\t\tnewlb[i] = 1;\n\n\tarray_extract_slice(newarray,\n\t\t\t\t\t\tndim, dim, lb,\n\t\t\t\t\t\tarraydataptr, arraynullsptr,\n\t\t\t\t\t\tlowerIndx, upperIndx,\n\t\t\t\t\t\telmlen, elmbyval, elmalign);\n\n\treturn PointerGetDatum(newarray);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "newarray"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_extract_slice",
          "args": [
            "newarray",
            "ndim",
            "dim",
            "lb",
            "arraydataptr",
            "arraynullsptr",
            "lowerIndx",
            "upperIndx",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "array_extract_slice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4818-4876",
          "snippet": "static void\narray_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim,\n\t\t\t\t\tint *dim,\n\t\t\t\t\tint *lb,\n\t\t\t\t\tchar *arraydataptr,\n\t\t\t\t\tbits8 *arraynullsptr,\n\t\t\t\t\tint *st,\n\t\t\t\t\tint *endp,\n\t\t\t\t\tint typlen,\n\t\t\t\t\tbool typbyval,\n\t\t\t\t\tchar typalign)\n{\n\tchar\t   *destdataptr = ARR_DATA_PTR(newarray);\n\tbits8\t   *destnullsptr = ARR_NULLBITMAP(newarray);\n\tchar\t   *srcdataptr;\n\tint\t\t\tsrc_offset,\n\t\t\t\tdest_offset,\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\n\tsrc_offset = ArrayGetOffset(ndim, dim, lb, st);\n\tsrcdataptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,\n\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_range(ndim, span, st, endp);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tdest_offset = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\tif (dist[j])\n\t\t{\n\t\t\t/* skip unwanted elements */\n\t\t\tsrcdataptr = array_seek(srcdataptr, src_offset, arraynullsptr,\n\t\t\t\t\t\t\t\t\tdist[j],\n\t\t\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\t\t\tsrc_offset += dist[j];\n\t\t}\n\t\tinc = array_copy(destdataptr, 1,\n\t\t\t\t\t\t srcdataptr, src_offset, arraynullsptr,\n\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\tif (destnullsptr)\n\t\t\tarray_bitmap_copy(destnullsptr, dest_offset,\n\t\t\t\t\t\t\t  arraynullsptr, src_offset,\n\t\t\t\t\t\t\t  1);\n\t\tdestdataptr += inc;\n\t\tsrcdataptr += inc;\n\t\tsrc_offset++;\n\t\tdest_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic void\narray_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim,\n\t\t\t\t\tint *dim,\n\t\t\t\t\tint *lb,\n\t\t\t\t\tchar *arraydataptr,\n\t\t\t\t\tbits8 *arraynullsptr,\n\t\t\t\t\tint *st,\n\t\t\t\t\tint *endp,\n\t\t\t\t\tint typlen,\n\t\t\t\t\tbool typbyval,\n\t\t\t\t\tchar typalign)\n{\n\tchar\t   *destdataptr = ARR_DATA_PTR(newarray);\n\tbits8\t   *destnullsptr = ARR_NULLBITMAP(newarray);\n\tchar\t   *srcdataptr;\n\tint\t\t\tsrc_offset,\n\t\t\t\tdest_offset,\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\n\tsrc_offset = ArrayGetOffset(ndim, dim, lb, st);\n\tsrcdataptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,\n\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_range(ndim, span, st, endp);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tdest_offset = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\tif (dist[j])\n\t\t{\n\t\t\t/* skip unwanted elements */\n\t\t\tsrcdataptr = array_seek(srcdataptr, src_offset, arraynullsptr,\n\t\t\t\t\t\t\t\t\tdist[j],\n\t\t\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\t\t\tsrc_offset += dist[j];\n\t\t}\n\t\tinc = array_copy(destdataptr, 1,\n\t\t\t\t\t\t srcdataptr, src_offset, arraynullsptr,\n\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\tif (destnullsptr)\n\t\t\tarray_bitmap_copy(destnullsptr, dest_offset,\n\t\t\t\t\t\t\t  arraynullsptr, src_offset,\n\t\t\t\t\t\t\t  1);\n\t\tdestdataptr += inc;\n\t\tsrcdataptr += inc;\n\t\tsrc_offset++;\n\t\tdest_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "newarray"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(newarray)",
            "span",
            "ndim * sizeof(int)"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "newarray"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "newarray",
            "bytes"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "bytes"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndim"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndim",
            "ArrayGetNItems(ndim, span)"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "span"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_slice_size",
          "args": [
            "arraydataptr",
            "arraynullsptr",
            "ndim",
            "dim",
            "lb",
            "lowerIndx",
            "upperIndx",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "array_slice_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4758-4808",
          "snippet": "static int\narray_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tsrc_offset,\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tchar\t   *ptr;\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\tint\t\t\tcount = 0;\n\n\tmda_get_range(ndim, span, st, endp);\n\n\t/* Pretty easy for fixed element length without nulls ... */\n\tif (typlen > 0 && !arraynullsptr)\n\t\treturn ArrayGetNItems(ndim, span) * att_align_nominal(typlen, typalign);\n\n\t/* Else gotta do it the hard way */\n\tsrc_offset = ArrayGetOffset(ndim, dim, lb, st);\n\tptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,\n\t\t\t\t\t typlen, typbyval, typalign);\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\tif (dist[j])\n\t\t{\n\t\t\tptr = array_seek(ptr, src_offset, arraynullsptr, dist[j],\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\t\tsrc_offset += dist[j];\n\t\t}\n\t\tif (!array_get_isnull(arraynullsptr, src_offset))\n\t\t{\n\t\t\tinc = att_addlength_pointer(0, typlen, ptr);\n\t\t\tinc = att_align_nominal(inc, typalign);\n\t\t\tptr += inc;\n\t\t\tcount += inc;\n\t\t}\n\t\tsrc_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n\treturn count;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\narray_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tsrc_offset,\n\t\t\t\tspan[MAXDIM],\n\t\t\t\tprod[MAXDIM],\n\t\t\t\tdist[MAXDIM],\n\t\t\t\tindx[MAXDIM];\n\tchar\t   *ptr;\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tinc;\n\tint\t\t\tcount = 0;\n\n\tmda_get_range(ndim, span, st, endp);\n\n\t/* Pretty easy for fixed element length without nulls ... */\n\tif (typlen > 0 && !arraynullsptr)\n\t\treturn ArrayGetNItems(ndim, span) * att_align_nominal(typlen, typalign);\n\n\t/* Else gotta do it the hard way */\n\tsrc_offset = ArrayGetOffset(ndim, dim, lb, st);\n\tptr = array_seek(arraydataptr, 0, arraynullsptr, src_offset,\n\t\t\t\t\t typlen, typbyval, typalign);\n\tmda_get_prod(ndim, dim, prod);\n\tmda_get_offset_values(ndim, dist, prod, span);\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tj = ndim - 1;\n\tdo\n\t{\n\t\tif (dist[j])\n\t\t{\n\t\t\tptr = array_seek(ptr, src_offset, arraynullsptr, dist[j],\n\t\t\t\t\t\t\t typlen, typbyval, typalign);\n\t\t\tsrc_offset += dist[j];\n\t\t}\n\t\tif (!array_get_isnull(arraynullsptr, src_offset))\n\t\t{\n\t\t\tinc = att_addlength_pointer(0, typlen, ptr);\n\t\t\tinc = att_align_nominal(inc, typalign);\n\t\t\tptr += inc;\n\t\t\tcount += inc;\n\t\t}\n\t\tsrc_offset++;\n\t} while ((j = mda_next_tuple(ndim, indx, span)) != -1);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mda_get_range",
          "args": [
            "ndim",
            "span",
            "lowerIndx",
            "upperIndx"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "119-126",
          "snippet": "void\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_range(int n, int *span, const int *st, const int *endp)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < n; i++)\n\t\tspan[i] = endp[i] - st[i] + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "construct_empty_array(elemtype)"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "elemtype"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "construct_empty_array(elemtype)"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "construct_empty_array(elemtype)"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "array"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "array"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "array"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "array"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "arraydatum"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "arraydatum"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"slices of fixed-length arrays not implemented\"))"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"slices of fixed-length arrays not implemented\""
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nDatum\narray_get_slice(Datum arraydatum,\n\t\t\t\tint nSubscripts,\n\t\t\t\tint *upperIndx,\n\t\t\t\tint *lowerIndx,\n\t\t\t\tbool *upperProvided,\n\t\t\t\tbool *lowerProvided,\n\t\t\t\tint arraytyplen,\n\t\t\t\tint elmlen,\n\t\t\t\tbool elmbyval,\n\t\t\t\tchar elmalign)\n{\n\tArrayType  *array;\n\tArrayType  *newarray;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t   *newlb;\n\tint\t\t\tfixedDim[1],\n\t\t\t\tfixedLb[1];\n\tOid\t\t\telemtype;\n\tchar\t   *arraydataptr;\n\tbits8\t   *arraynullsptr;\n\tint32\t\tdataoffset;\n\tint\t\t\tbytes,\n\t\t\t\tspan[MAXDIM];\n\n\tif (arraytyplen > 0)\n\t{\n\t\t/*\n\t\t * fixed-length arrays -- currently, cannot slice these because parser\n\t\t * labels output as being of the fixed-length array type! Code below\n\t\t * shows how we could support it if the parser were changed to label\n\t\t * output as a suitable varlena array type.\n\t\t */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"slices of fixed-length arrays not implemented\")));\n\n\t\t/*\n\t\t * fixed-length arrays -- these are assumed to be 1-d, 0-based\n\t\t *\n\t\t * XXX where would we get the correct ELEMTYPE from?\n\t\t */\n\t\tndim = 1;\n\t\tfixedDim[0] = arraytyplen / elmlen;\n\t\tfixedLb[0] = 0;\n\t\tdim = fixedDim;\n\t\tlb = fixedLb;\n\t\telemtype = InvalidOid;\t/* XXX */\n\t\tarraydataptr = (char *) DatumGetPointer(arraydatum);\n\t\tarraynullsptr = NULL;\n\t}\n\telse\n\t{\n\t\t/* detoast input array if necessary */\n\t\tarray = DatumGetArrayTypeP(arraydatum);\n\n\t\tndim = ARR_NDIM(array);\n\t\tdim = ARR_DIMS(array);\n\t\tlb = ARR_LBOUND(array);\n\t\telemtype = ARR_ELEMTYPE(array);\n\t\tarraydataptr = ARR_DATA_PTR(array);\n\t\tarraynullsptr = ARR_NULLBITMAP(array);\n\t}\n\n\t/*\n\t * Check provided subscripts.  A slice exceeding the current array limits\n\t * is silently truncated to the array limits.  If we end up with an empty\n\t * slice, return an empty array.\n\t */\n\tif (ndim < nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t\treturn PointerGetDatum(construct_empty_array(elemtype));\n\n\tfor (i = 0; i < nSubscripts; i++)\n\t{\n\t\tif (!lowerProvided[i] || lowerIndx[i] < lb[i])\n\t\t\tlowerIndx[i] = lb[i];\n\t\tif (!upperProvided[i] || upperIndx[i] >= (dim[i] + lb[i]))\n\t\t\tupperIndx[i] = dim[i] + lb[i] - 1;\n\t\tif (lowerIndx[i] > upperIndx[i])\n\t\t\treturn PointerGetDatum(construct_empty_array(elemtype));\n\t}\n\t/* fill any missing subscript positions with full array range */\n\tfor (; i < ndim; i++)\n\t{\n\t\tlowerIndx[i] = lb[i];\n\t\tupperIndx[i] = dim[i] + lb[i] - 1;\n\t\tif (lowerIndx[i] > upperIndx[i])\n\t\t\treturn PointerGetDatum(construct_empty_array(elemtype));\n\t}\n\n\tmda_get_range(ndim, span, lowerIndx, upperIndx);\n\n\tbytes = array_slice_size(arraydataptr, arraynullsptr,\n\t\t\t\t\t\t\t ndim, dim, lb,\n\t\t\t\t\t\t\t lowerIndx, upperIndx,\n\t\t\t\t\t\t\t elmlen, elmbyval, elmalign);\n\n\t/*\n\t * Currently, we put a null bitmap in the result if the source has one;\n\t * could be smarter ...\n\t */\n\tif (arraynullsptr)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, ArrayGetNItems(ndim, span));\n\t\tbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\n\tnewarray = (ArrayType *) palloc0(bytes);\n\tSET_VARSIZE(newarray, bytes);\n\tnewarray->ndim = ndim;\n\tnewarray->dataoffset = dataoffset;\n\tnewarray->elemtype = elemtype;\n\tmemcpy(ARR_DIMS(newarray), span, ndim * sizeof(int));\n\n\t/*\n\t * Lower bounds of the new array are set to 1.  Formerly (before 7.3) we\n\t * copied the given lowerIndx values ... but that seems confusing.\n\t */\n\tnewlb = ARR_LBOUND(newarray);\n\tfor (i = 0; i < ndim; i++)\n\t\tnewlb[i] = 1;\n\n\tarray_extract_slice(newarray,\n\t\t\t\t\t\tndim, dim, lb,\n\t\t\t\t\t\tarraydataptr, arraynullsptr,\n\t\t\t\t\t\tlowerIndx, upperIndx,\n\t\t\t\t\t\telmlen, elmbyval, elmalign);\n\n\treturn PointerGetDatum(newarray);\n}"
  },
  {
    "function_name": "array_get_element_expanded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1919-1996",
    "snippet": "static Datum\narray_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull)\n{\n\tExpandedArrayHeader *eah;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t\toffset;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\n\teah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* sanity-check caller's info against object */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\tndim = eah->ndims;\n\tdim = eah->dims;\n\tlb = eah->lbound;\n\n\t/*\n\t * Return NULL for invalid subscript\n\t */\n\tif (ndim != nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (indx[i] < lb[i] || indx[i] >= (dim[i] + lb[i]))\n\t\t{\n\t\t\t*isNull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the element number\n\t */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/*\n\t * Deconstruct array if we didn't already.  Note that we apply this even\n\t * if the input is nominally read-only: it should be safe enough.\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\t/*\n\t * Check for NULL array element\n\t */\n\tif (dnulls && dnulls[offset])\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/*\n\t * OK, get the element.  It's OK to return a pass-by-ref value as a\n\t * pointer into the expanded array, for the same reason that regular\n\t * array_get_element can return a pointer into flat arrays: the value is\n\t * assumed not to change for as long as the Datum reference can exist.\n\t */\n\t*isNull = false;\n\treturn dvalues[offset];\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
      "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deconstruct_expanded_array",
          "args": [
            "eah"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_expanded_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_expanded.c",
          "lines": "423-453",
          "snippet": "void\ndeconstruct_expanded_array(ExpandedArrayHeader *eah)\n{\n\tif (eah->dvalues == NULL)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\t\tDatum\t   *dvalues;\n\t\tbool\t   *dnulls;\n\t\tint\t\t\tnelems;\n\n\t\tdnulls = NULL;\n\t\tdeconstruct_array(eah->fvalue,\n\t\t\t\t\t\t  eah->element_type,\n\t\t\t\t\t\t  eah->typlen, eah->typbyval, eah->typalign,\n\t\t\t\t\t\t  &dvalues,\n\t\t\t\t\t\t  ARR_HASNULL(eah->fvalue) ? &dnulls : NULL,\n\t\t\t\t\t\t  &nelems);\n\n\t\t/*\n\t\t * Update header only after successful completion of this step.  If\n\t\t * deconstruct_array fails partway through, worst consequence is some\n\t\t * leaked memory in the object's context.  If the caller fails at a\n\t\t * later point, that's fine, since the deconstructed representation is\n\t\t * valid anyhow.\n\t\t */\n\t\teah->dvalues = dvalues;\n\t\teah->dnulls = dnulls;\n\t\teah->dvalueslen = eah->nelems = nelems;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/array.h\"",
            "#include \"access/tupmacs.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/array.h\"\n#include \"access/tupmacs.h\"\n#include \"postgres.h\"\n\nvoid\ndeconstruct_expanded_array(ExpandedArrayHeader *eah)\n{\n\tif (eah->dvalues == NULL)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\t\tDatum\t   *dvalues;\n\t\tbool\t   *dnulls;\n\t\tint\t\t\tnelems;\n\n\t\tdnulls = NULL;\n\t\tdeconstruct_array(eah->fvalue,\n\t\t\t\t\t\t  eah->element_type,\n\t\t\t\t\t\t  eah->typlen, eah->typbyval, eah->typalign,\n\t\t\t\t\t\t  &dvalues,\n\t\t\t\t\t\t  ARR_HASNULL(eah->fvalue) ? &dnulls : NULL,\n\t\t\t\t\t\t  &nelems);\n\n\t\t/*\n\t\t * Update header only after successful completion of this step.  If\n\t\t * deconstruct_array fails partway through, worst consequence is some\n\t\t * leaked memory in the object's context.  If the caller fails at a\n\t\t * later point, that's fine, since the deconstructed representation is\n\t\t * valid anyhow.\n\t\t */\n\t\teah->dvalues = dvalues;\n\t\teah->dnulls = dnulls;\n\t\teah->dvalueslen = eah->nelems = nelems;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetOffset",
          "args": [
            "nSubscripts",
            "dim",
            "lb",
            "indx"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "30-43",
          "snippet": "int\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "elmalign == eah->typalign"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "elmbyval == eah->typbyval"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "elmlen == eah->typlen"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "arraytyplen == -1"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "eah->ea_magic == EA_MAGIC"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetEOHP",
          "args": [
            "arraydatum"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "DatumGetEOHP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/expandeddatum.c",
          "lines": "28-38",
          "snippet": "ExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/expandeddatum.h\"\n#include \"postgres.h\"\n\nExpandedObjectHeader *\nDatumGetEOHP(Datum d)\n{\n\tvarattrib_1b_e *datum = (varattrib_1b_e *) DatumGetPointer(d);\n\tvaratt_expanded ptr;\n\n\tAssert(VARATT_IS_EXTERNAL_EXPANDED(datum));\n\tmemcpy(&ptr, VARDATA_EXTERNAL(datum), sizeof(ptr));\n\tAssert(VARATT_IS_EXPANDED_HEADER(ptr.eohptr));\n\treturn ptr.eohptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic Datum\narray_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull)\n{\n\tExpandedArrayHeader *eah;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t\toffset;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\n\teah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* sanity-check caller's info against object */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\tndim = eah->ndims;\n\tdim = eah->dims;\n\tlb = eah->lbound;\n\n\t/*\n\t * Return NULL for invalid subscript\n\t */\n\tif (ndim != nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (indx[i] < lb[i] || indx[i] >= (dim[i] + lb[i]))\n\t\t{\n\t\t\t*isNull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the element number\n\t */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/*\n\t * Deconstruct array if we didn't already.  Note that we apply this even\n\t * if the input is nominally read-only: it should be safe enough.\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\t/*\n\t * Check for NULL array element\n\t */\n\tif (dnulls && dnulls[offset])\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/*\n\t * OK, get the element.  It's OK to return a pass-by-ref value as a\n\t * pointer into the expanded array, for the same reason that regular\n\t * array_get_element can return a pointer into flat arrays: the value is\n\t * assumed not to change for as long as the Datum reference can exist.\n\t */\n\t*isNull = false;\n\treturn dvalues[offset];\n}"
  },
  {
    "function_name": "array_get_element",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1818-1914",
    "snippet": "Datum\narray_get_element(Datum arraydatum,\n\t\t\t\t  int nSubscripts,\n\t\t\t\t  int *indx,\n\t\t\t\t  int arraytyplen,\n\t\t\t\t  int elmlen,\n\t\t\t\t  bool elmbyval,\n\t\t\t\t  char elmalign,\n\t\t\t\t  bool *isNull)\n{\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t\toffset,\n\t\t\t\tfixedDim[1],\n\t\t\t\tfixedLb[1];\n\tchar\t   *arraydataptr,\n\t\t\t   *retptr;\n\tbits8\t   *arraynullsptr;\n\n\tif (arraytyplen > 0)\n\t{\n\t\t/*\n\t\t * fixed-length arrays -- these are assumed to be 1-d, 0-based\n\t\t */\n\t\tndim = 1;\n\t\tfixedDim[0] = arraytyplen / elmlen;\n\t\tfixedLb[0] = 0;\n\t\tdim = fixedDim;\n\t\tlb = fixedLb;\n\t\tarraydataptr = (char *) DatumGetPointer(arraydatum);\n\t\tarraynullsptr = NULL;\n\t}\n\telse if (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\t/* expanded array: let's do this in a separate function */\n\t\treturn array_get_element_expanded(arraydatum,\n\t\t\t\t\t\t\t\t\t\t  nSubscripts,\n\t\t\t\t\t\t\t\t\t\t  indx,\n\t\t\t\t\t\t\t\t\t\t  arraytyplen,\n\t\t\t\t\t\t\t\t\t\t  elmlen,\n\t\t\t\t\t\t\t\t\t\t  elmbyval,\n\t\t\t\t\t\t\t\t\t\t  elmalign,\n\t\t\t\t\t\t\t\t\t\t  isNull);\n\t}\n\telse\n\t{\n\t\t/* detoast array if necessary, producing normal varlena input */\n\t\tArrayType  *array = DatumGetArrayTypeP(arraydatum);\n\n\t\tndim = ARR_NDIM(array);\n\t\tdim = ARR_DIMS(array);\n\t\tlb = ARR_LBOUND(array);\n\t\tarraydataptr = ARR_DATA_PTR(array);\n\t\tarraynullsptr = ARR_NULLBITMAP(array);\n\t}\n\n\t/*\n\t * Return NULL for invalid subscript\n\t */\n\tif (ndim != nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (indx[i] < lb[i] || indx[i] >= (dim[i] + lb[i]))\n\t\t{\n\t\t\t*isNull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the element number\n\t */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/*\n\t * Check for NULL array element\n\t */\n\tif (array_get_isnull(arraynullsptr, offset))\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/*\n\t * OK, get the element\n\t */\n\t*isNull = false;\n\tretptr = array_seek(arraydataptr, 0, arraynullsptr, offset,\n\t\t\t\t\t\telmlen, elmbyval, elmalign);\n\treturn ArrayCast(retptr, elmbyval, elmlen);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
      "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
      "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
      "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ArrayCast",
          "args": [
            "retptr",
            "elmbyval",
            "elmlen"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayCast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4537-4541",
          "snippet": "static Datum\nArrayCast(char *value, bool byval, int len)\n{\n\treturn fetch_att(value, byval, len);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum ArrayCast(char *value, bool byval, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum ArrayCast(char *value, bool byval, int len);\n\nstatic Datum\nArrayCast(char *value, bool byval, int len)\n{\n\treturn fetch_att(value, byval, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_seek",
          "args": [
            "arraydataptr",
            "0",
            "arraynullsptr",
            "offset",
            "elmlen",
            "elmbyval",
            "elmalign"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "array_seek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4587-4628",
          "snippet": "static char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic char *\narray_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign)\n{\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\t/* easy if fixed-size elements and no NULLs */\n\tif (typlen > 0 && !nullbitmap)\n\t\treturn ptr + nitems * ((Size) att_align_nominal(typlen, typalign));\n\n\t/* seems worth having separate loops for NULL and no-NULLs cases */\n\tif (nullbitmap)\n\t{\n\t\tnullbitmap += offset / 8;\n\t\tbitmask = 1 << (offset % 8);\n\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tif (*nullbitmap & bitmask)\n\t\t\t{\n\t\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t\t}\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tnullbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < nitems; i++)\n\t\t{\n\t\t\tptr = att_addlength_pointer(ptr, typlen, ptr);\n\t\t\tptr = (char *) att_align_nominal(ptr, typalign);\n\t\t}\n\t}\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_get_isnull",
          "args": [
            "arraynullsptr",
            "offset"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "array_get_isnull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4502-4510",
          "snippet": "static bool\narray_get_isnull(const bits8 *nullbitmap, int offset)\n{\n\tif (nullbitmap == NULL)\n\t\treturn false;\t\t\t/* assume not null */\n\tif (nullbitmap[offset / 8] & (1 << (offset % 8)))\n\t\treturn false;\t\t\t/* not null */\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\n\nstatic bool\narray_get_isnull(const bits8 *nullbitmap, int offset)\n{\n\tif (nullbitmap == NULL)\n\t\treturn false;\t\t\t/* assume not null */\n\tif (nullbitmap[offset / 8] & (1 << (offset % 8)))\n\t\treturn false;\t\t\t/* not null */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetOffset",
          "args": [
            "nSubscripts",
            "dim",
            "lb",
            "indx"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "30-43",
          "snippet": "int\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nArrayGetOffset(int n, const int *dim, const int *lb, const int *indx)\n{\n\tint\t\t\ti,\n\t\t\t\tscale = 1,\n\t\t\t\toffset = 0;\n\n\tfor (i = n - 1; i >= 0; i--)\n\t{\n\t\toffset += (indx[i] - lb[i]) * scale;\n\t\tscale *= dim[i];\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "array"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "array"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "array"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "array"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "array"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "arraydatum"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_get_element_expanded",
          "args": [
            "arraydatum",
            "nSubscripts",
            "indx",
            "arraytyplen",
            "elmlen",
            "elmbyval",
            "elmalign",
            "isNull"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "array_get_element_expanded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "1919-1996",
          "snippet": "static Datum\narray_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull)\n{\n\tExpandedArrayHeader *eah;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t\toffset;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\n\teah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* sanity-check caller's info against object */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\tndim = eah->ndims;\n\tdim = eah->dims;\n\tlb = eah->lbound;\n\n\t/*\n\t * Return NULL for invalid subscript\n\t */\n\tif (ndim != nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (indx[i] < lb[i] || indx[i] >= (dim[i] + lb[i]))\n\t\t{\n\t\t\t*isNull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the element number\n\t */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/*\n\t * Deconstruct array if we didn't already.  Note that we apply this even\n\t * if the input is nominally read-only: it should be safe enough.\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\t/*\n\t * Check for NULL array element\n\t */\n\tif (dnulls && dnulls[offset])\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/*\n\t * OK, get the element.  It's OK to return a pass-by-ref value as a\n\t * pointer into the expanded array, for the same reason that regular\n\t * array_get_element can return a pointer into flat arrays: the value is\n\t * assumed not to change for as long as the Datum reference can exist.\n\t */\n\t*isNull = false;\n\treturn dvalues[offset];\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic Datum\narray_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull)\n{\n\tExpandedArrayHeader *eah;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t\toffset;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\n\teah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* sanity-check caller's info against object */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\tndim = eah->ndims;\n\tdim = eah->dims;\n\tlb = eah->lbound;\n\n\t/*\n\t * Return NULL for invalid subscript\n\t */\n\tif (ndim != nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (indx[i] < lb[i] || indx[i] >= (dim[i] + lb[i]))\n\t\t{\n\t\t\t*isNull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the element number\n\t */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/*\n\t * Deconstruct array if we didn't already.  Note that we apply this even\n\t * if the input is nominally read-only: it should be safe enough.\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\t/*\n\t * Check for NULL array element\n\t */\n\tif (dnulls && dnulls[offset])\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/*\n\t * OK, get the element.  It's OK to return a pass-by-ref value as a\n\t * pointer into the expanded array, for the same reason that regular\n\t * array_get_element can return a pointer into flat arrays: the value is\n\t * assumed not to change for as long as the Datum reference can exist.\n\t */\n\t*isNull = false;\n\treturn dvalues[offset];\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL_EXPANDED",
          "args": [
            "DatumGetPointer(arraydatum)"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "arraydatum"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "arraydatum"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\n\nDatum\narray_get_element(Datum arraydatum,\n\t\t\t\t  int nSubscripts,\n\t\t\t\t  int *indx,\n\t\t\t\t  int arraytyplen,\n\t\t\t\t  int elmlen,\n\t\t\t\t  bool elmbyval,\n\t\t\t\t  char elmalign,\n\t\t\t\t  bool *isNull)\n{\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t\toffset,\n\t\t\t\tfixedDim[1],\n\t\t\t\tfixedLb[1];\n\tchar\t   *arraydataptr,\n\t\t\t   *retptr;\n\tbits8\t   *arraynullsptr;\n\n\tif (arraytyplen > 0)\n\t{\n\t\t/*\n\t\t * fixed-length arrays -- these are assumed to be 1-d, 0-based\n\t\t */\n\t\tndim = 1;\n\t\tfixedDim[0] = arraytyplen / elmlen;\n\t\tfixedLb[0] = 0;\n\t\tdim = fixedDim;\n\t\tlb = fixedLb;\n\t\tarraydataptr = (char *) DatumGetPointer(arraydatum);\n\t\tarraynullsptr = NULL;\n\t}\n\telse if (VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(arraydatum)))\n\t{\n\t\t/* expanded array: let's do this in a separate function */\n\t\treturn array_get_element_expanded(arraydatum,\n\t\t\t\t\t\t\t\t\t\t  nSubscripts,\n\t\t\t\t\t\t\t\t\t\t  indx,\n\t\t\t\t\t\t\t\t\t\t  arraytyplen,\n\t\t\t\t\t\t\t\t\t\t  elmlen,\n\t\t\t\t\t\t\t\t\t\t  elmbyval,\n\t\t\t\t\t\t\t\t\t\t  elmalign,\n\t\t\t\t\t\t\t\t\t\t  isNull);\n\t}\n\telse\n\t{\n\t\t/* detoast array if necessary, producing normal varlena input */\n\t\tArrayType  *array = DatumGetArrayTypeP(arraydatum);\n\n\t\tndim = ARR_NDIM(array);\n\t\tdim = ARR_DIMS(array);\n\t\tlb = ARR_LBOUND(array);\n\t\tarraydataptr = ARR_DATA_PTR(array);\n\t\tarraynullsptr = ARR_NULLBITMAP(array);\n\t}\n\n\t/*\n\t * Return NULL for invalid subscript\n\t */\n\tif (ndim != nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (indx[i] < lb[i] || indx[i] >= (dim[i] + lb[i]))\n\t\t{\n\t\t\t*isNull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the element number\n\t */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/*\n\t * Check for NULL array element\n\t */\n\tif (array_get_isnull(arraynullsptr, offset))\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/*\n\t * OK, get the element\n\t */\n\t*isNull = false;\n\tretptr = array_seek(arraydataptr, 0, arraynullsptr, offset,\n\t\t\t\t\t\telmlen, elmbyval, elmalign);\n\treturn ArrayCast(retptr, elmbyval, elmlen);\n}"
  },
  {
    "function_name": "array_cardinality",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1788-1794",
    "snippet": "Datum\narray_cardinality(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\n\tPG_RETURN_INT32(ArrayGetNItems(AARR_NDIM(v), AARR_DIMS(v)));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "ArrayGetNItems(AARR_NDIM(v), AARR_DIMS(v))"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "AARR_NDIM(v)",
            "AARR_DIMS(v)"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "v"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\narray_cardinality(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\n\tPG_RETURN_INT32(ArrayGetNItems(AARR_NDIM(v), AARR_DIMS(v)));\n}"
  },
  {
    "function_name": "array_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1761-1782",
    "snippet": "Datum\narray_length(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tint\t\t\treqdim = PG_GETARG_INT32(1);\n\tint\t\t   *dimv;\n\tint\t\t\tresult;\n\n\t/* Sanity check: does it look like an array at all? */\n\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\tPG_RETURN_NULL();\n\n\t/* Sanity check: was the requested dim valid */\n\tif (reqdim <= 0 || reqdim > AARR_NDIM(v))\n\t\tPG_RETURN_NULL();\n\n\tdimv = AARR_DIMS(v);\n\n\tresult = dimv[reqdim - 1];\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "v"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\narray_length(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tint\t\t\treqdim = PG_GETARG_INT32(1);\n\tint\t\t   *dimv;\n\tint\t\t\tresult;\n\n\t/* Sanity check: does it look like an array at all? */\n\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\tPG_RETURN_NULL();\n\n\t/* Sanity check: was the requested dim valid */\n\tif (reqdim <= 0 || reqdim > AARR_NDIM(v))\n\t\tPG_RETURN_NULL();\n\n\tdimv = AARR_DIMS(v);\n\n\tresult = dimv[reqdim - 1];\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "array_upper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1731-1754",
    "snippet": "Datum\narray_upper(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tint\t\t\treqdim = PG_GETARG_INT32(1);\n\tint\t\t   *dimv,\n\t\t\t   *lb;\n\tint\t\t\tresult;\n\n\t/* Sanity check: does it look like an array at all? */\n\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\tPG_RETURN_NULL();\n\n\t/* Sanity check: was the requested dim valid */\n\tif (reqdim <= 0 || reqdim > AARR_NDIM(v))\n\t\tPG_RETURN_NULL();\n\n\tlb = AARR_LBOUND(v);\n\tdimv = AARR_DIMS(v);\n\n\tresult = dimv[reqdim - 1] + lb[reqdim - 1] - 1;\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "v"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "v"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\narray_upper(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tint\t\t\treqdim = PG_GETARG_INT32(1);\n\tint\t\t   *dimv,\n\t\t\t   *lb;\n\tint\t\t\tresult;\n\n\t/* Sanity check: does it look like an array at all? */\n\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\tPG_RETURN_NULL();\n\n\t/* Sanity check: was the requested dim valid */\n\tif (reqdim <= 0 || reqdim > AARR_NDIM(v))\n\t\tPG_RETURN_NULL();\n\n\tlb = AARR_LBOUND(v);\n\tdimv = AARR_DIMS(v);\n\n\tresult = dimv[reqdim - 1] + lb[reqdim - 1] - 1;\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "array_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1704-1724",
    "snippet": "Datum\narray_lower(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tint\t\t\treqdim = PG_GETARG_INT32(1);\n\tint\t\t   *lb;\n\tint\t\t\tresult;\n\n\t/* Sanity check: does it look like an array at all? */\n\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\tPG_RETURN_NULL();\n\n\t/* Sanity check: was the requested dim valid */\n\tif (reqdim <= 0 || reqdim > AARR_NDIM(v))\n\t\tPG_RETURN_NULL();\n\n\tlb = AARR_LBOUND(v);\n\tresult = lb[reqdim - 1];\n\n\tPG_RETURN_INT32(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "v"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\narray_lower(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tint\t\t\treqdim = PG_GETARG_INT32(1);\n\tint\t\t   *lb;\n\tint\t\t\tresult;\n\n\t/* Sanity check: does it look like an array at all? */\n\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\tPG_RETURN_NULL();\n\n\t/* Sanity check: was the requested dim valid */\n\tif (reqdim <= 0 || reqdim > AARR_NDIM(v))\n\t\tPG_RETURN_NULL();\n\n\tlb = AARR_LBOUND(v);\n\tresult = lb[reqdim - 1];\n\n\tPG_RETURN_INT32(result);\n}"
  },
  {
    "function_name": "array_dims",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1666-1697",
    "snippet": "Datum\narray_dims(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tchar\t   *p;\n\tint\t\t\ti;\n\tint\t\t   *dimv,\n\t\t\t   *lb;\n\n\t/*\n\t * 33 since we assume 15 digits per number + ':' +'[]'\n\t *\n\t * +1 for trailing null\n\t */\n\tchar\t\tbuf[MAXDIM * 33 + 1];\n\n\t/* Sanity check: does it look like an array at all? */\n\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\tPG_RETURN_NULL();\n\n\tdimv = AARR_DIMS(v);\n\tlb = AARR_LBOUND(v);\n\n\tp = buf;\n\tfor (i = 0; i < AARR_NDIM(v); i++)\n\t{\n\t\tsprintf(p, \"[%d:%d]\", lb[i], dimv[i] + lb[i] - 1);\n\t\tp += strlen(p);\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(buf));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(buf)"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "buf"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p",
            "\"[%d:%d]\"",
            "lb[i]",
            "dimv[i] + lb[i] - 1"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "v"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "v"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\narray_dims(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tchar\t   *p;\n\tint\t\t\ti;\n\tint\t\t   *dimv,\n\t\t\t   *lb;\n\n\t/*\n\t * 33 since we assume 15 digits per number + ':' +'[]'\n\t *\n\t * +1 for trailing null\n\t */\n\tchar\t\tbuf[MAXDIM * 33 + 1];\n\n\t/* Sanity check: does it look like an array at all? */\n\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\tPG_RETURN_NULL();\n\n\tdimv = AARR_DIMS(v);\n\tlb = AARR_LBOUND(v);\n\n\tp = buf;\n\tfor (i = 0; i < AARR_NDIM(v); i++)\n\t{\n\t\tsprintf(p, \"[%d:%d]\", lb[i], dimv[i] + lb[i] - 1);\n\t\tp += strlen(p);\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(buf));\n}"
  },
  {
    "function_name": "array_ndims",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1650-1660",
    "snippet": "Datum\narray_ndims(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\n\t/* Sanity check: does it look like an array at all? */\n\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(AARR_NDIM(v));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "AARR_NDIM(v)"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\narray_ndims(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\n\t/* Sanity check: does it look like an array at all? */\n\tif (AARR_NDIM(v) <= 0 || AARR_NDIM(v) > MAXDIM)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(AARR_NDIM(v));\n}"
  },
  {
    "function_name": "array_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1546-1644",
    "snippet": "Datum\narray_send(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(v);\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tnitems,\n\t\t\t\ti;\n\tint\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb;\n\tStringInfoData buf;\n\tarray_iter\titer;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * We arrange to look up info about element type, including its send\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/* Get info about element type, including its send proc */\n\t\tget_type_io_data(element_type, IOFunc_send,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tif (!OidIsValid(my_extra->typiofunc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tndim = AARR_NDIM(v);\n\tdim = AARR_DIMS(v);\n\tlb = AARR_LBOUND(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tpq_begintypsend(&buf);\n\n\t/* Send the array header information */\n\tpq_sendint32(&buf, ndim);\n\tpq_sendint32(&buf, AARR_HASNULL(v) ? 1 : 0);\n\tpq_sendint32(&buf, element_type);\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tpq_sendint32(&buf, dim[i]);\n\t\tpq_sendint32(&buf, lb[i]);\n\t}\n\n\t/* Send the array elements using the element's own sendproc */\n\tarray_iter_setup(&iter, v);\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tbool\t\tisnull;\n\n\t\t/* Get source element, checking for NULL */\n\t\titemvalue = array_iter_next(&iter, &isnull, i,\n\t\t\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\n\t\tif (isnull)\n\t\t{\n\t\t\t/* -1 length means a NULL */\n\t\t\tpq_sendint32(&buf, -1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbytea\t   *outputbytes;\n\n\t\t\toutputbytes = SendFunctionCall(&my_extra->proc, itemvalue);\n\t\t\tpq_sendint32(&buf, VARSIZE(outputbytes) - VARHDRSZ);\n\t\t\tpq_sendbytes(&buf, VARDATA(outputbytes),\n\t\t\t\t\t\t VARSIZE(outputbytes) - VARHDRSZ);\n\t\t\tpfree(outputbytes);\n\t\t}\n\t}\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tArrayCount(const char *str, int *dim, char typdelim);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "outputbytes"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_sendbytes",
          "args": [
            "&buf",
            "VARDATA(outputbytes)",
            "VARSIZE(outputbytes) - VARHDRSZ"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "outputbytes"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "outputbytes"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "VARSIZE(outputbytes) - VARHDRSZ"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "outputbytes"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendFunctionCall",
          "args": [
            "&my_extra->proc",
            "itemvalue"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "OidSendFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1851-1858",
          "snippet": "bytea *\nOidSendFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn SendFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbytea *\nOidSendFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn SendFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "-1"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&iter",
            "&isnull",
            "i",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&iter",
            "v"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "lb[i]"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "dim[i]"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "element_type"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "AARR_HASNULL(v) ? 1 : 0"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_HASNULL",
          "args": [
            "v"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "ndim"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "dim"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "v"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "v"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "my_extra->typiofunc",
            "&my_extra->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"no binary output function available for type %s\"",
            "format_type_be(element_type)"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "my_extra->typiofunc"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_type_io_data",
          "args": [
            "element_type",
            "IOFunc_send",
            "&my_extra->typlen",
            "&my_extra->typbyval",
            "&my_extra->typalign",
            "&my_extra->typdelim",
            "&my_extra->typioparam",
            "&my_extra->typiofunc"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "get_type_io_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2102-2173",
          "snippet": "void\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(ArrayMetaState)"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "v"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tArrayCount(const char *str, int *dim, char typdelim);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_send(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(v);\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tint\t\t\tnitems,\n\t\t\t\ti;\n\tint\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb;\n\tStringInfoData buf;\n\tarray_iter\titer;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * We arrange to look up info about element type, including its send\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/* Get info about element type, including its send proc */\n\t\tget_type_io_data(element_type, IOFunc_send,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tif (!OidIsValid(my_extra->typiofunc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"no binary output function available for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\n\tndim = AARR_NDIM(v);\n\tdim = AARR_DIMS(v);\n\tlb = AARR_LBOUND(v);\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\tpq_begintypsend(&buf);\n\n\t/* Send the array header information */\n\tpq_sendint32(&buf, ndim);\n\tpq_sendint32(&buf, AARR_HASNULL(v) ? 1 : 0);\n\tpq_sendint32(&buf, element_type);\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tpq_sendint32(&buf, dim[i]);\n\t\tpq_sendint32(&buf, lb[i]);\n\t}\n\n\t/* Send the array elements using the element's own sendproc */\n\tarray_iter_setup(&iter, v);\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tbool\t\tisnull;\n\n\t\t/* Get source element, checking for NULL */\n\t\titemvalue = array_iter_next(&iter, &isnull, i,\n\t\t\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\n\t\tif (isnull)\n\t\t{\n\t\t\t/* -1 length means a NULL */\n\t\t\tpq_sendint32(&buf, -1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbytea\t   *outputbytes;\n\n\t\t\toutputbytes = SendFunctionCall(&my_extra->proc, itemvalue);\n\t\t\tpq_sendint32(&buf, VARSIZE(outputbytes) - VARHDRSZ);\n\t\t\tpq_sendbytes(&buf, VARDATA(outputbytes),\n\t\t\t\t\t\t VARSIZE(outputbytes) - VARHDRSZ);\n\t\t\tpfree(outputbytes);\n\t\t}\n\t}\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "ReadArrayBinary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1441-1538",
    "snippet": "static void\nReadArrayBinary(StringInfo buf,\n\t\t\t\tint nitems,\n\t\t\t\tFmgrInfo *receiveproc,\n\t\t\t\tOid typioparam,\n\t\t\t\tint32 typmod,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tDatum *values,\n\t\t\t\tbool *nulls,\n\t\t\t\tbool *hasnulls,\n\t\t\t\tint32 *nbytes)\n{\n\tint\t\t\ti;\n\tbool\t\thasnull;\n\tint32\t\ttotbytes;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tint\t\t\titemlen;\n\t\tStringInfoData elem_buf;\n\t\tchar\t\tcsave;\n\n\t\t/* Get and check the item length */\n\t\titemlen = pq_getmsgint(buf, 4);\n\t\tif (itemlen < -1 || itemlen > (buf->len - buf->cursor))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"insufficient data left in message\")));\n\n\t\tif (itemlen == -1)\n\t\t{\n\t\t\t/* -1 length means NULL */\n\t\t\tvalues[i] = ReceiveFunctionCall(receiveproc, NULL,\n\t\t\t\t\t\t\t\t\t\t\ttypioparam, typmod);\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Rather than copying data around, we just set up a phony StringInfo\n\t\t * pointing to the correct portion of the input buffer. We assume we\n\t\t * can scribble on the input buffer so as to maintain the convention\n\t\t * that StringInfos have a trailing null.\n\t\t */\n\t\telem_buf.data = &buf->data[buf->cursor];\n\t\telem_buf.maxlen = itemlen + 1;\n\t\telem_buf.len = itemlen;\n\t\telem_buf.cursor = 0;\n\n\t\tbuf->cursor += itemlen;\n\n\t\tcsave = buf->data[buf->cursor];\n\t\tbuf->data[buf->cursor] = '\\0';\n\n\t\t/* Now call the element's receiveproc */\n\t\tvalues[i] = ReceiveFunctionCall(receiveproc, &elem_buf,\n\t\t\t\t\t\t\t\t\t\ttypioparam, typmod);\n\t\tnulls[i] = false;\n\n\t\t/* Trouble if it didn't eat the whole buffer */\n\t\tif (elem_buf.cursor != itemlen)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper binary format in array element %d\",\n\t\t\t\t\t\t\ti + 1)));\n\n\t\tbuf->data[buf->cursor] = csave;\n\t}\n\n\t/*\n\t * Check for nulls, compute total data space needed\n\t */\n\thasnull = false;\n\ttotbytes = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls[i])\n\t\t\thasnull = true;\n\t\telse\n\t\t{\n\t\t\t/* let's just make sure data is not toasted */\n\t\t\tif (typlen == -1)\n\t\t\t\tvalues[i] = PointerGetDatum(PG_DETOAST_DATUM(values[i]));\n\t\t\ttotbytes = att_addlength_datum(totbytes, typlen, values[i]);\n\t\t\ttotbytes = att_align_nominal(totbytes, typalign);\n\t\t\t/* check for overflow of total request */\n\t\t\tif (!AllocSizeIsValid(totbytes))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t}\n\t}\n\t*hasnulls = hasnull;\n\t*nbytes = totbytes;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
      "static Datum ArrayCast(char *value, bool byval, int len);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize))"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"array size exceeds the maximum allowed (%d)\"",
            "(int) MaxAllocSize"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSizeIsValid",
          "args": [
            "totbytes"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "totbytes",
            "typalign"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "totbytes",
            "typlen",
            "values[i]"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM(values[i])"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "values[i]"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper binary format in array element %d\",\n\t\t\t\t\t\t\ti + 1))"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReceiveFunctionCall",
          "args": [
            "receiveproc",
            "&elem_buf",
            "typioparam",
            "typmod"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "OidReceiveFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1841-1849",
          "snippet": "Datum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"insufficient data left in message\"))"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "4"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum ArrayCast(char *value, bool byval, int len);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic void\nReadArrayBinary(StringInfo buf,\n\t\t\t\tint nitems,\n\t\t\t\tFmgrInfo *receiveproc,\n\t\t\t\tOid typioparam,\n\t\t\t\tint32 typmod,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tDatum *values,\n\t\t\t\tbool *nulls,\n\t\t\t\tbool *hasnulls,\n\t\t\t\tint32 *nbytes)\n{\n\tint\t\t\ti;\n\tbool\t\thasnull;\n\tint32\t\ttotbytes;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tint\t\t\titemlen;\n\t\tStringInfoData elem_buf;\n\t\tchar\t\tcsave;\n\n\t\t/* Get and check the item length */\n\t\titemlen = pq_getmsgint(buf, 4);\n\t\tif (itemlen < -1 || itemlen > (buf->len - buf->cursor))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"insufficient data left in message\")));\n\n\t\tif (itemlen == -1)\n\t\t{\n\t\t\t/* -1 length means NULL */\n\t\t\tvalues[i] = ReceiveFunctionCall(receiveproc, NULL,\n\t\t\t\t\t\t\t\t\t\t\ttypioparam, typmod);\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Rather than copying data around, we just set up a phony StringInfo\n\t\t * pointing to the correct portion of the input buffer. We assume we\n\t\t * can scribble on the input buffer so as to maintain the convention\n\t\t * that StringInfos have a trailing null.\n\t\t */\n\t\telem_buf.data = &buf->data[buf->cursor];\n\t\telem_buf.maxlen = itemlen + 1;\n\t\telem_buf.len = itemlen;\n\t\telem_buf.cursor = 0;\n\n\t\tbuf->cursor += itemlen;\n\n\t\tcsave = buf->data[buf->cursor];\n\t\tbuf->data[buf->cursor] = '\\0';\n\n\t\t/* Now call the element's receiveproc */\n\t\tvalues[i] = ReceiveFunctionCall(receiveproc, &elem_buf,\n\t\t\t\t\t\t\t\t\t\ttypioparam, typmod);\n\t\tnulls[i] = false;\n\n\t\t/* Trouble if it didn't eat the whole buffer */\n\t\tif (elem_buf.cursor != itemlen)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper binary format in array element %d\",\n\t\t\t\t\t\t\ti + 1)));\n\n\t\tbuf->data[buf->cursor] = csave;\n\t}\n\n\t/*\n\t * Check for nulls, compute total data space needed\n\t */\n\thasnull = false;\n\ttotbytes = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls[i])\n\t\t\thasnull = true;\n\t\telse\n\t\t{\n\t\t\t/* let's just make sure data is not toasted */\n\t\t\tif (typlen == -1)\n\t\t\t\tvalues[i] = PointerGetDatum(PG_DETOAST_DATUM(values[i]));\n\t\t\ttotbytes = att_addlength_datum(totbytes, typlen, values[i]);\n\t\t\ttotbytes = att_align_nominal(totbytes, typalign);\n\t\t\t/* check for overflow of total request */\n\t\t\tif (!AllocSizeIsValid(totbytes))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t}\n\t}\n\t*hasnulls = hasnull;\n\t*nbytes = totbytes;\n}"
  },
  {
    "function_name": "array_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1266-1418",
    "snippet": "Datum\narray_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tOid\t\t\tspec_element_type = PG_GETARG_OID(1);\t/* type of an array\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * element */\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\t/* typmod for array elements */\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tOid\t\t\ttypioparam;\n\tint\t\t\ti,\n\t\t\t\tnitems;\n\tDatum\t   *dataPtr;\n\tbool\t   *nullsPtr;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tArrayType  *retval;\n\tint\t\t\tndim,\n\t\t\t\tflags,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlBound[MAXDIM];\n\tArrayMetaState *my_extra;\n\n\t/* Get the array header information */\n\tndim = pq_getmsgint(buf, 4);\n\tif (ndim < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndim)));\n\tif (ndim > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndim, MAXDIM)));\n\n\tflags = pq_getmsgint(buf, 4);\n\tif (flags != 0 && flags != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid array flags\")));\n\n\telement_type = pq_getmsgint(buf, sizeof(Oid));\n\tif (element_type != spec_element_type)\n\t{\n\t\t/* XXX Can we allow taking the input element type in any cases? */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"wrong element type\")));\n\t}\n\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tdim[i] = pq_getmsgint(buf, 4);\n\t\tlBound[i] = pq_getmsgint(buf, 4);\n\n\t\t/*\n\t\t * Check overflow of upper bound. (ArrayNItems() below checks that\n\t\t * dim[i] >= 0)\n\t\t */\n\t\tif (dim[i] != 0)\n\t\t{\n\t\t\tint\t\t\tub = lBound[i] + dim[i] - 1;\n\n\t\t\tif (lBound[i] > ub)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\")));\n\t\t}\n\t}\n\n\t/* This checks for overflow of array dimensions */\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/*\n\t * We arrange to look up info about element type, including its receive\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/* Get info about element type, including its receive proc */\n\t\tget_type_io_data(element_type, IOFunc_receive,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tif (!OidIsValid(my_extra->typiofunc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\n\tif (nitems == 0)\n\t{\n\t\t/* Return empty array ... but not till we've validated element_type */\n\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(element_type));\n\t}\n\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\ttypioparam = my_extra->typioparam;\n\n\tdataPtr = (Datum *) palloc(nitems * sizeof(Datum));\n\tnullsPtr = (bool *) palloc(nitems * sizeof(bool));\n\tReadArrayBinary(buf, nitems,\n\t\t\t\t\t&my_extra->proc, typioparam, typmod,\n\t\t\t\t\ttyplen, typbyval, typalign,\n\t\t\t\t\tdataPtr, nullsPtr,\n\t\t\t\t\t&hasnulls, &nbytes);\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tretval = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(retval, nbytes);\n\tretval->ndim = ndim;\n\tretval->dataoffset = dataoffset;\n\tretval->elemtype = element_type;\n\tmemcpy(ARR_DIMS(retval), dim, ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(retval), lBound, ndim * sizeof(int));\n\n\tCopyArrayEls(retval,\n\t\t\t\t dataPtr, nullsPtr, nitems,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t true);\n\n\tpfree(dataPtr);\n\tpfree(nullsPtr);\n\n\tPG_RETURN_ARRAYTYPE_P(retval);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tArrayCount(const char *str, int *dim, char typdelim);",
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "retval"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "nullsPtr"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CopyArrayEls",
          "args": [
            "retval",
            "dataPtr",
            "nullsPtr",
            "nitems",
            "typlen",
            "typbyval",
            "typalign",
            "true"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "CopyArrayEls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "956-1004",
          "snippet": "void\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nvoid\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(retval)",
            "lBound",
            "ndim * sizeof(int)"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "retval"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(retval)",
            "dim",
            "ndim * sizeof(int)"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "retval"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "retval",
            "nbytes"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nbytes"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndim"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndim",
            "nitems"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadArrayBinary",
          "args": [
            "buf",
            "nitems",
            "&my_extra->proc",
            "typioparam",
            "typmod",
            "typlen",
            "typbyval",
            "typalign",
            "dataPtr",
            "nullsPtr",
            "&hasnulls",
            "&nbytes"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "ReadArrayBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "1441-1538",
          "snippet": "static void\nReadArrayBinary(StringInfo buf,\n\t\t\t\tint nitems,\n\t\t\t\tFmgrInfo *receiveproc,\n\t\t\t\tOid typioparam,\n\t\t\t\tint32 typmod,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tDatum *values,\n\t\t\t\tbool *nulls,\n\t\t\t\tbool *hasnulls,\n\t\t\t\tint32 *nbytes)\n{\n\tint\t\t\ti;\n\tbool\t\thasnull;\n\tint32\t\ttotbytes;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tint\t\t\titemlen;\n\t\tStringInfoData elem_buf;\n\t\tchar\t\tcsave;\n\n\t\t/* Get and check the item length */\n\t\titemlen = pq_getmsgint(buf, 4);\n\t\tif (itemlen < -1 || itemlen > (buf->len - buf->cursor))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"insufficient data left in message\")));\n\n\t\tif (itemlen == -1)\n\t\t{\n\t\t\t/* -1 length means NULL */\n\t\t\tvalues[i] = ReceiveFunctionCall(receiveproc, NULL,\n\t\t\t\t\t\t\t\t\t\t\ttypioparam, typmod);\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Rather than copying data around, we just set up a phony StringInfo\n\t\t * pointing to the correct portion of the input buffer. We assume we\n\t\t * can scribble on the input buffer so as to maintain the convention\n\t\t * that StringInfos have a trailing null.\n\t\t */\n\t\telem_buf.data = &buf->data[buf->cursor];\n\t\telem_buf.maxlen = itemlen + 1;\n\t\telem_buf.len = itemlen;\n\t\telem_buf.cursor = 0;\n\n\t\tbuf->cursor += itemlen;\n\n\t\tcsave = buf->data[buf->cursor];\n\t\tbuf->data[buf->cursor] = '\\0';\n\n\t\t/* Now call the element's receiveproc */\n\t\tvalues[i] = ReceiveFunctionCall(receiveproc, &elem_buf,\n\t\t\t\t\t\t\t\t\t\ttypioparam, typmod);\n\t\tnulls[i] = false;\n\n\t\t/* Trouble if it didn't eat the whole buffer */\n\t\tif (elem_buf.cursor != itemlen)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper binary format in array element %d\",\n\t\t\t\t\t\t\ti + 1)));\n\n\t\tbuf->data[buf->cursor] = csave;\n\t}\n\n\t/*\n\t * Check for nulls, compute total data space needed\n\t */\n\thasnull = false;\n\ttotbytes = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls[i])\n\t\t\thasnull = true;\n\t\telse\n\t\t{\n\t\t\t/* let's just make sure data is not toasted */\n\t\t\tif (typlen == -1)\n\t\t\t\tvalues[i] = PointerGetDatum(PG_DETOAST_DATUM(values[i]));\n\t\t\ttotbytes = att_addlength_datum(totbytes, typlen, values[i]);\n\t\t\ttotbytes = att_align_nominal(totbytes, typalign);\n\t\t\t/* check for overflow of total request */\n\t\t\tif (!AllocSizeIsValid(totbytes))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t}\n\t}\n\t*hasnulls = hasnull;\n\t*nbytes = totbytes;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static Datum ArrayCast(char *value, bool byval, int len);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic Datum ArrayCast(char *value, bool byval, int len);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic void\nReadArrayBinary(StringInfo buf,\n\t\t\t\tint nitems,\n\t\t\t\tFmgrInfo *receiveproc,\n\t\t\t\tOid typioparam,\n\t\t\t\tint32 typmod,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tDatum *values,\n\t\t\t\tbool *nulls,\n\t\t\t\tbool *hasnulls,\n\t\t\t\tint32 *nbytes)\n{\n\tint\t\t\ti;\n\tbool\t\thasnull;\n\tint32\t\ttotbytes;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tint\t\t\titemlen;\n\t\tStringInfoData elem_buf;\n\t\tchar\t\tcsave;\n\n\t\t/* Get and check the item length */\n\t\titemlen = pq_getmsgint(buf, 4);\n\t\tif (itemlen < -1 || itemlen > (buf->len - buf->cursor))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"insufficient data left in message\")));\n\n\t\tif (itemlen == -1)\n\t\t{\n\t\t\t/* -1 length means NULL */\n\t\t\tvalues[i] = ReceiveFunctionCall(receiveproc, NULL,\n\t\t\t\t\t\t\t\t\t\t\ttypioparam, typmod);\n\t\t\tnulls[i] = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Rather than copying data around, we just set up a phony StringInfo\n\t\t * pointing to the correct portion of the input buffer. We assume we\n\t\t * can scribble on the input buffer so as to maintain the convention\n\t\t * that StringInfos have a trailing null.\n\t\t */\n\t\telem_buf.data = &buf->data[buf->cursor];\n\t\telem_buf.maxlen = itemlen + 1;\n\t\telem_buf.len = itemlen;\n\t\telem_buf.cursor = 0;\n\n\t\tbuf->cursor += itemlen;\n\n\t\tcsave = buf->data[buf->cursor];\n\t\tbuf->data[buf->cursor] = '\\0';\n\n\t\t/* Now call the element's receiveproc */\n\t\tvalues[i] = ReceiveFunctionCall(receiveproc, &elem_buf,\n\t\t\t\t\t\t\t\t\t\ttypioparam, typmod);\n\t\tnulls[i] = false;\n\n\t\t/* Trouble if it didn't eat the whole buffer */\n\t\tif (elem_buf.cursor != itemlen)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper binary format in array element %d\",\n\t\t\t\t\t\t\ti + 1)));\n\n\t\tbuf->data[buf->cursor] = csave;\n\t}\n\n\t/*\n\t * Check for nulls, compute total data space needed\n\t */\n\thasnull = false;\n\ttotbytes = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls[i])\n\t\t\thasnull = true;\n\t\telse\n\t\t{\n\t\t\t/* let's just make sure data is not toasted */\n\t\t\tif (typlen == -1)\n\t\t\t\tvalues[i] = PointerGetDatum(PG_DETOAST_DATUM(values[i]));\n\t\t\ttotbytes = att_addlength_datum(totbytes, typlen, values[i]);\n\t\t\ttotbytes = att_align_nominal(totbytes, typalign);\n\t\t\t/* check for overflow of total request */\n\t\t\tif (!AllocSizeIsValid(totbytes))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t}\n\t}\n\t*hasnulls = hasnull;\n\t*nbytes = totbytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nitems * sizeof(bool)"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "construct_empty_array(element_type)"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "element_type"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "my_extra->typiofunc",
            "&my_extra->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"no binary input function available for type %s\"",
            "format_type_be(element_type)"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "my_extra->typiofunc"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_type_io_data",
          "args": [
            "element_type",
            "IOFunc_receive",
            "&my_extra->typlen",
            "&my_extra->typbyval",
            "&my_extra->typalign",
            "&my_extra->typdelim",
            "&my_extra->typioparam",
            "&my_extra->typiofunc"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "get_type_io_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2102-2173",
          "snippet": "void\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(ArrayMetaState)"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "dim"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "4"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "4"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"wrong element type\"))"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(Oid)"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid array flags\"))"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "4"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndim, MAXDIM))"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndim))"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "4"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tArrayCount(const char *str, int *dim, char typdelim);\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tOid\t\t\tspec_element_type = PG_GETARG_OID(1);\t/* type of an array\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t * element */\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\t/* typmod for array elements */\n\tOid\t\t\telement_type;\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tOid\t\t\ttypioparam;\n\tint\t\t\ti,\n\t\t\t\tnitems;\n\tDatum\t   *dataPtr;\n\tbool\t   *nullsPtr;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tArrayType  *retval;\n\tint\t\t\tndim,\n\t\t\t\tflags,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlBound[MAXDIM];\n\tArrayMetaState *my_extra;\n\n\t/* Get the array header information */\n\tndim = pq_getmsgint(buf, 4);\n\tif (ndim < 0)\t\t\t\t/* we do allow zero-dimension arrays */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid number of dimensions: %d\", ndim)));\n\tif (ndim > MAXDIM)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tndim, MAXDIM)));\n\n\tflags = pq_getmsgint(buf, 4);\n\tif (flags != 0 && flags != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid array flags\")));\n\n\telement_type = pq_getmsgint(buf, sizeof(Oid));\n\tif (element_type != spec_element_type)\n\t{\n\t\t/* XXX Can we allow taking the input element type in any cases? */\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"wrong element type\")));\n\t}\n\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tdim[i] = pq_getmsgint(buf, 4);\n\t\tlBound[i] = pq_getmsgint(buf, 4);\n\n\t\t/*\n\t\t * Check overflow of upper bound. (ArrayNItems() below checks that\n\t\t * dim[i] >= 0)\n\t\t */\n\t\tif (dim[i] != 0)\n\t\t{\n\t\t\tint\t\t\tub = lBound[i] + dim[i] - 1;\n\n\t\t\tif (lBound[i] > ub)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"integer out of range\")));\n\t\t}\n\t}\n\n\t/* This checks for overflow of array dimensions */\n\tnitems = ArrayGetNItems(ndim, dim);\n\n\t/*\n\t * We arrange to look up info about element type, including its receive\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/* Get info about element type, including its receive proc */\n\t\tget_type_io_data(element_type, IOFunc_receive,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tif (!OidIsValid(my_extra->typiofunc))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\n\tif (nitems == 0)\n\t{\n\t\t/* Return empty array ... but not till we've validated element_type */\n\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(element_type));\n\t}\n\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\ttypioparam = my_extra->typioparam;\n\n\tdataPtr = (Datum *) palloc(nitems * sizeof(Datum));\n\tnullsPtr = (bool *) palloc(nitems * sizeof(bool));\n\tReadArrayBinary(buf, nitems,\n\t\t\t\t\t&my_extra->proc, typioparam, typmod,\n\t\t\t\t\ttyplen, typbyval, typalign,\n\t\t\t\t\tdataPtr, nullsPtr,\n\t\t\t\t\t&hasnulls, &nbytes);\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tretval = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(retval, nbytes);\n\tretval->ndim = ndim;\n\tretval->dataoffset = dataoffset;\n\tretval->elemtype = element_type;\n\tmemcpy(ARR_DIMS(retval), dim, ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(retval), lBound, ndim * sizeof(int));\n\n\tCopyArrayEls(retval,\n\t\t\t\t dataPtr, nullsPtr, nitems,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t true);\n\n\tpfree(dataPtr);\n\tpfree(nullsPtr);\n\n\tPG_RETURN_ARRAYTYPE_P(retval);\n}"
  },
  {
    "function_name": "array_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "1011-1256",
    "snippet": "Datum\narray_out(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(v);\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypdelim;\n\tchar\t   *p,\n\t\t\t   *tmp,\n\t\t\t   *retval,\n\t\t\t  **values,\n\t\t\t\tdims_str[(MAXDIM * 33) + 2];\n\n\t/*\n\t * 33 per dim since we assume 15 digits per number + ':' +'[]'\n\t *\n\t * +2 allows for assignment operator + trailing null\n\t */\n\tbool\t   *needquotes,\n\t\t\t\tneeddims = false;\n\tsize_t\t\toverall_length;\n\tint\t\t\tnitems,\n\t\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tk,\n\t\t\t\tindx[MAXDIM];\n\tint\t\t\tndim,\n\t\t\t   *dims,\n\t\t\t   *lb;\n\tarray_iter\titer;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * We arrange to look up info about element type, including its output\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its output conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_output,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\ttypdelim = my_extra->typdelim;\n\n\tndim = AARR_NDIM(v);\n\tdims = AARR_DIMS(v);\n\tlb = AARR_LBOUND(v);\n\tnitems = ArrayGetNItems(ndim, dims);\n\n\tif (nitems == 0)\n\t{\n\t\tretval = pstrdup(\"{}\");\n\t\tPG_RETURN_CSTRING(retval);\n\t}\n\n\t/*\n\t * we will need to add explicit dimensions if any dimension has a lower\n\t * bound other than one\n\t */\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (lb[i] != 1)\n\t\t{\n\t\t\tneeddims = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Convert all values to string form, count total space needed (including\n\t * any overhead such as escaping backslashes), and detect whether each\n\t * item needs double quotes.\n\t */\n\tvalues = (char **) palloc(nitems * sizeof(char *));\n\tneedquotes = (bool *) palloc(nitems * sizeof(bool));\n\toverall_length = 0;\n\n\tarray_iter_setup(&iter, v);\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tbool\t\tisnull;\n\t\tbool\t\tneedquote;\n\n\t\t/* Get source element, checking for NULL */\n\t\titemvalue = array_iter_next(&iter, &isnull, i,\n\t\t\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\n\t\tif (isnull)\n\t\t{\n\t\t\tvalues[i] = pstrdup(\"NULL\");\n\t\t\toverall_length += 4;\n\t\t\tneedquote = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalues[i] = OutputFunctionCall(&my_extra->proc, itemvalue);\n\n\t\t\t/* count data plus backslashes; detect chars needing quotes */\n\t\t\tif (values[i][0] == '\\0')\n\t\t\t\tneedquote = true;\t/* force quotes for empty string */\n\t\t\telse if (pg_strcasecmp(values[i], \"NULL\") == 0)\n\t\t\t\tneedquote = true;\t/* force quotes for literal NULL */\n\t\t\telse\n\t\t\t\tneedquote = false;\n\n\t\t\tfor (tmp = values[i]; *tmp != '\\0'; tmp++)\n\t\t\t{\n\t\t\t\tchar\t\tch = *tmp;\n\n\t\t\t\toverall_length += 1;\n\t\t\t\tif (ch == '\"' || ch == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tneedquote = true;\n\t\t\t\t\toverall_length += 1;\n\t\t\t\t}\n\t\t\t\telse if (ch == '{' || ch == '}' || ch == typdelim ||\n\t\t\t\t\t\t array_isspace(ch))\n\t\t\t\t\tneedquote = true;\n\t\t\t}\n\t\t}\n\n\t\tneedquotes[i] = needquote;\n\n\t\t/* Count the pair of double quotes, if needed */\n\t\tif (needquote)\n\t\t\toverall_length += 2;\n\t\t/* and the comma (or other typdelim delimiter) */\n\t\toverall_length += 1;\n\t}\n\n\t/*\n\t * The very last array element doesn't have a typdelim delimiter after it,\n\t * but that's OK; that space is needed for the trailing '\\0'.\n\t *\n\t * Now count total number of curly brace pairs in output string.\n\t */\n\tfor (i = j = 0, k = 1; i < ndim; i++)\n\t{\n\t\tj += k, k *= dims[i];\n\t}\n\toverall_length += 2 * j;\n\n\t/* Format explicit dimensions if required */\n\tdims_str[0] = '\\0';\n\tif (needdims)\n\t{\n\t\tchar\t   *ptr = dims_str;\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tsprintf(ptr, \"[%d:%d]\", lb[i], lb[i] + dims[i] - 1);\n\t\t\tptr += strlen(ptr);\n\t\t}\n\t\t*ptr++ = *ASSGN;\n\t\t*ptr = '\\0';\n\t\toverall_length += ptr - dims_str;\n\t}\n\n\t/* Now construct the output string */\n\tretval = (char *) palloc(overall_length);\n\tp = retval;\n\n#define APPENDSTR(str)\t(strcpy(p, (str)), p += strlen(p))\n#define APPENDCHAR(ch)\t(*p++ = (ch), *p = '\\0')\n\n\tif (needdims)\n\t\tAPPENDSTR(dims_str);\n\tAPPENDCHAR('{');\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tj = 0;\n\tk = 0;\n\tdo\n\t{\n\t\tfor (i = j; i < ndim - 1; i++)\n\t\t\tAPPENDCHAR('{');\n\n\t\tif (needquotes[k])\n\t\t{\n\t\t\tAPPENDCHAR('\"');\n\t\t\tfor (tmp = values[k]; *tmp; tmp++)\n\t\t\t{\n\t\t\t\tchar\t\tch = *tmp;\n\n\t\t\t\tif (ch == '\"' || ch == '\\\\')\n\t\t\t\t\t*p++ = '\\\\';\n\t\t\t\t*p++ = ch;\n\t\t\t}\n\t\t\t*p = '\\0';\n\t\t\tAPPENDCHAR('\"');\n\t\t}\n\t\telse\n\t\t\tAPPENDSTR(values[k]);\n\t\tpfree(values[k++]);\n\n\t\tfor (i = ndim - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (++(indx[i]) < dims[i])\n\t\t\t{\n\t\t\t\tAPPENDCHAR(typdelim);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tindx[i] = 0;\n\t\t\t\tAPPENDCHAR('}');\n\t\t\t}\n\t\t}\n\t\tj = i;\n\t} while (j != -1);\n\n#undef APPENDSTR\n#undef APPENDCHAR\n\n\t/* Assert that we calculated the string length accurately */\n\tAssert(overall_length == (p - retval + 1));\n\n\tpfree(values);\n\tpfree(needquotes);\n\n\tPG_RETURN_CSTRING(retval);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ASSGN\t \"=\""
    ],
    "globals_used": [
      "static bool array_isspace(char ch);",
      "static int\tArrayCount(const char *str, int *dim, char typdelim);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "retval"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "needquotes"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "overall_length == (p - retval + 1)"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPENDCHAR",
          "args": [
            "'}'"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPENDCHAR",
          "args": [
            "typdelim"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPENDSTR",
          "args": [
            "values[k]"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPENDCHAR",
          "args": [
            "'\"'"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPENDCHAR",
          "args": [
            "'\"'"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPENDCHAR",
          "args": [
            "'{'"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPENDCHAR",
          "args": [
            "'{'"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APPENDSTR",
          "args": [
            "dims_str"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "overall_length"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ptr",
            "\"[%d:%d]\"",
            "lb[i]",
            "lb[i] + dims[i] - 1"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_isspace",
          "args": [
            "ch"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "values[i]",
            "\"NULL\""
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputFunctionCall",
          "args": [
            "&my_extra->proc",
            "itemvalue"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "\"NULL\""
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_iter_next",
          "args": [
            "&iter",
            "&isnull",
            "i",
            "typlen",
            "typbyval",
            "typalign"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iter_setup",
          "args": [
            "&iter",
            "v"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "retval"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "dims"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_LBOUND",
          "args": [
            "v"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_DIMS",
          "args": [
            "v"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AARR_NDIM",
          "args": [
            "v"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "my_extra->typiofunc",
            "&my_extra->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_type_io_data",
          "args": [
            "element_type",
            "IOFunc_output",
            "&my_extra->typlen",
            "&my_extra->typbyval",
            "&my_extra->typalign",
            "&my_extra->typdelim",
            "&my_extra->typioparam",
            "&my_extra->typiofunc"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "get_type_io_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2102-2173",
          "snippet": "void\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(ArrayMetaState)"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AARR_ELEMTYPE",
          "args": [
            "v"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ANY_ARRAY_P",
          "args": [
            "0"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define ASSGN\t \"=\"\n\nstatic bool array_isspace(char ch);\nstatic int\tArrayCount(const char *str, int *dim, char typdelim);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_out(PG_FUNCTION_ARGS)\n{\n\tAnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0);\n\tOid\t\t\telement_type = AARR_ELEMTYPE(v);\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypdelim;\n\tchar\t   *p,\n\t\t\t   *tmp,\n\t\t\t   *retval,\n\t\t\t  **values,\n\t\t\t\tdims_str[(MAXDIM * 33) + 2];\n\n\t/*\n\t * 33 per dim since we assume 15 digits per number + ':' +'[]'\n\t *\n\t * +2 allows for assignment operator + trailing null\n\t */\n\tbool\t   *needquotes,\n\t\t\t\tneeddims = false;\n\tsize_t\t\toverall_length;\n\tint\t\t\tnitems,\n\t\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tk,\n\t\t\t\tindx[MAXDIM];\n\tint\t\t\tndim,\n\t\t\t   *dims,\n\t\t\t   *lb;\n\tarray_iter\titer;\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * We arrange to look up info about element type, including its output\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its output conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_output,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\ttypdelim = my_extra->typdelim;\n\n\tndim = AARR_NDIM(v);\n\tdims = AARR_DIMS(v);\n\tlb = AARR_LBOUND(v);\n\tnitems = ArrayGetNItems(ndim, dims);\n\n\tif (nitems == 0)\n\t{\n\t\tretval = pstrdup(\"{}\");\n\t\tPG_RETURN_CSTRING(retval);\n\t}\n\n\t/*\n\t * we will need to add explicit dimensions if any dimension has a lower\n\t * bound other than one\n\t */\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (lb[i] != 1)\n\t\t{\n\t\t\tneeddims = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Convert all values to string form, count total space needed (including\n\t * any overhead such as escaping backslashes), and detect whether each\n\t * item needs double quotes.\n\t */\n\tvalues = (char **) palloc(nitems * sizeof(char *));\n\tneedquotes = (bool *) palloc(nitems * sizeof(bool));\n\toverall_length = 0;\n\n\tarray_iter_setup(&iter, v);\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tDatum\t\titemvalue;\n\t\tbool\t\tisnull;\n\t\tbool\t\tneedquote;\n\n\t\t/* Get source element, checking for NULL */\n\t\titemvalue = array_iter_next(&iter, &isnull, i,\n\t\t\t\t\t\t\t\t\ttyplen, typbyval, typalign);\n\n\t\tif (isnull)\n\t\t{\n\t\t\tvalues[i] = pstrdup(\"NULL\");\n\t\t\toverall_length += 4;\n\t\t\tneedquote = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalues[i] = OutputFunctionCall(&my_extra->proc, itemvalue);\n\n\t\t\t/* count data plus backslashes; detect chars needing quotes */\n\t\t\tif (values[i][0] == '\\0')\n\t\t\t\tneedquote = true;\t/* force quotes for empty string */\n\t\t\telse if (pg_strcasecmp(values[i], \"NULL\") == 0)\n\t\t\t\tneedquote = true;\t/* force quotes for literal NULL */\n\t\t\telse\n\t\t\t\tneedquote = false;\n\n\t\t\tfor (tmp = values[i]; *tmp != '\\0'; tmp++)\n\t\t\t{\n\t\t\t\tchar\t\tch = *tmp;\n\n\t\t\t\toverall_length += 1;\n\t\t\t\tif (ch == '\"' || ch == '\\\\')\n\t\t\t\t{\n\t\t\t\t\tneedquote = true;\n\t\t\t\t\toverall_length += 1;\n\t\t\t\t}\n\t\t\t\telse if (ch == '{' || ch == '}' || ch == typdelim ||\n\t\t\t\t\t\t array_isspace(ch))\n\t\t\t\t\tneedquote = true;\n\t\t\t}\n\t\t}\n\n\t\tneedquotes[i] = needquote;\n\n\t\t/* Count the pair of double quotes, if needed */\n\t\tif (needquote)\n\t\t\toverall_length += 2;\n\t\t/* and the comma (or other typdelim delimiter) */\n\t\toverall_length += 1;\n\t}\n\n\t/*\n\t * The very last array element doesn't have a typdelim delimiter after it,\n\t * but that's OK; that space is needed for the trailing '\\0'.\n\t *\n\t * Now count total number of curly brace pairs in output string.\n\t */\n\tfor (i = j = 0, k = 1; i < ndim; i++)\n\t{\n\t\tj += k, k *= dims[i];\n\t}\n\toverall_length += 2 * j;\n\n\t/* Format explicit dimensions if required */\n\tdims_str[0] = '\\0';\n\tif (needdims)\n\t{\n\t\tchar\t   *ptr = dims_str;\n\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tsprintf(ptr, \"[%d:%d]\", lb[i], lb[i] + dims[i] - 1);\n\t\t\tptr += strlen(ptr);\n\t\t}\n\t\t*ptr++ = *ASSGN;\n\t\t*ptr = '\\0';\n\t\toverall_length += ptr - dims_str;\n\t}\n\n\t/* Now construct the output string */\n\tretval = (char *) palloc(overall_length);\n\tp = retval;\n\n#define APPENDSTR(str)\t(strcpy(p, (str)), p += strlen(p))\n#define APPENDCHAR(ch)\t(*p++ = (ch), *p = '\\0')\n\n\tif (needdims)\n\t\tAPPENDSTR(dims_str);\n\tAPPENDCHAR('{');\n\tfor (i = 0; i < ndim; i++)\n\t\tindx[i] = 0;\n\tj = 0;\n\tk = 0;\n\tdo\n\t{\n\t\tfor (i = j; i < ndim - 1; i++)\n\t\t\tAPPENDCHAR('{');\n\n\t\tif (needquotes[k])\n\t\t{\n\t\t\tAPPENDCHAR('\"');\n\t\t\tfor (tmp = values[k]; *tmp; tmp++)\n\t\t\t{\n\t\t\t\tchar\t\tch = *tmp;\n\n\t\t\t\tif (ch == '\"' || ch == '\\\\')\n\t\t\t\t\t*p++ = '\\\\';\n\t\t\t\t*p++ = ch;\n\t\t\t}\n\t\t\t*p = '\\0';\n\t\t\tAPPENDCHAR('\"');\n\t\t}\n\t\telse\n\t\t\tAPPENDSTR(values[k]);\n\t\tpfree(values[k++]);\n\n\t\tfor (i = ndim - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (++(indx[i]) < dims[i])\n\t\t\t{\n\t\t\t\tAPPENDCHAR(typdelim);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tindx[i] = 0;\n\t\t\t\tAPPENDCHAR('}');\n\t\t\t}\n\t\t}\n\t\tj = i;\n\t} while (j != -1);\n\n#undef APPENDSTR\n#undef APPENDCHAR\n\n\t/* Assert that we calculated the string length accurately */\n\tAssert(overall_length == (p - retval + 1));\n\n\tpfree(values);\n\tpfree(needquotes);\n\n\tPG_RETURN_CSTRING(retval);\n}"
  },
  {
    "function_name": "CopyArrayEls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "956-1004",
    "snippet": "void\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "DatumGetPointer(values[i])"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "values[i]"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayCastAndSet",
          "args": [
            "values[i]",
            "typlen",
            "typbyval",
            "typalign",
            "p"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayCastAndSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4548-4574",
          "snippet": "static int\nArrayCastAndSet(Datum src,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tchar *dest)\n{\n\tint\t\t\tinc;\n\n\tif (typlen > 0)\n\t{\n\t\tif (typbyval)\n\t\t\tstore_att_byval(dest, src, typlen);\n\t\telse\n\t\t\tmemmove(dest, DatumGetPointer(src), typlen);\n\t\tinc = att_align_nominal(typlen, typalign);\n\t}\n\telse\n\t{\n\t\tAssert(!typbyval);\n\t\tinc = att_addlength_datum(0, typlen, src);\n\t\tmemmove(dest, DatumGetPointer(src), inc);\n\t\tinc = att_align_nominal(inc, typalign);\n\t}\n\n\treturn inc;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int ArrayCastAndSet(Datum src,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tchar *dest);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int ArrayCastAndSet(Datum src,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tchar *dest);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic int\nArrayCastAndSet(Datum src,\n\t\t\t\tint typlen,\n\t\t\t\tbool typbyval,\n\t\t\t\tchar typalign,\n\t\t\t\tchar *dest)\n{\n\tint\t\t\tinc;\n\n\tif (typlen > 0)\n\t{\n\t\tif (typbyval)\n\t\t\tstore_att_byval(dest, src, typlen);\n\t\telse\n\t\t\tmemmove(dest, DatumGetPointer(src), typlen);\n\t\tinc = att_align_nominal(typlen, typalign);\n\t}\n\telse\n\t{\n\t\tAssert(!typbyval);\n\t\tinc = att_addlength_datum(0, typlen, src);\n\t\tmemmove(dest, DatumGetPointer(src), inc);\n\t\tinc = att_align_nominal(inc, typalign);\n\t}\n\n\treturn inc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"null array element where not supported\""
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "array"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "array"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nvoid\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}"
  },
  {
    "function_name": "ReadArrayStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "716-938",
    "snippet": "static void\nReadArrayStr(char *arrayStr,\n\t\t\t const char *origStr,\n\t\t\t int nitems,\n\t\t\t int ndim,\n\t\t\t int *dim,\n\t\t\t FmgrInfo *inputproc,\n\t\t\t Oid typioparam,\n\t\t\t int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t bool *hasnulls,\n\t\t\t int32 *nbytes)\n{\n\tint\t\t\ti,\n\t\t\t\tnest_level = 0;\n\tchar\t   *srcptr;\n\tbool\t\tin_quotes = false;\n\tbool\t\teoArray = false;\n\tbool\t\thasnull;\n\tint32\t\ttotbytes;\n\tint\t\t\tindx[MAXDIM],\n\t\t\t\tprod[MAXDIM];\n\n\tmda_get_prod(ndim, dim, prod);\n\tMemSet(indx, 0, sizeof(indx));\n\n\t/* Initialize is-null markers to true */\n\tmemset(nulls, true, nitems * sizeof(bool));\n\n\t/*\n\t * We have to remove \" and \\ characters to create a clean item value to\n\t * pass to the datatype input routine.  We overwrite each item value\n\t * in-place within arrayStr to do this.  srcptr is the current scan point,\n\t * and dstptr is where we are copying to.\n\t *\n\t * We also want to suppress leading and trailing unquoted whitespace. We\n\t * use the leadingspace flag to suppress leading space.  Trailing space is\n\t * tracked by using dstendptr to point to the last significant output\n\t * character.\n\t *\n\t * The error checking in this routine is mostly pro-forma, since we expect\n\t * that ArrayCount() already validated the string.  So we don't bother\n\t * with errdetail messages.\n\t */\n\tsrcptr = arrayStr;\n\twhile (!eoArray)\n\t{\n\t\tbool\t\titemdone = false;\n\t\tbool\t\tleadingspace = true;\n\t\tbool\t\thasquoting = false;\n\t\tchar\t   *itemstart;\n\t\tchar\t   *dstptr;\n\t\tchar\t   *dstendptr;\n\n\t\ti = -1;\n\t\titemstart = dstptr = dstendptr = srcptr;\n\n\t\twhile (!itemdone)\n\t\t{\n\t\t\tswitch (*srcptr)\n\t\t\t{\n\t\t\t\tcase '\\0':\n\t\t\t\t\t/* Signal a premature end of the string */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\t/* Skip backslash, copy next character as-is. */\n\t\t\t\t\tsrcptr++;\n\t\t\t\t\tif (*srcptr == '\\0')\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t/* Treat the escaped character as non-whitespace */\n\t\t\t\t\tleadingspace = false;\n\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\thasquoting = true;\t/* can't be a NULL marker */\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tin_quotes = !in_quotes;\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\tleadingspace = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Advance dstendptr when we exit in_quotes; this\n\t\t\t\t\t\t * saves having to do it in all the other in_quotes\n\t\t\t\t\t\t * cases.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\t}\n\t\t\t\t\thasquoting = true;\t/* can't be a NULL marker */\n\t\t\t\t\tsrcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '{':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nest_level >= ndim)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t\tnest_level++;\n\t\t\t\t\t\tindx[nest_level - 1] = 0;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t\tif (i == -1)\n\t\t\t\t\t\t\ti = ArrayGetOffset0(ndim, indx, prod);\n\t\t\t\t\t\tindx[nest_level - 1] = 0;\n\t\t\t\t\t\tnest_level--;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\teoArray = itemdone = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tindx[nest_level - 1]++;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\telse if (*srcptr == typdelim)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i == -1)\n\t\t\t\t\t\t\ti = ArrayGetOffset0(ndim, indx, prod);\n\t\t\t\t\t\titemdone = true;\n\t\t\t\t\t\tindx[ndim - 1]++;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (array_isspace(*srcptr))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If leading space, drop it immediately.  Else, copy\n\t\t\t\t\t\t * but don't advance dstendptr.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (leadingspace)\n\t\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t\tleadingspace = false;\n\t\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tAssert(dstptr < srcptr);\n\t\t*dstendptr = '\\0';\n\n\t\tif (i < 0 || i >= nitems)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\torigStr)));\n\n\t\tif (Array_nulls && !hasquoting &&\n\t\t\tpg_strcasecmp(itemstart, \"NULL\") == 0)\n\t\t{\n\t\t\t/* it's a NULL item */\n\t\t\tvalues[i] = InputFunctionCall(inputproc, NULL,\n\t\t\t\t\t\t\t\t\t\t  typioparam, typmod);\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalues[i] = InputFunctionCall(inputproc, itemstart,\n\t\t\t\t\t\t\t\t\t\t  typioparam, typmod);\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/*\n\t * Check for nulls, compute total data space needed\n\t */\n\thasnull = false;\n\ttotbytes = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls[i])\n\t\t\thasnull = true;\n\t\telse\n\t\t{\n\t\t\t/* let's just make sure data is not toasted */\n\t\t\tif (typlen == -1)\n\t\t\t\tvalues[i] = PointerGetDatum(PG_DETOAST_DATUM(values[i]));\n\t\t\ttotbytes = att_addlength_datum(totbytes, typlen, values[i]);\n\t\t\ttotbytes = att_align_nominal(totbytes, typalign);\n\t\t\t/* check for overflow of total request */\n\t\t\tif (!AllocSizeIsValid(totbytes))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t}\n\t}\n\t*hasnulls = hasnull;\n\t*nbytes = totbytes;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool\t\tArray_nulls = true;",
      "static int\tArrayCount(const char *str, int *dim, char typdelim);",
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize))"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"array size exceeds the maximum allowed (%d)\"",
            "(int) MaxAllocSize"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocSizeIsValid",
          "args": [
            "totbytes"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_align_nominal",
          "args": [
            "totbytes",
            "typalign"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "att_addlength_datum",
          "args": [
            "totbytes",
            "typlen",
            "values[i]"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "PG_DETOAST_DATUM(values[i])"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_DETOAST_DATUM",
          "args": [
            "values[i]"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InputFunctionCall",
          "args": [
            "inputproc",
            "itemstart",
            "typioparam",
            "typmod"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "OidInputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1823-1830",
          "snippet": "Datum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "itemstart",
            "\"NULL\""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\torigStr))"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "dstptr < srcptr"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_isspace",
          "args": [
            "*srcptr"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetOffset0",
          "args": [
            "ndim",
            "indx",
            "prod"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetOffset0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "49-58",
          "snippet": "int\nArrayGetOffset0(int n, const int *tup, const int *scale)\n{\n\tint\t\t\ti,\n\t\t\t\tlin = 0;\n\n\tfor (i = 0; i < n; i++)\n\t\tlin += tup[i] * scale[i];\n\treturn lin;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint\nArrayGetOffset0(int n, const int *tup, const int *scale)\n{\n\tint\t\t\ti,\n\t\t\t\tlin = 0;\n\n\tfor (i = 0; i < n; i++)\n\t\tlin += tup[i] * scale[i];\n\treturn lin;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\torigStr))"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\torigStr))"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\torigStr))"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\torigStr))"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nulls",
            "true",
            "nitems * sizeof(bool)"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "indx",
            "0",
            "sizeof(indx)"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mda_get_prod",
          "args": [
            "ndim",
            "dim",
            "prod"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "mda_get_prod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "133-141",
          "snippet": "void\nmda_get_prod(int n, const int *range, int *prod)\n{\n\tint\t\t\ti;\n\n\tprod[n - 1] = 1;\n\tfor (i = n - 2; i >= 0; i--)\n\t\tprod[i] = prod[i + 1] * range[i + 1];\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nvoid\nmda_get_prod(int n, const int *range, int *prod)\n{\n\tint\t\t\ti;\n\n\tprod[n - 1] = 1;\n\tfor (i = n - 2; i >= 0; i--)\n\t\tprod[i] = prod[i + 1] * range[i + 1];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\t\tArray_nulls = true;\nstatic int\tArrayCount(const char *str, int *dim, char typdelim);\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic void\nReadArrayStr(char *arrayStr,\n\t\t\t const char *origStr,\n\t\t\t int nitems,\n\t\t\t int ndim,\n\t\t\t int *dim,\n\t\t\t FmgrInfo *inputproc,\n\t\t\t Oid typioparam,\n\t\t\t int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t bool *hasnulls,\n\t\t\t int32 *nbytes)\n{\n\tint\t\t\ti,\n\t\t\t\tnest_level = 0;\n\tchar\t   *srcptr;\n\tbool\t\tin_quotes = false;\n\tbool\t\teoArray = false;\n\tbool\t\thasnull;\n\tint32\t\ttotbytes;\n\tint\t\t\tindx[MAXDIM],\n\t\t\t\tprod[MAXDIM];\n\n\tmda_get_prod(ndim, dim, prod);\n\tMemSet(indx, 0, sizeof(indx));\n\n\t/* Initialize is-null markers to true */\n\tmemset(nulls, true, nitems * sizeof(bool));\n\n\t/*\n\t * We have to remove \" and \\ characters to create a clean item value to\n\t * pass to the datatype input routine.  We overwrite each item value\n\t * in-place within arrayStr to do this.  srcptr is the current scan point,\n\t * and dstptr is where we are copying to.\n\t *\n\t * We also want to suppress leading and trailing unquoted whitespace. We\n\t * use the leadingspace flag to suppress leading space.  Trailing space is\n\t * tracked by using dstendptr to point to the last significant output\n\t * character.\n\t *\n\t * The error checking in this routine is mostly pro-forma, since we expect\n\t * that ArrayCount() already validated the string.  So we don't bother\n\t * with errdetail messages.\n\t */\n\tsrcptr = arrayStr;\n\twhile (!eoArray)\n\t{\n\t\tbool\t\titemdone = false;\n\t\tbool\t\tleadingspace = true;\n\t\tbool\t\thasquoting = false;\n\t\tchar\t   *itemstart;\n\t\tchar\t   *dstptr;\n\t\tchar\t   *dstendptr;\n\n\t\ti = -1;\n\t\titemstart = dstptr = dstendptr = srcptr;\n\n\t\twhile (!itemdone)\n\t\t{\n\t\t\tswitch (*srcptr)\n\t\t\t{\n\t\t\t\tcase '\\0':\n\t\t\t\t\t/* Signal a premature end of the string */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\t/* Skip backslash, copy next character as-is. */\n\t\t\t\t\tsrcptr++;\n\t\t\t\t\tif (*srcptr == '\\0')\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t/* Treat the escaped character as non-whitespace */\n\t\t\t\t\tleadingspace = false;\n\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\thasquoting = true;\t/* can't be a NULL marker */\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tin_quotes = !in_quotes;\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\tleadingspace = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Advance dstendptr when we exit in_quotes; this\n\t\t\t\t\t\t * saves having to do it in all the other in_quotes\n\t\t\t\t\t\t * cases.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\t}\n\t\t\t\t\thasquoting = true;\t/* can't be a NULL marker */\n\t\t\t\t\tsrcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '{':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nest_level >= ndim)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t\tnest_level++;\n\t\t\t\t\t\tindx[nest_level - 1] = 0;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t\tif (i == -1)\n\t\t\t\t\t\t\ti = ArrayGetOffset0(ndim, indx, prod);\n\t\t\t\t\t\tindx[nest_level - 1] = 0;\n\t\t\t\t\t\tnest_level--;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\teoArray = itemdone = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tindx[nest_level - 1]++;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\telse if (*srcptr == typdelim)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i == -1)\n\t\t\t\t\t\t\ti = ArrayGetOffset0(ndim, indx, prod);\n\t\t\t\t\t\titemdone = true;\n\t\t\t\t\t\tindx[ndim - 1]++;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (array_isspace(*srcptr))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If leading space, drop it immediately.  Else, copy\n\t\t\t\t\t\t * but don't advance dstendptr.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (leadingspace)\n\t\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t\tleadingspace = false;\n\t\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tAssert(dstptr < srcptr);\n\t\t*dstendptr = '\\0';\n\n\t\tif (i < 0 || i >= nitems)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\torigStr)));\n\n\t\tif (Array_nulls && !hasquoting &&\n\t\t\tpg_strcasecmp(itemstart, \"NULL\") == 0)\n\t\t{\n\t\t\t/* it's a NULL item */\n\t\t\tvalues[i] = InputFunctionCall(inputproc, NULL,\n\t\t\t\t\t\t\t\t\t\t  typioparam, typmod);\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalues[i] = InputFunctionCall(inputproc, itemstart,\n\t\t\t\t\t\t\t\t\t\t  typioparam, typmod);\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/*\n\t * Check for nulls, compute total data space needed\n\t */\n\thasnull = false;\n\ttotbytes = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls[i])\n\t\t\thasnull = true;\n\t\telse\n\t\t{\n\t\t\t/* let's just make sure data is not toasted */\n\t\t\tif (typlen == -1)\n\t\t\t\tvalues[i] = PointerGetDatum(PG_DETOAST_DATUM(values[i]));\n\t\t\ttotbytes = att_addlength_datum(totbytes, typlen, values[i]);\n\t\t\ttotbytes = att_align_nominal(totbytes, typalign);\n\t\t\t/* check for overflow of total request */\n\t\t\tif (!AllocSizeIsValid(totbytes))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t}\n\t}\n\t*hasnulls = hasnull;\n\t*nbytes = totbytes;\n}"
  },
  {
    "function_name": "ArrayCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "451-686",
    "snippet": "static int\nArrayCount(const char *str, int *dim, char typdelim)\n{\n\tint\t\t\tnest_level = 0,\n\t\t\t\ti;\n\tint\t\t\tndim = 1,\n\t\t\t\ttemp[MAXDIM],\n\t\t\t\tnelems[MAXDIM],\n\t\t\t\tnelems_last[MAXDIM];\n\tbool\t\tin_quotes = false;\n\tbool\t\teoArray = false;\n\tbool\t\tempty_array = true;\n\tconst char *ptr;\n\tArrayParseState parse_state = ARRAY_NO_LEVEL;\n\n\tfor (i = 0; i < MAXDIM; ++i)\n\t{\n\t\ttemp[i] = dim[i] = nelems_last[i] = 0;\n\t\tnelems[i] = 1;\n\t}\n\n\tptr = str;\n\twhile (!eoArray)\n\t{\n\t\tbool\t\titemdone = false;\n\n\t\twhile (!itemdone)\n\t\t{\n\t\t\tif (parse_state == ARRAY_ELEM_STARTED ||\n\t\t\t\tparse_state == ARRAY_QUOTED_ELEM_STARTED)\n\t\t\t\tempty_array = false;\n\n\t\t\tswitch (*ptr)\n\t\t\t{\n\t\t\t\tcase '\\0':\n\t\t\t\t\t/* Signal a premature end of the string */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\n\t\t\t\t\t/*\n\t\t\t\t\t * An escape must be after a level start, after an element\n\t\t\t\t\t * start, or after an element delimiter. In any case we\n\t\t\t\t\t * now must be past an element start.\n\t\t\t\t\t */\n\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t   '\\\\')));\n\t\t\t\t\tif (parse_state != ARRAY_QUOTED_ELEM_STARTED)\n\t\t\t\t\t\tparse_state = ARRAY_ELEM_STARTED;\n\t\t\t\t\t/* skip the escaped character */\n\t\t\t\t\tif (*(ptr + 1))\n\t\t\t\t\t\tptr++;\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\n\t\t\t\t\t/*\n\t\t\t\t\t * A quote must be after a level start, after a quoted\n\t\t\t\t\t * element start, or after an element delimiter. In any\n\t\t\t\t\t * case we now must be past an element start.\n\t\t\t\t\t */\n\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected array element.\")));\n\t\t\t\t\tin_quotes = !in_quotes;\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\tparse_state = ARRAY_QUOTED_ELEM_STARTED;\n\t\t\t\t\telse\n\t\t\t\t\t\tparse_state = ARRAY_QUOTED_ELEM_COMPLETED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '{':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A left brace can occur if no nesting has occurred\n\t\t\t\t\t\t * yet, after a level start, or after a level\n\t\t\t\t\t\t * delimiter.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (parse_state != ARRAY_NO_LEVEL &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_DELIMITED)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t   '{')));\n\t\t\t\t\t\tparse_state = ARRAY_LEVEL_STARTED;\n\t\t\t\t\t\tif (nest_level >= MAXDIM)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t\t\tnest_level + 1, MAXDIM)));\n\t\t\t\t\t\ttemp[nest_level] = 0;\n\t\t\t\t\t\tnest_level++;\n\t\t\t\t\t\tif (ndim < nest_level)\n\t\t\t\t\t\t\tndim = nest_level;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A right brace can occur after an element start, an\n\t\t\t\t\t\t * element completion, a quoted element completion, or\n\t\t\t\t\t\t * a level completion.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (parse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_COMPLETED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_COMPLETED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_COMPLETED &&\n\t\t\t\t\t\t\t!(nest_level == 1 && parse_state == ARRAY_LEVEL_STARTED))\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t   '}')));\n\t\t\t\t\t\tparse_state = ARRAY_LEVEL_COMPLETED;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unmatched \\\"%c\\\" character.\", '}')));\n\t\t\t\t\t\tnest_level--;\n\n\t\t\t\t\t\tif (nelems_last[nest_level] != 0 &&\n\t\t\t\t\t\t\tnelems[nest_level] != nelems_last[nest_level])\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t\t\t\t\t\t   \"sub-arrays with matching \"\n\t\t\t\t\t\t\t\t\t\t\t   \"dimensions.\")));\n\t\t\t\t\t\tnelems_last[nest_level] = nelems[nest_level];\n\t\t\t\t\t\tnelems[nest_level] = 1;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\teoArray = itemdone = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We don't set itemdone here; see comments in\n\t\t\t\t\t\t\t * ReadArrayStr\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\ttemp[nest_level - 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*ptr == typdelim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Delimiters can occur after an element start, an\n\t\t\t\t\t\t\t * element completion, a quoted element\n\t\t\t\t\t\t\t * completion, or a level completion.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (parse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_COMPLETED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_COMPLETED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_COMPLETED)\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t\t   typdelim)));\n\t\t\t\t\t\t\tif (parse_state == ARRAY_LEVEL_COMPLETED)\n\t\t\t\t\t\t\t\tparse_state = ARRAY_LEVEL_DELIMITED;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tparse_state = ARRAY_ELEM_DELIMITED;\n\t\t\t\t\t\t\titemdone = true;\n\t\t\t\t\t\t\tnelems[nest_level - 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!array_isspace(*ptr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Other non-space characters must be after a\n\t\t\t\t\t\t\t * level start, after an element start, or after\n\t\t\t\t\t\t\t * an element delimiter. In any case we now must\n\t\t\t\t\t\t\t * be past an element start.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected array element.\")));\n\t\t\t\t\t\t\tparse_state = ARRAY_ELEM_STARTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!itemdone)\n\t\t\t\tptr++;\n\t\t}\n\t\ttemp[ndim - 1]++;\n\t\tptr++;\n\t}\n\n\t/* only whitespace is allowed after the closing brace */\n\twhile (*ptr)\n\t{\n\t\tif (!array_isspace(*ptr++))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t errdetail(\"Junk after closing right brace.\")));\n\t}\n\n\t/* special case for an empty array */\n\tif (empty_array)\n\t\treturn 0;\n\n\tfor (i = 0; i < ndim; ++i)\n\t\tdim[i] = temp[i];\n\n\treturn ndim;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tArrayCount(const char *str, int *dim, char typdelim);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t errdetail(\"Junk after closing right brace.\"))"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Junk after closing right brace.\""
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"malformed array literal: \\\"%s\\\"\"",
            "str"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_isspace",
          "args": [
            "*ptr++"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected array element.\"))"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t\t   typdelim))"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t\t\t\t\t\t   \"sub-arrays with matching \"\n\t\t\t\t\t\t\t\t\t\t\t   \"dimensions.\"))"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unmatched \\\"%c\\\" character.\", '}'))"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t   '}'))"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t\t\tnest_level + 1, MAXDIM))"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t   '{'))"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected array element.\"))"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\"))"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t   '\\\\'))"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\"))"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tArrayCount(const char *str, int *dim, char typdelim);\n\nstatic int\nArrayCount(const char *str, int *dim, char typdelim)\n{\n\tint\t\t\tnest_level = 0,\n\t\t\t\ti;\n\tint\t\t\tndim = 1,\n\t\t\t\ttemp[MAXDIM],\n\t\t\t\tnelems[MAXDIM],\n\t\t\t\tnelems_last[MAXDIM];\n\tbool\t\tin_quotes = false;\n\tbool\t\teoArray = false;\n\tbool\t\tempty_array = true;\n\tconst char *ptr;\n\tArrayParseState parse_state = ARRAY_NO_LEVEL;\n\n\tfor (i = 0; i < MAXDIM; ++i)\n\t{\n\t\ttemp[i] = dim[i] = nelems_last[i] = 0;\n\t\tnelems[i] = 1;\n\t}\n\n\tptr = str;\n\twhile (!eoArray)\n\t{\n\t\tbool\t\titemdone = false;\n\n\t\twhile (!itemdone)\n\t\t{\n\t\t\tif (parse_state == ARRAY_ELEM_STARTED ||\n\t\t\t\tparse_state == ARRAY_QUOTED_ELEM_STARTED)\n\t\t\t\tempty_array = false;\n\n\t\t\tswitch (*ptr)\n\t\t\t{\n\t\t\t\tcase '\\0':\n\t\t\t\t\t/* Signal a premature end of the string */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\n\t\t\t\t\t/*\n\t\t\t\t\t * An escape must be after a level start, after an element\n\t\t\t\t\t * start, or after an element delimiter. In any case we\n\t\t\t\t\t * now must be past an element start.\n\t\t\t\t\t */\n\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t   '\\\\')));\n\t\t\t\t\tif (parse_state != ARRAY_QUOTED_ELEM_STARTED)\n\t\t\t\t\t\tparse_state = ARRAY_ELEM_STARTED;\n\t\t\t\t\t/* skip the escaped character */\n\t\t\t\t\tif (*(ptr + 1))\n\t\t\t\t\t\tptr++;\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\n\t\t\t\t\t/*\n\t\t\t\t\t * A quote must be after a level start, after a quoted\n\t\t\t\t\t * element start, or after an element delimiter. In any\n\t\t\t\t\t * case we now must be past an element start.\n\t\t\t\t\t */\n\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected array element.\")));\n\t\t\t\t\tin_quotes = !in_quotes;\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\tparse_state = ARRAY_QUOTED_ELEM_STARTED;\n\t\t\t\t\telse\n\t\t\t\t\t\tparse_state = ARRAY_QUOTED_ELEM_COMPLETED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '{':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A left brace can occur if no nesting has occurred\n\t\t\t\t\t\t * yet, after a level start, or after a level\n\t\t\t\t\t\t * delimiter.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (parse_state != ARRAY_NO_LEVEL &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_DELIMITED)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t   '{')));\n\t\t\t\t\t\tparse_state = ARRAY_LEVEL_STARTED;\n\t\t\t\t\t\tif (nest_level >= MAXDIM)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t\t\tnest_level + 1, MAXDIM)));\n\t\t\t\t\t\ttemp[nest_level] = 0;\n\t\t\t\t\t\tnest_level++;\n\t\t\t\t\t\tif (ndim < nest_level)\n\t\t\t\t\t\t\tndim = nest_level;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A right brace can occur after an element start, an\n\t\t\t\t\t\t * element completion, a quoted element completion, or\n\t\t\t\t\t\t * a level completion.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (parse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_COMPLETED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_COMPLETED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_COMPLETED &&\n\t\t\t\t\t\t\t!(nest_level == 1 && parse_state == ARRAY_LEVEL_STARTED))\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t   '}')));\n\t\t\t\t\t\tparse_state = ARRAY_LEVEL_COMPLETED;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unmatched \\\"%c\\\" character.\", '}')));\n\t\t\t\t\t\tnest_level--;\n\n\t\t\t\t\t\tif (nelems_last[nest_level] != 0 &&\n\t\t\t\t\t\t\tnelems[nest_level] != nelems_last[nest_level])\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t\t\t\t\t\t   \"sub-arrays with matching \"\n\t\t\t\t\t\t\t\t\t\t\t   \"dimensions.\")));\n\t\t\t\t\t\tnelems_last[nest_level] = nelems[nest_level];\n\t\t\t\t\t\tnelems[nest_level] = 1;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\teoArray = itemdone = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We don't set itemdone here; see comments in\n\t\t\t\t\t\t\t * ReadArrayStr\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\ttemp[nest_level - 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*ptr == typdelim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Delimiters can occur after an element start, an\n\t\t\t\t\t\t\t * element completion, a quoted element\n\t\t\t\t\t\t\t * completion, or a level completion.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (parse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_COMPLETED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_COMPLETED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_COMPLETED)\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t\t   typdelim)));\n\t\t\t\t\t\t\tif (parse_state == ARRAY_LEVEL_COMPLETED)\n\t\t\t\t\t\t\t\tparse_state = ARRAY_LEVEL_DELIMITED;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tparse_state = ARRAY_ELEM_DELIMITED;\n\t\t\t\t\t\t\titemdone = true;\n\t\t\t\t\t\t\tnelems[nest_level - 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!array_isspace(*ptr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Other non-space characters must be after a\n\t\t\t\t\t\t\t * level start, after an element start, or after\n\t\t\t\t\t\t\t * an element delimiter. In any case we now must\n\t\t\t\t\t\t\t * be past an element start.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected array element.\")));\n\t\t\t\t\t\t\tparse_state = ARRAY_ELEM_STARTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!itemdone)\n\t\t\t\tptr++;\n\t\t}\n\t\ttemp[ndim - 1]++;\n\t\tptr++;\n\t}\n\n\t/* only whitespace is allowed after the closing brace */\n\twhile (*ptr)\n\t{\n\t\tif (!array_isspace(*ptr++))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t errdetail(\"Junk after closing right brace.\")));\n\t}\n\n\t/* special case for an empty array */\n\tif (empty_array)\n\t\treturn 0;\n\n\tfor (i = 0; i < ndim; ++i)\n\t\tdim[i] = temp[i];\n\n\treturn ndim;\n}"
  },
  {
    "function_name": "array_isspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "431-442",
    "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool array_isspace(char ch);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "array_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
    "lines": "171-421",
    "snippet": "Datum\narray_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *string = PG_GETARG_CSTRING(0);\t/* external form */\n\tOid\t\t\telement_type = PG_GETARG_OID(1);\t/* type of an array\n\t\t\t\t\t\t\t\t\t\t\t\t\t * element */\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\t/* typmod for array elements */\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypdelim;\n\tOid\t\t\ttypioparam;\n\tchar\t   *string_save,\n\t\t\t   *p;\n\tint\t\t\ti,\n\t\t\t\tnitems;\n\tDatum\t   *dataPtr;\n\tbool\t   *nullsPtr;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tArrayType  *retval;\n\tint\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlBound[MAXDIM];\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * We arrange to look up info about element type, including its input\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its input conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_input,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\ttypdelim = my_extra->typdelim;\n\ttypioparam = my_extra->typioparam;\n\n\t/* Make a modifiable copy of the input */\n\tstring_save = pstrdup(string);\n\n\t/*\n\t * If the input string starts with dimension info, read and use that.\n\t * Otherwise, we require the input to be in curly-brace style, and we\n\t * prescan the input to determine dimensions.\n\t *\n\t * Dimension info takes the form of one or more [n] or [m:n] items. The\n\t * outer loop iterates once per dimension item.\n\t */\n\tp = string_save;\n\tndim = 0;\n\tfor (;;)\n\t{\n\t\tchar\t   *q;\n\t\tint\t\t\tub;\n\n\t\t/*\n\t\t * Note: we currently allow whitespace between, but not within,\n\t\t * dimension items.\n\t\t */\n\t\twhile (array_isspace(*p))\n\t\t\tp++;\n\t\tif (*p != '[')\n\t\t\tbreak;\t\t\t\t/* no more dimension items */\n\t\tp++;\n\t\tif (ndim >= MAXDIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tndim + 1, MAXDIM)));\n\n\t\tfor (q = p; isdigit((unsigned char) *q) || (*q == '-') || (*q == '+'); q++)\n\t\t\t /* skip */ ;\n\t\tif (q == p)\t\t\t\t/* no digits? */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"\\\"[\\\" must introduce explicitly-specified array dimensions.\")));\n\n\t\tif (*q == ':')\n\t\t{\n\t\t\t/* [m:n] format */\n\t\t\t*q = '\\0';\n\t\t\tlBound[ndim] = atoi(p);\n\t\t\tp = q + 1;\n\t\t\tfor (q = p; isdigit((unsigned char) *q) || (*q == '-') || (*q == '+'); q++)\n\t\t\t\t /* skip */ ;\n\t\t\tif (q == p)\t\t\t/* no digits? */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t\t errdetail(\"Missing array dimension value.\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* [n] format */\n\t\t\tlBound[ndim] = 1;\n\t\t}\n\t\tif (*q != ']')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Missing \\\"%s\\\" after array dimensions.\",\n\t\t\t\t\t\t\t   \"]\")));\n\n\t\t*q = '\\0';\n\t\tub = atoi(p);\n\t\tp = q + 1;\n\t\tif (ub < lBound[ndim])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\")));\n\n\t\tdim[ndim] = ub - lBound[ndim] + 1;\n\t\tndim++;\n\t}\n\n\tif (ndim == 0)\n\t{\n\t\t/* No array dimensions, so intuit dimensions from brace structure */\n\t\tif (*p != '{')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Array value must start with \\\"{\\\" or dimension information.\")));\n\t\tndim = ArrayCount(p, dim, typdelim);\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tlBound[i] = 1;\n\t}\n\telse\n\t{\n\t\tint\t\t\tndim_braces,\n\t\t\t\t\tdim_braces[MAXDIM];\n\n\t\t/* If array dimensions are given, expect '=' operator */\n\t\tif (strncmp(p, ASSGN, strlen(ASSGN)) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Missing \\\"%s\\\" after array dimensions.\",\n\t\t\t\t\t\t\t   ASSGN)));\n\t\tp += strlen(ASSGN);\n\t\twhile (array_isspace(*p))\n\t\t\tp++;\n\n\t\t/*\n\t\t * intuit dimensions from brace structure -- it better match what we\n\t\t * were given\n\t\t */\n\t\tif (*p != '{')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Array contents must start with \\\"{\\\".\")));\n\t\tndim_braces = ArrayCount(p, dim_braces, typdelim);\n\t\tif (ndim_braces != ndim)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Specified array dimensions do not match array contents.\")));\n\t\tfor (i = 0; i < ndim; ++i)\n\t\t{\n\t\t\tif (dim[i] != dim_braces[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t\t errdetail(\"Specified array dimensions do not match array contents.\")));\n\t\t}\n\t}\n\n#ifdef ARRAYDEBUG\n\tprintf(\"array_in- ndim %d (\", ndim);\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tprintf(\" %d\", dim[i]);\n\t};\n\tprintf(\") for %s\\n\", string);\n#endif\n\n\t/* This checks for overflow of the array dimensions */\n\tnitems = ArrayGetNItems(ndim, dim);\n\t/* Empty array? */\n\tif (nitems == 0)\n\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(element_type));\n\n\tdataPtr = (Datum *) palloc(nitems * sizeof(Datum));\n\tnullsPtr = (bool *) palloc(nitems * sizeof(bool));\n\tReadArrayStr(p, string,\n\t\t\t\t nitems, ndim, dim,\n\t\t\t\t &my_extra->proc, typioparam, typmod,\n\t\t\t\t typdelim,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t dataPtr, nullsPtr,\n\t\t\t\t &hasnulls, &nbytes);\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tretval = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(retval, nbytes);\n\tretval->ndim = ndim;\n\tretval->dataoffset = dataoffset;\n\n\t/*\n\t * This comes from the array's pg_type.typelem (which points to the base\n\t * data type's pg_type.oid) and stores system oids in user tables. This\n\t * oid must be preserved by binary upgrades.\n\t */\n\tretval->elemtype = element_type;\n\tmemcpy(ARR_DIMS(retval), dim, ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(retval), lBound, ndim * sizeof(int));\n\n\tCopyArrayEls(retval,\n\t\t\t\t dataPtr, nullsPtr, nitems,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t true);\n\n\tpfree(dataPtr);\n\tpfree(nullsPtr);\n\tpfree(string_save);\n\n\tPG_RETURN_ARRAYTYPE_P(retval);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/arrayaccess.h\"",
      "#include \"utils/array.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"funcapi.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <math.h>",
      "#include <float.h>\t\t\t\t/* for _isnan */",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ASSGN\t \"=\""
    ],
    "globals_used": [
      "static int\tArrayCount(const char *str, int *dim, char typdelim);",
      "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
      "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
      "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
      "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
      "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
      "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
      "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);",
      "static int\tarray_cmp(FunctionCallInfo fcinfo);",
      "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);",
      "static ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);",
      "static ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "retval"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "string_save"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CopyArrayEls",
          "args": [
            "retval",
            "dataPtr",
            "nullsPtr",
            "nitems",
            "typlen",
            "typbyval",
            "typalign",
            "true"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "CopyArrayEls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "956-1004",
          "snippet": "void\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nvoid\nCopyArrayEls(ArrayType *array,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t int nitems,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t bool freedata)\n{\n\tchar\t   *p = ARR_DATA_PTR(array);\n\tbits8\t   *bitmap = ARR_NULLBITMAP(array);\n\tint\t\t\tbitval = 0;\n\tint\t\t\tbitmask = 1;\n\tint\t\t\ti;\n\n\tif (typbyval)\n\t\tfreedata = false;\n\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls && nulls[i])\n\t\t{\n\t\t\tif (!bitmap)\t\t/* shouldn't happen */\n\t\t\t\telog(ERROR, \"null array element where not supported\");\n\t\t\t/* bitmap bit stays 0 */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbitval |= bitmask;\n\t\t\tp += ArrayCastAndSet(values[i], typlen, typbyval, typalign, p);\n\t\t\tif (freedata)\n\t\t\t\tpfree(DatumGetPointer(values[i]));\n\t\t}\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\t*bitmap++ = bitval;\n\t\t\t\tbitval = 0;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bitmap && bitmask != 1)\n\t\t*bitmap = bitval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(retval)",
            "lBound",
            "ndim * sizeof(int)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "retval"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(retval)",
            "dim",
            "ndim * sizeof(int)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "retval"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "retval",
            "nbytes"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nbytes"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndim"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndim",
            "nitems"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadArrayStr",
          "args": [
            "p",
            "string",
            "nitems",
            "ndim",
            "dim",
            "&my_extra->proc",
            "typioparam",
            "typmod",
            "typdelim",
            "typlen",
            "typbyval",
            "typalign",
            "dataPtr",
            "nullsPtr",
            "&hasnulls",
            "&nbytes"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "ReadArrayStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "716-938",
          "snippet": "static void\nReadArrayStr(char *arrayStr,\n\t\t\t const char *origStr,\n\t\t\t int nitems,\n\t\t\t int ndim,\n\t\t\t int *dim,\n\t\t\t FmgrInfo *inputproc,\n\t\t\t Oid typioparam,\n\t\t\t int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t bool *hasnulls,\n\t\t\t int32 *nbytes)\n{\n\tint\t\t\ti,\n\t\t\t\tnest_level = 0;\n\tchar\t   *srcptr;\n\tbool\t\tin_quotes = false;\n\tbool\t\teoArray = false;\n\tbool\t\thasnull;\n\tint32\t\ttotbytes;\n\tint\t\t\tindx[MAXDIM],\n\t\t\t\tprod[MAXDIM];\n\n\tmda_get_prod(ndim, dim, prod);\n\tMemSet(indx, 0, sizeof(indx));\n\n\t/* Initialize is-null markers to true */\n\tmemset(nulls, true, nitems * sizeof(bool));\n\n\t/*\n\t * We have to remove \" and \\ characters to create a clean item value to\n\t * pass to the datatype input routine.  We overwrite each item value\n\t * in-place within arrayStr to do this.  srcptr is the current scan point,\n\t * and dstptr is where we are copying to.\n\t *\n\t * We also want to suppress leading and trailing unquoted whitespace. We\n\t * use the leadingspace flag to suppress leading space.  Trailing space is\n\t * tracked by using dstendptr to point to the last significant output\n\t * character.\n\t *\n\t * The error checking in this routine is mostly pro-forma, since we expect\n\t * that ArrayCount() already validated the string.  So we don't bother\n\t * with errdetail messages.\n\t */\n\tsrcptr = arrayStr;\n\twhile (!eoArray)\n\t{\n\t\tbool\t\titemdone = false;\n\t\tbool\t\tleadingspace = true;\n\t\tbool\t\thasquoting = false;\n\t\tchar\t   *itemstart;\n\t\tchar\t   *dstptr;\n\t\tchar\t   *dstendptr;\n\n\t\ti = -1;\n\t\titemstart = dstptr = dstendptr = srcptr;\n\n\t\twhile (!itemdone)\n\t\t{\n\t\t\tswitch (*srcptr)\n\t\t\t{\n\t\t\t\tcase '\\0':\n\t\t\t\t\t/* Signal a premature end of the string */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\t/* Skip backslash, copy next character as-is. */\n\t\t\t\t\tsrcptr++;\n\t\t\t\t\tif (*srcptr == '\\0')\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t/* Treat the escaped character as non-whitespace */\n\t\t\t\t\tleadingspace = false;\n\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\thasquoting = true;\t/* can't be a NULL marker */\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tin_quotes = !in_quotes;\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\tleadingspace = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Advance dstendptr when we exit in_quotes; this\n\t\t\t\t\t\t * saves having to do it in all the other in_quotes\n\t\t\t\t\t\t * cases.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\t}\n\t\t\t\t\thasquoting = true;\t/* can't be a NULL marker */\n\t\t\t\t\tsrcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '{':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nest_level >= ndim)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t\tnest_level++;\n\t\t\t\t\t\tindx[nest_level - 1] = 0;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t\tif (i == -1)\n\t\t\t\t\t\t\ti = ArrayGetOffset0(ndim, indx, prod);\n\t\t\t\t\t\tindx[nest_level - 1] = 0;\n\t\t\t\t\t\tnest_level--;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\teoArray = itemdone = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tindx[nest_level - 1]++;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\telse if (*srcptr == typdelim)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i == -1)\n\t\t\t\t\t\t\ti = ArrayGetOffset0(ndim, indx, prod);\n\t\t\t\t\t\titemdone = true;\n\t\t\t\t\t\tindx[ndim - 1]++;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (array_isspace(*srcptr))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If leading space, drop it immediately.  Else, copy\n\t\t\t\t\t\t * but don't advance dstendptr.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (leadingspace)\n\t\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t\tleadingspace = false;\n\t\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tAssert(dstptr < srcptr);\n\t\t*dstendptr = '\\0';\n\n\t\tif (i < 0 || i >= nitems)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\torigStr)));\n\n\t\tif (Array_nulls && !hasquoting &&\n\t\t\tpg_strcasecmp(itemstart, \"NULL\") == 0)\n\t\t{\n\t\t\t/* it's a NULL item */\n\t\t\tvalues[i] = InputFunctionCall(inputproc, NULL,\n\t\t\t\t\t\t\t\t\t\t  typioparam, typmod);\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalues[i] = InputFunctionCall(inputproc, itemstart,\n\t\t\t\t\t\t\t\t\t\t  typioparam, typmod);\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/*\n\t * Check for nulls, compute total data space needed\n\t */\n\thasnull = false;\n\ttotbytes = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls[i])\n\t\t\thasnull = true;\n\t\telse\n\t\t{\n\t\t\t/* let's just make sure data is not toasted */\n\t\t\tif (typlen == -1)\n\t\t\t\tvalues[i] = PointerGetDatum(PG_DETOAST_DATUM(values[i]));\n\t\t\ttotbytes = att_addlength_datum(totbytes, typlen, values[i]);\n\t\t\ttotbytes = att_align_nominal(totbytes, typalign);\n\t\t\t/* check for overflow of total request */\n\t\t\tif (!AllocSizeIsValid(totbytes))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t}\n\t}\n\t*hasnulls = hasnull;\n\t*nbytes = totbytes;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tArray_nulls = true;",
            "static int\tArrayCount(const char *str, int *dim, char typdelim);",
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\t\tArray_nulls = true;\nstatic int\tArrayCount(const char *str, int *dim, char typdelim);\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic void\nReadArrayStr(char *arrayStr,\n\t\t\t const char *origStr,\n\t\t\t int nitems,\n\t\t\t int ndim,\n\t\t\t int *dim,\n\t\t\t FmgrInfo *inputproc,\n\t\t\t Oid typioparam,\n\t\t\t int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen,\n\t\t\t bool typbyval,\n\t\t\t char typalign,\n\t\t\t Datum *values,\n\t\t\t bool *nulls,\n\t\t\t bool *hasnulls,\n\t\t\t int32 *nbytes)\n{\n\tint\t\t\ti,\n\t\t\t\tnest_level = 0;\n\tchar\t   *srcptr;\n\tbool\t\tin_quotes = false;\n\tbool\t\teoArray = false;\n\tbool\t\thasnull;\n\tint32\t\ttotbytes;\n\tint\t\t\tindx[MAXDIM],\n\t\t\t\tprod[MAXDIM];\n\n\tmda_get_prod(ndim, dim, prod);\n\tMemSet(indx, 0, sizeof(indx));\n\n\t/* Initialize is-null markers to true */\n\tmemset(nulls, true, nitems * sizeof(bool));\n\n\t/*\n\t * We have to remove \" and \\ characters to create a clean item value to\n\t * pass to the datatype input routine.  We overwrite each item value\n\t * in-place within arrayStr to do this.  srcptr is the current scan point,\n\t * and dstptr is where we are copying to.\n\t *\n\t * We also want to suppress leading and trailing unquoted whitespace. We\n\t * use the leadingspace flag to suppress leading space.  Trailing space is\n\t * tracked by using dstendptr to point to the last significant output\n\t * character.\n\t *\n\t * The error checking in this routine is mostly pro-forma, since we expect\n\t * that ArrayCount() already validated the string.  So we don't bother\n\t * with errdetail messages.\n\t */\n\tsrcptr = arrayStr;\n\twhile (!eoArray)\n\t{\n\t\tbool\t\titemdone = false;\n\t\tbool\t\tleadingspace = true;\n\t\tbool\t\thasquoting = false;\n\t\tchar\t   *itemstart;\n\t\tchar\t   *dstptr;\n\t\tchar\t   *dstendptr;\n\n\t\ti = -1;\n\t\titemstart = dstptr = dstendptr = srcptr;\n\n\t\twhile (!itemdone)\n\t\t{\n\t\t\tswitch (*srcptr)\n\t\t\t{\n\t\t\t\tcase '\\0':\n\t\t\t\t\t/* Signal a premature end of the string */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\t/* Skip backslash, copy next character as-is. */\n\t\t\t\t\tsrcptr++;\n\t\t\t\t\tif (*srcptr == '\\0')\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t/* Treat the escaped character as non-whitespace */\n\t\t\t\t\tleadingspace = false;\n\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\thasquoting = true;\t/* can't be a NULL marker */\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\t\t\t\t\tin_quotes = !in_quotes;\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\tleadingspace = false;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Advance dstendptr when we exit in_quotes; this\n\t\t\t\t\t\t * saves having to do it in all the other in_quotes\n\t\t\t\t\t\t * cases.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\t}\n\t\t\t\t\thasquoting = true;\t/* can't be a NULL marker */\n\t\t\t\t\tsrcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '{':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nest_level >= ndim)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t\tnest_level++;\n\t\t\t\t\t\tindx[nest_level - 1] = 0;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\t\torigStr)));\n\t\t\t\t\t\tif (i == -1)\n\t\t\t\t\t\t\ti = ArrayGetOffset0(ndim, indx, prod);\n\t\t\t\t\t\tindx[nest_level - 1] = 0;\n\t\t\t\t\t\tnest_level--;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\teoArray = itemdone = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tindx[nest_level - 1]++;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\telse if (*srcptr == typdelim)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i == -1)\n\t\t\t\t\t\t\ti = ArrayGetOffset0(ndim, indx, prod);\n\t\t\t\t\t\titemdone = true;\n\t\t\t\t\t\tindx[ndim - 1]++;\n\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (array_isspace(*srcptr))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If leading space, drop it immediately.  Else, copy\n\t\t\t\t\t\t * but don't advance dstendptr.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (leadingspace)\n\t\t\t\t\t\t\tsrcptr++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t*dstptr++ = *srcptr++;\n\t\t\t\t\t\tleadingspace = false;\n\t\t\t\t\t\tdstendptr = dstptr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tAssert(dstptr < srcptr);\n\t\t*dstendptr = '\\0';\n\n\t\tif (i < 0 || i >= nitems)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\",\n\t\t\t\t\t\t\torigStr)));\n\n\t\tif (Array_nulls && !hasquoting &&\n\t\t\tpg_strcasecmp(itemstart, \"NULL\") == 0)\n\t\t{\n\t\t\t/* it's a NULL item */\n\t\t\tvalues[i] = InputFunctionCall(inputproc, NULL,\n\t\t\t\t\t\t\t\t\t\t  typioparam, typmod);\n\t\t\tnulls[i] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalues[i] = InputFunctionCall(inputproc, itemstart,\n\t\t\t\t\t\t\t\t\t\t  typioparam, typmod);\n\t\t\tnulls[i] = false;\n\t\t}\n\t}\n\n\t/*\n\t * Check for nulls, compute total data space needed\n\t */\n\thasnull = false;\n\ttotbytes = 0;\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls[i])\n\t\t\thasnull = true;\n\t\telse\n\t\t{\n\t\t\t/* let's just make sure data is not toasted */\n\t\t\tif (typlen == -1)\n\t\t\t\tvalues[i] = PointerGetDatum(PG_DETOAST_DATUM(values[i]));\n\t\t\ttotbytes = att_addlength_datum(totbytes, typlen, values[i]);\n\t\t\ttotbytes = att_align_nominal(totbytes, typalign);\n\t\t\t/* check for overflow of total request */\n\t\t\tif (!AllocSizeIsValid(totbytes))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t(int) MaxAllocSize)));\n\t\t}\n\t}\n\t*hasnulls = hasnull;\n\t*nbytes = totbytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "nitems * sizeof(bool)"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "construct_empty_array(element_type)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_empty_array",
          "args": [
            "element_type"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3409-3420",
          "snippet": "ArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nArrayType *\nconstruct_empty_array(Oid elmtype)\n{\n\tArrayType  *result;\n\n\tresult = (ArrayType *) palloc0(sizeof(ArrayType));\n\tSET_VARSIZE(result, sizeof(ArrayType));\n\tresult->ndim = 0;\n\tresult->dataoffset = 0;\n\tresult->elemtype = elmtype;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndim",
            "dim"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\") for %s\\n\"",
            "string"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" %d\"",
            "dim[i]"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"array_in- ndim %d (\"",
            "ndim"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t\t errdetail(\"Specified array dimensions do not match array contents.\"))"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Specified array dimensions do not match array contents.\""
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"malformed array literal: \\\"%s\\\"\"",
            "string"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Specified array dimensions do not match array contents.\"))"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayCount",
          "args": [
            "p",
            "dim_braces",
            "typdelim"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "451-686",
          "snippet": "static int\nArrayCount(const char *str, int *dim, char typdelim)\n{\n\tint\t\t\tnest_level = 0,\n\t\t\t\ti;\n\tint\t\t\tndim = 1,\n\t\t\t\ttemp[MAXDIM],\n\t\t\t\tnelems[MAXDIM],\n\t\t\t\tnelems_last[MAXDIM];\n\tbool\t\tin_quotes = false;\n\tbool\t\teoArray = false;\n\tbool\t\tempty_array = true;\n\tconst char *ptr;\n\tArrayParseState parse_state = ARRAY_NO_LEVEL;\n\n\tfor (i = 0; i < MAXDIM; ++i)\n\t{\n\t\ttemp[i] = dim[i] = nelems_last[i] = 0;\n\t\tnelems[i] = 1;\n\t}\n\n\tptr = str;\n\twhile (!eoArray)\n\t{\n\t\tbool\t\titemdone = false;\n\n\t\twhile (!itemdone)\n\t\t{\n\t\t\tif (parse_state == ARRAY_ELEM_STARTED ||\n\t\t\t\tparse_state == ARRAY_QUOTED_ELEM_STARTED)\n\t\t\t\tempty_array = false;\n\n\t\t\tswitch (*ptr)\n\t\t\t{\n\t\t\t\tcase '\\0':\n\t\t\t\t\t/* Signal a premature end of the string */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\n\t\t\t\t\t/*\n\t\t\t\t\t * An escape must be after a level start, after an element\n\t\t\t\t\t * start, or after an element delimiter. In any case we\n\t\t\t\t\t * now must be past an element start.\n\t\t\t\t\t */\n\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t   '\\\\')));\n\t\t\t\t\tif (parse_state != ARRAY_QUOTED_ELEM_STARTED)\n\t\t\t\t\t\tparse_state = ARRAY_ELEM_STARTED;\n\t\t\t\t\t/* skip the escaped character */\n\t\t\t\t\tif (*(ptr + 1))\n\t\t\t\t\t\tptr++;\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\n\t\t\t\t\t/*\n\t\t\t\t\t * A quote must be after a level start, after a quoted\n\t\t\t\t\t * element start, or after an element delimiter. In any\n\t\t\t\t\t * case we now must be past an element start.\n\t\t\t\t\t */\n\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected array element.\")));\n\t\t\t\t\tin_quotes = !in_quotes;\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\tparse_state = ARRAY_QUOTED_ELEM_STARTED;\n\t\t\t\t\telse\n\t\t\t\t\t\tparse_state = ARRAY_QUOTED_ELEM_COMPLETED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '{':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A left brace can occur if no nesting has occurred\n\t\t\t\t\t\t * yet, after a level start, or after a level\n\t\t\t\t\t\t * delimiter.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (parse_state != ARRAY_NO_LEVEL &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_DELIMITED)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t   '{')));\n\t\t\t\t\t\tparse_state = ARRAY_LEVEL_STARTED;\n\t\t\t\t\t\tif (nest_level >= MAXDIM)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t\t\tnest_level + 1, MAXDIM)));\n\t\t\t\t\t\ttemp[nest_level] = 0;\n\t\t\t\t\t\tnest_level++;\n\t\t\t\t\t\tif (ndim < nest_level)\n\t\t\t\t\t\t\tndim = nest_level;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A right brace can occur after an element start, an\n\t\t\t\t\t\t * element completion, a quoted element completion, or\n\t\t\t\t\t\t * a level completion.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (parse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_COMPLETED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_COMPLETED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_COMPLETED &&\n\t\t\t\t\t\t\t!(nest_level == 1 && parse_state == ARRAY_LEVEL_STARTED))\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t   '}')));\n\t\t\t\t\t\tparse_state = ARRAY_LEVEL_COMPLETED;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unmatched \\\"%c\\\" character.\", '}')));\n\t\t\t\t\t\tnest_level--;\n\n\t\t\t\t\t\tif (nelems_last[nest_level] != 0 &&\n\t\t\t\t\t\t\tnelems[nest_level] != nelems_last[nest_level])\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t\t\t\t\t\t   \"sub-arrays with matching \"\n\t\t\t\t\t\t\t\t\t\t\t   \"dimensions.\")));\n\t\t\t\t\t\tnelems_last[nest_level] = nelems[nest_level];\n\t\t\t\t\t\tnelems[nest_level] = 1;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\teoArray = itemdone = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We don't set itemdone here; see comments in\n\t\t\t\t\t\t\t * ReadArrayStr\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\ttemp[nest_level - 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*ptr == typdelim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Delimiters can occur after an element start, an\n\t\t\t\t\t\t\t * element completion, a quoted element\n\t\t\t\t\t\t\t * completion, or a level completion.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (parse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_COMPLETED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_COMPLETED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_COMPLETED)\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t\t   typdelim)));\n\t\t\t\t\t\t\tif (parse_state == ARRAY_LEVEL_COMPLETED)\n\t\t\t\t\t\t\t\tparse_state = ARRAY_LEVEL_DELIMITED;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tparse_state = ARRAY_ELEM_DELIMITED;\n\t\t\t\t\t\t\titemdone = true;\n\t\t\t\t\t\t\tnelems[nest_level - 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!array_isspace(*ptr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Other non-space characters must be after a\n\t\t\t\t\t\t\t * level start, after an element start, or after\n\t\t\t\t\t\t\t * an element delimiter. In any case we now must\n\t\t\t\t\t\t\t * be past an element start.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected array element.\")));\n\t\t\t\t\t\t\tparse_state = ARRAY_ELEM_STARTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!itemdone)\n\t\t\t\tptr++;\n\t\t}\n\t\ttemp[ndim - 1]++;\n\t\tptr++;\n\t}\n\n\t/* only whitespace is allowed after the closing brace */\n\twhile (*ptr)\n\t{\n\t\tif (!array_isspace(*ptr++))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t errdetail(\"Junk after closing right brace.\")));\n\t}\n\n\t/* special case for an empty array */\n\tif (empty_array)\n\t\treturn 0;\n\n\tfor (i = 0; i < ndim; ++i)\n\t\tdim[i] = temp[i];\n\n\treturn ndim;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tArrayCount(const char *str, int *dim, char typdelim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tArrayCount(const char *str, int *dim, char typdelim);\n\nstatic int\nArrayCount(const char *str, int *dim, char typdelim)\n{\n\tint\t\t\tnest_level = 0,\n\t\t\t\ti;\n\tint\t\t\tndim = 1,\n\t\t\t\ttemp[MAXDIM],\n\t\t\t\tnelems[MAXDIM],\n\t\t\t\tnelems_last[MAXDIM];\n\tbool\t\tin_quotes = false;\n\tbool\t\teoArray = false;\n\tbool\t\tempty_array = true;\n\tconst char *ptr;\n\tArrayParseState parse_state = ARRAY_NO_LEVEL;\n\n\tfor (i = 0; i < MAXDIM; ++i)\n\t{\n\t\ttemp[i] = dim[i] = nelems_last[i] = 0;\n\t\tnelems[i] = 1;\n\t}\n\n\tptr = str;\n\twhile (!eoArray)\n\t{\n\t\tbool\t\titemdone = false;\n\n\t\twhile (!itemdone)\n\t\t{\n\t\t\tif (parse_state == ARRAY_ELEM_STARTED ||\n\t\t\t\tparse_state == ARRAY_QUOTED_ELEM_STARTED)\n\t\t\t\tempty_array = false;\n\n\t\t\tswitch (*ptr)\n\t\t\t{\n\t\t\t\tcase '\\0':\n\t\t\t\t\t/* Signal a premature end of the string */\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\n\t\t\t\t\t/*\n\t\t\t\t\t * An escape must be after a level start, after an element\n\t\t\t\t\t * start, or after an element delimiter. In any case we\n\t\t\t\t\t * now must be past an element start.\n\t\t\t\t\t */\n\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t   '\\\\')));\n\t\t\t\t\tif (parse_state != ARRAY_QUOTED_ELEM_STARTED)\n\t\t\t\t\t\tparse_state = ARRAY_ELEM_STARTED;\n\t\t\t\t\t/* skip the escaped character */\n\t\t\t\t\tif (*(ptr + 1))\n\t\t\t\t\t\tptr++;\n\t\t\t\t\telse\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected end of input.\")));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"':\n\n\t\t\t\t\t/*\n\t\t\t\t\t * A quote must be after a level start, after a quoted\n\t\t\t\t\t * element start, or after an element delimiter. In any\n\t\t\t\t\t * case we now must be past an element start.\n\t\t\t\t\t */\n\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_STARTED &&\n\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t errdetail(\"Unexpected array element.\")));\n\t\t\t\t\tin_quotes = !in_quotes;\n\t\t\t\t\tif (in_quotes)\n\t\t\t\t\t\tparse_state = ARRAY_QUOTED_ELEM_STARTED;\n\t\t\t\t\telse\n\t\t\t\t\t\tparse_state = ARRAY_QUOTED_ELEM_COMPLETED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '{':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A left brace can occur if no nesting has occurred\n\t\t\t\t\t\t * yet, after a level start, or after a level\n\t\t\t\t\t\t * delimiter.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (parse_state != ARRAY_NO_LEVEL &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_DELIMITED)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t   '{')));\n\t\t\t\t\t\tparse_state = ARRAY_LEVEL_STARTED;\n\t\t\t\t\t\tif (nest_level >= MAXDIM)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t\t\t\t\tnest_level + 1, MAXDIM)));\n\t\t\t\t\t\ttemp[nest_level] = 0;\n\t\t\t\t\t\tnest_level++;\n\t\t\t\t\t\tif (ndim < nest_level)\n\t\t\t\t\t\t\tndim = nest_level;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A right brace can occur after an element start, an\n\t\t\t\t\t\t * element completion, a quoted element completion, or\n\t\t\t\t\t\t * a level completion.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (parse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_COMPLETED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_COMPLETED &&\n\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_COMPLETED &&\n\t\t\t\t\t\t\t!(nest_level == 1 && parse_state == ARRAY_LEVEL_STARTED))\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t   '}')));\n\t\t\t\t\t\tparse_state = ARRAY_LEVEL_COMPLETED;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Unmatched \\\"%c\\\" character.\", '}')));\n\t\t\t\t\t\tnest_level--;\n\n\t\t\t\t\t\tif (nelems_last[nest_level] != 0 &&\n\t\t\t\t\t\t\tnelems[nest_level] != nelems_last[nest_level])\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t errdetail(\"Multidimensional arrays must have \"\n\t\t\t\t\t\t\t\t\t\t\t   \"sub-arrays with matching \"\n\t\t\t\t\t\t\t\t\t\t\t   \"dimensions.\")));\n\t\t\t\t\t\tnelems_last[nest_level] = nelems[nest_level];\n\t\t\t\t\t\tnelems[nest_level] = 1;\n\t\t\t\t\t\tif (nest_level == 0)\n\t\t\t\t\t\t\teoArray = itemdone = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We don't set itemdone here; see comments in\n\t\t\t\t\t\t\t * ReadArrayStr\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\ttemp[nest_level - 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!in_quotes)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (*ptr == typdelim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Delimiters can occur after an element start, an\n\t\t\t\t\t\t\t * element completion, a quoted element\n\t\t\t\t\t\t\t * completion, or a level completion.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (parse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_COMPLETED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_QUOTED_ELEM_COMPLETED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_LEVEL_COMPLETED)\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected \\\"%c\\\" character.\",\n\t\t\t\t\t\t\t\t\t\t\t\t   typdelim)));\n\t\t\t\t\t\t\tif (parse_state == ARRAY_LEVEL_COMPLETED)\n\t\t\t\t\t\t\t\tparse_state = ARRAY_LEVEL_DELIMITED;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tparse_state = ARRAY_ELEM_DELIMITED;\n\t\t\t\t\t\t\titemdone = true;\n\t\t\t\t\t\t\tnelems[nest_level - 1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!array_isspace(*ptr))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Other non-space characters must be after a\n\t\t\t\t\t\t\t * level start, after an element start, or after\n\t\t\t\t\t\t\t * an element delimiter. In any case we now must\n\t\t\t\t\t\t\t * be past an element start.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (parse_state != ARRAY_LEVEL_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_STARTED &&\n\t\t\t\t\t\t\t\tparse_state != ARRAY_ELEM_DELIMITED)\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t\t\t\t\t\t errdetail(\"Unexpected array element.\")));\n\t\t\t\t\t\t\tparse_state = ARRAY_ELEM_STARTED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!itemdone)\n\t\t\t\tptr++;\n\t\t}\n\t\ttemp[ndim - 1]++;\n\t\tptr++;\n\t}\n\n\t/* only whitespace is allowed after the closing brace */\n\twhile (*ptr)\n\t{\n\t\tif (!array_isspace(*ptr++))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", str),\n\t\t\t\t\t errdetail(\"Junk after closing right brace.\")));\n\t}\n\n\t/* special case for an empty array */\n\tif (empty_array)\n\t\treturn 0;\n\n\tfor (i = 0; i < ndim; ++i)\n\t\tdim[i] = temp[i];\n\n\treturn ndim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Array contents must start with \\\"{\\\".\"))"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_isspace",
          "args": [
            "*p"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ASSGN"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Missing \\\"%s\\\" after array dimensions.\",\n\t\t\t\t\t\t\t   ASSGN))"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "ASSGN",
            "strlen(ASSGN)"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Array value must start with \\\"{\\\" or dimension information.\"))"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\"))"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Missing \\\"%s\\\" after array dimensions.\",\n\t\t\t\t\t\t\t   \"]\"))"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t\t errdetail(\"Missing array dimension value.\"))"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *q"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "p"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"\\\"[\\\" must introduce explicitly-specified array dimensions.\"))"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char) *q"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tndim + 1, MAXDIM))"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "string"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "my_extra->typiofunc",
            "&my_extra->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_type_io_data",
          "args": [
            "element_type",
            "IOFunc_input",
            "&my_extra->typlen",
            "&my_extra->typbyval",
            "&my_extra->typalign",
            "&my_extra->typdelim",
            "&my_extra->typioparam",
            "&my_extra->typiofunc"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "get_type_io_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2102-2173",
          "snippet": "void\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_type_io_data(Oid typid,\n\t\t\t\t IOFuncSelector which_func,\n\t\t\t\t int16 *typlen,\n\t\t\t\t bool *typbyval,\n\t\t\t\t char *typalign,\n\t\t\t\t char *typdelim,\n\t\t\t\t Oid *typioparam,\n\t\t\t\t Oid *func)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeStruct;\n\n\t/*\n\t * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to\n\t * use array_in and array_out during bootstrap.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\tOid\t\t\ttypinput;\n\t\tOid\t\t\ttypoutput;\n\n\t\tboot_get_type_io_data(typid,\n\t\t\t\t\t\t\t  typlen,\n\t\t\t\t\t\t\t  typbyval,\n\t\t\t\t\t\t\t  typalign,\n\t\t\t\t\t\t\t  typdelim,\n\t\t\t\t\t\t\t  typioparam,\n\t\t\t\t\t\t\t  &typinput,\n\t\t\t\t\t\t\t  &typoutput);\n\t\tswitch (which_func)\n\t\t{\n\t\t\tcase IOFunc_input:\n\t\t\t\t*func = typinput;\n\t\t\t\tbreak;\n\t\t\tcase IOFunc_output:\n\t\t\t\t*func = typoutput;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"binary I/O not supported during bootstrap\");\n\t\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttypeStruct = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t*typlen = typeStruct->typlen;\n\t*typbyval = typeStruct->typbyval;\n\t*typalign = typeStruct->typalign;\n\t*typdelim = typeStruct->typdelim;\n\t*typioparam = getTypeIOParam(typeTuple);\n\tswitch (which_func)\n\t{\n\t\tcase IOFunc_input:\n\t\t\t*func = typeStruct->typinput;\n\t\t\tbreak;\n\t\tcase IOFunc_output:\n\t\t\t*func = typeStruct->typoutput;\n\t\t\tbreak;\n\t\tcase IOFunc_receive:\n\t\t\t*func = typeStruct->typreceive;\n\t\t\tbreak;\n\t\tcase IOFunc_send:\n\t\t\t*func = typeStruct->typsend;\n\t\t\tbreak;\n\t}\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(ArrayMetaState)"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define ASSGN\t \"=\"\n\nstatic int\tArrayCount(const char *str, int *dim, char typdelim);\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\nstatic int\tarray_cmp(FunctionCallInfo fcinfo);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\nstatic ArrayType *array_fill_internal(ArrayType *dims, ArrayType *lbs,\n\t\t\t\t\tDatum value, bool isnull, Oid elmtype,\n\t\t\t\t\tFunctionCallInfo fcinfo);\nstatic ArrayType *array_replace_internal(ArrayType *array,\n\t\t\t\t\t   Datum search, bool search_isnull,\n\t\t\t\t\t   Datum replace, bool replace_isnull,\n\t\t\t\t\t   bool remove, Oid collation,\n\t\t\t\t\t   FunctionCallInfo fcinfo);\n\nDatum\narray_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *string = PG_GETARG_CSTRING(0);\t/* external form */\n\tOid\t\t\telement_type = PG_GETARG_OID(1);\t/* type of an array\n\t\t\t\t\t\t\t\t\t\t\t\t\t * element */\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\t/* typmod for array elements */\n\tint\t\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypdelim;\n\tOid\t\t\ttypioparam;\n\tchar\t   *string_save,\n\t\t\t   *p;\n\tint\t\t\ti,\n\t\t\t\tnitems;\n\tDatum\t   *dataPtr;\n\tbool\t   *nullsPtr;\n\tbool\t\thasnulls;\n\tint32\t\tnbytes;\n\tint32\t\tdataoffset;\n\tArrayType  *retval;\n\tint\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlBound[MAXDIM];\n\tArrayMetaState *my_extra;\n\n\t/*\n\t * We arrange to look up info about element type, including its input\n\t * conversion proc, only once per series of calls, assuming the element\n\t * type doesn't change underneath us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\t/*\n\t\t * Get info about element type, including its input conversion proc\n\t\t */\n\t\tget_type_io_data(element_type, IOFunc_input,\n\t\t\t\t\t\t &my_extra->typlen, &my_extra->typbyval,\n\t\t\t\t\t\t &my_extra->typalign, &my_extra->typdelim,\n\t\t\t\t\t\t &my_extra->typioparam, &my_extra->typiofunc);\n\t\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tmy_extra->element_type = element_type;\n\t}\n\ttyplen = my_extra->typlen;\n\ttypbyval = my_extra->typbyval;\n\ttypalign = my_extra->typalign;\n\ttypdelim = my_extra->typdelim;\n\ttypioparam = my_extra->typioparam;\n\n\t/* Make a modifiable copy of the input */\n\tstring_save = pstrdup(string);\n\n\t/*\n\t * If the input string starts with dimension info, read and use that.\n\t * Otherwise, we require the input to be in curly-brace style, and we\n\t * prescan the input to determine dimensions.\n\t *\n\t * Dimension info takes the form of one or more [n] or [m:n] items. The\n\t * outer loop iterates once per dimension item.\n\t */\n\tp = string_save;\n\tndim = 0;\n\tfor (;;)\n\t{\n\t\tchar\t   *q;\n\t\tint\t\t\tub;\n\n\t\t/*\n\t\t * Note: we currently allow whitespace between, but not within,\n\t\t * dimension items.\n\t\t */\n\t\twhile (array_isspace(*p))\n\t\t\tp++;\n\t\tif (*p != '[')\n\t\t\tbreak;\t\t\t\t/* no more dimension items */\n\t\tp++;\n\t\tif (ndim >= MAXDIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tndim + 1, MAXDIM)));\n\n\t\tfor (q = p; isdigit((unsigned char) *q) || (*q == '-') || (*q == '+'); q++)\n\t\t\t /* skip */ ;\n\t\tif (q == p)\t\t\t\t/* no digits? */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"\\\"[\\\" must introduce explicitly-specified array dimensions.\")));\n\n\t\tif (*q == ':')\n\t\t{\n\t\t\t/* [m:n] format */\n\t\t\t*q = '\\0';\n\t\t\tlBound[ndim] = atoi(p);\n\t\t\tp = q + 1;\n\t\t\tfor (q = p; isdigit((unsigned char) *q) || (*q == '-') || (*q == '+'); q++)\n\t\t\t\t /* skip */ ;\n\t\t\tif (q == p)\t\t\t/* no digits? */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t\t errdetail(\"Missing array dimension value.\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* [n] format */\n\t\t\tlBound[ndim] = 1;\n\t\t}\n\t\tif (*q != ']')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Missing \\\"%s\\\" after array dimensions.\",\n\t\t\t\t\t\t\t   \"]\")));\n\n\t\t*q = '\\0';\n\t\tub = atoi(p);\n\t\tp = q + 1;\n\t\tif (ub < lBound[ndim])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"upper bound cannot be less than lower bound\")));\n\n\t\tdim[ndim] = ub - lBound[ndim] + 1;\n\t\tndim++;\n\t}\n\n\tif (ndim == 0)\n\t{\n\t\t/* No array dimensions, so intuit dimensions from brace structure */\n\t\tif (*p != '{')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Array value must start with \\\"{\\\" or dimension information.\")));\n\t\tndim = ArrayCount(p, dim, typdelim);\n\t\tfor (i = 0; i < ndim; i++)\n\t\t\tlBound[i] = 1;\n\t}\n\telse\n\t{\n\t\tint\t\t\tndim_braces,\n\t\t\t\t\tdim_braces[MAXDIM];\n\n\t\t/* If array dimensions are given, expect '=' operator */\n\t\tif (strncmp(p, ASSGN, strlen(ASSGN)) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Missing \\\"%s\\\" after array dimensions.\",\n\t\t\t\t\t\t\t   ASSGN)));\n\t\tp += strlen(ASSGN);\n\t\twhile (array_isspace(*p))\n\t\t\tp++;\n\n\t\t/*\n\t\t * intuit dimensions from brace structure -- it better match what we\n\t\t * were given\n\t\t */\n\t\tif (*p != '{')\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Array contents must start with \\\"{\\\".\")));\n\t\tndim_braces = ArrayCount(p, dim_braces, typdelim);\n\t\tif (ndim_braces != ndim)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t errdetail(\"Specified array dimensions do not match array contents.\")));\n\t\tfor (i = 0; i < ndim; ++i)\n\t\t{\n\t\t\tif (dim[i] != dim_braces[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"malformed array literal: \\\"%s\\\"\", string),\n\t\t\t\t\t\t errdetail(\"Specified array dimensions do not match array contents.\")));\n\t\t}\n\t}\n\n#ifdef ARRAYDEBUG\n\tprintf(\"array_in- ndim %d (\", ndim);\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tprintf(\" %d\", dim[i]);\n\t};\n\tprintf(\") for %s\\n\", string);\n#endif\n\n\t/* This checks for overflow of the array dimensions */\n\tnitems = ArrayGetNItems(ndim, dim);\n\t/* Empty array? */\n\tif (nitems == 0)\n\t\tPG_RETURN_ARRAYTYPE_P(construct_empty_array(element_type));\n\n\tdataPtr = (Datum *) palloc(nitems * sizeof(Datum));\n\tnullsPtr = (bool *) palloc(nitems * sizeof(bool));\n\tReadArrayStr(p, string,\n\t\t\t\t nitems, ndim, dim,\n\t\t\t\t &my_extra->proc, typioparam, typmod,\n\t\t\t\t typdelim,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t dataPtr, nullsPtr,\n\t\t\t\t &hasnulls, &nbytes);\n\tif (hasnulls)\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndim, nitems);\n\t\tnbytes += dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes += ARR_OVERHEAD_NONULLS(ndim);\n\t}\n\tretval = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(retval, nbytes);\n\tretval->ndim = ndim;\n\tretval->dataoffset = dataoffset;\n\n\t/*\n\t * This comes from the array's pg_type.typelem (which points to the base\n\t * data type's pg_type.oid) and stores system oids in user tables. This\n\t * oid must be preserved by binary upgrades.\n\t */\n\tretval->elemtype = element_type;\n\tmemcpy(ARR_DIMS(retval), dim, ndim * sizeof(int));\n\tmemcpy(ARR_LBOUND(retval), lBound, ndim * sizeof(int));\n\n\tCopyArrayEls(retval,\n\t\t\t\t dataPtr, nullsPtr, nitems,\n\t\t\t\t typlen, typbyval, typalign,\n\t\t\t\t true);\n\n\tpfree(dataPtr);\n\tpfree(nullsPtr);\n\tpfree(string_save);\n\n\tPG_RETURN_ARRAYTYPE_P(retval);\n}"
  }
]