[
  {
    "function_name": "macaddr8tomacaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "552-577",
    "snippet": "Datum\nmacaddr8tomacaddr(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tmacaddr    *result;\n\n\tresult = (macaddr *) palloc0(sizeof(macaddr));\n\n\tif ((addr->d != 0xFF) || (addr->e != 0xFE))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"macaddr8 data out of range to convert to macaddr\"),\n\t\t\t\t errhint(\"Only addresses that have FF and FE as values in the \"\n\t\t\t\t\t\t \"4th and 5th bytes from the left, for example \"\n\t\t\t\t\t\t \"xx:xx:xx:ff:fe:xx:xx:xx, are eligible to be converted \"\n\t\t\t\t\t\t \"from macaddr8 to macaddr.\")));\n\n\tresult->a = addr->a;\n\tresult->b = addr->b;\n\tresult->c = addr->c;\n\tresult->d = addr->f;\n\tresult->e = addr->g;\n\tresult->f = addr->h;\n\n\tPG_RETURN_MACADDR_P(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_MACADDR_P",
          "args": [
            "result"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"macaddr8 data out of range to convert to macaddr\"),\n\t\t\t\t errhint(\"Only addresses that have FF and FE as values in the \"\n\t\t\t\t\t\t \"4th and 5th bytes from the left, for example \"\n\t\t\t\t\t\t \"xx:xx:xx:ff:fe:xx:xx:xx, are eligible to be converted \"\n\t\t\t\t\t\t \"from macaddr8 to macaddr.\"))"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Only addresses that have FF and FE as values in the \"\n\t\t\t\t\t\t \"4th and 5th bytes from the left, for example \"\n\t\t\t\t\t\t \"xx:xx:xx:ff:fe:xx:xx:xx, are eligible to be converted \"\n\t\t\t\t\t\t \"from macaddr8 to macaddr.\""
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"macaddr8 data out of range to convert to macaddr\""
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(macaddr)"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8tomacaddr(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tmacaddr    *result;\n\n\tresult = (macaddr *) palloc0(sizeof(macaddr));\n\n\tif ((addr->d != 0xFF) || (addr->e != 0xFE))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"macaddr8 data out of range to convert to macaddr\"),\n\t\t\t\t errhint(\"Only addresses that have FF and FE as values in the \"\n\t\t\t\t\t\t \"4th and 5th bytes from the left, for example \"\n\t\t\t\t\t\t \"xx:xx:xx:ff:fe:xx:xx:xx, are eligible to be converted \"\n\t\t\t\t\t\t \"from macaddr8 to macaddr.\")));\n\n\tresult->a = addr->a;\n\tresult->b = addr->b;\n\tresult->c = addr->c;\n\tresult->d = addr->f;\n\tresult->e = addr->g;\n\tresult->f = addr->h;\n\n\tPG_RETURN_MACADDR_P(result);\n}"
  },
  {
    "function_name": "macaddrtomacaddr8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "531-550",
    "snippet": "Datum\nmacaddrtomacaddr8(PG_FUNCTION_ARGS)\n{\n\tmacaddr    *addr6 = PG_GETARG_MACADDR_P(0);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\n\tresult->a = addr6->a;\n\tresult->b = addr6->b;\n\tresult->c = addr6->c;\n\tresult->d = 0xFF;\n\tresult->e = 0xFE;\n\tresult->f = addr6->d;\n\tresult->g = addr6->e;\n\tresult->h = addr6->f;\n\n\n\tPG_RETURN_MACADDR8_P(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_MACADDR8_P",
          "args": [
            "result"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(macaddr8)"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR_P",
          "args": [
            "0"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddrtomacaddr8(PG_FUNCTION_ARGS)\n{\n\tmacaddr    *addr6 = PG_GETARG_MACADDR_P(0);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\n\tresult->a = addr6->a;\n\tresult->b = addr6->b;\n\tresult->c = addr6->c;\n\tresult->d = 0xFF;\n\tresult->e = 0xFE;\n\tresult->f = addr6->d;\n\tresult->g = addr6->e;\n\tresult->h = addr6->f;\n\n\n\tPG_RETURN_MACADDR8_P(result);\n}"
  },
  {
    "function_name": "macaddr8_set7bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "507-525",
    "snippet": "Datum\nmacaddr8_set7bit(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\n\tresult->a = addr->a | 0x02;\n\tresult->b = addr->b;\n\tresult->c = addr->c;\n\tresult->d = addr->d;\n\tresult->e = addr->e;\n\tresult->f = addr->f;\n\tresult->g = addr->g;\n\tresult->h = addr->h;\n\n\tPG_RETURN_MACADDR8_P(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_MACADDR8_P",
          "args": [
            "result"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(macaddr8)"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_set7bit(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\n\tresult->a = addr->a | 0x02;\n\tresult->b = addr->b;\n\tresult->c = addr->c;\n\tresult->d = addr->d;\n\tresult->e = addr->e;\n\tresult->f = addr->f;\n\tresult->g = addr->g;\n\tresult->h = addr->h;\n\n\tPG_RETURN_MACADDR8_P(result);\n}"
  },
  {
    "function_name": "macaddr8_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "484-502",
    "snippet": "Datum\nmacaddr8_trunc(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\n\tresult->a = addr->a;\n\tresult->b = addr->b;\n\tresult->c = addr->c;\n\tresult->d = 0;\n\tresult->e = 0;\n\tresult->f = 0;\n\tresult->g = 0;\n\tresult->h = 0;\n\n\tPG_RETURN_MACADDR8_P(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_MACADDR8_P",
          "args": [
            "result"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(macaddr8)"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_trunc(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\n\tresult->a = addr->a;\n\tresult->b = addr->b;\n\tresult->c = addr->c;\n\tresult->d = 0;\n\tresult->e = 0;\n\tresult->f = 0;\n\tresult->g = 0;\n\tresult->h = 0;\n\n\tPG_RETURN_MACADDR8_P(result);\n}"
  },
  {
    "function_name": "macaddr8_or",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "461-479",
    "snippet": "Datum\nmacaddr8_or(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *addr2 = PG_GETARG_MACADDR8_P(1);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\tresult->a = addr1->a | addr2->a;\n\tresult->b = addr1->b | addr2->b;\n\tresult->c = addr1->c | addr2->c;\n\tresult->d = addr1->d | addr2->d;\n\tresult->e = addr1->e | addr2->e;\n\tresult->f = addr1->f | addr2->f;\n\tresult->g = addr1->g | addr2->g;\n\tresult->h = addr1->h | addr2->h;\n\n\tPG_RETURN_MACADDR8_P(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_MACADDR8_P",
          "args": [
            "result"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(macaddr8)"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "1"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_or(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *addr2 = PG_GETARG_MACADDR8_P(1);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\tresult->a = addr1->a | addr2->a;\n\tresult->b = addr1->b | addr2->b;\n\tresult->c = addr1->c | addr2->c;\n\tresult->d = addr1->d | addr2->d;\n\tresult->e = addr1->e | addr2->e;\n\tresult->f = addr1->f | addr2->f;\n\tresult->g = addr1->g | addr2->g;\n\tresult->h = addr1->h | addr2->h;\n\n\tPG_RETURN_MACADDR8_P(result);\n}"
  },
  {
    "function_name": "macaddr8_and",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "441-459",
    "snippet": "Datum\nmacaddr8_and(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *addr2 = PG_GETARG_MACADDR8_P(1);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\tresult->a = addr1->a & addr2->a;\n\tresult->b = addr1->b & addr2->b;\n\tresult->c = addr1->c & addr2->c;\n\tresult->d = addr1->d & addr2->d;\n\tresult->e = addr1->e & addr2->e;\n\tresult->f = addr1->f & addr2->f;\n\tresult->g = addr1->g & addr2->g;\n\tresult->h = addr1->h & addr2->h;\n\n\tPG_RETURN_MACADDR8_P(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_MACADDR8_P",
          "args": [
            "result"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(macaddr8)"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "1"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_and(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *addr2 = PG_GETARG_MACADDR8_P(1);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\tresult->a = addr1->a & addr2->a;\n\tresult->b = addr1->b & addr2->b;\n\tresult->c = addr1->c & addr2->c;\n\tresult->d = addr1->d & addr2->d;\n\tresult->e = addr1->e & addr2->e;\n\tresult->f = addr1->f & addr2->f;\n\tresult->g = addr1->g & addr2->g;\n\tresult->h = addr1->h & addr2->h;\n\n\tPG_RETURN_MACADDR8_P(result);\n}"
  },
  {
    "function_name": "macaddr8_not",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "422-439",
    "snippet": "Datum\nmacaddr8_not(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\tresult->a = ~addr->a;\n\tresult->b = ~addr->b;\n\tresult->c = ~addr->c;\n\tresult->d = ~addr->d;\n\tresult->e = ~addr->e;\n\tresult->f = ~addr->f;\n\tresult->g = ~addr->g;\n\tresult->h = ~addr->h;\n\n\tPG_RETURN_MACADDR8_P(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_MACADDR8_P",
          "args": [
            "result"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(macaddr8)"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_not(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *result;\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\tresult->a = ~addr->a;\n\tresult->b = ~addr->b;\n\tresult->c = ~addr->c;\n\tresult->d = ~addr->d;\n\tresult->e = ~addr->e;\n\tresult->f = ~addr->f;\n\tresult->g = ~addr->g;\n\tresult->h = ~addr->h;\n\n\tPG_RETURN_MACADDR8_P(result);\n}"
  },
  {
    "function_name": "hashmacaddr8extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "410-417",
    "snippet": "Datum\nhashmacaddr8extended(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *key = PG_GETARG_MACADDR8_P(0);\n\n\treturn hash_any_extended((unsigned char *) key, sizeof(macaddr8),\n\t\t\t\t\t\t\t PG_GETARG_INT64(1));\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_any_extended",
          "args": [
            "(unsigned char *) key",
            "sizeof(macaddr8)",
            "PG_GETARG_INT64(1)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "1"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nhashmacaddr8extended(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *key = PG_GETARG_MACADDR8_P(0);\n\n\treturn hash_any_extended((unsigned char *) key, sizeof(macaddr8),\n\t\t\t\t\t\t\t PG_GETARG_INT64(1));\n}"
  },
  {
    "function_name": "hashmacaddr8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "402-408",
    "snippet": "Datum\nhashmacaddr8(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *key = PG_GETARG_MACADDR8_P(0);\n\n\treturn hash_any((unsigned char *) key, sizeof(macaddr8));\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_any",
          "args": [
            "(unsigned char *) key",
            "sizeof(macaddr8)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nhashmacaddr8(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *key = PG_GETARG_MACADDR8_P(0);\n\n\treturn hash_any((unsigned char *) key, sizeof(macaddr8));\n}"
  },
  {
    "function_name": "macaddr8_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "390-397",
    "snippet": "Datum\nmacaddr8_ne(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) != 0);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "macaddr8_cmp_internal(a1, a2) != 0"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macaddr8_cmp_internal",
          "args": [
            "a1",
            "a2"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "macaddr8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
          "lines": "317-330",
          "snippet": "static int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "1"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_ne(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) != 0);\n}"
  },
  {
    "function_name": "macaddr8_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "381-388",
    "snippet": "Datum\nmacaddr8_gt(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) > 0);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "macaddr8_cmp_internal(a1, a2) > 0"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macaddr8_cmp_internal",
          "args": [
            "a1",
            "a2"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "macaddr8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
          "lines": "317-330",
          "snippet": "static int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "1"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_gt(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) > 0);\n}"
  },
  {
    "function_name": "macaddr8_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "372-379",
    "snippet": "Datum\nmacaddr8_ge(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) >= 0);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "macaddr8_cmp_internal(a1, a2) >= 0"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macaddr8_cmp_internal",
          "args": [
            "a1",
            "a2"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "macaddr8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
          "lines": "317-330",
          "snippet": "static int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "1"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_ge(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) >= 0);\n}"
  },
  {
    "function_name": "macaddr8_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "363-370",
    "snippet": "Datum\nmacaddr8_eq(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) == 0);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "macaddr8_cmp_internal(a1, a2) == 0"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macaddr8_cmp_internal",
          "args": [
            "a1",
            "a2"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "macaddr8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
          "lines": "317-330",
          "snippet": "static int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "1"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_eq(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) == 0);\n}"
  },
  {
    "function_name": "macaddr8_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "354-361",
    "snippet": "Datum\nmacaddr8_le(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) <= 0);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "macaddr8_cmp_internal(a1, a2) <= 0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macaddr8_cmp_internal",
          "args": [
            "a1",
            "a2"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "macaddr8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
          "lines": "317-330",
          "snippet": "static int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "1"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_le(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) <= 0);\n}"
  },
  {
    "function_name": "macaddr8_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "345-352",
    "snippet": "Datum\nmacaddr8_lt(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) < 0);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "macaddr8_cmp_internal(a1, a2) < 0"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macaddr8_cmp_internal",
          "args": [
            "a1",
            "a2"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "macaddr8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
          "lines": "317-330",
          "snippet": "static int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "1"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_lt(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_BOOL(macaddr8_cmp_internal(a1, a2) < 0);\n}"
  },
  {
    "function_name": "macaddr8_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "332-339",
    "snippet": "Datum\nmacaddr8_cmp(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_INT32(macaddr8_cmp_internal(a1, a2));\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "macaddr8_cmp_internal(a1, a2)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "macaddr8_cmp_internal",
          "args": [
            "a1",
            "a2"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "macaddr8_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
          "lines": "317-330",
          "snippet": "static int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "1"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_cmp(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *a1 = PG_GETARG_MACADDR8_P(0);\n\tmacaddr8   *a2 = PG_GETARG_MACADDR8_P(1);\n\n\tPG_RETURN_INT32(macaddr8_cmp_internal(a1, a2));\n}"
  },
  {
    "function_name": "macaddr8_cmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "317-330",
    "snippet": "static int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lobits",
          "args": [
            "a2"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lobits",
          "args": [
            "a1"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lobits",
          "args": [
            "a2"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lobits",
          "args": [
            "a1"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibits",
          "args": [
            "a2"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibits",
          "args": [
            "a1"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibits",
          "args": [
            "a2"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibits",
          "args": [
            "a1"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic int32\nmacaddr8_cmp_internal(macaddr8 *a1, macaddr8 *a2)\n{\n\tif (hibits(a1) < hibits(a2))\n\t\treturn -1;\n\telse if (hibits(a1) > hibits(a2))\n\t\treturn 1;\n\telse if (lobits(a1) < lobits(a2))\n\t\treturn -1;\n\telse if (lobits(a1) > lobits(a2))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "macaddr8_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "294-311",
    "snippet": "Datum\nmacaddr8_send(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendbyte(&buf, addr->a);\n\tpq_sendbyte(&buf, addr->b);\n\tpq_sendbyte(&buf, addr->c);\n\tpq_sendbyte(&buf, addr->d);\n\tpq_sendbyte(&buf, addr->e);\n\tpq_sendbyte(&buf, addr->f);\n\tpq_sendbyte(&buf, addr->g);\n\tpq_sendbyte(&buf, addr->h);\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&buf",
            "addr->h"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&buf",
            "addr->g"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&buf",
            "addr->f"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&buf",
            "addr->e"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&buf",
            "addr->d"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&buf",
            "addr->c"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&buf",
            "addr->b"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&buf",
            "addr->a"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_send(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendbyte(&buf, addr->a);\n\tpq_sendbyte(&buf, addr->b);\n\tpq_sendbyte(&buf, addr->c);\n\tpq_sendbyte(&buf, addr->d);\n\tpq_sendbyte(&buf, addr->e);\n\tpq_sendbyte(&buf, addr->f);\n\tpq_sendbyte(&buf, addr->g);\n\tpq_sendbyte(&buf, addr->h);\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "macaddr8_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "261-289",
    "snippet": "Datum\nmacaddr8_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tmacaddr8   *addr;\n\n\taddr = (macaddr8 *) palloc0(sizeof(macaddr8));\n\n\taddr->a = pq_getmsgbyte(buf);\n\taddr->b = pq_getmsgbyte(buf);\n\taddr->c = pq_getmsgbyte(buf);\n\n\tif (buf->len == 6)\n\t{\n\t\taddr->d = 0xFF;\n\t\taddr->e = 0xFE;\n\t}\n\telse\n\t{\n\t\taddr->d = pq_getmsgbyte(buf);\n\t\taddr->e = pq_getmsgbyte(buf);\n\t}\n\n\taddr->f = pq_getmsgbyte(buf);\n\taddr->g = pq_getmsgbyte(buf);\n\taddr->h = pq_getmsgbyte(buf);\n\n\tPG_RETURN_MACADDR8_P(addr);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_MACADDR8_P",
          "args": [
            "addr"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbyte",
          "args": [
            "buf"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbyte",
          "args": [
            "buf"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbyte",
          "args": [
            "buf"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbyte",
          "args": [
            "buf"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbyte",
          "args": [
            "buf"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbyte",
          "args": [
            "buf"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbyte",
          "args": [
            "buf"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgbyte",
          "args": [
            "buf"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(macaddr8)"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tmacaddr8   *addr;\n\n\taddr = (macaddr8 *) palloc0(sizeof(macaddr8));\n\n\taddr->a = pq_getmsgbyte(buf);\n\taddr->b = pq_getmsgbyte(buf);\n\taddr->c = pq_getmsgbyte(buf);\n\n\tif (buf->len == 6)\n\t{\n\t\taddr->d = 0xFF;\n\t\taddr->e = 0xFE;\n\t}\n\telse\n\t{\n\t\taddr->d = pq_getmsgbyte(buf);\n\t\taddr->e = pq_getmsgbyte(buf);\n\t}\n\n\taddr->f = pq_getmsgbyte(buf);\n\taddr->g = pq_getmsgbyte(buf);\n\taddr->h = pq_getmsgbyte(buf);\n\n\tPG_RETURN_MACADDR8_P(addr);\n}"
  },
  {
    "function_name": "macaddr8_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "241-254",
    "snippet": "Datum\nmacaddr8_out(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(32);\n\n\tsnprintf(result, 32, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\",\n\t\t\t addr->a, addr->b, addr->c, addr->d,\n\t\t\t addr->e, addr->f, addr->g, addr->h);\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "32",
            "\"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\"",
            "addr->a",
            "addr->b",
            "addr->c",
            "addr->d",
            "addr->e",
            "addr->f",
            "addr->g",
            "addr->h"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "32"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_MACADDR8_P",
          "args": [
            "0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nDatum\nmacaddr8_out(PG_FUNCTION_ARGS)\n{\n\tmacaddr8   *addr = PG_GETARG_MACADDR8_P(0);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(32);\n\n\tsnprintf(result, 32, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\",\n\t\t\t addr->a, addr->b, addr->c, addr->d,\n\t\t\t addr->e, addr->f, addr->g, addr->h);\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "macaddr8_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "103-236",
    "snippet": "Datum\nmacaddr8_in(PG_FUNCTION_ARGS)\n{\n\tconst unsigned char *str = (unsigned char *) PG_GETARG_CSTRING(0);\n\tconst unsigned char *ptr = str;\n\tmacaddr8   *result;\n\tunsigned char a = 0,\n\t\t\t\tb = 0,\n\t\t\t\tc = 0,\n\t\t\t\td = 0,\n\t\t\t\te = 0,\n\t\t\t\tf = 0,\n\t\t\t\tg = 0,\n\t\t\t\th = 0;\n\tint\t\t\tcount = 0;\n\tunsigned char spacer = '\\0';\n\n\t/* skip leading spaces */\n\twhile (*ptr && isspace(*ptr))\n\t\tptr++;\n\n\t/* digits must always come in pairs */\n\twhile (*ptr && *(ptr + 1))\n\t{\n\t\t/*\n\t\t * Attempt to decode each byte, which must be 2 hex digits in a row.\n\t\t * If either digit is not hex, hex2_to_uchar will throw ereport() for\n\t\t * us.  Either 6 or 8 byte MAC addresses are supported.\n\t\t */\n\n\t\t/* Attempt to collect a byte */\n\t\tcount++;\n\n\t\tswitch (count)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\ta = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tb = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\td = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\te = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tf = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tg = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\th = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* must be trailing garbage... */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\t\t\tstr)));\n\t\t}\n\n\t\t/* Move forward to where the next byte should be */\n\t\tptr += 2;\n\n\t\t/* Check for a spacer, these are valid, anything else is not */\n\t\tif (*ptr == ':' || *ptr == '-' || *ptr == '.')\n\t\t{\n\t\t\t/* remember the spacer used, if it changes then it isn't valid */\n\t\t\tif (spacer == '\\0')\n\t\t\t\tspacer = *ptr;\n\n\t\t\t/* Have to use the same spacer throughout */\n\t\t\telse if (spacer != *ptr)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\t\t\tstr)));\n\n\t\t\t/* move past the spacer */\n\t\t\tptr++;\n\t\t}\n\n\t\t/* allow trailing whitespace after if we have 6 or 8 bytes */\n\t\tif (count == 6 || count == 8)\n\t\t{\n\t\t\tif (isspace(*ptr))\n\t\t\t{\n\t\t\t\twhile (*++ptr && isspace(*ptr));\n\n\t\t\t\t/* If we found a space and then non-space, it's invalid */\n\t\t\t\tif (*ptr)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\t\t\t\tstr)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Convert a 6 byte MAC address to macaddr8 */\n\tif (count == 6)\n\t{\n\t\th = f;\n\t\tg = e;\n\t\tf = d;\n\n\t\td = 0xFF;\n\t\te = 0xFE;\n\t}\n\telse if (count != 8)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\tstr)));\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\n\tresult->a = a;\n\tresult->b = b;\n\tresult->c = c;\n\tresult->d = d;\n\tresult->e = e;\n\tresult->f = f;\n\tresult->g = g;\n\tresult->h = h;\n\n\tPG_RETURN_MACADDR8_P(result);\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char hex2_to_uchar(const unsigned char *str, const unsigned char *ptr);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_MACADDR8_P",
          "args": [
            "result"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(macaddr8)"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\tstr))"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "\"macaddr8\"",
            "str"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\t\t\t\tstr))"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*ptr"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\t\t\tstr))"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\t\t\tstr))"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex2_to_uchar",
          "args": [
            "ptr",
            "str"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "hex2_to_uchar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
          "lines": "60-98",
          "snippet": "static inline unsigned char\nhex2_to_uchar(const unsigned char *ptr, const unsigned char *str)\n{\n\tunsigned char ret = 0;\n\tsigned char lookup;\n\n\t/* Handle the first character */\n\tif (*ptr > 127)\n\t\tgoto invalid_input;\n\n\tlookup = hexlookup[*ptr];\n\tif (lookup < 0)\n\t\tgoto invalid_input;\n\n\tret = lookup << 4;\n\n\t/* Move to the second character */\n\tptr++;\n\n\tif (*ptr > 127)\n\t\tgoto invalid_input;\n\n\tlookup = hexlookup[*ptr];\n\tif (lookup < 0)\n\t\tgoto invalid_input;\n\n\tret += lookup;\n\n\treturn ret;\n\ninvalid_input:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\tstr)));\n\n\t/* We do not actually reach here */\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char hex2_to_uchar(const unsigned char *str, const unsigned char *ptr);",
            "static const signed char hexlookup[128] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic unsigned char hex2_to_uchar(const unsigned char *str, const unsigned char *ptr);\nstatic const signed char hexlookup[128] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n};\n\nstatic inline unsigned char\nhex2_to_uchar(const unsigned char *ptr, const unsigned char *str)\n{\n\tunsigned char ret = 0;\n\tsigned char lookup;\n\n\t/* Handle the first character */\n\tif (*ptr > 127)\n\t\tgoto invalid_input;\n\n\tlookup = hexlookup[*ptr];\n\tif (lookup < 0)\n\t\tgoto invalid_input;\n\n\tret = lookup << 4;\n\n\t/* Move to the second character */\n\tptr++;\n\n\tif (*ptr > 127)\n\t\tgoto invalid_input;\n\n\tlookup = hexlookup[*ptr];\n\tif (lookup < 0)\n\t\tgoto invalid_input;\n\n\tret += lookup;\n\n\treturn ret;\n\ninvalid_input:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\tstr)));\n\n\t/* We do not actually reach here */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic unsigned char hex2_to_uchar(const unsigned char *str, const unsigned char *ptr);\n\nDatum\nmacaddr8_in(PG_FUNCTION_ARGS)\n{\n\tconst unsigned char *str = (unsigned char *) PG_GETARG_CSTRING(0);\n\tconst unsigned char *ptr = str;\n\tmacaddr8   *result;\n\tunsigned char a = 0,\n\t\t\t\tb = 0,\n\t\t\t\tc = 0,\n\t\t\t\td = 0,\n\t\t\t\te = 0,\n\t\t\t\tf = 0,\n\t\t\t\tg = 0,\n\t\t\t\th = 0;\n\tint\t\t\tcount = 0;\n\tunsigned char spacer = '\\0';\n\n\t/* skip leading spaces */\n\twhile (*ptr && isspace(*ptr))\n\t\tptr++;\n\n\t/* digits must always come in pairs */\n\twhile (*ptr && *(ptr + 1))\n\t{\n\t\t/*\n\t\t * Attempt to decode each byte, which must be 2 hex digits in a row.\n\t\t * If either digit is not hex, hex2_to_uchar will throw ereport() for\n\t\t * us.  Either 6 or 8 byte MAC addresses are supported.\n\t\t */\n\n\t\t/* Attempt to collect a byte */\n\t\tcount++;\n\n\t\tswitch (count)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\ta = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tb = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tc = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\td = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\te = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tf = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tg = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\th = hex2_to_uchar(ptr, str);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* must be trailing garbage... */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\t\t\tstr)));\n\t\t}\n\n\t\t/* Move forward to where the next byte should be */\n\t\tptr += 2;\n\n\t\t/* Check for a spacer, these are valid, anything else is not */\n\t\tif (*ptr == ':' || *ptr == '-' || *ptr == '.')\n\t\t{\n\t\t\t/* remember the spacer used, if it changes then it isn't valid */\n\t\t\tif (spacer == '\\0')\n\t\t\t\tspacer = *ptr;\n\n\t\t\t/* Have to use the same spacer throughout */\n\t\t\telse if (spacer != *ptr)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\t\t\tstr)));\n\n\t\t\t/* move past the spacer */\n\t\t\tptr++;\n\t\t}\n\n\t\t/* allow trailing whitespace after if we have 6 or 8 bytes */\n\t\tif (count == 6 || count == 8)\n\t\t{\n\t\t\tif (isspace(*ptr))\n\t\t\t{\n\t\t\t\twhile (*++ptr && isspace(*ptr));\n\n\t\t\t\t/* If we found a space and then non-space, it's invalid */\n\t\t\t\tif (*ptr)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\t\t\t\tstr)));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Convert a 6 byte MAC address to macaddr8 */\n\tif (count == 6)\n\t{\n\t\th = f;\n\t\tg = e;\n\t\tf = d;\n\n\t\td = 0xFF;\n\t\te = 0xFE;\n\t}\n\telse if (count != 8)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\t\tstr)));\n\n\tresult = (macaddr8 *) palloc0(sizeof(macaddr8));\n\n\tresult->a = a;\n\tresult->b = b;\n\tresult->c = c;\n\tresult->d = d;\n\tresult->e = e;\n\tresult->f = f;\n\tresult->g = g;\n\tresult->h = h;\n\n\tPG_RETURN_MACADDR8_P(result);\n}"
  },
  {
    "function_name": "hex2_to_uchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/mac8.c",
    "lines": "60-98",
    "snippet": "static inline unsigned char\nhex2_to_uchar(const unsigned char *ptr, const unsigned char *str)\n{\n\tunsigned char ret = 0;\n\tsigned char lookup;\n\n\t/* Handle the first character */\n\tif (*ptr > 127)\n\t\tgoto invalid_input;\n\n\tlookup = hexlookup[*ptr];\n\tif (lookup < 0)\n\t\tgoto invalid_input;\n\n\tret = lookup << 4;\n\n\t/* Move to the second character */\n\tptr++;\n\n\tif (*ptr > 127)\n\t\tgoto invalid_input;\n\n\tlookup = hexlookup[*ptr];\n\tif (lookup < 0)\n\t\tgoto invalid_input;\n\n\tret += lookup;\n\n\treturn ret;\n\ninvalid_input:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\tstr)));\n\n\t/* We do not actually reach here */\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/hash.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char hex2_to_uchar(const unsigned char *str, const unsigned char *ptr);",
      "static const signed char hexlookup[128] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\tstr))"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "\"macaddr8\"",
            "str"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TEXT_REPRESENTATION"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic unsigned char hex2_to_uchar(const unsigned char *str, const unsigned char *ptr);\nstatic const signed char hexlookup[128] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n};\n\nstatic inline unsigned char\nhex2_to_uchar(const unsigned char *ptr, const unsigned char *str)\n{\n\tunsigned char ret = 0;\n\tsigned char lookup;\n\n\t/* Handle the first character */\n\tif (*ptr > 127)\n\t\tgoto invalid_input;\n\n\tlookup = hexlookup[*ptr];\n\tif (lookup < 0)\n\t\tgoto invalid_input;\n\n\tret = lookup << 4;\n\n\t/* Move to the second character */\n\tptr++;\n\n\tif (*ptr > 127)\n\t\tgoto invalid_input;\n\n\tlookup = hexlookup[*ptr];\n\tif (lookup < 0)\n\t\tgoto invalid_input;\n\n\tret += lookup;\n\n\treturn ret;\n\ninvalid_input:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\", \"macaddr8\",\n\t\t\t\t\tstr)));\n\n\t/* We do not actually reach here */\n\treturn 0;\n}"
  }
]