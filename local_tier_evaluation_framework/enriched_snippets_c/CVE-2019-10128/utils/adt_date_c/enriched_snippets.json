[
  {
    "function_name": "timetz_izone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2835-2863",
    "snippet": "Datum\ntimetz_izone(PG_FUNCTION_ARGS)\n{\n\tInterval   *zone = PG_GETARG_INTERVAL_P(0);\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(1);\n\tTimeTzADT  *result;\n\tint\t\t\ttz;\n\n\tif (zone->month != 0 || zone->day != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))))));\n\n\ttz = -(zone->time / USECS_PER_SEC);\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time->time + (time->zone - tz) * USECS_PER_SEC;\n\twhile (result->time < INT64CONST(0))\n\t\tresult->time += USECS_PER_DAY;\n\twhile (result->time >= USECS_PER_DAY)\n\t\tresult->time -= USECS_PER_DAY;\n\n\tresult->zone = tz;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeTzADT)"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone)))))"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"interval time zone \\\"%s\\\" must not include months or days\"",
            "DatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone)))"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "interval_out",
            "PointerGetDatum(zone)"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "zone"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimetz_izone(PG_FUNCTION_ARGS)\n{\n\tInterval   *zone = PG_GETARG_INTERVAL_P(0);\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(1);\n\tTimeTzADT  *result;\n\tint\t\t\ttz;\n\n\tif (zone->month != 0 || zone->day != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))))));\n\n\ttz = -(zone->time / USECS_PER_SEC);\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time->time + (time->zone - tz) * USECS_PER_SEC;\n\twhile (result->time < INT64CONST(0))\n\t\tresult->time += USECS_PER_DAY;\n\twhile (result->time >= USECS_PER_DAY)\n\t\tresult->time -= USECS_PER_DAY;\n\n\tresult->zone = tz;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "timetz_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2753-2830",
    "snippet": "Datum\ntimetz_zone(PG_FUNCTION_ARGS)\n{\n\ttext\t   *zone = PG_GETARG_TEXT_PP(0);\n\tTimeTzADT  *t = PG_GETARG_TIMETZADT_P(1);\n\tTimeTzADT  *result;\n\tint\t\t\ttz;\n\tchar\t\ttzname[TZ_STRLEN_MAX + 1];\n\tchar\t   *lowzone;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tpg_tz\t   *tzp;\n\n\t/*\n\t * Look up the requested timezone.  First we look in the timezone\n\t * abbreviation table (to handle cases like \"EST\"), and if that fails, we\n\t * look in the timezone database (to handle cases like\n\t * \"America/New_York\").  (This matches the order in which timestamp input\n\t * checks the cases; it's important because the timezone database unwisely\n\t * uses a few zone names that are identical to offset abbreviations.)\n\t */\n\ttext_to_cstring_buffer(zone, tzname, sizeof(tzname));\n\n\t/* DecodeTimezoneAbbrev requires lowercase input */\n\tlowzone = downcase_truncate_identifier(tzname,\n\t\t\t\t\t\t\t\t\t\t   strlen(tzname),\n\t\t\t\t\t\t\t\t\t\t   false);\n\n\ttype = DecodeTimezoneAbbrev(0, lowzone, &val, &tzp);\n\n\tif (type == TZ || type == DTZ)\n\t{\n\t\t/* fixed-offset abbreviation */\n\t\ttz = -val;\n\t}\n\telse if (type == DYNTZ)\n\t{\n\t\t/* dynamic-offset abbreviation, resolve using current time */\n\t\tpg_time_t\tnow = (pg_time_t) time(NULL);\n\t\tstruct pg_tm *tm;\n\n\t\ttm = pg_localtime(&now, tzp);\n\t\ttz = DetermineTimeZoneAbbrevOffset(tm, tzname, tzp);\n\t}\n\telse\n\t{\n\t\t/* try it as a full zone name */\n\t\ttzp = pg_tzset(tzname);\n\t\tif (tzp)\n\t\t{\n\t\t\t/* Get the offset-from-GMT that is valid today for the zone */\n\t\t\tpg_time_t\tnow = (pg_time_t) time(NULL);\n\t\t\tstruct pg_tm *tm;\n\n\t\t\ttm = pg_localtime(&now, tzp);\n\t\t\ttz = -tm->tm_gmtoff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\t\t\ttz = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = t->time + (t->zone - tz) * USECS_PER_SEC;\n\twhile (result->time < INT64CONST(0))\n\t\tresult->time += USECS_PER_DAY;\n\twhile (result->time >= USECS_PER_DAY)\n\t\tresult->time -= USECS_PER_DAY;\n\n\tresult->zone = tz;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeTzADT)"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname))"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"time zone \\\"%s\\\" not recognized\"",
            "tzname"
          ],
          "line": 2814
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_localtime",
          "args": [
            "&now",
            "tzp"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_izone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2835-2863",
          "snippet": "Datum\ntimetz_izone(PG_FUNCTION_ARGS)\n{\n\tInterval   *zone = PG_GETARG_INTERVAL_P(0);\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(1);\n\tTimeTzADT  *result;\n\tint\t\t\ttz;\n\n\tif (zone->month != 0 || zone->day != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))))));\n\n\ttz = -(zone->time / USECS_PER_SEC);\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time->time + (time->zone - tz) * USECS_PER_SEC;\n\twhile (result->time < INT64CONST(0))\n\t\tresult->time += USECS_PER_DAY;\n\twhile (result->time >= USECS_PER_DAY)\n\t\tresult->time -= USECS_PER_DAY;\n\n\tresult->zone = tz;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimetz_izone(PG_FUNCTION_ARGS)\n{\n\tInterval   *zone = PG_GETARG_INTERVAL_P(0);\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(1);\n\tTimeTzADT  *result;\n\tint\t\t\ttz;\n\n\tif (zone->month != 0 || zone->day != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"interval time zone \\\"%s\\\" must not include months or days\",\n\t\t\t\t\t\tDatumGetCString(DirectFunctionCall1(interval_out,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(zone))))));\n\n\ttz = -(zone->time / USECS_PER_SEC);\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time->time + (time->zone - tz) * USECS_PER_SEC;\n\twhile (result->time < INT64CONST(0))\n\t\tresult->time += USECS_PER_DAY;\n\twhile (result->time >= USECS_PER_DAY)\n\t\tresult->time -= USECS_PER_DAY;\n\n\tresult->zone = tz;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_tzset",
          "args": [
            "tzname"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneAbbrevOffset",
          "args": [
            "tm",
            "tzname",
            "tzp"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneAbbrevOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1615-1645",
          "snippet": "int\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneAbbrevOffset(struct pg_tm *tm, const char *abbr, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\tint\t\t\tzone_offset;\n\tint\t\t\tabbr_offset;\n\tint\t\t\tabbr_isdst;\n\n\t/*\n\t * Compute the UTC time we want to probe at.  (In event of overflow, we'll\n\t * probe at the epoch, which is a bit random but probably doesn't matter.)\n\t */\n\tzone_offset = DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n\n\t/*\n\t * Try to match the abbreviation to something in the zone definition.\n\t */\n\tif (DetermineTimeZoneAbbrevOffsetInternal(t, abbr, tzp,\n\t\t\t\t\t\t\t\t\t\t\t  &abbr_offset, &abbr_isdst))\n\t{\n\t\t/* Success, so use the abbrev-specific answers. */\n\t\ttm->tm_isdst = abbr_isdst;\n\t\treturn abbr_offset;\n\t}\n\n\t/*\n\t * No match, so use the answers we already got from\n\t * DetermineTimeZoneOffsetInternal.\n\t */\n\treturn zone_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_localtime",
          "args": [
            "&now",
            "tzp"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeTimezoneAbbrev",
          "args": [
            "0",
            "lowzone",
            "&val",
            "&tzp"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimezoneAbbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2970-3010",
          "snippet": "int\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static TimeZoneAbbrevTable *zoneabbrevtbl = NULL;",
            "static const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic TimeZoneAbbrevTable *zoneabbrevtbl = NULL;\nstatic const datetkn *abbrevcache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeTimezoneAbbrev(int field, char *lowtoken,\n\t\t\t\t\t int *offset, pg_tz **tz)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = abbrevcache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\tif (zoneabbrevtbl)\n\t\t\ttp = datebsearch(lowtoken, zoneabbrevtbl->abbrevs,\n\t\t\t\t\t\t\t zoneabbrevtbl->numabbrevs);\n\t\telse\n\t\t\ttp = NULL;\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*offset = 0;\n\t\t*tz = NULL;\n\t}\n\telse\n\t{\n\t\tabbrevcache[field] = tp;\n\t\ttype = tp->type;\n\t\tif (type == DYNTZ)\n\t\t{\n\t\t\t*offset = 0;\n\t\t\t*tz = FetchDynamicTimeZone(zoneabbrevtbl, tp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*offset = tp->value;\n\t\t\t*tz = NULL;\n\t\t}\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "tzname",
            "strlen(tzname)",
            "false"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tzname"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring_buffer",
          "args": [
            "zone",
            "tzname",
            "sizeof(tzname)"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "212-232",
          "snippet": "void\ntext_to_cstring_buffer(const text *src, char *dst, size_t dst_len)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *srcunpacked = pg_detoast_datum_packed((struct varlena *) src);\n\tsize_t\t\tsrc_len = VARSIZE_ANY_EXHDR(srcunpacked);\n\n\tif (dst_len > 0)\n\t{\n\t\tdst_len--;\n\t\tif (dst_len >= src_len)\n\t\t\tdst_len = src_len;\n\t\telse\t\t\t\t\t/* ensure truncation is encoding-safe */\n\t\t\tdst_len = pg_mbcliplen(VARDATA_ANY(srcunpacked), src_len, dst_len);\n\t\tmemcpy(dst, VARDATA_ANY(srcunpacked), dst_len);\n\t\tdst[dst_len] = '\\0';\n\t}\n\n\tif (srcunpacked != src)\n\t\tpfree(srcunpacked);\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\ntext_to_cstring_buffer(const text *src, char *dst, size_t dst_len)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *srcunpacked = pg_detoast_datum_packed((struct varlena *) src);\n\tsize_t\t\tsrc_len = VARSIZE_ANY_EXHDR(srcunpacked);\n\n\tif (dst_len > 0)\n\t{\n\t\tdst_len--;\n\t\tif (dst_len >= src_len)\n\t\t\tdst_len = src_len;\n\t\telse\t\t\t\t\t/* ensure truncation is encoding-safe */\n\t\t\tdst_len = pg_mbcliplen(VARDATA_ANY(srcunpacked), src_len, dst_len);\n\t\tmemcpy(dst, VARDATA_ANY(srcunpacked), dst_len);\n\t\tdst[dst_len] = '\\0';\n\t}\n\n\tif (srcunpacked != src)\n\t\tpfree(srcunpacked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimetz_zone(PG_FUNCTION_ARGS)\n{\n\ttext\t   *zone = PG_GETARG_TEXT_PP(0);\n\tTimeTzADT  *t = PG_GETARG_TIMETZADT_P(1);\n\tTimeTzADT  *result;\n\tint\t\t\ttz;\n\tchar\t\ttzname[TZ_STRLEN_MAX + 1];\n\tchar\t   *lowzone;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tpg_tz\t   *tzp;\n\n\t/*\n\t * Look up the requested timezone.  First we look in the timezone\n\t * abbreviation table (to handle cases like \"EST\"), and if that fails, we\n\t * look in the timezone database (to handle cases like\n\t * \"America/New_York\").  (This matches the order in which timestamp input\n\t * checks the cases; it's important because the timezone database unwisely\n\t * uses a few zone names that are identical to offset abbreviations.)\n\t */\n\ttext_to_cstring_buffer(zone, tzname, sizeof(tzname));\n\n\t/* DecodeTimezoneAbbrev requires lowercase input */\n\tlowzone = downcase_truncate_identifier(tzname,\n\t\t\t\t\t\t\t\t\t\t   strlen(tzname),\n\t\t\t\t\t\t\t\t\t\t   false);\n\n\ttype = DecodeTimezoneAbbrev(0, lowzone, &val, &tzp);\n\n\tif (type == TZ || type == DTZ)\n\t{\n\t\t/* fixed-offset abbreviation */\n\t\ttz = -val;\n\t}\n\telse if (type == DYNTZ)\n\t{\n\t\t/* dynamic-offset abbreviation, resolve using current time */\n\t\tpg_time_t\tnow = (pg_time_t) time(NULL);\n\t\tstruct pg_tm *tm;\n\n\t\ttm = pg_localtime(&now, tzp);\n\t\ttz = DetermineTimeZoneAbbrevOffset(tm, tzname, tzp);\n\t}\n\telse\n\t{\n\t\t/* try it as a full zone name */\n\t\ttzp = pg_tzset(tzname);\n\t\tif (tzp)\n\t\t{\n\t\t\t/* Get the offset-from-GMT that is valid today for the zone */\n\t\t\tpg_time_t\tnow = (pg_time_t) time(NULL);\n\t\t\tstruct pg_tm *tm;\n\n\t\t\ttm = pg_localtime(&now, tzp);\n\t\t\ttz = -tm->tm_gmtoff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\", tzname)));\n\t\t\ttz = 0;\t\t\t\t/* keep compiler quiet */\n\t\t}\n\t}\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = t->time + (t->zone - tz) * USECS_PER_SEC;\n\twhile (result->time < INT64CONST(0))\n\t\tresult->time += USECS_PER_DAY;\n\twhile (result->time >= USECS_PER_DAY)\n\t\tresult->time -= USECS_PER_DAY;\n\n\tresult->zone = tz;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "timetz_part",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2653-2747",
    "snippet": "Datum\ntimetz_part(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(1);\n\tfloat8\t\tresult;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\tif (type == UNKNOWN_FIELD)\n\t\ttype = DecodeSpecial(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tdouble\t\tdummy;\n\t\tint\t\t\ttz;\n\t\tfsec_t\t\tfsec;\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tm = &tt;\n\n\t\ttimetz2tm(time, tm, &fsec, &tz);\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_TZ:\n\t\t\t\tresult = -tz;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ_MINUTE:\n\t\t\t\tresult = -tz;\n\t\t\t\tresult /= SECS_PER_MINUTE;\n\t\t\t\tFMODULO(result, dummy, (double) SECS_PER_MINUTE);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ_HOUR:\n\t\t\t\tdummy = -tz;\n\t\t\t\tFMODULO(dummy, result, (double) SECS_PER_HOUR);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tresult = tm->tm_sec * 1000000.0 + fsec;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tresult = tm->tm_sec * 1000.0 + fsec / 1000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_SECOND:\n\t\t\t\tresult = tm->tm_sec + fsec / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MINUTE:\n\t\t\t\tresult = tm->tm_min;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_HOUR:\n\t\t\t\tresult = tm->tm_hour;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DAY:\n\t\t\tcase DTK_MONTH:\n\t\t\tcase DTK_QUARTER:\n\t\t\tcase DTK_YEAR:\n\t\t\tcase DTK_DECADE:\n\t\t\tcase DTK_CENTURY:\n\t\t\tcase DTK_MILLENNIUM:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"\\\"time with time zone\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\t}\n\telse if (type == RESERV && val == DTK_EPOCH)\n\t{\n\t\tresult = time->time / 1000000.0 + time->zone;\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"time with time zone\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"time with time zone\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits))"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"\\\"time with time zone\\\" units \\\"%s\\\" not recognized\"",
            "lowunits"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"\\\"time with time zone\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FMODULO",
          "args": [
            "dummy",
            "result",
            "(double) SECS_PER_HOUR"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FMODULO",
          "args": [
            "result",
            "dummy",
            "(double) SECS_PER_MINUTE"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz2tm",
          "args": [
            "time",
            "tm",
            "&fsec",
            "&tz"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "timetz2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2141-2157",
          "snippet": "int\ntimetz2tm(TimeTzADT *time, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tTimeOffset\ttrem = time->time;\n\n\ttm->tm_hour = trem / USECS_PER_HOUR;\n\ttrem -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = trem / USECS_PER_MINUTE;\n\ttrem -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = trem / USECS_PER_SEC;\n\t*fsec = trem - tm->tm_sec * USECS_PER_SEC;\n\n\tif (tzp != NULL)\n\t\t*tzp = time->zone;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimetz2tm(TimeTzADT *time, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tTimeOffset\ttrem = time->time;\n\n\ttm->tm_hour = trem / USECS_PER_HOUR;\n\ttrem -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = trem / USECS_PER_MINUTE;\n\ttrem -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = trem / USECS_PER_SEC;\n\t*fsec = trem - tm->tm_sec * USECS_PER_SEC;\n\n\tif (tzp != NULL)\n\t\t*tzp = time->zone;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeSpecial",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3025-3050",
          "snippet": "int\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];",
            "static const datetkn *datecache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\nstatic const datetkn *datecache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeUnits",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeUnits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3716-3741",
          "snippet": "int\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
            "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];",
            "static const datetkn *deltacache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\nstatic const datetkn *deltacache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "VARDATA_ANY(units)",
            "VARSIZE_ANY_EXHDR(units)",
            "false"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "units"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "units"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimetz_part(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(1);\n\tfloat8\t\tresult;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\tif (type == UNKNOWN_FIELD)\n\t\ttype = DecodeSpecial(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tdouble\t\tdummy;\n\t\tint\t\t\ttz;\n\t\tfsec_t\t\tfsec;\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tm = &tt;\n\n\t\ttimetz2tm(time, tm, &fsec, &tz);\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_TZ:\n\t\t\t\tresult = -tz;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ_MINUTE:\n\t\t\t\tresult = -tz;\n\t\t\t\tresult /= SECS_PER_MINUTE;\n\t\t\t\tFMODULO(result, dummy, (double) SECS_PER_MINUTE);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ_HOUR:\n\t\t\t\tdummy = -tz;\n\t\t\t\tFMODULO(dummy, result, (double) SECS_PER_HOUR);\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tresult = tm->tm_sec * 1000000.0 + fsec;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tresult = tm->tm_sec * 1000.0 + fsec / 1000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_SECOND:\n\t\t\t\tresult = tm->tm_sec + fsec / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MINUTE:\n\t\t\t\tresult = tm->tm_min;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_HOUR:\n\t\t\t\tresult = tm->tm_hour;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_DAY:\n\t\t\tcase DTK_MONTH:\n\t\t\tcase DTK_QUARTER:\n\t\t\tcase DTK_YEAR:\n\t\t\tcase DTK_DECADE:\n\t\t\tcase DTK_CENTURY:\n\t\t\tcase DTK_MILLENNIUM:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"\\\"time with time zone\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\t}\n\telse if (type == RESERV && val == DTK_EPOCH)\n\t{\n\t\tresult = time->time / 1000000.0 + time->zone;\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"time with time zone\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "datetimetz_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2612-2647",
    "snippet": "Datum\ndatetimetz_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdate = PG_GETARG_DATEADT(0);\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(1);\n\tTimestampTz result;\n\n\tif (DATE_IS_NOBEGIN(date))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(date))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (date >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t\tresult = date * USECS_PER_DAY + time->time + time->zone * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\"))"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date out of range for timestamp\""
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 2642
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\"))"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 2622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_IS_NOEND",
          "args": [
            "date"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_IS_NOBEGIN",
          "args": [
            "date"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ndatetimetz_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdate = PG_GETARG_DATEADT(0);\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(1);\n\tTimestampTz result;\n\n\tif (DATE_IS_NOBEGIN(date))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(date))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (date >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t\tresult = date * USECS_PER_DAY + time->time + time->zone * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamptz_timetz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2580-2603",
    "snippet": "Datum\ntimestamptz_timetz(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMP(0);\n\tTimeTzADT  *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_NULL();\n\n\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\ttm2timetz(tm, fsec, tz, result);\n\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm2timetz",
          "args": [
            "tm",
            "fsec",
            "tz",
            "result"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timetz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2007-2015",
          "snippet": "static int\ntm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result)\n{\n\tresult->time = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t\t\tUSECS_PER_SEC) + fsec;\n\tresult->zone = tz;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic int\ntm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result)\n{\n\tresult->time = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t\t\tUSECS_PER_SEC) + fsec;\n\tresult->zone = tz;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeTzADT)"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimestamptz_timetz(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMP(0);\n\tTimeTzADT  *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_NULL();\n\n\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\ttm2timetz(tm, fsec, tz, result);\n\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "time_timetz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2554-2574",
    "snippet": "Datum\ntime_timetz(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tTimeTzADT  *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tGetCurrentDateTime(tm);\n\ttime2tm(time, tm, &fsec);\n\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time;\n\tresult->zone = tz;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeTzADT)"
          ],
          "line": 2568
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "tm",
            "session_timezone"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time2tm",
          "args": [
            "time",
            "tm",
            "&fsec"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "time2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1278-1289",
          "snippet": "int\ntime2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_hour = time / USECS_PER_HOUR;\n\ttime -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = time / USECS_PER_MINUTE;\n\ttime -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = time / USECS_PER_SEC;\n\ttime -= tm->tm_sec * USECS_PER_SEC;\n\t*fsec = time;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntime2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_hour = time / USECS_PER_HOUR;\n\ttime -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = time / USECS_PER_MINUTE;\n\ttime -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = time / USECS_PER_SEC;\n\ttime -= tm->tm_sec * USECS_PER_SEC;\n\t*fsec = time;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentDateTime",
          "args": [
            "tm"
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "353-362",
          "snippet": "void\nGetCurrentDateTime(struct pg_tm *tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nGetCurrentDateTime(struct pg_tm *tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntime_timetz(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tTimeTzADT  *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tGetCurrentDateTime(tm);\n\ttime2tm(time, tm, &fsec);\n\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time;\n\tresult->zone = tz;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "timetz_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2541-2551",
    "snippet": "Datum\ntimetz_time(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *timetz = PG_GETARG_TIMETZADT_P(0);\n\tTimeADT\t\tresult;\n\n\t/* swallow the time zone and just return the time */\n\tresult = timetz->time;\n\n\tPG_RETURN_TIMEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "result"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimetz_time(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *timetz = PG_GETARG_TIMETZADT_P(0);\n\tTimeADT\t\tresult;\n\n\t/* swallow the time zone and just return the time */\n\tresult = timetz->time;\n\n\tPG_RETURN_TIMEADT(result);\n}"
  },
  {
    "function_name": "overlaps_timetz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2421-2538",
    "snippet": "Datum\noverlaps_timetz(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * The arguments are TimeTzADT *, but we leave them as generic Datums for\n\t * convenience of notation --- and to avoid dereferencing nulls.\n\t */\n\tDatum\t\tts1 = PG_GETARG_DATUM(0);\n\tDatum\t\tte1 = PG_GETARG_DATUM(1);\n\tDatum\t\tts2 = PG_GETARG_DATUM(2);\n\tDatum\t\tte2 = PG_GETARG_DATUM(3);\n\tbool\t\tts1IsNull = PG_ARGISNULL(0);\n\tbool\t\tte1IsNull = PG_ARGISNULL(1);\n\tbool\t\tts2IsNull = PG_ARGISNULL(2);\n\tbool\t\tte2IsNull = PG_ARGISNULL(3);\n\n#define TIMETZ_GT(t1,t2) \\\n\tDatumGetBool(DirectFunctionCall2(timetz_gt,t1,t2))\n#define TIMETZ_LT(t1,t2) \\\n\tDatumGetBool(DirectFunctionCall2(timetz_lt,t1,t2))\n\n\t/*\n\t * If both endpoints of interval 1 are null, the result is null (unknown).\n\t * If just one endpoint is null, take ts1 as the non-null one. Otherwise,\n\t * take ts1 as the lesser endpoint.\n\t */\n\tif (ts1IsNull)\n\t{\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts1 = te1;\n\t\tte1IsNull = true;\n\t}\n\telse if (!te1IsNull)\n\t{\n\t\tif (TIMETZ_GT(ts1, te1))\n\t\t{\n\t\t\tDatum\t\ttt = ts1;\n\n\t\t\tts1 = te1;\n\t\t\tte1 = tt;\n\t\t}\n\t}\n\n\t/* Likewise for interval 2. */\n\tif (ts2IsNull)\n\t{\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts2 = te2;\n\t\tte2IsNull = true;\n\t}\n\telse if (!te2IsNull)\n\t{\n\t\tif (TIMETZ_GT(ts2, te2))\n\t\t{\n\t\t\tDatum\t\ttt = ts2;\n\n\t\t\tts2 = te2;\n\t\t\tte2 = tt;\n\t\t}\n\t}\n\n\t/*\n\t * At this point neither ts1 nor ts2 is null, so we can consider three\n\t * cases: ts1 > ts2, ts1 < ts2, ts1 = ts2\n\t */\n\tif (TIMETZ_GT(ts1, ts2))\n\t{\n\t\t/*\n\t\t * This case is ts1 < te2 OR te1 < te2, which may look redundant but\n\t\t * in the presence of nulls it's not quite completely so.\n\t\t */\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMETZ_LT(ts1, te2))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te1 is not null then we had ts1 <= te1 above, and we just found\n\t\t * ts1 >= te2, hence te1 >= te2.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse if (TIMETZ_LT(ts1, ts2))\n\t{\n\t\t/* This case is ts2 < te1 OR te2 < te1 */\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMETZ_LT(ts2, te1))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te2 is not null then we had ts2 <= te2 above, and we just found\n\t\t * ts2 >= te1, hence te2 >= te1.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For ts1 = ts2 the spec says te1 <> te2 OR te1 = te2, which is a\n\t\t * rather silly way of saying \"true if both are nonnull, else null\".\n\t\t */\n\t\tif (te1IsNull || te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(true);\n\t}\n\n#undef TIMETZ_GT\n#undef TIMETZ_LT\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMETZ_LT",
          "args": [
            "ts2",
            "te1"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMETZ_LT",
          "args": [
            "ts1",
            "ts2"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMETZ_LT",
          "args": [
            "ts1",
            "te2"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMETZ_GT",
          "args": [
            "ts1",
            "ts2"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMETZ_GT",
          "args": [
            "ts2",
            "te2"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMETZ_GT",
          "args": [
            "ts1",
            "te1"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "3"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "3"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "2"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\noverlaps_timetz(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * The arguments are TimeTzADT *, but we leave them as generic Datums for\n\t * convenience of notation --- and to avoid dereferencing nulls.\n\t */\n\tDatum\t\tts1 = PG_GETARG_DATUM(0);\n\tDatum\t\tte1 = PG_GETARG_DATUM(1);\n\tDatum\t\tts2 = PG_GETARG_DATUM(2);\n\tDatum\t\tte2 = PG_GETARG_DATUM(3);\n\tbool\t\tts1IsNull = PG_ARGISNULL(0);\n\tbool\t\tte1IsNull = PG_ARGISNULL(1);\n\tbool\t\tts2IsNull = PG_ARGISNULL(2);\n\tbool\t\tte2IsNull = PG_ARGISNULL(3);\n\n#define TIMETZ_GT(t1,t2) \\\n\tDatumGetBool(DirectFunctionCall2(timetz_gt,t1,t2))\n#define TIMETZ_LT(t1,t2) \\\n\tDatumGetBool(DirectFunctionCall2(timetz_lt,t1,t2))\n\n\t/*\n\t * If both endpoints of interval 1 are null, the result is null (unknown).\n\t * If just one endpoint is null, take ts1 as the non-null one. Otherwise,\n\t * take ts1 as the lesser endpoint.\n\t */\n\tif (ts1IsNull)\n\t{\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts1 = te1;\n\t\tte1IsNull = true;\n\t}\n\telse if (!te1IsNull)\n\t{\n\t\tif (TIMETZ_GT(ts1, te1))\n\t\t{\n\t\t\tDatum\t\ttt = ts1;\n\n\t\t\tts1 = te1;\n\t\t\tte1 = tt;\n\t\t}\n\t}\n\n\t/* Likewise for interval 2. */\n\tif (ts2IsNull)\n\t{\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts2 = te2;\n\t\tte2IsNull = true;\n\t}\n\telse if (!te2IsNull)\n\t{\n\t\tif (TIMETZ_GT(ts2, te2))\n\t\t{\n\t\t\tDatum\t\ttt = ts2;\n\n\t\t\tts2 = te2;\n\t\t\tte2 = tt;\n\t\t}\n\t}\n\n\t/*\n\t * At this point neither ts1 nor ts2 is null, so we can consider three\n\t * cases: ts1 > ts2, ts1 < ts2, ts1 = ts2\n\t */\n\tif (TIMETZ_GT(ts1, ts2))\n\t{\n\t\t/*\n\t\t * This case is ts1 < te2 OR te1 < te2, which may look redundant but\n\t\t * in the presence of nulls it's not quite completely so.\n\t\t */\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMETZ_LT(ts1, te2))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te1 is not null then we had ts1 <= te1 above, and we just found\n\t\t * ts1 >= te2, hence te1 >= te2.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse if (TIMETZ_LT(ts1, ts2))\n\t{\n\t\t/* This case is ts2 < te1 OR te2 < te1 */\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMETZ_LT(ts2, te1))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te2 is not null then we had ts2 <= te2 above, and we just found\n\t\t * ts2 >= te1, hence te2 >= te1.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For ts1 = ts2 the spec says te1 <> te2 OR te1 = te2, which is a\n\t\t * rather silly way of saying \"true if both are nonnull, else null\".\n\t\t */\n\t\tif (te1IsNull || te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(true);\n\t}\n\n#undef TIMETZ_GT\n#undef TIMETZ_LT\n}"
  },
  {
    "function_name": "in_range_timetz_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2378-2413",
    "snippet": "Datum\nin_range_timetz_interval(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *val = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *base = PG_GETARG_TIMETZADT_P(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tTimeTzADT\tsum;\n\n\t/*\n\t * Like timetz_pl_interval/timetz_mi_interval, we disregard the month and\n\t * day fields of the offset.  So our test for negative should too.\n\t */\n\tif (offset->time < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/*\n\t * We can't use timetz_pl_interval/timetz_mi_interval here, because their\n\t * wraparound behavior would give wrong (or at least undesirable) answers.\n\t * Fortunately the equivalent non-wrapping behavior is trivial, especially\n\t * since we don't worry about integer overflow.\n\t */\n\tif (sub)\n\t\tsum.time = base->time - offset->time;\n\telse\n\t\tsum.time = base->time + offset->time;\n\tsum.zone = base->zone;\n\n\tif (less)\n\t\tPG_RETURN_BOOL(timetz_cmp_internal(val, &sum) <= 0);\n\telse\n\t\tPG_RETURN_BOOL(timetz_cmp_internal(val, &sum) >= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timetz_cmp_internal(val, &sum) >= 0"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz_cmp_internal",
          "args": [
            "val",
            "&sum"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2181-2206",
          "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timetz_cmp_internal(val, &sum) <= 0"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\"))"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid preceding or following size in window function\""
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "4"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "2"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nin_range_timetz_interval(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *val = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *base = PG_GETARG_TIMETZADT_P(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tTimeTzADT\tsum;\n\n\t/*\n\t * Like timetz_pl_interval/timetz_mi_interval, we disregard the month and\n\t * day fields of the offset.  So our test for negative should too.\n\t */\n\tif (offset->time < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/*\n\t * We can't use timetz_pl_interval/timetz_mi_interval here, because their\n\t * wraparound behavior would give wrong (or at least undesirable) answers.\n\t * Fortunately the equivalent non-wrapping behavior is trivial, especially\n\t * since we don't worry about integer overflow.\n\t */\n\tif (sub)\n\t\tsum.time = base->time - offset->time;\n\telse\n\t\tsum.time = base->time + offset->time;\n\tsum.zone = base->zone;\n\n\tif (less)\n\t\tPG_RETURN_BOOL(timetz_cmp_internal(val, &sum) <= 0);\n\telse\n\t\tPG_RETURN_BOOL(timetz_cmp_internal(val, &sum) >= 0);\n}"
  },
  {
    "function_name": "timetz_mi_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2356-2373",
    "snippet": "Datum\ntimetz_mi_interval(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimeTzADT  *result;\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time->time - span->time;\n\tresult->time -= result->time / USECS_PER_DAY * USECS_PER_DAY;\n\tif (result->time < INT64CONST(0))\n\t\tresult->time += USECS_PER_DAY;\n\n\tresult->zone = time->zone;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeTzADT)"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimetz_mi_interval(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimeTzADT  *result;\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time->time - span->time;\n\tresult->time -= result->time / USECS_PER_DAY * USECS_PER_DAY;\n\tif (result->time < INT64CONST(0))\n\t\tresult->time += USECS_PER_DAY;\n\n\tresult->zone = time->zone;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "timetz_pl_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2334-2351",
    "snippet": "Datum\ntimetz_pl_interval(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimeTzADT  *result;\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time->time + span->time;\n\tresult->time -= result->time / USECS_PER_DAY * USECS_PER_DAY;\n\tif (result->time < INT64CONST(0))\n\t\tresult->time += USECS_PER_DAY;\n\n\tresult->zone = time->zone;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeTzADT)"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimetz_pl_interval(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimeTzADT  *result;\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time->time + span->time;\n\tresult->time -= result->time / USECS_PER_DAY * USECS_PER_DAY;\n\tif (result->time < INT64CONST(0))\n\t\tresult->time += USECS_PER_DAY;\n\n\tresult->zone = time->zone;\n\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "timetz_smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2317-2329",
    "snippet": "Datum\ntimetz_smaller(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\tTimeTzADT  *result;\n\n\tif (timetz_cmp_internal(time1, time2) < 0)\n\t\tresult = time1;\n\telse\n\t\tresult = time2;\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz_cmp_internal",
          "args": [
            "time1",
            "time2"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2181-2206",
          "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimetz_smaller(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\tTimeTzADT  *result;\n\n\tif (timetz_cmp_internal(time1, time2) < 0)\n\t\tresult = time1;\n\telse\n\t\tresult = time2;\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "timetz_larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2303-2315",
    "snippet": "Datum\ntimetz_larger(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\tTimeTzADT  *result;\n\n\tif (timetz_cmp_internal(time1, time2) > 0)\n\t\tresult = time1;\n\telse\n\t\tresult = time2;\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz_cmp_internal",
          "args": [
            "time1",
            "time2"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2181-2206",
          "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimetz_larger(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\tTimeTzADT  *result;\n\n\tif (timetz_cmp_internal(time1, time2) > 0)\n\t\tresult = time1;\n\telse\n\t\tresult = time2;\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "timetz_hash_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2287-2301",
    "snippet": "Datum\ntimetz_hash_extended(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *key = PG_GETARG_TIMETZADT_P(0);\n\tDatum\t\tseed = PG_GETARG_DATUM(1);\n\tuint64\t\tthash;\n\n\t/* Same approach as timetz_hash */\n\tthash = DatumGetUInt64(DirectFunctionCall2(hashint8extended,\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatumFast(key->time),\n\t\t\t\t\t\t\t\t\t\t\t   seed));\n\tthash ^= DatumGetUInt64(hash_uint32_extended(key->zone,\n\t\t\t\t\t\t\t\t\t\t\t\t DatumGetInt64(seed)));\n\tPG_RETURN_UINT64(thash);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_UINT64",
          "args": [
            "thash"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt64",
          "args": [
            "hash_uint32_extended(key->zone,\n\t\t\t\t\t\t\t\t\t\t\t\t DatumGetInt64(seed))"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_uint32_extended",
          "args": [
            "key->zone",
            "DatumGetInt64(seed)"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetInt64",
          "args": [
            "seed"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt64",
          "args": [
            "DirectFunctionCall2(hashint8extended,\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatumFast(key->time),\n\t\t\t\t\t\t\t\t\t\t\t   seed)"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "hashint8extended",
            "Int64GetDatumFast(key->time)",
            "seed"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatumFast",
          "args": [
            "key->time"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetz_hash_extended(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *key = PG_GETARG_TIMETZADT_P(0);\n\tDatum\t\tseed = PG_GETARG_DATUM(1);\n\tuint64\t\tthash;\n\n\t/* Same approach as timetz_hash */\n\tthash = DatumGetUInt64(DirectFunctionCall2(hashint8extended,\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatumFast(key->time),\n\t\t\t\t\t\t\t\t\t\t\t   seed));\n\tthash ^= DatumGetUInt64(hash_uint32_extended(key->zone,\n\t\t\t\t\t\t\t\t\t\t\t\t DatumGetInt64(seed)));\n\tPG_RETURN_UINT64(thash);\n}"
  },
  {
    "function_name": "timetz_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2271-2285",
    "snippet": "Datum\ntimetz_hash(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *key = PG_GETARG_TIMETZADT_P(0);\n\tuint32\t\tthash;\n\n\t/*\n\t * To avoid any problems with padding bytes in the struct, we figure the\n\t * field hashes separately and XOR them.\n\t */\n\tthash = DatumGetUInt32(DirectFunctionCall1(hashint8,\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatumFast(key->time)));\n\tthash ^= DatumGetUInt32(hash_uint32(key->zone));\n\tPG_RETURN_UINT32(thash);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_UINT32",
          "args": [
            "thash"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "hash_uint32(key->zone)"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_uint32",
          "args": [
            "key->zone"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetUInt32",
          "args": [
            "DirectFunctionCall1(hashint8,\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatumFast(key->time))"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "hashint8",
            "Int64GetDatumFast(key->time)"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int64GetDatumFast",
          "args": [
            "key->time"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetz_hash(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *key = PG_GETARG_TIMETZADT_P(0);\n\tuint32\t\tthash;\n\n\t/*\n\t * To avoid any problems with padding bytes in the struct, we figure the\n\t * field hashes separately and XOR them.\n\t */\n\tthash = DatumGetUInt32(DirectFunctionCall1(hashint8,\n\t\t\t\t\t\t\t\t\t\t\t   Int64GetDatumFast(key->time)));\n\tthash ^= DatumGetUInt32(hash_uint32(key->zone));\n\tPG_RETURN_UINT32(thash);\n}"
  },
  {
    "function_name": "timetz_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2262-2269",
    "snippet": "Datum\ntimetz_cmp(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_INT32(timetz_cmp_internal(time1, time2));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "timetz_cmp_internal(time1, time2)"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz_cmp_internal",
          "args": [
            "time1",
            "time2"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2181-2206",
          "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetz_cmp(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_INT32(timetz_cmp_internal(time1, time2));\n}"
  },
  {
    "function_name": "timetz_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2253-2260",
    "snippet": "Datum\ntimetz_ge(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) >= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timetz_cmp_internal(time1, time2) >= 0"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz_cmp_internal",
          "args": [
            "time1",
            "time2"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2181-2206",
          "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetz_ge(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) >= 0);\n}"
  },
  {
    "function_name": "timetz_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2244-2251",
    "snippet": "Datum\ntimetz_gt(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) > 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timetz_cmp_internal(time1, time2) > 0"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz_cmp_internal",
          "args": [
            "time1",
            "time2"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2181-2206",
          "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetz_gt(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) > 0);\n}"
  },
  {
    "function_name": "timetz_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2235-2242",
    "snippet": "Datum\ntimetz_le(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) <= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timetz_cmp_internal(time1, time2) <= 0"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz_cmp_internal",
          "args": [
            "time1",
            "time2"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2181-2206",
          "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetz_le(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) <= 0);\n}"
  },
  {
    "function_name": "timetz_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2226-2233",
    "snippet": "Datum\ntimetz_lt(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) < 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timetz_cmp_internal(time1, time2) < 0"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz_cmp_internal",
          "args": [
            "time1",
            "time2"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2181-2206",
          "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetz_lt(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) < 0);\n}"
  },
  {
    "function_name": "timetz_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2217-2224",
    "snippet": "Datum\ntimetz_ne(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) != 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timetz_cmp_internal(time1, time2) != 0"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz_cmp_internal",
          "args": [
            "time1",
            "time2"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2181-2206",
          "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetz_ne(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) != 0);\n}"
  },
  {
    "function_name": "timetz_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2208-2215",
    "snippet": "Datum\ntimetz_eq(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) == 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timetz_cmp_internal(time1, time2) == 0"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timetz_cmp_internal",
          "args": [
            "time1",
            "time2"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "timetz_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2181-2206",
          "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "1"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetz_eq(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0);\n\tTimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1);\n\n\tPG_RETURN_BOOL(timetz_cmp_internal(time1, time2) == 0);\n}"
  },
  {
    "function_name": "timetz_cmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2181-2206",
    "snippet": "static int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ntimetz_cmp_internal(TimeTzADT *time1, TimeTzADT *time2)\n{\n\tTimeOffset\tt1,\n\t\t\t\tt2;\n\n\t/* Primary sort is by true (GMT-equivalent) time */\n\tt1 = time1->time + (time1->zone * USECS_PER_SEC);\n\tt2 = time2->time + (time2->zone * USECS_PER_SEC);\n\n\tif (t1 > t2)\n\t\treturn 1;\n\tif (t1 < t2)\n\t\treturn -1;\n\n\t/*\n\t * If same GMT time, sort by timezone; we only want to say that two\n\t * timetz's are equal if both the time and zone parts are equal.\n\t */\n\tif (time1->zone > time2->zone)\n\t\treturn 1;\n\tif (time1->zone < time2->zone)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "timetz_scale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2163-2178",
    "snippet": "Datum\ntimetz_scale(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tTimeTzADT  *result;\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time->time;\n\tresult->zone = time->zone;\n\n\tAdjustTimeForTypmod(&(result->time), typmod);\n\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);",
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimeForTypmod",
          "args": [
            "&(result->time)",
            "typmod"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimeForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1429-1461",
          "snippet": "static void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeTzADT)"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nDatum\ntimetz_scale(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tTimeTzADT  *result;\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = time->time;\n\tresult->zone = time->zone;\n\n\tAdjustTimeForTypmod(&(result->time), typmod);\n\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "timetz2tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2141-2157",
    "snippet": "int\ntimetz2tm(TimeTzADT *time, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tTimeOffset\ttrem = time->time;\n\n\ttm->tm_hour = trem / USECS_PER_HOUR;\n\ttrem -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = trem / USECS_PER_MINUTE;\n\ttrem -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = trem / USECS_PER_SEC;\n\t*fsec = trem - tm->tm_sec * USECS_PER_SEC;\n\n\tif (tzp != NULL)\n\t\t*tzp = time->zone;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimetz2tm(TimeTzADT *time, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tTimeOffset\ttrem = time->time;\n\n\ttm->tm_hour = trem / USECS_PER_HOUR;\n\ttrem -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = trem / USECS_PER_MINUTE;\n\ttrem -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = trem / USECS_PER_SEC;\n\t*fsec = trem - tm->tm_sec * USECS_PER_SEC;\n\n\tif (tzp != NULL)\n\t\t*tzp = time->zone;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "timetztypmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2129-2135",
    "snippet": "Datum\ntimetztypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anytime_typmodout(true, typmod));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "anytime_typmodout(true, typmod)"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anytime_typmodout",
          "args": [
            "true",
            "typmod"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "anytime_typmodout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "93-102",
          "snippet": "static char *\nanytime_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic char *\nanytime_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nDatum\ntimetztypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anytime_typmodout(true, typmod));\n}"
  },
  {
    "function_name": "timetztypmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2121-2127",
    "snippet": "Datum\ntimetztypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anytime_typmodin(true, ta));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "anytime_typmodin(true, ta)"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anytime_typmodin",
          "args": [
            "true",
            "ta"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "anytime_typmodin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "50-68",
          "snippet": "static int32\nanytime_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIME\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytime_typmod_check(istz, tl[0]);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32\nanytime_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIME\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytime_typmod_check(istz, tl[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetztypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anytime_typmodin(true, ta));\n}"
  },
  {
    "function_name": "timetz_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2109-2119",
    "snippet": "Datum\ntimetz_send(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, time->time);\n\tpq_sendint32(&buf, time->zone);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "time->zone"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint64",
          "args": [
            "&buf",
            "time->time"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 2115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetz_send(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, time->time);\n\tpq_sendint32(&buf, time->zone);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "timetz_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2073-2104",
    "snippet": "Datum\ntimetz_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimeTzADT  *result;\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = pq_getmsgint64(buf);\n\n\tif (result->time < INT64CONST(0) || result->time > USECS_PER_DAY)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"time out of range\")));\n\n\tresult->zone = pq_getmsgint(buf, sizeof(result->zone));\n\n\t/* Check for sane GMT displacement; see notes in datatype/timestamp.h */\n\tif (result->zone <= -TZDISP_LIMIT || result->zone >= TZDISP_LIMIT)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t errmsg(\"time zone displacement out of range\")));\n\n\tAdjustTimeForTypmod(&(result->time), typmod);\n\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);",
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimeForTypmod",
          "args": [
            "&(result->time)",
            "typmod"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimeForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1429-1461",
          "snippet": "static void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t errmsg(\"time zone displacement out of range\"))"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"time zone displacement out of range\""
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(result->zone)"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"time out of range\"))"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint64",
          "args": [
            "buf"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeTzADT)"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nDatum\ntimetz_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimeTzADT  *result;\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\n\tresult->time = pq_getmsgint64(buf);\n\n\tif (result->time < INT64CONST(0) || result->time > USECS_PER_DAY)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"time out of range\")));\n\n\tresult->zone = pq_getmsgint(buf, sizeof(result->zone));\n\n\t/* Check for sane GMT displacement; see notes in datatype/timestamp.h */\n\tif (result->zone <= -TZDISP_LIMIT || result->zone >= TZDISP_LIMIT)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t errmsg(\"time zone displacement out of range\")));\n\n\tAdjustTimeForTypmod(&(result->time), typmod);\n\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "timetz_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2052-2068",
    "snippet": "Datum\ntimetz_out(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\ttimetz2tm(time, tm, &fsec, &tz);\n\tEncodeTimeOnly(tm, fsec, true, tz, DateStyle, buf);\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "buf"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeTimeOnly",
          "args": [
            "tm",
            "fsec",
            "true",
            "tz",
            "DateStyle",
            "buf"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeTimeOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3957-3968",
          "snippet": "void\nEncodeTimeOnly(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, int style, char *str)\n{\n\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t*str++ = ':';\n\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t*str++ = ':';\n\tstr = AppendSeconds(str, tm->tm_sec, fsec, MAX_TIME_PRECISION, true);\n\tif (print_tz)\n\t\tstr = EncodeTimezone(str, tz, style);\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeTimeOnly(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, int style, char *str)\n{\n\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t*str++ = ':';\n\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t*str++ = ':';\n\tstr = AppendSeconds(str, tm->tm_sec, fsec, MAX_TIME_PRECISION, true);\n\tif (print_tz)\n\t\tstr = EncodeTimezone(str, tz, style);\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "timetz2tm",
          "args": [
            "time",
            "tm",
            "&fsec",
            "&tz"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "timetz2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2141-2157",
          "snippet": "int\ntimetz2tm(TimeTzADT *time, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tTimeOffset\ttrem = time->time;\n\n\ttm->tm_hour = trem / USECS_PER_HOUR;\n\ttrem -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = trem / USECS_PER_MINUTE;\n\ttrem -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = trem / USECS_PER_SEC;\n\t*fsec = trem - tm->tm_sec * USECS_PER_SEC;\n\n\tif (tzp != NULL)\n\t\t*tzp = time->zone;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimetz2tm(TimeTzADT *time, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tTimeOffset\ttrem = time->time;\n\n\ttm->tm_hour = trem / USECS_PER_HOUR;\n\ttrem -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = trem / USECS_PER_MINUTE;\n\ttrem -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = trem / USECS_PER_SEC;\n\t*fsec = trem - tm->tm_sec * USECS_PER_SEC;\n\n\tif (tzp != NULL)\n\t\t*tzp = time->zone;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMETZADT_P",
          "args": [
            "0"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimetz_out(PG_FUNCTION_ARGS)\n{\n\tTimeTzADT  *time = PG_GETARG_TIMETZADT_P(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\ttimetz2tm(time, tm, &fsec, &tz);\n\tEncodeTimeOnly(tm, fsec, true, tz, DateStyle, buf);\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "timetz_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2017-2050",
    "snippet": "Datum\ntimetz_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimeTzADT  *result;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tint\t\t\tnf;\n\tint\t\t\tdterr;\n\tchar\t\tworkbuf[MAXDATELEN + 1];\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tdtype;\n\tint\t\t\tftype[MAXDATEFIELDS];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeTimeOnly(field, ftype, nf, &dtype, tm, &fsec, &tz);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"time with time zone\");\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\ttm2timetz(tm, fsec, tz, result);\n\tAdjustTimeForTypmod(&(result->time), typmod);\n\n\tPG_RETURN_TIMETZADT_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);",
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMETZADT_P",
          "args": [
            "result"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimeForTypmod",
          "args": [
            "&(result->time)",
            "typmod"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimeForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1429-1461",
          "snippet": "static void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2timetz",
          "args": [
            "tm",
            "fsec",
            "tz",
            "result"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timetz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2007-2015",
          "snippet": "static int\ntm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result)\n{\n\tresult->time = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t\t\tUSECS_PER_SEC) + fsec;\n\tresult->zone = tz;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic int\ntm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result)\n{\n\tresult->time = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t\t\tUSECS_PER_SEC) + fsec;\n\tresult->zone = tz;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeTzADT)"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeParseError",
          "args": [
            "dterr",
            "str",
            "\"time with time zone\""
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeParseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3753-3792",
          "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeTimeOnly",
          "args": [
            "field",
            "ftype",
            "nf",
            "&dtype",
            "tm",
            "&fsec",
            "&tz"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimeOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1730-2343",
          "snippet": "int\nDecodeTimeOnly(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO h04mm05s06 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tint\t\t\tmer = HR24;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tchar\t   *abbrev = NULL;\n\tpg_tz\t   *valtz;\n\n\t*dtype = DTK_TIME;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Time zone not allowed? Then should not accept dates or time\n\t\t\t\t * zones no matter what else!\n\t\t\t\t */\n\t\t\t\tif (tzp == NULL)\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t/* Under limited circumstances, we will accept a date... */\n\t\t\t\tif (i == 0 && nf >= 2 &&\n\t\t\t\t\t(ftype[nf - 1] == DTK_DATE || ftype[1] == DTK_TIME))\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\t/* otherwise, this is a time and/or time zone */\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with time already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Should not get here and fail. Sanity check only...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t   INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO time\" with embedded field labels? An\n\t\t\t\t * example is \"h04m05s06\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\t/* Only accept a date under limited circumstances */\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal? */\n\t\t\t\t\tif (cp != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Under limited circumstances, we will accept a\n\t\t\t\t\t\t * date...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (i == 0 && nf >= 2 && ftype[nf - 1] == DTK_DATE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\t\telse if (flen - strlen(cp) > 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Interpret as a concatenated date or time Set\n\t\t\t\t\t\t\t * the type field to allow decoding other fields\n\t\t\t\t\t\t\t * later. Example: 20011223 or 040506\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flen > 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t false,\n\t\t\t\t\t\t\t\t\t\t\t (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = DTK_TIME_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, NULL);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/*\n\t * This should match the checks in make_timestamp_internal\n\t */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)) ||\n\t\t*fsec < INT64CONST(0) || *fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/*\n\t * If we had a full timezone spec, compute the offset (we could not do it\n\t * before, because we may need the date to resolve DST status).\n\t */\n\tif (namedTz != NULL)\n\t{\n\t\tlong int\tgmtoff;\n\n\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* if non-DST zone, we do not need to know the date */\n\t\tif (pg_get_timezone_offset(namedTz, &gmtoff))\n\t\t{\n\t\t\t*tzp = -(int) gmtoff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* a date has to be specified */\n\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, if we had a dynamic timezone abbreviation, resolve it now.\n\t */\n\tif (abbrevTz != NULL)\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneAbbrevOffset(tmp, abbrev, abbrevTz);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\t/* timezone not specified? then use session timezone */\n\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneOffset(tmp, session_timezone);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeTimeOnly(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO h04mm05s06 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tint\t\t\tmer = HR24;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tchar\t   *abbrev = NULL;\n\tpg_tz\t   *valtz;\n\n\t*dtype = DTK_TIME;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Time zone not allowed? Then should not accept dates or time\n\t\t\t\t * zones no matter what else!\n\t\t\t\t */\n\t\t\t\tif (tzp == NULL)\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t/* Under limited circumstances, we will accept a date... */\n\t\t\t\tif (i == 0 && nf >= 2 &&\n\t\t\t\t\t(ftype[nf - 1] == DTK_DATE || ftype[1] == DTK_TIME))\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\t/* otherwise, this is a time and/or time zone */\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with time already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Should not get here and fail. Sanity check only...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t   INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO time\" with embedded field labels? An\n\t\t\t\t * example is \"h04m05s06\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\t/* Only accept a date under limited circumstances */\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal? */\n\t\t\t\t\tif (cp != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Under limited circumstances, we will accept a\n\t\t\t\t\t\t * date...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (i == 0 && nf >= 2 && ftype[nf - 1] == DTK_DATE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\t\telse if (flen - strlen(cp) > 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Interpret as a concatenated date or time Set\n\t\t\t\t\t\t\t * the type field to allow decoding other fields\n\t\t\t\t\t\t\t * later. Example: 20011223 or 040506\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flen > 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t false,\n\t\t\t\t\t\t\t\t\t\t\t (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = DTK_TIME_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, NULL);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/*\n\t * This should match the checks in make_timestamp_internal\n\t */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)) ||\n\t\t*fsec < INT64CONST(0) || *fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/*\n\t * If we had a full timezone spec, compute the offset (we could not do it\n\t * before, because we may need the date to resolve DST status).\n\t */\n\tif (namedTz != NULL)\n\t{\n\t\tlong int\tgmtoff;\n\n\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* if non-DST zone, we do not need to know the date */\n\t\tif (pg_get_timezone_offset(namedTz, &gmtoff))\n\t\t{\n\t\t\t*tzp = -(int) gmtoff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* a date has to be specified */\n\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, if we had a dynamic timezone abbreviation, resolve it now.\n\t */\n\tif (abbrevTz != NULL)\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneAbbrevOffset(tmp, abbrev, abbrevTz);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\t/* timezone not specified? then use session timezone */\n\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneOffset(tmp, session_timezone);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseDateTime",
          "args": [
            "str",
            "workbuf",
            "sizeof(workbuf)",
            "field",
            "ftype",
            "MAXDATEFIELDS",
            "&nf"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "ParseDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "545-739",
          "snippet": "int\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\n\nint\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nDatum\ntimetz_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimeTzADT  *result;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tint\t\t\tnf;\n\tint\t\t\tdterr;\n\tchar\t\tworkbuf[MAXDATELEN + 1];\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tdtype;\n\tint\t\t\tftype[MAXDATEFIELDS];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeTimeOnly(field, ftype, nf, &dtype, tm, &fsec, &tz);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"time with time zone\");\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\ttm2timetz(tm, fsec, tz, result);\n\tAdjustTimeForTypmod(&(result->time), typmod);\n\n\tPG_RETURN_TIMETZADT_P(result);\n}"
  },
  {
    "function_name": "tm2timetz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "2007-2015",
    "snippet": "static int\ntm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result)\n{\n\tresult->time = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t\t\tUSECS_PER_SEC) + fsec;\n\tresult->zone = tz;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic int\ntm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result)\n{\n\tresult->time = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t\t\tUSECS_PER_SEC) + fsec;\n\tresult->zone = tz;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "time_part",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1916-1997",
    "snippet": "Datum\ntime_part(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(1);\n\tfloat8\t\tresult;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\tif (type == UNKNOWN_FIELD)\n\t\ttype = DecodeSpecial(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tfsec_t\t\tfsec;\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tm = &tt;\n\n\t\ttime2tm(time, tm, &fsec);\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tresult = tm->tm_sec * 1000000.0 + fsec;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tresult = tm->tm_sec * 1000.0 + fsec / 1000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_SECOND:\n\t\t\t\tresult = tm->tm_sec + fsec / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MINUTE:\n\t\t\t\tresult = tm->tm_min;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_HOUR:\n\t\t\t\tresult = tm->tm_hour;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\tcase DTK_TZ_MINUTE:\n\t\t\tcase DTK_TZ_HOUR:\n\t\t\tcase DTK_DAY:\n\t\t\tcase DTK_MONTH:\n\t\t\tcase DTK_QUARTER:\n\t\t\tcase DTK_YEAR:\n\t\t\tcase DTK_DECADE:\n\t\t\tcase DTK_CENTURY:\n\t\t\tcase DTK_MILLENNIUM:\n\t\t\tcase DTK_ISOYEAR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"\\\"time\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\t}\n\telse if (type == RESERV && val == DTK_EPOCH)\n\t{\n\t\tresult = time / 1000000.0;\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"time\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "result"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"time\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits))"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"\\\"time\\\" units \\\"%s\\\" not recognized\"",
            "lowunits"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"\\\"time\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\tlowunits))"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time2tm",
          "args": [
            "time",
            "tm",
            "&fsec"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "time2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1278-1289",
          "snippet": "int\ntime2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_hour = time / USECS_PER_HOUR;\n\ttime -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = time / USECS_PER_MINUTE;\n\ttime -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = time / USECS_PER_SEC;\n\ttime -= tm->tm_sec * USECS_PER_SEC;\n\t*fsec = time;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntime2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_hour = time / USECS_PER_HOUR;\n\ttime -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = time / USECS_PER_MINUTE;\n\ttime -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = time / USECS_PER_SEC;\n\ttime -= tm->tm_sec * USECS_PER_SEC;\n\t*fsec = time;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeSpecial",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeSpecial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3025-3050",
          "snippet": "int\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];",
            "static const datetkn *datecache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\nstatic const datetkn *datecache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeSpecial(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = datecache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, datetktbl, szdatetktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdatecache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeUnits",
          "args": [
            "0",
            "lowunits",
            "&val"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeUnits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3716-3741",
          "snippet": "int\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);",
            "static pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);",
            "static const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};",
            "static int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];",
            "static const datetkn *deltacache[MAXDATEFIELDS] = {NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DetermineTimeZoneOffsetInternal(struct pg_tm *tm, pg_tz *tzp,\n\t\t\t\t\t\t\t\tpg_time_t *tp);\nstatic pg_tz *FetchDynamicTimeZone(TimeZoneAbbrevTable *tbl, const datetkn *tp);\nstatic const datetkn deltatktbl[] = {\n\t/* token, type, value */\n\t{\"@\", IGNORE_DTF, 0},\t\t/* postgres relative prefix */\n\t{DAGO, AGO, 0},\t\t\t\t/* \"ago\" indicates negative time offset */\n\t{\"c\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"cent\", UNITS, DTK_CENTURY},\t/* \"century\" relative */\n\t{\"centuries\", UNITS, DTK_CENTURY},\t/* \"centuries\" relative */\n\t{DCENTURY, UNITS, DTK_CENTURY}, /* \"century\" relative */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{DDAY, UNITS, DTK_DAY},\t\t/* \"day\" relative */\n\t{\"days\", UNITS, DTK_DAY},\t/* \"days\" relative */\n\t{\"dec\", UNITS, DTK_DECADE}, /* \"decade\" relative */\n\t{DDECADE, UNITS, DTK_DECADE},\t/* \"decade\" relative */\n\t{\"decades\", UNITS, DTK_DECADE}, /* \"decades\" relative */\n\t{\"decs\", UNITS, DTK_DECADE},\t/* \"decades\" relative */\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" relative */\n\t{DHOUR, UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hours\", UNITS, DTK_HOUR}, /* \"hours\" relative */\n\t{\"hr\", UNITS, DTK_HOUR},\t/* \"hour\" relative */\n\t{\"hrs\", UNITS, DTK_HOUR},\t/* \"hours\" relative */\n\t{INVALID, RESERV, DTK_INVALID}, /* reserved for invalid time */\n\t{\"m\", UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"microsecon\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"mil\", UNITS, DTK_MILLENNIUM}, /* \"millennium\" relative */\n\t{\"millennia\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{DMILLENNIUM, UNITS, DTK_MILLENNIUM},\t/* \"millennium\" relative */\n\t{\"millisecon\", UNITS, DTK_MILLISEC},\t/* relative */\n\t{\"mils\", UNITS, DTK_MILLENNIUM},\t/* \"millennia\" relative */\n\t{\"min\", UNITS, DTK_MINUTE}, /* \"minute\" relative */\n\t{\"mins\", UNITS, DTK_MINUTE},\t/* \"minutes\" relative */\n\t{DMINUTE, UNITS, DTK_MINUTE},\t/* \"minute\" relative */\n\t{\"minutes\", UNITS, DTK_MINUTE}, /* \"minutes\" relative */\n\t{\"mon\", UNITS, DTK_MONTH},\t/* \"months\" relative */\n\t{\"mons\", UNITS, DTK_MONTH}, /* \"months\" relative */\n\t{DMONTH, UNITS, DTK_MONTH}, /* \"month\" relative */\n\t{\"months\", UNITS, DTK_MONTH},\n\t{\"ms\", UNITS, DTK_MILLISEC},\n\t{\"msec\", UNITS, DTK_MILLISEC},\n\t{DMILLISEC, UNITS, DTK_MILLISEC},\n\t{\"mseconds\", UNITS, DTK_MILLISEC},\n\t{\"msecs\", UNITS, DTK_MILLISEC},\n\t{\"qtr\", UNITS, DTK_QUARTER},\t/* \"quarter\" relative */\n\t{DQUARTER, UNITS, DTK_QUARTER}, /* \"quarter\" relative */\n\t{\"s\", UNITS, DTK_SECOND},\n\t{\"sec\", UNITS, DTK_SECOND},\n\t{DSECOND, UNITS, DTK_SECOND},\n\t{\"seconds\", UNITS, DTK_SECOND},\n\t{\"secs\", UNITS, DTK_SECOND},\n\t{DTIMEZONE, UNITS, DTK_TZ}, /* \"timezone\" time offset */\n\t{\"timezone_h\", UNITS, DTK_TZ_HOUR}, /* timezone hour units */\n\t{\"timezone_m\", UNITS, DTK_TZ_MINUTE},\t/* timezone minutes units */\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"us\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"usec\", UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{DMICROSEC, UNITS, DTK_MICROSEC},\t/* \"microsecond\" relative */\n\t{\"useconds\", UNITS, DTK_MICROSEC},\t/* \"microseconds\" relative */\n\t{\"usecs\", UNITS, DTK_MICROSEC}, /* \"microseconds\" relative */\n\t{\"w\", UNITS, DTK_WEEK},\t\t/* \"week\" relative */\n\t{DWEEK, UNITS, DTK_WEEK},\t/* \"week\" relative */\n\t{\"weeks\", UNITS, DTK_WEEK}, /* \"weeks\" relative */\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" relative */\n\t{DYEAR, UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"years\", UNITS, DTK_YEAR}, /* \"years\" relative */\n\t{\"yr\", UNITS, DTK_YEAR},\t/* \"year\" relative */\n\t{\"yrs\", UNITS, DTK_YEAR}\t/* \"years\" relative */\n};\nstatic int\tszdeltatktbl = sizeof deltatktbl / sizeof deltatktbl[0];\nstatic const datetkn *deltacache[MAXDATEFIELDS] = {NULL};\n\nint\nDecodeUnits(int field, char *lowtoken, int *val)\n{\n\tint\t\t\ttype;\n\tconst datetkn *tp;\n\n\ttp = deltacache[field];\n\t/* use strncmp so that we match truncated tokens */\n\tif (tp == NULL || strncmp(lowtoken, tp->token, TOKMAXLEN) != 0)\n\t{\n\t\ttp = datebsearch(lowtoken, deltatktbl, szdeltatktbl);\n\t}\n\tif (tp == NULL)\n\t{\n\t\ttype = UNKNOWN_FIELD;\n\t\t*val = 0;\n\t}\n\telse\n\t{\n\t\tdeltacache[field] = tp;\n\t\ttype = tp->type;\n\t\t*val = tp->value;\n\t}\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcase_truncate_identifier",
          "args": [
            "VARDATA_ANY(units)",
            "VARSIZE_ANY_EXHDR(units)",
            "false"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "units"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "units"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntime_part(PG_FUNCTION_ARGS)\n{\n\ttext\t   *units = PG_GETARG_TEXT_PP(0);\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(1);\n\tfloat8\t\tresult;\n\tint\t\t\ttype,\n\t\t\t\tval;\n\tchar\t   *lowunits;\n\n\tlowunits = downcase_truncate_identifier(VARDATA_ANY(units),\n\t\t\t\t\t\t\t\t\t\t\tVARSIZE_ANY_EXHDR(units),\n\t\t\t\t\t\t\t\t\t\t\tfalse);\n\n\ttype = DecodeUnits(0, lowunits, &val);\n\tif (type == UNKNOWN_FIELD)\n\t\ttype = DecodeSpecial(0, lowunits, &val);\n\n\tif (type == UNITS)\n\t{\n\t\tfsec_t\t\tfsec;\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tm = &tt;\n\n\t\ttime2tm(time, tm, &fsec);\n\n\t\tswitch (val)\n\t\t{\n\t\t\tcase DTK_MICROSEC:\n\t\t\t\tresult = tm->tm_sec * 1000000.0 + fsec;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MILLISEC:\n\t\t\t\tresult = tm->tm_sec * 1000.0 + fsec / 1000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_SECOND:\n\t\t\t\tresult = tm->tm_sec + fsec / 1000000.0;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_MINUTE:\n\t\t\t\tresult = tm->tm_min;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_HOUR:\n\t\t\t\tresult = tm->tm_hour;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\tcase DTK_TZ_MINUTE:\n\t\t\tcase DTK_TZ_HOUR:\n\t\t\tcase DTK_DAY:\n\t\t\tcase DTK_MONTH:\n\t\t\tcase DTK_QUARTER:\n\t\t\tcase DTK_YEAR:\n\t\t\tcase DTK_DECADE:\n\t\t\tcase DTK_CENTURY:\n\t\t\tcase DTK_MILLENNIUM:\n\t\t\tcase DTK_ISOYEAR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"\\\"time\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\tlowunits)));\n\t\t\t\tresult = 0;\n\t\t}\n\t}\n\telse if (type == RESERV && val == DTK_EPOCH)\n\t{\n\t\tresult = time / 1000000.0;\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"\\\"time\\\" units \\\"%s\\\" not recognized\",\n\t\t\t\t\t\tlowunits)));\n\t\tresult = 0;\n\t}\n\n\tPG_RETURN_FLOAT8(result);\n}"
  },
  {
    "function_name": "in_range_time_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1876-1910",
    "snippet": "Datum\nin_range_time_interval(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\tval = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\tbase = PG_GETARG_TIMEADT(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tTimeADT\t\tsum;\n\n\t/*\n\t * Like time_pl_interval/time_mi_interval, we disregard the month and day\n\t * fields of the offset.  So our test for negative should too.\n\t */\n\tif (offset->time < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/*\n\t * We can't use time_pl_interval/time_mi_interval here, because their\n\t * wraparound behavior would give wrong (or at least undesirable) answers.\n\t * Fortunately the equivalent non-wrapping behavior is trivial, especially\n\t * since we don't worry about integer overflow.\n\t */\n\tif (sub)\n\t\tsum = base - offset->time;\n\telse\n\t\tsum = base + offset->time;\n\n\tif (less)\n\t\tPG_RETURN_BOOL(val <= sum);\n\telse\n\t\tPG_RETURN_BOOL(val >= sum);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "val >= sum"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "val <= sum"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\"))"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid preceding or following size in window function\""
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "4"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "2"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nin_range_time_interval(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\tval = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\tbase = PG_GETARG_TIMEADT(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tTimeADT\t\tsum;\n\n\t/*\n\t * Like time_pl_interval/time_mi_interval, we disregard the month and day\n\t * fields of the offset.  So our test for negative should too.\n\t */\n\tif (offset->time < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE),\n\t\t\t\t errmsg(\"invalid preceding or following size in window function\")));\n\n\t/*\n\t * We can't use time_pl_interval/time_mi_interval here, because their\n\t * wraparound behavior would give wrong (or at least undesirable) answers.\n\t * Fortunately the equivalent non-wrapping behavior is trivial, especially\n\t * since we don't worry about integer overflow.\n\t */\n\tif (sub)\n\t\tsum = base - offset->time;\n\telse\n\t\tsum = base + offset->time;\n\n\tif (less)\n\t\tPG_RETURN_BOOL(val <= sum);\n\telse\n\t\tPG_RETURN_BOOL(val >= sum);\n}"
  },
  {
    "function_name": "time_mi_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1858-1871",
    "snippet": "Datum\ntime_mi_interval(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimeADT\t\tresult;\n\n\tresult = time - span->time;\n\tresult -= result / USECS_PER_DAY * USECS_PER_DAY;\n\tif (result < INT64CONST(0))\n\t\tresult += USECS_PER_DAY;\n\n\tPG_RETURN_TIMEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "result"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntime_mi_interval(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimeADT\t\tresult;\n\n\tresult = time - span->time;\n\tresult -= result / USECS_PER_DAY * USECS_PER_DAY;\n\tif (result < INT64CONST(0))\n\t\tresult += USECS_PER_DAY;\n\n\tPG_RETURN_TIMEADT(result);\n}"
  },
  {
    "function_name": "time_pl_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1840-1853",
    "snippet": "Datum\ntime_pl_interval(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimeADT\t\tresult;\n\n\tresult = time + span->time;\n\tresult -= result / USECS_PER_DAY * USECS_PER_DAY;\n\tif (result < INT64CONST(0))\n\t\tresult += USECS_PER_DAY;\n\n\tPG_RETURN_TIMEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "result"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntime_pl_interval(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimeADT\t\tresult;\n\n\tresult = time + span->time;\n\tresult -= result / USECS_PER_DAY * USECS_PER_DAY;\n\tif (result < INT64CONST(0))\n\t\tresult += USECS_PER_DAY;\n\n\tPG_RETURN_TIMEADT(result);\n}"
  },
  {
    "function_name": "time_mi_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1821-1835",
    "snippet": "Datum\ntime_mi_time(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult->month = 0;\n\tresult->day = 0;\n\tresult->time = time1 - time2;\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntime_mi_time(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult->month = 0;\n\tresult->day = 0;\n\tresult->time = time1 - time2;\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1796-1816",
    "snippet": "Datum\ninterval_time(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tTimeADT\t\tresult;\n\tint64\t\tdays;\n\n\tresult = span->time;\n\tif (result >= USECS_PER_DAY)\n\t{\n\t\tdays = result / USECS_PER_DAY;\n\t\tresult -= days * USECS_PER_DAY;\n\t}\n\telse if (result < 0)\n\t{\n\t\tdays = (-result + USECS_PER_DAY - 1) / USECS_PER_DAY;\n\t\tresult += days * USECS_PER_DAY;\n\t}\n\n\tPG_RETURN_TIMEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "result"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ninterval_time(PG_FUNCTION_ARGS)\n{\n\tInterval   *span = PG_GETARG_INTERVAL_P(0);\n\tTimeADT\t\tresult;\n\tint64\t\tdays;\n\n\tresult = span->time;\n\tif (result >= USECS_PER_DAY)\n\t{\n\t\tdays = result / USECS_PER_DAY;\n\t\tresult -= days * USECS_PER_DAY;\n\t}\n\telse if (result < 0)\n\t{\n\t\tdays = (-result + USECS_PER_DAY - 1) / USECS_PER_DAY;\n\t\tresult += days * USECS_PER_DAY;\n\t}\n\n\tPG_RETURN_TIMEADT(result);\n}"
  },
  {
    "function_name": "time_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1773-1786",
    "snippet": "Datum\ntime_interval(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult->time = time;\n\tresult->day = 0;\n\tresult->month = 0;\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntime_interval(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tInterval   *result;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tresult->time = time;\n\tresult->day = 0;\n\tresult->month = 0;\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "datetime_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1750-1768",
    "snippet": "Datum\ndatetime_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdate = PG_GETARG_DATEADT(0);\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(1);\n\tTimestamp\tresult;\n\n\tresult = date2timestamp(date);\n\tif (!TIMESTAMP_NOT_FINITE(result))\n\t{\n\t\tresult += time;\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "result"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "date"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ndatetime_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdate = PG_GETARG_DATEADT(0);\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(1);\n\tTimestamp\tresult;\n\n\tresult = date2timestamp(date);\n\tif (!TIMESTAMP_NOT_FINITE(result))\n\t{\n\t\tresult += time;\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t}\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamptz_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1719-1745",
    "snippet": "Datum\ntimestamptz_time(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMP(0);\n\tTimeADT\t\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_NULL();\n\n\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t/*\n\t * Could also do this with time = (timestamp / USECS_PER_DAY *\n\t * USECS_PER_DAY) - timestamp;\n\t */\n\tresult = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t  USECS_PER_SEC) + fsec;\n\n\tPG_RETURN_TIMEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "result"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimestamptz_time(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMP(0);\n\tTimeADT\t\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_NULL();\n\n\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t/*\n\t * Could also do this with time = (timestamp / USECS_PER_DAY *\n\t * USECS_PER_DAY) - timestamp;\n\t */\n\tresult = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t  USECS_PER_SEC) + fsec;\n\n\tPG_RETURN_TIMEADT(result);\n}"
  },
  {
    "function_name": "timestamp_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1689-1714",
    "snippet": "Datum\ntimestamp_time(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tTimeADT\t\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_NULL();\n\n\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t/*\n\t * Could also do this with time = (timestamp / USECS_PER_DAY *\n\t * USECS_PER_DAY) - timestamp;\n\t */\n\tresult = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t  USECS_PER_SEC) + fsec;\n\n\tPG_RETURN_TIMEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "result"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOT_FINITE",
          "args": [
            "timestamp"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimestamp_time(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tTimeADT\t\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\n\tif (TIMESTAMP_NOT_FINITE(timestamp))\n\t\tPG_RETURN_NULL();\n\n\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t/*\n\t * Could also do this with time = (timestamp / USECS_PER_DAY *\n\t * USECS_PER_DAY) - timestamp;\n\t */\n\tresult = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t  USECS_PER_SEC) + fsec;\n\n\tPG_RETURN_TIMEADT(result);\n}"
  },
  {
    "function_name": "overlaps_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1567-1684",
    "snippet": "Datum\noverlaps_time(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * The arguments are TimeADT, but we leave them as generic Datums to avoid\n\t * dereferencing nulls (TimeADT is pass-by-reference!)\n\t */\n\tDatum\t\tts1 = PG_GETARG_DATUM(0);\n\tDatum\t\tte1 = PG_GETARG_DATUM(1);\n\tDatum\t\tts2 = PG_GETARG_DATUM(2);\n\tDatum\t\tte2 = PG_GETARG_DATUM(3);\n\tbool\t\tts1IsNull = PG_ARGISNULL(0);\n\tbool\t\tte1IsNull = PG_ARGISNULL(1);\n\tbool\t\tts2IsNull = PG_ARGISNULL(2);\n\tbool\t\tte2IsNull = PG_ARGISNULL(3);\n\n#define TIMEADT_GT(t1,t2) \\\n\t(DatumGetTimeADT(t1) > DatumGetTimeADT(t2))\n#define TIMEADT_LT(t1,t2) \\\n\t(DatumGetTimeADT(t1) < DatumGetTimeADT(t2))\n\n\t/*\n\t * If both endpoints of interval 1 are null, the result is null (unknown).\n\t * If just one endpoint is null, take ts1 as the non-null one. Otherwise,\n\t * take ts1 as the lesser endpoint.\n\t */\n\tif (ts1IsNull)\n\t{\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts1 = te1;\n\t\tte1IsNull = true;\n\t}\n\telse if (!te1IsNull)\n\t{\n\t\tif (TIMEADT_GT(ts1, te1))\n\t\t{\n\t\t\tDatum\t\ttt = ts1;\n\n\t\t\tts1 = te1;\n\t\t\tte1 = tt;\n\t\t}\n\t}\n\n\t/* Likewise for interval 2. */\n\tif (ts2IsNull)\n\t{\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts2 = te2;\n\t\tte2IsNull = true;\n\t}\n\telse if (!te2IsNull)\n\t{\n\t\tif (TIMEADT_GT(ts2, te2))\n\t\t{\n\t\t\tDatum\t\ttt = ts2;\n\n\t\t\tts2 = te2;\n\t\t\tte2 = tt;\n\t\t}\n\t}\n\n\t/*\n\t * At this point neither ts1 nor ts2 is null, so we can consider three\n\t * cases: ts1 > ts2, ts1 < ts2, ts1 = ts2\n\t */\n\tif (TIMEADT_GT(ts1, ts2))\n\t{\n\t\t/*\n\t\t * This case is ts1 < te2 OR te1 < te2, which may look redundant but\n\t\t * in the presence of nulls it's not quite completely so.\n\t\t */\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMEADT_LT(ts1, te2))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te1 is not null then we had ts1 <= te1 above, and we just found\n\t\t * ts1 >= te2, hence te1 >= te2.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse if (TIMEADT_LT(ts1, ts2))\n\t{\n\t\t/* This case is ts2 < te1 OR te2 < te1 */\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMEADT_LT(ts2, te1))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te2 is not null then we had ts2 <= te2 above, and we just found\n\t\t * ts2 >= te1, hence te2 >= te1.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For ts1 = ts2 the spec says te1 <> te2 OR te1 = te2, which is a\n\t\t * rather silly way of saying \"true if both are nonnull, else null\".\n\t\t */\n\t\tif (te1IsNull || te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(true);\n\t}\n\n#undef TIMEADT_GT\n#undef TIMEADT_LT\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMEADT_LT",
          "args": [
            "ts2",
            "te1"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMEADT_LT",
          "args": [
            "ts1",
            "ts2"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMEADT_LT",
          "args": [
            "ts1",
            "te2"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMEADT_GT",
          "args": [
            "ts1",
            "ts2"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMEADT_GT",
          "args": [
            "ts2",
            "te2"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMEADT_GT",
          "args": [
            "ts1",
            "te1"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "3"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "3"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "2"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\noverlaps_time(PG_FUNCTION_ARGS)\n{\n\t/*\n\t * The arguments are TimeADT, but we leave them as generic Datums to avoid\n\t * dereferencing nulls (TimeADT is pass-by-reference!)\n\t */\n\tDatum\t\tts1 = PG_GETARG_DATUM(0);\n\tDatum\t\tte1 = PG_GETARG_DATUM(1);\n\tDatum\t\tts2 = PG_GETARG_DATUM(2);\n\tDatum\t\tte2 = PG_GETARG_DATUM(3);\n\tbool\t\tts1IsNull = PG_ARGISNULL(0);\n\tbool\t\tte1IsNull = PG_ARGISNULL(1);\n\tbool\t\tts2IsNull = PG_ARGISNULL(2);\n\tbool\t\tte2IsNull = PG_ARGISNULL(3);\n\n#define TIMEADT_GT(t1,t2) \\\n\t(DatumGetTimeADT(t1) > DatumGetTimeADT(t2))\n#define TIMEADT_LT(t1,t2) \\\n\t(DatumGetTimeADT(t1) < DatumGetTimeADT(t2))\n\n\t/*\n\t * If both endpoints of interval 1 are null, the result is null (unknown).\n\t * If just one endpoint is null, take ts1 as the non-null one. Otherwise,\n\t * take ts1 as the lesser endpoint.\n\t */\n\tif (ts1IsNull)\n\t{\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts1 = te1;\n\t\tte1IsNull = true;\n\t}\n\telse if (!te1IsNull)\n\t{\n\t\tif (TIMEADT_GT(ts1, te1))\n\t\t{\n\t\t\tDatum\t\ttt = ts1;\n\n\t\t\tts1 = te1;\n\t\t\tte1 = tt;\n\t\t}\n\t}\n\n\t/* Likewise for interval 2. */\n\tif (ts2IsNull)\n\t{\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\t/* swap null for non-null */\n\t\tts2 = te2;\n\t\tte2IsNull = true;\n\t}\n\telse if (!te2IsNull)\n\t{\n\t\tif (TIMEADT_GT(ts2, te2))\n\t\t{\n\t\t\tDatum\t\ttt = ts2;\n\n\t\t\tts2 = te2;\n\t\t\tte2 = tt;\n\t\t}\n\t}\n\n\t/*\n\t * At this point neither ts1 nor ts2 is null, so we can consider three\n\t * cases: ts1 > ts2, ts1 < ts2, ts1 = ts2\n\t */\n\tif (TIMEADT_GT(ts1, ts2))\n\t{\n\t\t/*\n\t\t * This case is ts1 < te2 OR te1 < te2, which may look redundant but\n\t\t * in the presence of nulls it's not quite completely so.\n\t\t */\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMEADT_LT(ts1, te2))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te1 is not null then we had ts1 <= te1 above, and we just found\n\t\t * ts1 >= te2, hence te1 >= te2.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse if (TIMEADT_LT(ts1, ts2))\n\t{\n\t\t/* This case is ts2 < te1 OR te2 < te1 */\n\t\tif (te1IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tif (TIMEADT_LT(ts2, te1))\n\t\t\tPG_RETURN_BOOL(true);\n\t\tif (te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\n\t\t/*\n\t\t * If te2 is not null then we had ts2 <= te2 above, and we just found\n\t\t * ts2 >= te1, hence te2 >= te1.\n\t\t */\n\t\tPG_RETURN_BOOL(false);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * For ts1 = ts2 the spec says te1 <> te2 OR te1 = te2, which is a\n\t\t * rather silly way of saying \"true if both are nonnull, else null\".\n\t\t */\n\t\tif (te1IsNull || te2IsNull)\n\t\t\tPG_RETURN_NULL();\n\t\tPG_RETURN_BOOL(true);\n\t}\n\n#undef TIMEADT_GT\n#undef TIMEADT_LT\n}"
  },
  {
    "function_name": "time_smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1552-1559",
    "snippet": "Datum\ntime_smaller(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_TIMEADT((time1 < time2) ? time1 : time2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "(time1 < time2) ? time1 : time2"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_smaller(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_TIMEADT((time1 < time2) ? time1 : time2);\n}"
  },
  {
    "function_name": "time_larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1543-1550",
    "snippet": "Datum\ntime_larger(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_TIMEADT((time1 > time2) ? time1 : time2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "(time1 > time2) ? time1 : time2"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_larger(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_TIMEADT((time1 > time2) ? time1 : time2);\n}"
  },
  {
    "function_name": "time_hash_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1537-1541",
    "snippet": "Datum\ntime_hash_extended(PG_FUNCTION_ARGS)\n{\n\treturn hashint8extended(fcinfo);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashint8extended",
          "args": [
            "fcinfo"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_hash_extended(PG_FUNCTION_ARGS)\n{\n\treturn hashint8extended(fcinfo);\n}"
  },
  {
    "function_name": "time_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1531-1535",
    "snippet": "Datum\ntime_hash(PG_FUNCTION_ARGS)\n{\n\treturn hashint8(fcinfo);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashint8",
          "args": [
            "fcinfo"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_hash(PG_FUNCTION_ARGS)\n{\n\treturn hashint8(fcinfo);\n}"
  },
  {
    "function_name": "time_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1518-1529",
    "snippet": "Datum\ntime_cmp(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tif (time1 < time2)\n\t\tPG_RETURN_INT32(-1);\n\tif (time1 > time2)\n\t\tPG_RETURN_INT32(1);\n\tPG_RETURN_INT32(0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "0"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "1"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "-1"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_cmp(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tif (time1 < time2)\n\t\tPG_RETURN_INT32(-1);\n\tif (time1 > time2)\n\t\tPG_RETURN_INT32(1);\n\tPG_RETURN_INT32(0);\n}"
  },
  {
    "function_name": "time_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1509-1516",
    "snippet": "Datum\ntime_ge(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 >= time2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "time1 >= time2"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_ge(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 >= time2);\n}"
  },
  {
    "function_name": "time_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1500-1507",
    "snippet": "Datum\ntime_gt(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 > time2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "time1 > time2"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_gt(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 > time2);\n}"
  },
  {
    "function_name": "time_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1491-1498",
    "snippet": "Datum\ntime_le(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 <= time2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "time1 <= time2"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_le(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 <= time2);\n}"
  },
  {
    "function_name": "time_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1482-1489",
    "snippet": "Datum\ntime_lt(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 < time2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "time1 < time2"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_lt(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 < time2);\n}"
  },
  {
    "function_name": "time_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1473-1480",
    "snippet": "Datum\ntime_ne(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 != time2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "time1 != time2"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_ne(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 != time2);\n}"
  },
  {
    "function_name": "time_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1464-1471",
    "snippet": "Datum\ntime_eq(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 == time2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "time1 == time2"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "1"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_eq(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime1 = PG_GETARG_TIMEADT(0);\n\tTimeADT\t\ttime2 = PG_GETARG_TIMEADT(1);\n\n\tPG_RETURN_BOOL(time1 == time2);\n}"
  },
  {
    "function_name": "AdjustTimeForTypmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1429-1461",
    "snippet": "static void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "5"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "50"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "500"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "5000"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "50000"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "500000"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "10"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1000"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "10000"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "100000"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1000000"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}"
  },
  {
    "function_name": "time_scale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1409-1420",
    "snippet": "Datum\ntime_scale(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tTimeADT\t\tresult;\n\n\tresult = time;\n\tAdjustTimeForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);",
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "result"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimeForTypmod",
          "args": [
            "&result",
            "typmod"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimeForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1429-1461",
          "snippet": "static void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nDatum\ntime_scale(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tTimeADT\t\tresult;\n\n\tresult = time;\n\tAdjustTimeForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMEADT(result);\n}"
  },
  {
    "function_name": "time_transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1398-1403",
    "snippet": "Datum\ntime_transform(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_POINTER(TemporalTransform(MAX_TIME_PRECISION,\n\t\t\t\t\t\t\t\t\t\t(Node *) PG_GETARG_POINTER(0)));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "TemporalTransform(MAX_TIME_PRECISION,\n\t\t\t\t\t\t\t\t\t\t(Node *) PG_GETARG_POINTER(0))"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TemporalTransform",
          "args": [
            "MAX_TIME_PRECISION",
            "(Node *) PG_GETARG_POINTER(0)"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "TemporalTransform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4474-4497",
          "snippet": "Node *\nTemporalTransform(int32 max_precis, Node *node)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, node);\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\told_precis = exprTypmod(source);\n\t\tint32\t\tnew_precis = DatumGetInt32(((Const *) typmod)->constvalue);\n\n\t\tif (new_precis < 0 || new_precis == max_precis ||\n\t\t\t(old_precis >= 0 && new_precis >= old_precis))\n\t\t\tret = relabel_to_typmod(source, new_precis);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nNode *\nTemporalTransform(int32 max_precis, Node *node)\n{\n\tFuncExpr   *expr = castNode(FuncExpr, node);\n\tNode\t   *ret = NULL;\n\tNode\t   *typmod;\n\n\tAssert(list_length(expr->args) >= 2);\n\n\ttypmod = (Node *) lsecond(expr->args);\n\n\tif (IsA(typmod, Const) &&!((Const *) typmod)->constisnull)\n\t{\n\t\tNode\t   *source = (Node *) linitial(expr->args);\n\t\tint32\t\told_precis = exprTypmod(source);\n\t\tint32\t\tnew_precis = DatumGetInt32(((Const *) typmod)->constvalue);\n\n\t\tif (new_precis < 0 || new_precis == max_precis ||\n\t\t\t(old_precis >= 0 && new_precis >= old_precis))\n\t\t\tret = relabel_to_typmod(source, new_precis);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_transform(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_POINTER(TemporalTransform(MAX_TIME_PRECISION,\n\t\t\t\t\t\t\t\t\t\t(Node *) PG_GETARG_POINTER(0)));\n}"
  },
  {
    "function_name": "make_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1367-1391",
    "snippet": "Datum\nmake_time(PG_FUNCTION_ARGS)\n{\n\tint\t\t\ttm_hour = PG_GETARG_INT32(0);\n\tint\t\t\ttm_min = PG_GETARG_INT32(1);\n\tdouble\t\tsec = PG_GETARG_FLOAT8(2);\n\tTimeADT\t\ttime;\n\n\t/* This should match the checks in DecodeTimeOnly */\n\tif (tm_hour < 0 || tm_min < 0 || tm_min > MINS_PER_HOUR - 1 ||\n\t\tsec < 0 || sec > SECS_PER_MINUTE ||\n\t\ttm_hour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(tm_hour == HOURS_PER_DAY && (tm_min > 0 || sec > 0)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\ttm_hour, tm_min, sec)));\n\n\t/* This should match tm2time */\n\ttime = (((tm_hour * MINS_PER_HOUR + tm_min) * SECS_PER_MINUTE)\n\t\t\t* USECS_PER_SEC) + rint(sec * USECS_PER_SEC);\n\n\tPG_RETURN_TIMEADT(time);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "time"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint",
          "args": [
            "sec * USECS_PER_SEC"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "PrintCatCacheListLeakWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2114-2120",
          "snippet": "void\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrintCatCacheListLeakWarning(CatCList *list)\n{\n\telog(WARNING, \"cache reference leak: cache %s (%d), list %p has count %d\",\n\t\t list->my_cache->cc_relname, list->my_cache->id,\n\t\t list, list->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\ttm_hour, tm_min, sec))"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"time field value out of range: %d:%02d:%02g\"",
            "tm_hour",
            "tm_min",
            "sec"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_FIELD_OVERFLOW"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_FLOAT8",
          "args": [
            "2"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmake_time(PG_FUNCTION_ARGS)\n{\n\tint\t\t\ttm_hour = PG_GETARG_INT32(0);\n\tint\t\t\ttm_min = PG_GETARG_INT32(1);\n\tdouble\t\tsec = PG_GETARG_FLOAT8(2);\n\tTimeADT\t\ttime;\n\n\t/* This should match the checks in DecodeTimeOnly */\n\tif (tm_hour < 0 || tm_min < 0 || tm_min > MINS_PER_HOUR - 1 ||\n\t\tsec < 0 || sec > SECS_PER_MINUTE ||\n\t\ttm_hour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(tm_hour == HOURS_PER_DAY && (tm_min > 0 || sec > 0)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"time field value out of range: %d:%02d:%02g\",\n\t\t\t\t\t\ttm_hour, tm_min, sec)));\n\n\t/* This should match tm2time */\n\ttime = (((tm_hour * MINS_PER_HOUR + tm_min) * SECS_PER_MINUTE)\n\t\t\t* USECS_PER_SEC) + rint(sec * USECS_PER_SEC);\n\n\tPG_RETURN_TIMEADT(time);\n}"
  },
  {
    "function_name": "timetypmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1356-1362",
    "snippet": "Datum\ntimetypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anytime_typmodout(false, typmod));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "anytime_typmodout(false, typmod)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anytime_typmodout",
          "args": [
            "false",
            "typmod"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "anytime_typmodout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "93-102",
          "snippet": "static char *\nanytime_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic char *\nanytime_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nDatum\ntimetypmodout(PG_FUNCTION_ARGS)\n{\n\tint32\t\ttypmod = PG_GETARG_INT32(0);\n\n\tPG_RETURN_CSTRING(anytime_typmodout(false, typmod));\n}"
  },
  {
    "function_name": "timetypmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1348-1354",
    "snippet": "Datum\ntimetypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anytime_typmodin(false, ta));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "anytime_typmodin(false, ta)"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anytime_typmodin",
          "args": [
            "false",
            "ta"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "anytime_typmodin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "50-68",
          "snippet": "static int32\nanytime_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIME\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytime_typmod_check(istz, tl[0]);\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32\nanytime_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIME\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytime_typmod_check(istz, tl[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimetypmodin(PG_FUNCTION_ARGS)\n{\n\tArrayType  *ta = PG_GETARG_ARRAYTYPE_P(0);\n\n\tPG_RETURN_INT32(anytime_typmodin(false, ta));\n}"
  },
  {
    "function_name": "time_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1337-1346",
    "snippet": "Datum\ntime_send(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, time);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint64",
          "args": [
            "&buf",
            "time"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntime_send(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint64(&buf, time);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "time_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1311-1332",
    "snippet": "Datum\ntime_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimeADT\t\tresult;\n\n\tresult = pq_getmsgint64(buf);\n\n\tif (result < INT64CONST(0) || result > USECS_PER_DAY)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"time out of range\")));\n\n\tAdjustTimeForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);",
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "result"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimeForTypmod",
          "args": [
            "&result",
            "typmod"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimeForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1429-1461",
          "snippet": "static void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"time out of range\"))"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"time out of range\""
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "0"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint64",
          "args": [
            "buf"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nDatum\ntime_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimeADT\t\tresult;\n\n\tresult = pq_getmsgint64(buf);\n\n\tif (result < INT64CONST(0) || result > USECS_PER_DAY)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"time out of range\")));\n\n\tAdjustTimeForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMEADT(result);\n}"
  },
  {
    "function_name": "time_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1291-1306",
    "snippet": "Datum\ntime_out(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\ttime2tm(time, tm, &fsec);\n\tEncodeTimeOnly(tm, fsec, false, 0, DateStyle, buf);\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "buf"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeTimeOnly",
          "args": [
            "tm",
            "fsec",
            "false",
            "0",
            "DateStyle",
            "buf"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeTimeOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3957-3968",
          "snippet": "void\nEncodeTimeOnly(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, int style, char *str)\n{\n\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t*str++ = ':';\n\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t*str++ = ':';\n\tstr = AppendSeconds(str, tm->tm_sec, fsec, MAX_TIME_PRECISION, true);\n\tif (print_tz)\n\t\tstr = EncodeTimezone(str, tz, style);\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeTimeOnly(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, int style, char *str)\n{\n\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t*str++ = ':';\n\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t*str++ = ':';\n\tstr = AppendSeconds(str, tm->tm_sec, fsec, MAX_TIME_PRECISION, true);\n\tif (print_tz)\n\t\tstr = EncodeTimezone(str, tz, style);\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "time2tm",
          "args": [
            "time",
            "tm",
            "&fsec"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "time2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1278-1289",
          "snippet": "int\ntime2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_hour = time / USECS_PER_HOUR;\n\ttime -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = time / USECS_PER_MINUTE;\n\ttime -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = time / USECS_PER_SEC;\n\ttime -= tm->tm_sec * USECS_PER_SEC;\n\t*fsec = time;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntime2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_hour = time / USECS_PER_HOUR;\n\ttime -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = time / USECS_PER_MINUTE;\n\ttime -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = time / USECS_PER_SEC;\n\ttime -= tm->tm_sec * USECS_PER_SEC;\n\t*fsec = time;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEADT",
          "args": [
            "0"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntime_out(PG_FUNCTION_ARGS)\n{\n\tTimeADT\t\ttime = PG_GETARG_TIMEADT(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\ttime2tm(time, tm, &fsec);\n\tEncodeTimeOnly(tm, fsec, false, 0, DateStyle, buf);\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "time2tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1278-1289",
    "snippet": "int\ntime2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_hour = time / USECS_PER_HOUR;\n\ttime -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = time / USECS_PER_MINUTE;\n\ttime -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = time / USECS_PER_SEC;\n\ttime -= tm->tm_sec * USECS_PER_SEC;\n\t*fsec = time;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntime2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec)\n{\n\ttm->tm_hour = time / USECS_PER_HOUR;\n\ttime -= tm->tm_hour * USECS_PER_HOUR;\n\ttm->tm_min = time / USECS_PER_MINUTE;\n\ttime -= tm->tm_min * USECS_PER_MINUTE;\n\ttm->tm_sec = time / USECS_PER_SEC;\n\ttime -= tm->tm_sec * USECS_PER_SEC;\n\t*fsec = time;\n\treturn 0;\n}"
  },
  {
    "function_name": "tm2time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1263-1269",
    "snippet": "static int\ntm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result)\n{\n\t*result = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec)\n\t\t\t   * USECS_PER_SEC) + fsec;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic int\ntm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result)\n{\n\t*result = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec)\n\t\t\t   * USECS_PER_SEC) + fsec;\n\treturn 0;\n}"
  },
  {
    "function_name": "time_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1226-1258",
    "snippet": "Datum\ntime_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimeADT\t\tresult;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tint\t\t\tnf;\n\tint\t\t\tdterr;\n\tchar\t\tworkbuf[MAXDATELEN + 1];\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tdtype;\n\tint\t\t\tftype[MAXDATEFIELDS];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeTimeOnly(field, ftype, nf, &dtype, tm, &fsec, &tz);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"time\");\n\n\ttm2time(tm, fsec, &result);\n\tAdjustTimeForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);",
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEADT",
          "args": [
            "result"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AdjustTimeForTypmod",
          "args": [
            "&result",
            "typmod"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimeForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1429-1461",
          "snippet": "static void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2time",
          "args": [
            "tm",
            "fsec",
            "&result"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "tm2time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1263-1269",
          "snippet": "static int\ntm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result)\n{\n\t*result = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec)\n\t\t\t   * USECS_PER_SEC) + fsec;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic int\ntm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result)\n{\n\t*result = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec)\n\t\t\t   * USECS_PER_SEC) + fsec;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeParseError",
          "args": [
            "dterr",
            "str",
            "\"time\""
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeParseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3753-3792",
          "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeTimeOnly",
          "args": [
            "field",
            "ftype",
            "nf",
            "&dtype",
            "tm",
            "&fsec",
            "&tz"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeTimeOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1730-2343",
          "snippet": "int\nDecodeTimeOnly(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO h04mm05s06 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tint\t\t\tmer = HR24;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tchar\t   *abbrev = NULL;\n\tpg_tz\t   *valtz;\n\n\t*dtype = DTK_TIME;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Time zone not allowed? Then should not accept dates or time\n\t\t\t\t * zones no matter what else!\n\t\t\t\t */\n\t\t\t\tif (tzp == NULL)\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t/* Under limited circumstances, we will accept a date... */\n\t\t\t\tif (i == 0 && nf >= 2 &&\n\t\t\t\t\t(ftype[nf - 1] == DTK_DATE || ftype[1] == DTK_TIME))\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\t/* otherwise, this is a time and/or time zone */\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with time already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Should not get here and fail. Sanity check only...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t   INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO time\" with embedded field labels? An\n\t\t\t\t * example is \"h04m05s06\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\t/* Only accept a date under limited circumstances */\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal? */\n\t\t\t\t\tif (cp != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Under limited circumstances, we will accept a\n\t\t\t\t\t\t * date...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (i == 0 && nf >= 2 && ftype[nf - 1] == DTK_DATE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\t\telse if (flen - strlen(cp) > 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Interpret as a concatenated date or time Set\n\t\t\t\t\t\t\t * the type field to allow decoding other fields\n\t\t\t\t\t\t\t * later. Example: 20011223 or 040506\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flen > 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t false,\n\t\t\t\t\t\t\t\t\t\t\t (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = DTK_TIME_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, NULL);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/*\n\t * This should match the checks in make_timestamp_internal\n\t */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)) ||\n\t\t*fsec < INT64CONST(0) || *fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/*\n\t * If we had a full timezone spec, compute the offset (we could not do it\n\t * before, because we may need the date to resolve DST status).\n\t */\n\tif (namedTz != NULL)\n\t{\n\t\tlong int\tgmtoff;\n\n\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* if non-DST zone, we do not need to know the date */\n\t\tif (pg_get_timezone_offset(namedTz, &gmtoff))\n\t\t{\n\t\t\t*tzp = -(int) gmtoff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* a date has to be specified */\n\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, if we had a dynamic timezone abbreviation, resolve it now.\n\t */\n\tif (abbrevTz != NULL)\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneAbbrevOffset(tmp, abbrev, abbrevTz);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\t/* timezone not specified? then use session timezone */\n\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneOffset(tmp, session_timezone);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeTimeOnly(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO h04mm05s06 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tint\t\t\tmer = HR24;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tchar\t   *abbrev = NULL;\n\tpg_tz\t   *valtz;\n\n\t*dtype = DTK_TIME;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Time zone not allowed? Then should not accept dates or time\n\t\t\t\t * zones no matter what else!\n\t\t\t\t */\n\t\t\t\tif (tzp == NULL)\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t/* Under limited circumstances, we will accept a date... */\n\t\t\t\tif (i == 0 && nf >= 2 &&\n\t\t\t\t\t(ftype[nf - 1] == DTK_DATE || ftype[1] == DTK_TIME))\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\t/* otherwise, this is a time and/or time zone */\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with time already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Should not get here and fail. Sanity check only...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t   INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO time\" with embedded field labels? An\n\t\t\t\t * example is \"h04m05s06\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\t/* Only accept a date under limited circumstances */\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal? */\n\t\t\t\t\tif (cp != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Under limited circumstances, we will accept a\n\t\t\t\t\t\t * date...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (i == 0 && nf >= 2 && ftype[nf - 1] == DTK_DATE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\t\telse if (flen - strlen(cp) > 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Interpret as a concatenated date or time Set\n\t\t\t\t\t\t\t * the type field to allow decoding other fields\n\t\t\t\t\t\t\t * later. Example: 20011223 or 040506\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flen > 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\tftype[i] = dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t false,\n\t\t\t\t\t\t\t\t\t\t\t (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = DTK_TIME_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, NULL);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_TIME;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tftype[i] = DTK_TZ;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/*\n\t * This should match the checks in make_timestamp_internal\n\t */\n\tif (tm->tm_hour < 0 || tm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\n\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)) ||\n\t\t*fsec < INT64CONST(0) || *fsec > USECS_PER_SEC)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\n\tif ((fmask & DTK_TIME_M) != DTK_TIME_M)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/*\n\t * If we had a full timezone spec, compute the offset (we could not do it\n\t * before, because we may need the date to resolve DST status).\n\t */\n\tif (namedTz != NULL)\n\t{\n\t\tlong int\tgmtoff;\n\n\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* if non-DST zone, we do not need to know the date */\n\t\tif (pg_get_timezone_offset(namedTz, &gmtoff))\n\t\t{\n\t\t\t*tzp = -(int) gmtoff;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* a date has to be specified */\n\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, if we had a dynamic timezone abbreviation, resolve it now.\n\t */\n\tif (abbrevTz != NULL)\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneAbbrevOffset(tmp, abbrev, abbrevTz);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\t/* timezone not specified? then use session timezone */\n\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t{\n\t\tstruct pg_tm tt,\n\t\t\t\t   *tmp = &tt;\n\n\t\t/*\n\t\t * daylight savings time modifier but no standard timezone? then error\n\t\t */\n\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\tif ((fmask & DTK_DATE_M) == 0)\n\t\t\tGetCurrentDateTime(tmp);\n\t\telse\n\t\t{\n\t\t\ttmp->tm_year = tm->tm_year;\n\t\t\ttmp->tm_mon = tm->tm_mon;\n\t\t\ttmp->tm_mday = tm->tm_mday;\n\t\t}\n\t\ttmp->tm_hour = tm->tm_hour;\n\t\ttmp->tm_min = tm->tm_min;\n\t\ttmp->tm_sec = tm->tm_sec;\n\t\t*tzp = DetermineTimeZoneOffset(tmp, session_timezone);\n\t\ttm->tm_isdst = tmp->tm_isdst;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseDateTime",
          "args": [
            "str",
            "workbuf",
            "sizeof(workbuf)",
            "field",
            "ftype",
            "MAXDATEFIELDS",
            "&nf"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "ParseDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "545-739",
          "snippet": "int\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\n\nint\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nDatum\ntime_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\n#ifdef NOT_USED\n\tOid\t\t\ttypelem = PG_GETARG_OID(1);\n#endif\n\tint32\t\ttypmod = PG_GETARG_INT32(2);\n\tTimeADT\t\tresult;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tint\t\t\tnf;\n\tint\t\t\tdterr;\n\tchar\t\tworkbuf[MAXDATELEN + 1];\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tdtype;\n\tint\t\t\tftype[MAXDATEFIELDS];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeTimeOnly(field, ftype, nf, &dtype, tm, &fsec, &tz);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"time\");\n\n\ttm2time(tm, fsec, &result);\n\tAdjustTimeForTypmod(&result, typmod);\n\n\tPG_RETURN_TIMEADT(result);\n}"
  },
  {
    "function_name": "abstime_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1176-1219",
    "snippet": "Datum\nabstime_date(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime abstime = PG_GETARG_ABSOLUTETIME(0);\n\tDateADT\t\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tswitch (abstime)\n\t{\n\t\tcase INVALID_ABSTIME:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert reserved abstime value to date\")));\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\n\t\tcase NOSTART_ABSTIME:\n\t\t\tDATE_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase NOEND_ABSTIME:\n\t\t\tDATE_NOEND(result);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tabstime2tm(abstime, &tz, tm, NULL);\n\t\t\t/* Prevent overflow in Julian-day routines */\n\t\t\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"abstime out of range for date\")));\n\t\t\tresult = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\t\t\t/* Now check for just-out-of-range dates */\n\t\t\tif (!IS_VALID_DATE(result))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"abstime out of range for date\")));\n\t\t\tbreak;\n\t}\n\n\tPG_RETURN_DATEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "result"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"abstime out of range for date\"))"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"abstime out of range for date\""
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_DATE",
          "args": [
            "result"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"abstime out of range for date\"))"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_VALID_JULIAN",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abstime2tm",
          "args": [
            "abstime",
            "&tz",
            "tm",
            "NULL"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "abstime2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "98-146",
          "snippet": "void\nabstime2tm(AbsoluteTime _time, int *tzp, struct pg_tm *tm, char **tzn)\n{\n\tpg_time_t\ttime = (pg_time_t) _time;\n\tstruct pg_tm *tx;\n\n\tif (tzp != NULL)\n\t\ttx = pg_localtime(&time, session_timezone);\n\telse\n\t\ttx = pg_gmtime(&time);\n\n\tif (tx == NULL)\n\t\telog(ERROR, \"could not convert abstime to timestamp: %m\");\n\n\ttm->tm_year = tx->tm_year + 1900;\n\ttm->tm_mon = tx->tm_mon + 1;\n\ttm->tm_mday = tx->tm_mday;\n\ttm->tm_hour = tx->tm_hour;\n\ttm->tm_min = tx->tm_min;\n\ttm->tm_sec = tx->tm_sec;\n\ttm->tm_isdst = tx->tm_isdst;\n\n\ttm->tm_gmtoff = tx->tm_gmtoff;\n\ttm->tm_zone = tx->tm_zone;\n\n\tif (tzp != NULL)\n\t{\n\t\t*tzp = -tm->tm_gmtoff;\t/* tm_gmtoff is Sun/DEC-ism */\n\n\t\t/*\n\t\t * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23\n\t\t */\n\t\tif (tzn != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it\n\t\t\t * contains an error message, which doesn't fit in the buffer\n\t\t\t */\n\t\t\tStrNCpy(*tzn, tm->tm_zone, MAXTZLEN + 1);\n\t\t\tif (strlen(tm->tm_zone) > MAXTZLEN)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone)));\n\t\t}\n\t}\n\telse\n\t\ttm->tm_isdst = -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nvoid\nabstime2tm(AbsoluteTime _time, int *tzp, struct pg_tm *tm, char **tzn)\n{\n\tpg_time_t\ttime = (pg_time_t) _time;\n\tstruct pg_tm *tx;\n\n\tif (tzp != NULL)\n\t\ttx = pg_localtime(&time, session_timezone);\n\telse\n\t\ttx = pg_gmtime(&time);\n\n\tif (tx == NULL)\n\t\telog(ERROR, \"could not convert abstime to timestamp: %m\");\n\n\ttm->tm_year = tx->tm_year + 1900;\n\ttm->tm_mon = tx->tm_mon + 1;\n\ttm->tm_mday = tx->tm_mday;\n\ttm->tm_hour = tx->tm_hour;\n\ttm->tm_min = tx->tm_min;\n\ttm->tm_sec = tx->tm_sec;\n\ttm->tm_isdst = tx->tm_isdst;\n\n\ttm->tm_gmtoff = tx->tm_gmtoff;\n\ttm->tm_zone = tx->tm_zone;\n\n\tif (tzp != NULL)\n\t{\n\t\t*tzp = -tm->tm_gmtoff;\t/* tm_gmtoff is Sun/DEC-ism */\n\n\t\t/*\n\t\t * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23\n\t\t */\n\t\tif (tzn != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it\n\t\t\t * contains an error message, which doesn't fit in the buffer\n\t\t\t */\n\t\t\tStrNCpy(*tzn, tm->tm_zone, MAXTZLEN + 1);\n\t\t\tif (strlen(tm->tm_zone) > MAXTZLEN)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone)));\n\t\t}\n\t}\n\telse\n\t\ttm->tm_isdst = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATE_NOEND",
          "args": [
            "result"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert reserved abstime value to date\"))"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\nabstime_date(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime abstime = PG_GETARG_ABSOLUTETIME(0);\n\tDateADT\t\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tswitch (abstime)\n\t{\n\t\tcase INVALID_ABSTIME:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert reserved abstime value to date\")));\n\t\t\tresult = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\n\t\tcase NOSTART_ABSTIME:\n\t\t\tDATE_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase NOEND_ABSTIME:\n\t\t\tDATE_NOEND(result);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tabstime2tm(abstime, &tz, tm, NULL);\n\t\t\t/* Prevent overflow in Julian-day routines */\n\t\t\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"abstime out of range for date\")));\n\t\t\tresult = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\t\t\t/* Now check for just-out-of-range dates */\n\t\t\tif (!IS_VALID_DATE(result))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"abstime out of range for date\")));\n\t\t\tbreak;\n\t}\n\n\tPG_RETURN_DATEADT(result);\n}"
  },
  {
    "function_name": "timestamptz_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1145-1170",
    "snippet": "Datum\ntimestamptz_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_IS_NOBEGIN(timestamp))\n\t\tDATE_NOBEGIN(result);\n\telse if (TIMESTAMP_IS_NOEND(timestamp))\n\t\tDATE_NOEND(result);\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tresult = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\t}\n\n\tPG_RETURN_DATEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "result"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATE_NOEND",
          "args": [
            "result"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOEND",
          "args": [
            "timestamp"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOBEGIN",
          "args": [
            "timestamp"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimestamptz_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tif (TIMESTAMP_IS_NOBEGIN(timestamp))\n\t\tDATE_NOBEGIN(result);\n\telse if (TIMESTAMP_IS_NOEND(timestamp))\n\t\tDATE_NOEND(result);\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tresult = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\t}\n\n\tPG_RETURN_DATEADT(result);\n}"
  },
  {
    "function_name": "date_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1130-1139",
    "snippet": "Datum\ndate_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz result;\n\n\tresult = date2timestamptz(dateVal);\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ndate_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz result;\n\n\tresult = date2timestamptz(dateVal);\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamp_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1100-1124",
    "snippet": "Datum\ntimestamp_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\n\tif (TIMESTAMP_IS_NOBEGIN(timestamp))\n\t\tDATE_NOBEGIN(result);\n\telse if (TIMESTAMP_IS_NOEND(timestamp))\n\t\tDATE_NOEND(result);\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tresult = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\t}\n\n\tPG_RETURN_DATEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "result"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATE_NOEND",
          "args": [
            "result"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOEND",
          "args": [
            "timestamp"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOBEGIN",
          "args": [
            "timestamp"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ntimestamp_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\n\tif (TIMESTAMP_IS_NOBEGIN(timestamp))\n\t\tDATE_NOBEGIN(result);\n\telse if (TIMESTAMP_IS_NOEND(timestamp))\n\t\tDATE_NOEND(result);\n\telse\n\t{\n\t\tif (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\t\tresult = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\t}\n\n\tPG_RETURN_DATEADT(result);\n}"
  },
  {
    "function_name": "date_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1086-1095",
    "snippet": "Datum\ndate_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tresult;\n\n\tresult = date2timestamp(dateVal);\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ndate_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tresult;\n\n\tresult = date2timestamp(dateVal);\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "date_mi_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1069-1081",
    "snippet": "Datum\ndate_mi_interval(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimestamp\tdateStamp;\n\n\tdateStamp = date2timestamp(dateVal);\n\n\treturn DirectFunctionCall2(timestamp_mi_interval,\n\t\t\t\t\t\t\t   TimestampGetDatum(dateStamp),\n\t\t\t\t\t\t\t   PointerGetDatum(span));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "timestamp_mi_interval",
            "TimestampGetDatum(dateStamp)",
            "PointerGetDatum(span)"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "span"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampGetDatum",
          "args": [
            "dateStamp"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_mi_interval(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimestamp\tdateStamp;\n\n\tdateStamp = date2timestamp(dateVal);\n\n\treturn DirectFunctionCall2(timestamp_mi_interval,\n\t\t\t\t\t\t\t   TimestampGetDatum(dateStamp),\n\t\t\t\t\t\t\t   PointerGetDatum(span));\n}"
  },
  {
    "function_name": "date_pl_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1049-1061",
    "snippet": "Datum\ndate_pl_interval(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimestamp\tdateStamp;\n\n\tdateStamp = date2timestamp(dateVal);\n\n\treturn DirectFunctionCall2(timestamp_pl_interval,\n\t\t\t\t\t\t\t   TimestampGetDatum(dateStamp),\n\t\t\t\t\t\t\t   PointerGetDatum(span));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "timestamp_pl_interval",
            "TimestampGetDatum(dateStamp)",
            "PointerGetDatum(span)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "span"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampGetDatum",
          "args": [
            "dateStamp"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "1"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_pl_interval(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tInterval   *span = PG_GETARG_INTERVAL_P(1);\n\tTimestamp\tdateStamp;\n\n\tdateStamp = date2timestamp(dateVal);\n\n\treturn DirectFunctionCall2(timestamp_pl_interval,\n\t\t\t\t\t\t\t   TimestampGetDatum(dateStamp),\n\t\t\t\t\t\t\t   PointerGetDatum(span));\n}"
  },
  {
    "function_name": "in_range_date_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1020-1040",
    "snippet": "Datum\nin_range_date_interval(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tval = PG_GETARG_DATEADT(0);\n\tDateADT\t\tbase = PG_GETARG_DATEADT(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tTimestamp\tvalStamp;\n\tTimestamp\tbaseStamp;\n\n\tvalStamp = date2timestamp(val);\n\tbaseStamp = date2timestamp(base);\n\n\treturn DirectFunctionCall5(in_range_timestamp_interval,\n\t\t\t\t\t\t\t   TimestampGetDatum(valStamp),\n\t\t\t\t\t\t\t   TimestampGetDatum(baseStamp),\n\t\t\t\t\t\t\t   IntervalPGetDatum(offset),\n\t\t\t\t\t\t\t   BoolGetDatum(sub),\n\t\t\t\t\t\t\t   BoolGetDatum(less));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall5",
          "args": [
            "in_range_timestamp_interval",
            "TimestampGetDatum(valStamp)",
            "TimestampGetDatum(baseStamp)",
            "IntervalPGetDatum(offset)",
            "BoolGetDatum(sub)",
            "BoolGetDatum(less)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "less"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BoolGetDatum",
          "args": [
            "sub"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntervalPGetDatum",
          "args": [
            "offset"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampGetDatum",
          "args": [
            "baseStamp"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampGetDatum",
          "args": [
            "valStamp"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "base"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "4"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BOOL",
          "args": [
            "3"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "2"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nin_range_date_interval(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tval = PG_GETARG_DATEADT(0);\n\tDateADT\t\tbase = PG_GETARG_DATEADT(1);\n\tInterval   *offset = PG_GETARG_INTERVAL_P(2);\n\tbool\t\tsub = PG_GETARG_BOOL(3);\n\tbool\t\tless = PG_GETARG_BOOL(4);\n\tTimestamp\tvalStamp;\n\tTimestamp\tbaseStamp;\n\n\tvalStamp = date2timestamp(val);\n\tbaseStamp = date2timestamp(base);\n\n\treturn DirectFunctionCall5(in_range_timestamp_interval,\n\t\t\t\t\t\t\t   TimestampGetDatum(valStamp),\n\t\t\t\t\t\t\t   TimestampGetDatum(baseStamp),\n\t\t\t\t\t\t\t   IntervalPGetDatum(offset),\n\t\t\t\t\t\t\t   BoolGetDatum(sub),\n\t\t\t\t\t\t\t   BoolGetDatum(less));\n}"
  },
  {
    "function_name": "timestamptz_cmp_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "1002-1012",
    "snippet": "Datum\ntimestamptz_cmp_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_INT32(timestamptz_cmp_internal(dt1, dt2));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2)"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_cmp_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_INT32(timestamptz_cmp_internal(dt1, dt2));\n}"
  },
  {
    "function_name": "timestamptz_ge_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "990-1000",
    "snippet": "Datum\ntimestamptz_ge_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) >= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) >= 0"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_ge_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) >= 0);\n}"
  },
  {
    "function_name": "timestamptz_le_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "978-988",
    "snippet": "Datum\ntimestamptz_le_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) <= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) <= 0"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_le_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) <= 0);\n}"
  },
  {
    "function_name": "timestamptz_gt_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "966-976",
    "snippet": "Datum\ntimestamptz_gt_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) > 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) > 0"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_gt_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) > 0);\n}"
  },
  {
    "function_name": "timestamptz_lt_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "954-964",
    "snippet": "Datum\ntimestamptz_lt_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) < 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) < 0"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_lt_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) < 0);\n}"
  },
  {
    "function_name": "timestamptz_ne_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "942-952",
    "snippet": "Datum\ntimestamptz_ne_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) != 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) != 0"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_ne_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) != 0);\n}"
  },
  {
    "function_name": "timestamptz_eq_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "930-940",
    "snippet": "Datum\ntimestamptz_eq_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) == 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) == 0"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "0"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamptz_eq_date(PG_FUNCTION_ARGS)\n{\n\tTimestampTz dt1 = PG_GETARG_TIMESTAMPTZ(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestampTz dt2;\n\n\tdt2 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) == 0);\n}"
  },
  {
    "function_name": "timestamp_cmp_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "918-928",
    "snippet": "Datum\ntimestamp_cmp_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_INT32(timestamp_cmp_internal(dt1, dt2));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "timestamp_cmp_internal(dt1, dt2)"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_cmp_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_INT32(timestamp_cmp_internal(dt1, dt2));\n}"
  },
  {
    "function_name": "timestamp_ge_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "906-916",
    "snippet": "Datum\ntimestamp_ge_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) >= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) >= 0"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_ge_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) >= 0);\n}"
  },
  {
    "function_name": "timestamp_le_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "894-904",
    "snippet": "Datum\ntimestamp_le_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) <= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) <= 0"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_le_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) <= 0);\n}"
  },
  {
    "function_name": "timestamp_gt_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "882-892",
    "snippet": "Datum\ntimestamp_gt_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) > 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) > 0"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_gt_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) > 0);\n}"
  },
  {
    "function_name": "timestamp_lt_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "870-880",
    "snippet": "Datum\ntimestamp_lt_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) < 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) < 0"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_lt_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) < 0);\n}"
  },
  {
    "function_name": "timestamp_ne_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "858-868",
    "snippet": "Datum\ntimestamp_ne_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) != 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) != 0"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_ne_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) != 0);\n}"
  },
  {
    "function_name": "timestamp_eq_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "846-856",
    "snippet": "Datum\ntimestamp_eq_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) == 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) == 0"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimestamp_eq_date(PG_FUNCTION_ARGS)\n{\n\tTimestamp\tdt1 = PG_GETARG_TIMESTAMP(0);\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(1);\n\tTimestamp\tdt2;\n\n\tdt2 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) == 0);\n}"
  },
  {
    "function_name": "date_cmp_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "834-844",
    "snippet": "Datum\ndate_cmp_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_INT32(timestamptz_cmp_internal(dt1, dt2));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2)"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_cmp_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_INT32(timestamptz_cmp_internal(dt1, dt2));\n}"
  },
  {
    "function_name": "date_ge_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "822-832",
    "snippet": "Datum\ndate_ge_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) >= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) >= 0"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_ge_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) >= 0);\n}"
  },
  {
    "function_name": "date_le_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "810-820",
    "snippet": "Datum\ndate_le_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) <= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) <= 0"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_le_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) <= 0);\n}"
  },
  {
    "function_name": "date_gt_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "798-808",
    "snippet": "Datum\ndate_gt_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) > 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) > 0"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_gt_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) > 0);\n}"
  },
  {
    "function_name": "date_lt_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "786-796",
    "snippet": "Datum\ndate_lt_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) < 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) < 0"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_lt_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) < 0);\n}"
  },
  {
    "function_name": "date_ne_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "774-784",
    "snippet": "Datum\ndate_ne_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) != 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) != 0"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_ne_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) != 0);\n}"
  },
  {
    "function_name": "date_eq_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "762-772",
    "snippet": "Datum\ndate_eq_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) == 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamptz_cmp_internal(dt1, dt2) == 0"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamptz_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2timestamptz",
          "args": [
            "dateVal"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamptz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "599-643",
          "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMPTZ",
          "args": [
            "1"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_eq_timestamptz(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1);\n\tTimestampTz dt1;\n\n\tdt1 = date2timestamptz(dateVal);\n\n\tPG_RETURN_BOOL(timestamptz_cmp_internal(dt1, dt2) == 0);\n}"
  },
  {
    "function_name": "date_cmp_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "750-760",
    "snippet": "Datum\ndate_cmp_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_INT32(timestamp_cmp_internal(dt1, dt2));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "timestamp_cmp_internal(dt1, dt2)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_cmp_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_INT32(timestamp_cmp_internal(dt1, dt2));\n}"
  },
  {
    "function_name": "date_ge_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "738-748",
    "snippet": "Datum\ndate_ge_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) >= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) >= 0"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_ge_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) >= 0);\n}"
  },
  {
    "function_name": "date_le_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "726-736",
    "snippet": "Datum\ndate_le_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) <= 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) <= 0"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_le_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) <= 0);\n}"
  },
  {
    "function_name": "date_gt_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "714-724",
    "snippet": "Datum\ndate_gt_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) > 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) > 0"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_gt_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) > 0);\n}"
  },
  {
    "function_name": "date_lt_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "702-712",
    "snippet": "Datum\ndate_lt_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) < 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) < 0"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_lt_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) < 0);\n}"
  },
  {
    "function_name": "date_ne_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "690-700",
    "snippet": "Datum\ndate_ne_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) != 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) != 0"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_ne_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) != 0);\n}"
  },
  {
    "function_name": "date_eq_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "678-688",
    "snippet": "Datum\ndate_eq_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) == 0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "timestamp_cmp_internal(dt1, dt2) == 0"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timestamp_cmp_internal",
          "args": [
            "dt1",
            "dt2"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "2025-2029",
          "snippet": "int\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ntimestamp_cmp_internal(Timestamp dt1, Timestamp dt2)\n{\n\treturn (dt1 < dt2) ? -1 : ((dt1 > dt2) ? 1 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "date2timestamp",
          "args": [
            "dateVal"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "date2timestamp_no_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "655-671",
          "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "1"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_eq_timestamp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tTimestamp\tdt2 = PG_GETARG_TIMESTAMP(1);\n\tTimestamp\tdt1;\n\n\tdt1 = date2timestamp(dateVal);\n\n\tPG_RETURN_BOOL(timestamp_cmp_internal(dt1, dt2) == 0);\n}"
  },
  {
    "function_name": "date2timestamp_no_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "655-671",
    "snippet": "double\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DATE_IS_NOEND",
          "args": [
            "dateVal"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_IS_NOBEGIN",
          "args": [
            "dateVal"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\ndouble\ndate2timestamp_no_overflow(DateADT dateVal)\n{\n\tdouble\t\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tresult = -DBL_MAX;\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tresult = DBL_MAX;\n\telse\n\t{\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * (double) USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "date2timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "599-643",
    "snippet": "static TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\"))"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date out of range for timestamp\""
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "tm",
            "session_timezone"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "dateVal + POSTGRES_EPOCH_JDATE",
            "&(tm->tm_year)",
            "&(tm->tm_mon)",
            "&(tm->tm_mday)"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\"))"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_IS_NOEND",
          "args": [
            "dateVal"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_IS_NOBEGIN",
          "args": [
            "dateVal"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic TimestampTz\ndate2timestamptz(DateADT dateVal)\n{\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\tj2date(dateVal + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\ttm->tm_hour = 0;\n\t\ttm->tm_min = 0;\n\t\ttm->tm_sec = 0;\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\n\t\tresult = dateVal * USECS_PER_DAY + tz * USECS_PER_SEC;\n\n\t\t/*\n\t\t * Since it is possible to go beyond allowed timestamptz range because\n\t\t * of time zone, check for allowed timestamp range after adding tz.\n\t\t */\n\t\tif (!IS_VALID_TIMESTAMP(result))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "date2timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "571-597",
    "snippet": "static Timestamp\ndate2timestamp(DateADT dateVal)\n{\n\tTimestamp\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * USECS_PER_DAY;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\"))"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date out of range for timestamp\""
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_IS_NOEND",
          "args": [
            "dateVal"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_IS_NOBEGIN",
          "args": [
            "dateVal"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic Timestamp\ndate2timestamp(DateADT dateVal)\n{\n\tTimestamp\tresult;\n\n\tif (DATE_IS_NOBEGIN(dateVal))\n\t\tTIMESTAMP_NOBEGIN(result);\n\telse if (DATE_IS_NOEND(dateVal))\n\t\tTIMESTAMP_NOEND(result);\n\telse\n\t{\n\t\t/*\n\t\t * Date's range is wider than timestamp's, so check for boundaries.\n\t\t * Since dates have the same minimum values as timestamps, only upper\n\t\t * boundary need be checked for overflow.\n\t\t */\n\t\tif (dateVal >= (TIMESTAMP_END_JULIAN - POSTGRES_EPOCH_JDATE))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"date out of range for timestamp\")));\n\n\t\t/* date is days since 2000, timestamp is microseconds since same... */\n\t\tresult = dateVal * USECS_PER_DAY;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "date_mii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "544-564",
    "snippet": "Datum\ndate_mii(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tint32\t\tdays = PG_GETARG_INT32(1);\n\tDateADT\t\tresult;\n\n\tif (DATE_NOT_FINITE(dateVal))\n\t\tPG_RETURN_DATEADT(dateVal); /* can't change infinity */\n\n\tresult = dateVal - days;\n\n\t/* Check for integer overflow and out-of-allowed-range */\n\tif ((days >= 0 ? (result > dateVal) : (result < dateVal)) ||\n\t\t!IS_VALID_DATE(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range\")));\n\n\tPG_RETURN_DATEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "result"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range\"))"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date out of range\""
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_DATE",
          "args": [
            "result"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "dateVal"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOT_FINITE",
          "args": [
            "dateVal"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ndate_mii(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tint32\t\tdays = PG_GETARG_INT32(1);\n\tDateADT\t\tresult;\n\n\tif (DATE_NOT_FINITE(dateVal))\n\t\tPG_RETURN_DATEADT(dateVal); /* can't change infinity */\n\n\tresult = dateVal - days;\n\n\t/* Check for integer overflow and out-of-allowed-range */\n\tif ((days >= 0 ? (result > dateVal) : (result < dateVal)) ||\n\t\t!IS_VALID_DATE(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range\")));\n\n\tPG_RETURN_DATEADT(result);\n}"
  },
  {
    "function_name": "date_pli",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "520-540",
    "snippet": "Datum\ndate_pli(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tint32\t\tdays = PG_GETARG_INT32(1);\n\tDateADT\t\tresult;\n\n\tif (DATE_NOT_FINITE(dateVal))\n\t\tPG_RETURN_DATEADT(dateVal); /* can't change infinity */\n\n\tresult = dateVal + days;\n\n\t/* Check for integer overflow and out-of-allowed-range */\n\tif ((days >= 0 ? (result < dateVal) : (result > dateVal)) ||\n\t\t!IS_VALID_DATE(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range\")));\n\n\tPG_RETURN_DATEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "result"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range\"))"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date out of range\""
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_DATE",
          "args": [
            "result"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "dateVal"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOT_FINITE",
          "args": [
            "dateVal"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ndate_pli(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal = PG_GETARG_DATEADT(0);\n\tint32\t\tdays = PG_GETARG_INT32(1);\n\tDateADT\t\tresult;\n\n\tif (DATE_NOT_FINITE(dateVal))\n\t\tPG_RETURN_DATEADT(dateVal); /* can't change infinity */\n\n\tresult = dateVal + days;\n\n\t/* Check for integer overflow and out-of-allowed-range */\n\tif ((days >= 0 ? (result < dateVal) : (result > dateVal)) ||\n\t\t!IS_VALID_DATE(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range\")));\n\n\tPG_RETURN_DATEADT(result);\n}"
  },
  {
    "function_name": "date_mi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "503-515",
    "snippet": "Datum\ndate_mi(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tif (DATE_NOT_FINITE(dateVal1) || DATE_NOT_FINITE(dateVal2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"cannot subtract infinite dates\")));\n\n\tPG_RETURN_INT32((int32) (dateVal1 - dateVal2));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "(int32) (dateVal1 - dateVal2)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dateVal1 - dateVal2"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"cannot subtract infinite dates\"))"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot subtract infinite dates\""
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATE_NOT_FINITE",
          "args": [
            "dateVal2"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOT_FINITE",
          "args": [
            "dateVal1"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_mi(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tif (DATE_NOT_FINITE(dateVal1) || DATE_NOT_FINITE(dateVal2))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"cannot subtract infinite dates\")));\n\n\tPG_RETURN_INT32((int32) (dateVal1 - dateVal2));\n}"
  },
  {
    "function_name": "date_smaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "492-499",
    "snippet": "Datum\ndate_smaller(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_DATEADT((dateVal1 < dateVal2) ? dateVal1 : dateVal2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "(dateVal1 < dateVal2) ? dateVal1 : dateVal2"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_smaller(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_DATEADT((dateVal1 < dateVal2) ? dateVal1 : dateVal2);\n}"
  },
  {
    "function_name": "date_larger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "483-490",
    "snippet": "Datum\ndate_larger(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_DATEADT((dateVal1 > dateVal2) ? dateVal1 : dateVal2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "(dateVal1 > dateVal2) ? dateVal1 : dateVal2"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_larger(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_DATEADT((dateVal1 > dateVal2) ? dateVal1 : dateVal2);\n}"
  },
  {
    "function_name": "date_finite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "475-481",
    "snippet": "Datum\ndate_finite(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdate = PG_GETARG_DATEADT(0);\n\n\tPG_RETURN_BOOL(!DATE_NOT_FINITE(date));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "!DATE_NOT_FINITE(date)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOT_FINITE",
          "args": [
            "date"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_finite(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdate = PG_GETARG_DATEADT(0);\n\n\tPG_RETURN_BOOL(!DATE_NOT_FINITE(date));\n}"
  },
  {
    "function_name": "date_sortsupport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "466-473",
    "snippet": "Datum\ndate_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\n\tssup->comparator = date_fastcmp;\n\tPG_RETURN_VOID();\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_VOID",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_sortsupport(PG_FUNCTION_ARGS)\n{\n\tSortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);\n\n\tssup->comparator = date_fastcmp;\n\tPG_RETURN_VOID();\n}"
  },
  {
    "function_name": "date_fastcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "453-464",
    "snippet": "static int\ndate_fastcmp(Datum x, Datum y, SortSupport ssup)\n{\n\tDateADT\t\ta = DatumGetDateADT(x);\n\tDateADT\t\tb = DatumGetDateADT(y);\n\n\tif (a < b)\n\t\treturn -1;\n\telse if (a > b)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetDateADT",
          "args": [
            "y"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetDateADT",
          "args": [
            "x"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ndate_fastcmp(Datum x, Datum y, SortSupport ssup)\n{\n\tDateADT\t\ta = DatumGetDateADT(x);\n\tDateADT\t\tb = DatumGetDateADT(y);\n\n\tif (a < b)\n\t\treturn -1;\n\telse if (a > b)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "date_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "440-451",
    "snippet": "Datum\ndate_cmp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tif (dateVal1 < dateVal2)\n\t\tPG_RETURN_INT32(-1);\n\telse if (dateVal1 > dateVal2)\n\t\tPG_RETURN_INT32(1);\n\tPG_RETURN_INT32(0);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "0"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "1"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "-1"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_cmp(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tif (dateVal1 < dateVal2)\n\t\tPG_RETURN_INT32(-1);\n\telse if (dateVal1 > dateVal2)\n\t\tPG_RETURN_INT32(1);\n\tPG_RETURN_INT32(0);\n}"
  },
  {
    "function_name": "date_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "431-438",
    "snippet": "Datum\ndate_ge(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 >= dateVal2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "dateVal1 >= dateVal2"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_ge(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 >= dateVal2);\n}"
  },
  {
    "function_name": "date_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "422-429",
    "snippet": "Datum\ndate_gt(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 > dateVal2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "dateVal1 > dateVal2"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_gt(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 > dateVal2);\n}"
  },
  {
    "function_name": "date_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "413-420",
    "snippet": "Datum\ndate_le(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 <= dateVal2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "dateVal1 <= dateVal2"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_le(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 <= dateVal2);\n}"
  },
  {
    "function_name": "date_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "404-411",
    "snippet": "Datum\ndate_lt(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 < dateVal2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "dateVal1 < dateVal2"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_lt(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 < dateVal2);\n}"
  },
  {
    "function_name": "date_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "395-402",
    "snippet": "Datum\ndate_ne(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 != dateVal2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "dateVal1 != dateVal2"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_ne(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 != dateVal2);\n}"
  },
  {
    "function_name": "date_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "386-393",
    "snippet": "Datum\ndate_eq(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 == dateVal2);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "dateVal1 == dateVal2"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "1"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_eq(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdateVal1 = PG_GETARG_DATEADT(0);\n\tDateADT\t\tdateVal2 = PG_GETARG_DATEADT(1);\n\n\tPG_RETURN_BOOL(dateVal1 == dateVal2);\n}"
  },
  {
    "function_name": "GetSQLLocalTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "359-379",
    "snippet": "TimeADT\nGetSQLLocalTime(int32 typmod)\n{\n\tTimeADT\t\tresult;\n\tTimestampTz ts;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tts = GetCurrentTransactionStartTimestamp();\n\n\tif (timestamp2tm(ts, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\ttm2time(tm, fsec, &result);\n\tAdjustTimeForTypmod(&result, typmod);\n\treturn result;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);",
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdjustTimeForTypmod",
          "args": [
            "&result",
            "typmod"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimeForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1429-1461",
          "snippet": "static void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2time",
          "args": [
            "tm",
            "fsec",
            "&result"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "tm2time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1263-1269",
          "snippet": "static int\ntm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result)\n{\n\t*result = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec)\n\t\t\t   * USECS_PER_SEC) + fsec;\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic int\ntm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result)\n{\n\t*result = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec)\n\t\t\t   * USECS_PER_SEC) + fsec;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "ts",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionStartTimestamp",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nTimeADT\nGetSQLLocalTime(int32 typmod)\n{\n\tTimeADT\t\tresult;\n\tTimestampTz ts;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tts = GetCurrentTransactionStartTimestamp();\n\n\tif (timestamp2tm(ts, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\ttm2time(tm, fsec, &result);\n\tAdjustTimeForTypmod(&result, typmod);\n\treturn result;\n}"
  },
  {
    "function_name": "GetSQLCurrentTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "333-354",
    "snippet": "TimeTzADT *\nGetSQLCurrentTime(int32 typmod)\n{\n\tTimeTzADT  *result;\n\tTimestampTz ts;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tts = GetCurrentTransactionStartTimestamp();\n\n\tif (timestamp2tm(ts, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\ttm2timetz(tm, fsec, tz, result);\n\tAdjustTimeForTypmod(&(result->time), typmod);\n\treturn result;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);",
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdjustTimeForTypmod",
          "args": [
            "&(result->time)",
            "typmod"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "AdjustTimeForTypmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "1429-1461",
          "snippet": "static void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic void\nAdjustTimeForTypmod(TimeADT *time, int32 typmod)\n{\n\tstatic const int64 TimeScales[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(1000000),\n\t\tINT64CONST(100000),\n\t\tINT64CONST(10000),\n\t\tINT64CONST(1000),\n\t\tINT64CONST(100),\n\t\tINT64CONST(10),\n\t\tINT64CONST(1)\n\t};\n\n\tstatic const int64 TimeOffsets[MAX_TIME_PRECISION + 1] = {\n\t\tINT64CONST(500000),\n\t\tINT64CONST(50000),\n\t\tINT64CONST(5000),\n\t\tINT64CONST(500),\n\t\tINT64CONST(50),\n\t\tINT64CONST(5),\n\t\tINT64CONST(0)\n\t};\n\n\tif (typmod >= 0 && typmod <= MAX_TIME_PRECISION)\n\t{\n\t\tif (*time >= INT64CONST(0))\n\t\t\t*time = ((*time + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\tTimeScales[typmod];\n\t\telse\n\t\t\t*time = -((((-*time) + TimeOffsets[typmod]) / TimeScales[typmod]) *\n\t\t\t\t\t  TimeScales[typmod]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2timetz",
          "args": [
            "tm",
            "fsec",
            "tz",
            "result"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timetz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "2007-2015",
          "snippet": "static int\ntm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result)\n{\n\tresult->time = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t\t\tUSECS_PER_SEC) + fsec;\n\tresult->zone = tz;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
            "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nstatic int\ntm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result)\n{\n\tresult->time = ((((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec) *\n\t\t\t\t\tUSECS_PER_SEC) + fsec;\n\tresult->zone = tz;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeTzADT)"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "ts",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionStartTimestamp",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nTimeTzADT *\nGetSQLCurrentTime(int32 typmod)\n{\n\tTimeTzADT  *result;\n\tTimestampTz ts;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tts = GetCurrentTransactionStartTimestamp();\n\n\tif (timestamp2tm(ts, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\tresult = (TimeTzADT *) palloc(sizeof(TimeTzADT));\n\ttm2timetz(tm, fsec, tz, result);\n\tAdjustTimeForTypmod(&(result->time), typmod);\n\treturn result;\n}"
  },
  {
    "function_name": "GetSQLCurrentDate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "311-328",
    "snippet": "DateADT\nGetSQLCurrentDate(void)\n{\n\tTimestampTz ts;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tts = GetCurrentTransactionStartTimestamp();\n\n\tif (timestamp2tm(ts, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\treturn date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "ts",
            "&tz",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionStartTimestamp",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDateADT\nGetSQLCurrentDate(void)\n{\n\tTimestampTz ts;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\n\tts = GetCurrentTransactionStartTimestamp();\n\n\tif (timestamp2tm(ts, &tz, tm, &fsec, NULL, NULL) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\n\treturn date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n}"
  },
  {
    "function_name": "EncodeSpecialDate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "296-305",
    "snippet": "void\nEncodeSpecialDate(DateADT dt, char *str)\n{\n\tif (DATE_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (DATE_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialDate\");\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid argument for EncodeSpecialDate\""
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "str",
            "LATE"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATE_IS_NOEND",
          "args": [
            "dt"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_IS_NOBEGIN",
          "args": [
            "dt"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nEncodeSpecialDate(DateADT dt, char *str)\n{\n\tif (DATE_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (DATE_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialDate\");\n}"
  },
  {
    "function_name": "make_date",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "247-291",
    "snippet": "Datum\nmake_date(PG_FUNCTION_ARGS)\n{\n\tstruct pg_tm tm;\n\tDateADT\t\tdate;\n\tint\t\t\tdterr;\n\tbool\t\tbc = false;\n\n\ttm.tm_year = PG_GETARG_INT32(0);\n\ttm.tm_mon = PG_GETARG_INT32(1);\n\ttm.tm_mday = PG_GETARG_INT32(2);\n\n\t/* Handle negative years as BC */\n\tif (tm.tm_year < 0)\n\t{\n\t\tbc = true;\n\t\ttm.tm_year = -tm.tm_year;\n\t}\n\n\tdterr = ValidateDate(DTK_DATE_M, false, false, bc, &tm);\n\n\tif (dterr != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday)));\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday)));\n\n\tdate = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/* Now check for just-out-of-range dates */\n\tif (!IS_VALID_DATE(date))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday)));\n\n\tPG_RETURN_DATEADT(date);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "date"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday))"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date out of range: %d-%02d-%02d\"",
            "tm.tm_year",
            "tm.tm_mon",
            "tm.tm_mday"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_DATE",
          "args": [
            "date"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm.tm_year",
            "tm.tm_mon",
            "tm.tm_mday"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday))"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_VALID_JULIAN",
          "args": [
            "tm.tm_year",
            "tm.tm_mon",
            "tm.tm_mday"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday))"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ValidateDate",
          "args": [
            "DTK_DATE_M",
            "false",
            "false",
            "bc",
            "&tm"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ValidateDate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "2465-2534",
          "snippet": "int\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst int\tday_tab[2][13] =\n{\n\t{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0},\n\t{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0}\n};\n\nint\nValidateDate(int fmask, bool isjulian, bool is2digits, bool bc,\n\t\t\t struct pg_tm *tm)\n{\n\tif (fmask & DTK_M(YEAR))\n\t{\n\t\tif (isjulian)\n\t\t{\n\t\t\t/* tm_year is correct and should not be touched */\n\t\t}\n\t\telse if (bc)\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */\n\t\t\ttm->tm_year = -(tm->tm_year - 1);\n\t\t}\n\t\telse if (is2digits)\n\t\t{\n\t\t\t/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */\n\t\t\tif (tm->tm_year < 0)\t/* just paranoia */\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\tif (tm->tm_year < 70)\n\t\t\t\ttm->tm_year += 2000;\n\t\t\telse if (tm->tm_year < 100)\n\t\t\t\ttm->tm_year += 1900;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* there is no year zero in AD/BC notation */\n\t\t\tif (tm->tm_year <= 0)\n\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t}\n\t}\n\n\t/* now that we have correct year, decode DOY */\n\tif (fmask & DTK_M(DOY))\n\t{\n\t\tj2date(date2j(tm->tm_year, 1, 1) + tm->tm_yday - 1,\n\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t}\n\n\t/* check for valid month */\n\tif (fmask & DTK_M(MONTH))\n\t{\n\t\tif (tm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\t/* minimal check for valid day */\n\tif (fmask & DTK_M(DAY))\n\t{\n\t\tif (tm->tm_mday < 1 || tm->tm_mday > 31)\n\t\t\treturn DTERR_MD_FIELD_OVERFLOW;\n\t}\n\n\tif ((fmask & DTK_DATE_M) == DTK_DATE_M)\n\t{\n\t\t/*\n\t\t * Check for valid day of month, now that we know for sure the month\n\t\t * and year.  Note we don't use MD_FIELD_OVERFLOW here, since it seems\n\t\t * unlikely that \"Feb 29\" is a YMD-order error.\n\t\t */\n\t\tif (tm->tm_mday > day_tab[isleap(tm->tm_year)][tm->tm_mon - 1])\n\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmake_date(PG_FUNCTION_ARGS)\n{\n\tstruct pg_tm tm;\n\tDateADT\t\tdate;\n\tint\t\t\tdterr;\n\tbool\t\tbc = false;\n\n\ttm.tm_year = PG_GETARG_INT32(0);\n\ttm.tm_mon = PG_GETARG_INT32(1);\n\ttm.tm_mday = PG_GETARG_INT32(2);\n\n\t/* Handle negative years as BC */\n\tif (tm.tm_year < 0)\n\t{\n\t\tbc = true;\n\t\ttm.tm_year = -tm.tm_year;\n\t}\n\n\tdterr = ValidateDate(DTK_DATE_M, false, false, bc, &tm);\n\n\tif (dterr != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t errmsg(\"date field value out of range: %d-%02d-%02d\",\n\t\t\t\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday)));\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm.tm_year, tm.tm_mon, tm.tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday)));\n\n\tdate = date2j(tm.tm_year, tm.tm_mon, tm.tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/* Now check for just-out-of-range dates */\n\tif (!IS_VALID_DATE(date))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: %d-%02d-%02d\",\n\t\t\t\t\t\ttm.tm_year, tm.tm_mon, tm.tm_mday)));\n\n\tPG_RETURN_DATEADT(date);\n}"
  },
  {
    "function_name": "date_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "233-242",
    "snippet": "Datum\ndate_send(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdate = PG_GETARG_DATEADT(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, date);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "date"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_send(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdate = PG_GETARG_DATEADT(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, date);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "date_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "211-228",
    "snippet": "Datum\ndate_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tDateADT\t\tresult;\n\n\tresult = (DateADT) pq_getmsgint(buf, sizeof(DateADT));\n\n\t/* Limit to the same range that date_in() accepts. */\n\tif (DATE_NOT_FINITE(result))\n\t\t /* ok */ ;\n\telse if (!IS_VALID_DATE(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range\")));\n\n\tPG_RETURN_DATEADT(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "result"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range\"))"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date out of range\""
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_DATE",
          "args": [
            "result"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOT_FINITE",
          "args": [
            "result"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(DateADT)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ndate_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tDateADT\t\tresult;\n\n\tresult = (DateADT) pq_getmsgint(buf, sizeof(DateADT));\n\n\t/* Limit to the same range that date_in() accepts. */\n\tif (DATE_NOT_FINITE(result))\n\t\t /* ok */ ;\n\telse if (!IS_VALID_DATE(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range\")));\n\n\tPG_RETURN_DATEADT(result);\n}"
  },
  {
    "function_name": "date_out",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "186-206",
    "snippet": "Datum\ndate_out(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdate = PG_GETARG_DATEADT(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\tif (DATE_NOT_FINITE(date))\n\t\tEncodeSpecialDate(date, buf);\n\telse\n\t{\n\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\tEncodeDateOnly(tm, DateStyle, buf);\n\t}\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);",
      "static int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "buf"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeDateOnly",
          "args": [
            "tm",
            "DateStyle",
            "buf"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDateOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3872-3946",
          "snippet": "void\nEncodeDateOnly(struct pg_tm *tm, int style, char *str)\n{\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* compatible with ISO date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German-style date format */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* traditional date-only style for Postgres */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeDateOnly(struct pg_tm *tm, int style, char *str)\n{\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* compatible with ISO date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German-style date format */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* traditional date-only style for Postgres */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '-';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "j2date",
          "args": [
            "date + POSTGRES_EPOCH_JDATE",
            "&(tm->tm_year)",
            "&(tm->tm_mon)",
            "&(tm->tm_mday)"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "j2date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "300-325",
          "snippet": "void\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nj2date(int jd, int *year, int *month, int *day)\n{\n\tunsigned int julian;\n\tunsigned int quad;\n\tunsigned int extra;\n\tint\t\t\ty;\n\n\tjulian = jd;\n\tjulian += 32044;\n\tquad = julian / 146097;\n\textra = (julian - quad * 146097) * 4 + 3;\n\tjulian += 60 + quad * 3 + extra / 146097;\n\tquad = julian / 1461;\n\tjulian -= quad * 1461;\n\ty = julian * 4 / 1461;\n\tjulian = ((y != 0) ? ((julian + 305) % 365) : ((julian + 306) % 366))\n\t\t+ 123;\n\ty += quad * 4;\n\t*year = y - 4800;\n\tquad = julian * 2141 / 65536;\n\t*day = julian - 7834 * quad / 256;\n\t*month = (quad + 10) % MONTHS_PER_YEAR + 1;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeSpecialDate",
          "args": [
            "date",
            "buf"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeSpecialDate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "296-305",
          "snippet": "void\nEncodeSpecialDate(DateADT dt, char *str)\n{\n\tif (DATE_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (DATE_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialDate\");\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nEncodeSpecialDate(DateADT dt, char *str)\n{\n\tif (DATE_IS_NOBEGIN(dt))\n\t\tstrcpy(str, EARLY);\n\telse if (DATE_IS_NOEND(dt))\n\t\tstrcpy(str, LATE);\n\telse\t\t\t\t\t\t/* shouldn't happen */\n\t\telog(ERROR, \"invalid argument for EncodeSpecialDate\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "DATE_NOT_FINITE",
          "args": [
            "date"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATEADT",
          "args": [
            "0"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\ttm2time(struct pg_tm *tm, fsec_t fsec, TimeADT *result);\nstatic int\ttm2timetz(struct pg_tm *tm, fsec_t fsec, int tz, TimeTzADT *result);\n\nDatum\ndate_out(PG_FUNCTION_ARGS)\n{\n\tDateADT\t\tdate = PG_GETARG_DATEADT(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\tif (DATE_NOT_FINITE(date))\n\t\tEncodeSpecialDate(date, buf);\n\telse\n\t{\n\t\tj2date(date + POSTGRES_EPOCH_JDATE,\n\t\t\t   &(tm->tm_year), &(tm->tm_mon), &(tm->tm_mday));\n\t\tEncodeDateOnly(tm, DateStyle, buf);\n\t}\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "date_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "113-181",
    "snippet": "Datum\ndate_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tDateADT\t\tdate;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttzp;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tworkbuf[MAXDATELEN + 1];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, &tzp);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"date\");\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tbreak;\n\n\t\tcase DTK_CURRENT:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\tGetCurrentDateTime(tm);\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\t\t\tGetEpochTime(tm);\n\t\t\tbreak;\n\n\t\tcase DTK_LATE:\n\t\t\tDATE_NOEND(date);\n\t\t\tPG_RETURN_DATEADT(date);\n\n\t\tcase DTK_EARLY:\n\t\t\tDATE_NOBEGIN(date);\n\t\t\tPG_RETURN_DATEADT(date);\n\n\t\tdefault:\n\t\t\tDateTimeParseError(DTERR_BAD_FORMAT, str, \"date\");\n\t\t\tbreak;\n\t}\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\", str)));\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/* Now check for just-out-of-range dates */\n\tif (!IS_VALID_DATE(date))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\", str)));\n\n\tPG_RETURN_DATEADT(date);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "date"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\", str))"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"date out of range: \\\"%s\\\"\"",
            "str"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_VALID_DATE",
          "args": [
            "date"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\", str))"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_VALID_JULIAN",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeParseError",
          "args": [
            "DTERR_BAD_FORMAT",
            "str",
            "\"date\""
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeParseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3753-3792",
          "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "date"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOBEGIN",
          "args": [
            "date"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATEADT",
          "args": [
            "date"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATE_NOEND",
          "args": [
            "date"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetEpochTime",
          "args": [
            "tm"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "GetEpochTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1983-2003",
          "snippet": "void\nGetEpochTime(struct pg_tm *tm)\n{\n\tstruct pg_tm *t0;\n\tpg_time_t\tepoch = 0;\n\n\tt0 = pg_gmtime(&epoch);\n\n\tif (t0 == NULL)\n\t\telog(ERROR, \"could not convert epoch to timestamp: %m\");\n\n\ttm->tm_year = t0->tm_year;\n\ttm->tm_mon = t0->tm_mon;\n\ttm->tm_mday = t0->tm_mday;\n\ttm->tm_hour = t0->tm_hour;\n\ttm->tm_min = t0->tm_min;\n\ttm->tm_sec = t0->tm_sec;\n\n\ttm->tm_year += 1900;\n\ttm->tm_mon++;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nvoid\nGetEpochTime(struct pg_tm *tm)\n{\n\tstruct pg_tm *t0;\n\tpg_time_t\tepoch = 0;\n\n\tt0 = pg_gmtime(&epoch);\n\n\tif (t0 == NULL)\n\t\telog(ERROR, \"could not convert epoch to timestamp: %m\");\n\n\ttm->tm_year = t0->tm_year;\n\ttm->tm_mon = t0->tm_mon;\n\ttm->tm_mday = t0->tm_mday;\n\ttm->tm_hour = t0->tm_hour;\n\ttm->tm_min = t0->tm_min;\n\ttm->tm_sec = t0->tm_sec;\n\n\ttm->tm_year += 1900;\n\ttm->tm_mon++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentDateTime",
          "args": [
            "tm"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "353-362",
          "snippet": "void\nGetCurrentDateTime(struct pg_tm *tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nGetCurrentDateTime(struct pg_tm *tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t/* Note: don't pass NULL tzp to timestamp2tm; affects behavior */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\"))"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeDateTime",
          "args": [
            "field",
            "ftype",
            "nf",
            "&dtype",
            "tm",
            "&fsec",
            "&tzp"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "766-1439",
          "snippet": "int\nDecodeDateTime(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO y2001m02d04 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tint\t\t\tmer = HR24;\n\tbool\t\thaveTextMonth = false;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tpg_tz\t   *valtz;\n\tchar\t   *abbrev = NULL;\n\tstruct pg_tm cur_tm;\n\n\t/*\n\t * We'll insist on at least all of the date fields, but initialize the\n\t * remaining fields in case they are not set later...\n\t */\n\t*dtype = DTK_DATE;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Integral julian day with attached time zone? All other\n\t\t\t\t * forms with JD will be separated into distinct fields, so we\n\t\t\t\t * handle just this case here.\n\t\t\t\t */\n\t\t\t\tif (ptype == DTK_JULIAN)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val < 0)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\ttmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);\n\t\t\t\t\tptype = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Already have a date? Then this might be a time zone name\n\t\t\t\t * with embedded punctuation (e.g. \"America/New_York\") or a\n\t\t\t\t * run-together time with trailing time zone (e.g. hhmmss-zz).\n\t\t\t\t * - thomas 2001-12-25\n\t\t\t\t *\n\t\t\t\t * We consider it a time zone if we already have month & day.\n\t\t\t\t * This is to allow the form \"mmm dd hhmmss tz year\", which\n\t\t\t\t * we've historically accepted.\n\t\t\t\t */\n\t\t\t\telse if (ptype != 0 ||\n\t\t\t\t\t\t ((fmask & (DTK_M(MONTH) | DTK_M(DAY))) ==\n\t\t\t\t\t\t  (DTK_M(MONTH) | DTK_M(DAY))))\n\t\t\t\t{\n\t\t\t\t\t/* No time zone accepted? Then quit... */\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]) || ptype != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\tif (ptype != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tptype = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with a date and time\n\t\t\t\t\t\t * already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * modify tmask after returning from\n\t\t\t\t\t\t * DecodeNumberField()\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\n\t\t\t\t/*\n\t\t\t\t * This might be an ISO time following a \"t\" field.\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tptype = 0;\n\t\t\t\t}\n\t\t\t\tdterr = DecodeTime(field[i], fmask, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\n\t\t\t\t/*\n\t\t\t\t * Check upper limit on hours; other limits checked in\n\t\t\t\t * DecodeTime()\n\t\t\t\t */\n\t\t\t\t/* test for > 24:00:00 */\n\t\t\t\tif (tm->tm_hour > HOURS_PER_DAY ||\n\t\t\t\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t\t\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)))\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO date\" with embedded field labels? An\n\t\t\t\t * example is \"y2001m02d04\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\t/* fractional Julian Day? */\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal and no date yet? */\n\t\t\t\t\tif (cp != NULL && !(fmask & DTK_DATE_M))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\telse if (cp != NULL && flen - strlen(cp) > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Interpret as a concatenated date or time Set the\n\t\t\t\t\t\t * type field to allow decoding other fields later.\n\t\t\t\t\t\t * Example: 20011223 or 040506\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Is this a YMD or HMS specification, or a year number?\n\t\t\t\t\t * YMD and HMS are required to be six digits or more, so\n\t\t\t\t\t * if it is 5 digits, it is a year.  If it is six or more\n\t\t\t\t\t * more digits, we assume it is YMD or HMS unless no date\n\t\t\t\t\t * and no time values have been specified.  This forces 6+\n\t\t\t\t\t * digit years to be at the end of the string, or to use\n\t\t\t\t\t * the ISO date specification.\n\t\t\t\t\t */\n\t\t\t\t\telse if (flen >= 6 && (!(fmask & DTK_DATE_M) ||\n\t\t\t\t\t\t\t\t\t\t   !(fmask & DTK_TIME_M)))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t haveTextMonth, fmask,\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, tzp);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_YESTERDAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TODAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\ttm->tm_year = cur_tm.tm_year;\n\t\t\t\t\t\t\t\ttm->tm_mon = cur_tm.tm_mon;\n\t\t\t\t\t\t\t\ttm->tm_mday = cur_tm.tm_mday;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TOMORROW:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\tif (tzp != NULL)\n\t\t\t\t\t\t\t\t\t*tzp = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * already have a (numeric) month? then see if we can\n\t\t\t\t\t\t * substitute...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) && !haveTextMonth &&\n\t\t\t\t\t\t\t!(fmask & DTK_M(DAY)) && tm->tm_mon >= 1 &&\n\t\t\t\t\t\t\ttm->tm_mon <= 31)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm->tm_mday = tm->tm_mon;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DOW:\n\t\t\t\t\t\ttm->tm_wday = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a filler field \"t\" indicating that the next\n\t\t\t\t\t\t * field is time. Try to verify that this is sensible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/* No preceding date? Then quit... */\n\t\t\t\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/* do additional checking for full date specs... */\n\tif (*dtype == DTK_DATE)\n\t{\n\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t{\n\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\treturn 1;\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\t/*\n\t\t * If we had a full timezone spec, compute the offset (we could not do\n\t\t * it before, because we need the date to resolve DST status).\n\t\t */\n\t\tif (namedTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we had a dynamic timezone abbreviation, resolve it\n\t\t * now.\n\t\t */\n\t\tif (abbrevTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with dynamic TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneAbbrevOffset(tm, abbrev, abbrevTz);\n\t\t}\n\n\t\t/* timezone not specified? then use session timezone */\n\t\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t\t{\n\t\t\t/*\n\t\t\t * daylight savings time modifier but no standard timezone? then\n\t\t\t * error\n\t\t\t */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, session_timezone);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeDateTime(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO y2001m02d04 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tint\t\t\tmer = HR24;\n\tbool\t\thaveTextMonth = false;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tpg_tz\t   *valtz;\n\tchar\t   *abbrev = NULL;\n\tstruct pg_tm cur_tm;\n\n\t/*\n\t * We'll insist on at least all of the date fields, but initialize the\n\t * remaining fields in case they are not set later...\n\t */\n\t*dtype = DTK_DATE;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Integral julian day with attached time zone? All other\n\t\t\t\t * forms with JD will be separated into distinct fields, so we\n\t\t\t\t * handle just this case here.\n\t\t\t\t */\n\t\t\t\tif (ptype == DTK_JULIAN)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val < 0)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\ttmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);\n\t\t\t\t\tptype = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Already have a date? Then this might be a time zone name\n\t\t\t\t * with embedded punctuation (e.g. \"America/New_York\") or a\n\t\t\t\t * run-together time with trailing time zone (e.g. hhmmss-zz).\n\t\t\t\t * - thomas 2001-12-25\n\t\t\t\t *\n\t\t\t\t * We consider it a time zone if we already have month & day.\n\t\t\t\t * This is to allow the form \"mmm dd hhmmss tz year\", which\n\t\t\t\t * we've historically accepted.\n\t\t\t\t */\n\t\t\t\telse if (ptype != 0 ||\n\t\t\t\t\t\t ((fmask & (DTK_M(MONTH) | DTK_M(DAY))) ==\n\t\t\t\t\t\t  (DTK_M(MONTH) | DTK_M(DAY))))\n\t\t\t\t{\n\t\t\t\t\t/* No time zone accepted? Then quit... */\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]) || ptype != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\tif (ptype != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tptype = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with a date and time\n\t\t\t\t\t\t * already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * modify tmask after returning from\n\t\t\t\t\t\t * DecodeNumberField()\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\n\t\t\t\t/*\n\t\t\t\t * This might be an ISO time following a \"t\" field.\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tptype = 0;\n\t\t\t\t}\n\t\t\t\tdterr = DecodeTime(field[i], fmask, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\n\t\t\t\t/*\n\t\t\t\t * Check upper limit on hours; other limits checked in\n\t\t\t\t * DecodeTime()\n\t\t\t\t */\n\t\t\t\t/* test for > 24:00:00 */\n\t\t\t\tif (tm->tm_hour > HOURS_PER_DAY ||\n\t\t\t\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t\t\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)))\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO date\" with embedded field labels? An\n\t\t\t\t * example is \"y2001m02d04\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\t/* fractional Julian Day? */\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal and no date yet? */\n\t\t\t\t\tif (cp != NULL && !(fmask & DTK_DATE_M))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\telse if (cp != NULL && flen - strlen(cp) > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Interpret as a concatenated date or time Set the\n\t\t\t\t\t\t * type field to allow decoding other fields later.\n\t\t\t\t\t\t * Example: 20011223 or 040506\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Is this a YMD or HMS specification, or a year number?\n\t\t\t\t\t * YMD and HMS are required to be six digits or more, so\n\t\t\t\t\t * if it is 5 digits, it is a year.  If it is six or more\n\t\t\t\t\t * more digits, we assume it is YMD or HMS unless no date\n\t\t\t\t\t * and no time values have been specified.  This forces 6+\n\t\t\t\t\t * digit years to be at the end of the string, or to use\n\t\t\t\t\t * the ISO date specification.\n\t\t\t\t\t */\n\t\t\t\t\telse if (flen >= 6 && (!(fmask & DTK_DATE_M) ||\n\t\t\t\t\t\t\t\t\t\t   !(fmask & DTK_TIME_M)))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t haveTextMonth, fmask,\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, tzp);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_YESTERDAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TODAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\ttm->tm_year = cur_tm.tm_year;\n\t\t\t\t\t\t\t\ttm->tm_mon = cur_tm.tm_mon;\n\t\t\t\t\t\t\t\ttm->tm_mday = cur_tm.tm_mday;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TOMORROW:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\tif (tzp != NULL)\n\t\t\t\t\t\t\t\t\t*tzp = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * already have a (numeric) month? then see if we can\n\t\t\t\t\t\t * substitute...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) && !haveTextMonth &&\n\t\t\t\t\t\t\t!(fmask & DTK_M(DAY)) && tm->tm_mon >= 1 &&\n\t\t\t\t\t\t\ttm->tm_mon <= 31)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm->tm_mday = tm->tm_mon;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DOW:\n\t\t\t\t\t\ttm->tm_wday = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a filler field \"t\" indicating that the next\n\t\t\t\t\t\t * field is time. Try to verify that this is sensible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/* No preceding date? Then quit... */\n\t\t\t\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/* do additional checking for full date specs... */\n\tif (*dtype == DTK_DATE)\n\t{\n\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t{\n\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\treturn 1;\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\t/*\n\t\t * If we had a full timezone spec, compute the offset (we could not do\n\t\t * it before, because we need the date to resolve DST status).\n\t\t */\n\t\tif (namedTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we had a dynamic timezone abbreviation, resolve it\n\t\t * now.\n\t\t */\n\t\tif (abbrevTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with dynamic TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneAbbrevOffset(tm, abbrev, abbrevTz);\n\t\t}\n\n\t\t/* timezone not specified? then use session timezone */\n\t\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t\t{\n\t\t\t/*\n\t\t\t * daylight savings time modifier but no standard timezone? then\n\t\t\t * error\n\t\t\t */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, session_timezone);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseDateTime",
          "args": [
            "str",
            "workbuf",
            "sizeof(workbuf)",
            "field",
            "ftype",
            "MAXDATEFIELDS",
            "&nf"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ParseDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "545-739",
          "snippet": "int\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\n\nint\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ndate_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tDateADT\t\tdate;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttzp;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tworkbuf[MAXDATELEN + 1];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, &tzp);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"date\");\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tbreak;\n\n\t\tcase DTK_CURRENT:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\tGetCurrentDateTime(tm);\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\t\t\tGetEpochTime(tm);\n\t\t\tbreak;\n\n\t\tcase DTK_LATE:\n\t\t\tDATE_NOEND(date);\n\t\t\tPG_RETURN_DATEADT(date);\n\n\t\tcase DTK_EARLY:\n\t\t\tDATE_NOBEGIN(date);\n\t\t\tPG_RETURN_DATEADT(date);\n\n\t\tdefault:\n\t\t\tDateTimeParseError(DTERR_BAD_FORMAT, str, \"date\");\n\t\t\tbreak;\n\t}\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\", str)));\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\n\t/* Now check for just-out-of-range dates */\n\tif (!IS_VALID_DATE(date))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"date out of range: \\\"%s\\\"\", str)));\n\n\tPG_RETURN_DATEADT(date);\n}"
  },
  {
    "function_name": "anytime_typmodout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "93-102",
    "snippet": "static char *\nanytime_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s\"",
            "tz"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"(%d)%s\"",
            "(int) typmod",
            "tz"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nstatic char *\nanytime_typmodout(bool istz, int32 typmod)\n{\n\tconst char *tz = istz ? \" with time zone\" : \" without time zone\";\n\n\tif (typmod >= 0)\n\t\treturn psprintf(\"(%d)%s\", (int) typmod, tz);\n\telse\n\t\treturn psprintf(\"%s\", tz);\n}"
  },
  {
    "function_name": "anytime_typmod_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "71-90",
    "snippet": "int32\nanytime_typmod_check(bool istz, int32 typmod)\n{\n\tif (typmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIME(%d)%s precision must not be negative\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"))));\n\tif (typmod > MAX_TIME_PRECISION)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIME(%d)%s precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"),\n\t\t\t\t\t\tMAX_TIME_PRECISION)));\n\t\ttypmod = MAX_TIME_PRECISION;\n\t}\n\n\treturn typmod;\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIME(%d)%s precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"),\n\t\t\t\t\t\tMAX_TIME_PRECISION))"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"TIME(%d)%s precision reduced to maximum allowed, %d\"",
            "typmod",
            "(istz ? \" WITH TIME ZONE\" : \"\")",
            "MAX_TIME_PRECISION"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIME(%d)%s precision must not be negative\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\")))"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nint32\nanytime_typmod_check(bool istz, int32 typmod)\n{\n\tif (typmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIME(%d)%s precision must not be negative\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"))));\n\tif (typmod > MAX_TIME_PRECISION)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIME(%d)%s precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"),\n\t\t\t\t\t\tMAX_TIME_PRECISION)));\n\t\ttypmod = MAX_TIME_PRECISION;\n\t}\n\n\treturn typmod;\n}"
  },
  {
    "function_name": "anytime_typmodin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
    "lines": "50-68",
    "snippet": "static int32\nanytime_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIME\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytime_typmod_check(istz, tl[0]);\n}",
    "includes": [
      "#include \"utils/sortsupport.h\"",
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/date.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/hash.h\"",
      "#include <time.h>",
      "#include <float.h>",
      "#include <limits.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "anytime_typmod_check",
          "args": [
            "istz",
            "tl[0]"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "anytime_typmod_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/date.c",
          "lines": "71-90",
          "snippet": "int32\nanytime_typmod_check(bool istz, int32 typmod)\n{\n\tif (typmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIME(%d)%s precision must not be negative\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"))));\n\tif (typmod > MAX_TIME_PRECISION)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIME(%d)%s precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"),\n\t\t\t\t\t\tMAX_TIME_PRECISION)));\n\t\ttypmod = MAX_TIME_PRECISION;\n\t}\n\n\treturn typmod;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <time.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void AdjustTimeForTypmod(TimeADT *time, int32 typmod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void AdjustTimeForTypmod(TimeADT *time, int32 typmod);\n\nint32\nanytime_typmod_check(bool istz, int32 typmod)\n{\n\tif (typmod < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIME(%d)%s precision must not be negative\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"))));\n\tif (typmod > MAX_TIME_PRECISION)\n\t{\n\t\tereport(WARNING,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"TIME(%d)%s precision reduced to maximum allowed, %d\",\n\t\t\t\t\t\ttypmod, (istz ? \" WITH TIME ZONE\" : \"\"),\n\t\t\t\t\t\tMAX_TIME_PRECISION)));\n\t\ttypmod = MAX_TIME_PRECISION;\n\t}\n\n\treturn typmod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\"))"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid type modifier\""
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayGetIntegerTypmods",
          "args": [
            "ta",
            "&n"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetIntegerTypmods",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "199-235",
          "snippet": "int32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nint32 *\nArrayGetIntegerTypmods(ArrayType *arr, int *n)\n{\n\tint32\t   *result;\n\tDatum\t   *elem_values;\n\tint\t\t\ti;\n\n\tif (ARR_ELEMTYPE(arr) != CSTRINGOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_ELEMENT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be type cstring[]\")));\n\n\tif (ARR_NDIM(arr) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"typmod array must be one-dimensional\")));\n\n\tif (array_contains_nulls(arr))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"typmod array must not contain nulls\")));\n\n\t/* hardwired knowledge about cstring's representation details here */\n\tdeconstruct_array(arr, CSTRINGOID,\n\t\t\t\t\t  -2, false, 'c',\n\t\t\t\t\t  &elem_values, NULL, n);\n\n\tresult = (int32 *) palloc(*n * sizeof(int32));\n\n\tfor (i = 0; i < *n; i++)\n\t\tresult[i] = pg_atoi(DatumGetCString(elem_values[i]),\n\t\t\t\t\t\t\tsizeof(int32), '\\0');\n\n\tpfree(elem_values);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <time.h>\n#include <float.h>\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32\nanytime_typmodin(bool istz, ArrayType *ta)\n{\n\tint32\t   *tl;\n\tint\t\t\tn;\n\n\ttl = ArrayGetIntegerTypmods(ta, &n);\n\n\t/*\n\t * we're not too tense about good error message here because grammar\n\t * shouldn't allow wrong number of modifiers for TIME\n\t */\n\tif (n != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid type modifier\")));\n\n\treturn anytime_typmod_check(istz, tl[0]);\n}"
  }
]