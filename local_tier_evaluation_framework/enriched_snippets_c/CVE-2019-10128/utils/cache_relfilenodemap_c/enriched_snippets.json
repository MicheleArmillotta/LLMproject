[
  {
    "function_name": "RelidByRelfilenode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relfilenodemap.c",
    "lines": "140-259",
    "snippet": "Oid\nRelidByRelfilenode(Oid reltablespace, Oid relfilenode)\n{\n\tRelfilenodeMapKey key;\n\tRelfilenodeMapEntry *entry;\n\tbool\t\tfound;\n\tSysScanDesc scandesc;\n\tRelation\trelation;\n\tHeapTuple\tntp;\n\tScanKeyData skey[2];\n\tOid\t\t\trelid;\n\n\tif (RelfilenodeMapHash == NULL)\n\t\tInitializeRelfilenodeMap();\n\n\t/* pg_class will show 0 when the value is actually MyDatabaseTableSpace */\n\tif (reltablespace == MyDatabaseTableSpace)\n\t\treltablespace = 0;\n\n\tMemSet(&key, 0, sizeof(key));\n\tkey.reltablespace = reltablespace;\n\tkey.relfilenode = relfilenode;\n\n\t/*\n\t * Check cache and return entry if one is found. Even if no target\n\t * relation can be found later on we store the negative match and return a\n\t * InvalidOid from cache. That's not really necessary for performance\n\t * since querying invalid values isn't supposed to be a frequent thing,\n\t * but it's basically free.\n\t */\n\tentry = hash_search(RelfilenodeMapHash, (void *) &key, HASH_FIND, &found);\n\n\tif (found)\n\t\treturn entry->relid;\n\n\t/* ok, no previous cache entry, do it the hard way */\n\n\t/* initialize empty/negative cache entry before doing the actual lookups */\n\trelid = InvalidOid;\n\n\tif (reltablespace == GLOBALTABLESPACE_OID)\n\t{\n\t\t/*\n\t\t * Ok, shared table, check relmapper.\n\t\t */\n\t\trelid = RelationMapFilenodeToOid(relfilenode, true);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not a shared table, could either be a plain relation or a\n\t\t * non-shared, nailed one, like e.g. pg_class.\n\t\t */\n\n\t\t/* check for plain relations by looking in pg_class */\n\t\trelation = heap_open(RelationRelationId, AccessShareLock);\n\n\t\t/* copy scankey to local copy, it will be modified during the scan */\n\t\tmemcpy(skey, relfilenode_skey, sizeof(skey));\n\n\t\t/* set scan arguments */\n\t\tskey[0].sk_argument = ObjectIdGetDatum(reltablespace);\n\t\tskey[1].sk_argument = ObjectIdGetDatum(relfilenode);\n\n\t\tscandesc = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t\t  ClassTblspcRelfilenodeIndexId,\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t  2,\n\t\t\t\t\t\t\t\t\t  skey);\n\n\t\tfound = false;\n\n\t\twhile (HeapTupleIsValid(ntp = systable_getnext(scandesc)))\n\t\t{\n\t\t\tif (found)\n\t\t\t\telog(ERROR,\n\t\t\t\t\t \"unexpected duplicate for tablespace %u, relfilenode %u\",\n\t\t\t\t\t reltablespace, relfilenode);\n\t\t\tfound = true;\n\n#ifdef USE_ASSERT_CHECKING\n\t\t\t{\n\t\t\t\tbool\t\tisnull;\n\t\t\t\tOid\t\t\tcheck;\n\n\t\t\t\tcheck = fastgetattr(ntp, Anum_pg_class_reltablespace,\n\t\t\t\t\t\t\t\t\tRelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t&isnull);\n\t\t\t\tAssert(!isnull && check == reltablespace);\n\n\t\t\t\tcheck = fastgetattr(ntp, Anum_pg_class_relfilenode,\n\t\t\t\t\t\t\t\t\tRelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t&isnull);\n\t\t\t\tAssert(!isnull && check == relfilenode);\n\t\t\t}\n#endif\n\t\t\trelid = HeapTupleGetOid(ntp);\n\t\t}\n\n\t\tsystable_endscan(scandesc);\n\t\theap_close(relation, AccessShareLock);\n\n\t\t/* check for tables that are mapped but not shared */\n\t\tif (!found)\n\t\t\trelid = RelationMapFilenodeToOid(relfilenode, false);\n\t}\n\n\t/*\n\t * Only enter entry into cache now, our opening of pg_class could have\n\t * caused cache invalidations to be executed which would have deleted a\n\t * new entry if we had entered it above.\n\t */\n\tentry = hash_search(RelfilenodeMapHash, (void *) &key, HASH_ENTER, &found);\n\tif (found)\n\t\telog(ERROR, \"corrupted hashtable\");\n\tentry->relid = relid;\n\n\treturn relid;\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *RelfilenodeMapHash = NULL;",
      "static ScanKeyData relfilenode_skey[2];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"corrupted hashtable\""
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "RelfilenodeMapHash",
            "(void *) &key",
            "HASH_ENTER",
            "&found"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationMapFilenodeToOid",
          "args": [
            "relfilenode",
            "false"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapFilenodeToOid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "198-237",
          "snippet": "Oid\nRelationMapFilenodeToOid(Oid filenode, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static RelMapFile active_shared_updates;",
            "static RelMapFile active_local_updates;",
            "static void load_relmap_file(bool shared);",
            "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic void load_relmap_file(bool shared);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nOid\nRelationMapFilenodeToOid(Oid filenode, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (filenode == map->mappings[i].mapfilenode)\n\t\t\t\treturn map->mappings[i].mapoid;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "relation",
            "AccessShareLock"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "scandesc"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "ntp"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull && check == relfilenode"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "ntp",
            "Anum_pg_class_relfilenode",
            "RelationGetDescr(relation)",
            "&isnull"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "relation"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull && check == reltablespace"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "ntp",
            "Anum_pg_class_reltablespace",
            "RelationGetDescr(relation)",
            "&isnull"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "relation"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "ntp = systable_getnext(scandesc)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "scandesc"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "relation",
            "ClassTblspcRelfilenodeIndexId",
            "true",
            "NULL",
            "2",
            "skey"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "relfilenode"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "reltablespace"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "skey",
            "relfilenode_skey",
            "sizeof(skey)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "RelationRelationId",
            "AccessShareLock"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&key",
            "0",
            "sizeof(key)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitializeRelfilenodeMap",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "InitializeRelfilenodeMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relfilenodemap.c",
          "lines": "88-132",
          "snippet": "static void\nInitializeRelfilenodeMap(void)\n{\n\tHASHCTL\t\tctl;\n\tint\t\t\ti;\n\n\t/* Make sure we've initialized CacheMemoryContext. */\n\tif (CacheMemoryContext == NULL)\n\t\tCreateCacheMemoryContext();\n\n\t/* build skey */\n\tMemSet(&relfilenode_skey, 0, sizeof(relfilenode_skey));\n\n\tfor (i = 0; i < 2; i++)\n\t{\n\t\tfmgr_info_cxt(F_OIDEQ,\n\t\t\t\t\t  &relfilenode_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\t\trelfilenode_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\trelfilenode_skey[i].sk_subtype = InvalidOid;\n\t\trelfilenode_skey[i].sk_collation = InvalidOid;\n\t}\n\n\trelfilenode_skey[0].sk_attno = Anum_pg_class_reltablespace;\n\trelfilenode_skey[1].sk_attno = Anum_pg_class_relfilenode;\n\n\t/* Initialize the hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RelfilenodeMapKey);\n\tctl.entrysize = sizeof(RelfilenodeMapEntry);\n\tctl.hcxt = CacheMemoryContext;\n\n\t/*\n\t * Only create the RelfilenodeMapHash now, so we don't end up partially\n\t * initialized when fmgr_info_cxt() above ERRORs out with an out of memory\n\t * error.\n\t */\n\tRelfilenodeMapHash =\n\t\thash_create(\"RelfilenodeMap cache\", 64, &ctl,\n\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\n\t/* Watch for invalidation events. */\n\tCacheRegisterRelcacheCallback(RelfilenodeMapInvalidateCallback,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *RelfilenodeMapHash = NULL;",
            "static ScanKeyData relfilenode_skey[2];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic HTAB *RelfilenodeMapHash = NULL;\nstatic ScanKeyData relfilenode_skey[2];\n\nstatic void\nInitializeRelfilenodeMap(void)\n{\n\tHASHCTL\t\tctl;\n\tint\t\t\ti;\n\n\t/* Make sure we've initialized CacheMemoryContext. */\n\tif (CacheMemoryContext == NULL)\n\t\tCreateCacheMemoryContext();\n\n\t/* build skey */\n\tMemSet(&relfilenode_skey, 0, sizeof(relfilenode_skey));\n\n\tfor (i = 0; i < 2; i++)\n\t{\n\t\tfmgr_info_cxt(F_OIDEQ,\n\t\t\t\t\t  &relfilenode_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\t\trelfilenode_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\trelfilenode_skey[i].sk_subtype = InvalidOid;\n\t\trelfilenode_skey[i].sk_collation = InvalidOid;\n\t}\n\n\trelfilenode_skey[0].sk_attno = Anum_pg_class_reltablespace;\n\trelfilenode_skey[1].sk_attno = Anum_pg_class_relfilenode;\n\n\t/* Initialize the hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RelfilenodeMapKey);\n\tctl.entrysize = sizeof(RelfilenodeMapEntry);\n\tctl.hcxt = CacheMemoryContext;\n\n\t/*\n\t * Only create the RelfilenodeMapHash now, so we don't end up partially\n\t * initialized when fmgr_info_cxt() above ERRORs out with an out of memory\n\t * error.\n\t */\n\tRelfilenodeMapHash =\n\t\thash_create(\"RelfilenodeMap cache\", 64, &ctl,\n\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\n\t/* Watch for invalidation events. */\n\tCacheRegisterRelcacheCallback(RelfilenodeMapInvalidateCallback,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic HTAB *RelfilenodeMapHash = NULL;\nstatic ScanKeyData relfilenode_skey[2];\n\nOid\nRelidByRelfilenode(Oid reltablespace, Oid relfilenode)\n{\n\tRelfilenodeMapKey key;\n\tRelfilenodeMapEntry *entry;\n\tbool\t\tfound;\n\tSysScanDesc scandesc;\n\tRelation\trelation;\n\tHeapTuple\tntp;\n\tScanKeyData skey[2];\n\tOid\t\t\trelid;\n\n\tif (RelfilenodeMapHash == NULL)\n\t\tInitializeRelfilenodeMap();\n\n\t/* pg_class will show 0 when the value is actually MyDatabaseTableSpace */\n\tif (reltablespace == MyDatabaseTableSpace)\n\t\treltablespace = 0;\n\n\tMemSet(&key, 0, sizeof(key));\n\tkey.reltablespace = reltablespace;\n\tkey.relfilenode = relfilenode;\n\n\t/*\n\t * Check cache and return entry if one is found. Even if no target\n\t * relation can be found later on we store the negative match and return a\n\t * InvalidOid from cache. That's not really necessary for performance\n\t * since querying invalid values isn't supposed to be a frequent thing,\n\t * but it's basically free.\n\t */\n\tentry = hash_search(RelfilenodeMapHash, (void *) &key, HASH_FIND, &found);\n\n\tif (found)\n\t\treturn entry->relid;\n\n\t/* ok, no previous cache entry, do it the hard way */\n\n\t/* initialize empty/negative cache entry before doing the actual lookups */\n\trelid = InvalidOid;\n\n\tif (reltablespace == GLOBALTABLESPACE_OID)\n\t{\n\t\t/*\n\t\t * Ok, shared table, check relmapper.\n\t\t */\n\t\trelid = RelationMapFilenodeToOid(relfilenode, true);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Not a shared table, could either be a plain relation or a\n\t\t * non-shared, nailed one, like e.g. pg_class.\n\t\t */\n\n\t\t/* check for plain relations by looking in pg_class */\n\t\trelation = heap_open(RelationRelationId, AccessShareLock);\n\n\t\t/* copy scankey to local copy, it will be modified during the scan */\n\t\tmemcpy(skey, relfilenode_skey, sizeof(skey));\n\n\t\t/* set scan arguments */\n\t\tskey[0].sk_argument = ObjectIdGetDatum(reltablespace);\n\t\tskey[1].sk_argument = ObjectIdGetDatum(relfilenode);\n\n\t\tscandesc = systable_beginscan(relation,\n\t\t\t\t\t\t\t\t\t  ClassTblspcRelfilenodeIndexId,\n\t\t\t\t\t\t\t\t\t  true,\n\t\t\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t\t\t  2,\n\t\t\t\t\t\t\t\t\t  skey);\n\n\t\tfound = false;\n\n\t\twhile (HeapTupleIsValid(ntp = systable_getnext(scandesc)))\n\t\t{\n\t\t\tif (found)\n\t\t\t\telog(ERROR,\n\t\t\t\t\t \"unexpected duplicate for tablespace %u, relfilenode %u\",\n\t\t\t\t\t reltablespace, relfilenode);\n\t\t\tfound = true;\n\n#ifdef USE_ASSERT_CHECKING\n\t\t\t{\n\t\t\t\tbool\t\tisnull;\n\t\t\t\tOid\t\t\tcheck;\n\n\t\t\t\tcheck = fastgetattr(ntp, Anum_pg_class_reltablespace,\n\t\t\t\t\t\t\t\t\tRelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t&isnull);\n\t\t\t\tAssert(!isnull && check == reltablespace);\n\n\t\t\t\tcheck = fastgetattr(ntp, Anum_pg_class_relfilenode,\n\t\t\t\t\t\t\t\t\tRelationGetDescr(relation),\n\t\t\t\t\t\t\t\t\t&isnull);\n\t\t\t\tAssert(!isnull && check == relfilenode);\n\t\t\t}\n#endif\n\t\t\trelid = HeapTupleGetOid(ntp);\n\t\t}\n\n\t\tsystable_endscan(scandesc);\n\t\theap_close(relation, AccessShareLock);\n\n\t\t/* check for tables that are mapped but not shared */\n\t\tif (!found)\n\t\t\trelid = RelationMapFilenodeToOid(relfilenode, false);\n\t}\n\n\t/*\n\t * Only enter entry into cache now, our opening of pg_class could have\n\t * caused cache invalidations to be executed which would have deleted a\n\t * new entry if we had entered it above.\n\t */\n\tentry = hash_search(RelfilenodeMapHash, (void *) &key, HASH_ENTER, &found);\n\tif (found)\n\t\telog(ERROR, \"corrupted hashtable\");\n\tentry->relid = relid;\n\n\treturn relid;\n}"
  },
  {
    "function_name": "InitializeRelfilenodeMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relfilenodemap.c",
    "lines": "88-132",
    "snippet": "static void\nInitializeRelfilenodeMap(void)\n{\n\tHASHCTL\t\tctl;\n\tint\t\t\ti;\n\n\t/* Make sure we've initialized CacheMemoryContext. */\n\tif (CacheMemoryContext == NULL)\n\t\tCreateCacheMemoryContext();\n\n\t/* build skey */\n\tMemSet(&relfilenode_skey, 0, sizeof(relfilenode_skey));\n\n\tfor (i = 0; i < 2; i++)\n\t{\n\t\tfmgr_info_cxt(F_OIDEQ,\n\t\t\t\t\t  &relfilenode_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\t\trelfilenode_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\trelfilenode_skey[i].sk_subtype = InvalidOid;\n\t\trelfilenode_skey[i].sk_collation = InvalidOid;\n\t}\n\n\trelfilenode_skey[0].sk_attno = Anum_pg_class_reltablespace;\n\trelfilenode_skey[1].sk_attno = Anum_pg_class_relfilenode;\n\n\t/* Initialize the hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RelfilenodeMapKey);\n\tctl.entrysize = sizeof(RelfilenodeMapEntry);\n\tctl.hcxt = CacheMemoryContext;\n\n\t/*\n\t * Only create the RelfilenodeMapHash now, so we don't end up partially\n\t * initialized when fmgr_info_cxt() above ERRORs out with an out of memory\n\t * error.\n\t */\n\tRelfilenodeMapHash =\n\t\thash_create(\"RelfilenodeMap cache\", 64, &ctl,\n\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\n\t/* Watch for invalidation events. */\n\tCacheRegisterRelcacheCallback(RelfilenodeMapInvalidateCallback,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *RelfilenodeMapHash = NULL;",
      "static ScanKeyData relfilenode_skey[2];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CacheRegisterRelcacheCallback",
          "args": [
            "RelfilenodeMapInvalidateCallback",
            "(Datum) 0"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "CacheRegisterRelcacheCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1467-1478",
          "snippet": "void\nCacheRegisterRelcacheCallback(RelcacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (relcache_callback_count >= MAX_RELCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of relcache_callback_list slots\");\n\n\trelcache_callback_list[relcache_callback_count].function = func;\n\trelcache_callback_list[relcache_callback_count].arg = arg;\n\n\t++relcache_callback_count;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_RELCACHE_CALLBACKS 10"
          ],
          "globals_used": [
            "static struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];",
            "static int\trelcache_callback_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_RELCACHE_CALLBACKS 10\n\nstatic struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];\nstatic int\trelcache_callback_count = 0;\n\nvoid\nCacheRegisterRelcacheCallback(RelcacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (relcache_callback_count >= MAX_RELCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of relcache_callback_list slots\");\n\n\trelcache_callback_list[relcache_callback_count].function = func;\n\trelcache_callback_list[relcache_callback_count].arg = arg;\n\n\t++relcache_callback_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"RelfilenodeMap cache\"",
            "64",
            "&ctl",
            "HASH_ELEM | HASH_BLOBS | HASH_CONTEXT"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "F_OIDEQ",
            "&relfilenode_skey[i].sk_func",
            "CacheMemoryContext"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&relfilenode_skey",
            "0",
            "sizeof(relfilenode_skey)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateCacheMemoryContext",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "CreateCacheMemoryContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "635-646",
          "snippet": "void\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nvoid\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic HTAB *RelfilenodeMapHash = NULL;\nstatic ScanKeyData relfilenode_skey[2];\n\nstatic void\nInitializeRelfilenodeMap(void)\n{\n\tHASHCTL\t\tctl;\n\tint\t\t\ti;\n\n\t/* Make sure we've initialized CacheMemoryContext. */\n\tif (CacheMemoryContext == NULL)\n\t\tCreateCacheMemoryContext();\n\n\t/* build skey */\n\tMemSet(&relfilenode_skey, 0, sizeof(relfilenode_skey));\n\n\tfor (i = 0; i < 2; i++)\n\t{\n\t\tfmgr_info_cxt(F_OIDEQ,\n\t\t\t\t\t  &relfilenode_skey[i].sk_func,\n\t\t\t\t\t  CacheMemoryContext);\n\t\trelfilenode_skey[i].sk_strategy = BTEqualStrategyNumber;\n\t\trelfilenode_skey[i].sk_subtype = InvalidOid;\n\t\trelfilenode_skey[i].sk_collation = InvalidOid;\n\t}\n\n\trelfilenode_skey[0].sk_attno = Anum_pg_class_reltablespace;\n\trelfilenode_skey[1].sk_attno = Anum_pg_class_relfilenode;\n\n\t/* Initialize the hash table. */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(RelfilenodeMapKey);\n\tctl.entrysize = sizeof(RelfilenodeMapEntry);\n\tctl.hcxt = CacheMemoryContext;\n\n\t/*\n\t * Only create the RelfilenodeMapHash now, so we don't end up partially\n\t * initialized when fmgr_info_cxt() above ERRORs out with an out of memory\n\t * error.\n\t */\n\tRelfilenodeMapHash =\n\t\thash_create(\"RelfilenodeMap cache\", 64, &ctl,\n\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT);\n\n\t/* Watch for invalidation events. */\n\tCacheRegisterRelcacheCallback(RelfilenodeMapInvalidateCallback,\n\t\t\t\t\t\t\t\t  (Datum) 0);\n}"
  },
  {
    "function_name": "RelfilenodeMapInvalidateCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relfilenodemap.c",
    "lines": "54-82",
    "snippet": "static void\nRelfilenodeMapInvalidateCallback(Datum arg, Oid relid)\n{\n\tHASH_SEQ_STATUS status;\n\tRelfilenodeMapEntry *entry;\n\n\t/* callback only gets registered after creating the hash */\n\tAssert(RelfilenodeMapHash != NULL);\n\n\thash_seq_init(&status, RelfilenodeMapHash);\n\twhile ((entry = (RelfilenodeMapEntry *) hash_seq_search(&status)) != NULL)\n\t{\n\t\t/*\n\t\t * If relid is InvalidOid, signalling a complete reset, we must remove\n\t\t * all entries, otherwise just remove the specific relation's entry.\n\t\t * Always remove negative cache entries.\n\t\t */\n\t\tif (relid == InvalidOid ||\t/* complete reset */\n\t\t\tentry->relid == InvalidOid ||\t/* negative cache entry */\n\t\t\tentry->relid == relid)\t/* individual flushed relation */\n\t\t{\n\t\t\tif (hash_search(RelfilenodeMapHash,\n\t\t\t\t\t\t\t(void *) &entry->key,\n\t\t\t\t\t\t\tHASH_REMOVE,\n\t\t\t\t\t\t\tNULL) == NULL)\n\t\t\t\telog(ERROR, \"hash table corrupted\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/relmapper.h\"",
      "#include \"utils/relfilenodemap.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/hsearch.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/heapam.h\"",
      "#include \"access/genam.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *RelfilenodeMapHash = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"hash table corrupted\""
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "RelfilenodeMapHash",
            "(void *) &entry->key",
            "HASH_REMOVE",
            "NULL"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "RelfilenodeMapHash"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "RelfilenodeMapHash != NULL"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/inval.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/indexing.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic HTAB *RelfilenodeMapHash = NULL;\n\nstatic void\nRelfilenodeMapInvalidateCallback(Datum arg, Oid relid)\n{\n\tHASH_SEQ_STATUS status;\n\tRelfilenodeMapEntry *entry;\n\n\t/* callback only gets registered after creating the hash */\n\tAssert(RelfilenodeMapHash != NULL);\n\n\thash_seq_init(&status, RelfilenodeMapHash);\n\twhile ((entry = (RelfilenodeMapEntry *) hash_seq_search(&status)) != NULL)\n\t{\n\t\t/*\n\t\t * If relid is InvalidOid, signalling a complete reset, we must remove\n\t\t * all entries, otherwise just remove the specific relation's entry.\n\t\t * Always remove negative cache entries.\n\t\t */\n\t\tif (relid == InvalidOid ||\t/* complete reset */\n\t\t\tentry->relid == InvalidOid ||\t/* negative cache entry */\n\t\t\tentry->relid == relid)\t/* individual flushed relation */\n\t\t{\n\t\t\tif (hash_search(RelfilenodeMapHash,\n\t\t\t\t\t\t\t(void *) &entry->key,\n\t\t\t\t\t\t\tHASH_REMOVE,\n\t\t\t\t\t\t\tNULL) == NULL)\n\t\t\t\telog(ERROR, \"hash table corrupted\");\n\t\t}\n\t}\n}"
  }
]